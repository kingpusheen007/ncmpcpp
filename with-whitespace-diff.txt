diff --git a/.coafile b/.coafile
new file mode 100644
index 0000000..32c0b10
--- /dev/null
+++ b/.coafile
@@ -0,0 +1,14 @@
+# Generated by coala-quickstart on 12 Jan 2018.
+[default]
+bears = InvalidLinkBear, FilenameBear, coalaBear
+files = **.cpp, **.h, **.yml
+ignore = 
+[c]
+bears = ClangComplexityBear, GNUIndentBear, CSecurityBear
+files = **.h
+[yaml]
+bears = LineLengthBear, YAMLLintBear
+files = **.yml
+[c++]
+bears = ClangComplexityBear, CPPCleanBear, GNUIndentBear, CPPCheckBear
+files = **.h, **.cpp
diff --git a/coala-ci.log b/coala-ci.log
new file mode 100644
index 0000000..ec86e1f
--- /dev/null
+++ b/coala-ci.log
@@ -0,0 +1,79284 @@
+Executing section Default...
+
+.travis.yml
+|  12| ••#•Create•two•diff•files,•and•upload•to•https://clbin.com
+|    | [MAJOR] InvalidLinkBear:
+|    | Broken link - unable to connect to https://clbin.com
+
+.travis.yml
+|  20| ••#•Upload•logs•to•https://clbin.com
+|    | [MAJOR] InvalidLinkBear:
+|    | Broken link - unable to connect to https://clbin.com
+Executing section c...
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/html.h
+|    |++++| /app/src/utility/html.h
+|  23|  23| 
+|  24|  24| #include <string>
+|  25|  25| 
+|  26|    |-std::string unescapeHtmlUtf8(const std::string &s);
+|  27|    |-void unescapeHtmlEntities(std::string &s);
+|  28|    |-void stripHtmlTags(std::string &s);
+|    |  26|+std::string unescapeHtmlUtf8 (const std::string & s);
+|    |  27|+void unescapeHtmlEntities (std::string & s);
+|    |  28|+void stripHtmlTags (std::string & s);
+|  29|  29| 
+|  30|  30| #endif // NCMPCPP_UTILITY_HTML_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+|  27|  27| #include "curses/formatted_color.h"
+|  28|  28| #include "curses/window.h"
+|  29|  29| 
+|  30|    |-namespace NC {
+|    |  30|+namespace NC
+|    |  31|+{
+|  31|  32| 
+|  32|  33| /// Buffer template class that stores text
+|  33|  34| /// along with its properties (colors/formatting).
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+|  31|  31| 
+|  32|  32| /// Buffer template class that stores text
+|  33|  33| /// along with its properties (colors/formatting).
+|  34|    |-template <typename CharT> class BasicBuffer
+|  35|    |-{
+|  36|    |-	struct Property
+|  37|    |-	{
+|  38|    |-		template <typename ArgT>
+|  39|    |-		Property(ArgT &&arg, size_t id_)
+|  40|    |-		: m_impl(std::forward<ArgT>(arg)), m_id(id_) { }
+|  41|    |-		
+|  42|    |-		size_t id() const { return m_id; }
+|  43|    |-
+|  44|    |-		bool operator==(const Property &rhs) const
+|  45|    |-		{
+|  46|    |-			return m_id == rhs.m_id && m_impl == rhs.m_impl;
+|  47|    |-		}
+|  48|    |-
+|  49|    |-		template <typename OutputStreamT>
+|  50|    |-		friend OutputStreamT &operator<<(OutputStreamT &os, const Property &p)
+|  51|    |-		{
+|  52|    |-			boost::apply_visitor([&os](const auto &v) { os << v; }, p.m_impl);
+|  53|    |-			return os;
+|  54|    |-		}
+|  55|    |-		
+|  56|    |-	private:
+|  57|    |-		boost::variant<Color,
+|  58|    |-		               Format,
+|  59|    |-		               FormattedColor,
+|  60|    |-		               FormattedColor::End<StorageKind::Value>
+|  61|    |-		               > m_impl;
+|  62|    |-		size_t m_id;
+|  63|    |-	};
+|  64|    |-	
+|  65|    |-public:
+|  66|    |-	typedef std::basic_string<CharT> StringType;
+|  67|    |-	typedef std::multimap<size_t, Property> Properties;
+|  68|    |-	
+|  69|    |-	const StringType &str() const { return m_string; }
+|  70|    |-	const Properties &properties() const { return m_properties; }
+|  71|    |-	
+|  72|    |-	template <typename PropertyT>
+|  73|    |-	void addProperty(size_t position, PropertyT &&property, size_t id = -1)
+|  74|    |-	{
+|  75|    |-		assert(position <= m_string.size());
+|  76|    |-		m_properties.emplace(position, Property(std::forward<PropertyT>(property), id));
+|  77|    |-	}
+|  78|    |-
+|  79|    |-	void removeProperties(size_t id = -1)
+|  80|    |-	{
+|  81|    |-		auto it = m_properties.begin();
+|  82|    |-		while (it != m_properties.end())
+|  83|    |-		{
+|  84|    |-			if (it->second.id() == id)
+|  85|    |-				m_properties.erase(it++);
+|  86|    |-			else
+|  87|    |-				++it;
+|  88|    |-		}
+|  89|    |-	}
+|  90|    |-
+|  91|    |-	bool empty() const
+|  92|    |-	{
+|  93|    |-		return m_string.empty() && m_properties.empty();
+|  94|    |-	}
+|  95|    |-
+|  96|    |-	void clear()
+|  97|    |-	{
+|  98|    |-		m_string.clear();
+|  99|    |-		m_properties.clear();
+| 100|    |-	}
+| 101|    |-	
+| 102|    |-	BasicBuffer<CharT> &operator<<(int n)
+| 103|    |-	{
+| 104|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 105|    |-		return *this;
+| 106|    |-	}
+| 107|    |-	
+| 108|    |-	BasicBuffer<CharT> &operator<<(long int n)
+| 109|    |-	{
+| 110|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 111|    |-		return *this;
+| 112|    |-	}
+| 113|    |-	
+| 114|    |-	BasicBuffer<CharT> &operator<<(unsigned int n)
+| 115|    |-	{
+| 116|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 117|    |-		return *this;
+| 118|    |-	}
+| 119|    |-	
+| 120|    |-	BasicBuffer<CharT> &operator<<(unsigned long int n)
+| 121|    |-	{
+| 122|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 123|    |-		return *this;
+| 124|    |-	}
+| 125|    |-	
+| 126|    |-	BasicBuffer<CharT> &operator<<(CharT c)
+| 127|    |-	{
+| 128|    |-		m_string += c;
+| 129|    |-		return *this;
+| 130|    |-	}
+| 131|    |-
+| 132|    |-	BasicBuffer<CharT> &operator<<(const CharT *s)
+| 133|    |-	{
+| 134|    |-		m_string += s;
+| 135|    |-		return *this;
+| 136|    |-	}
+| 137|    |-	
+| 138|    |-	BasicBuffer<CharT> &operator<<(const StringType &s)
+| 139|    |-	{
+| 140|    |-		m_string += s;
+| 141|    |-		return *this;
+| 142|    |-	}
+| 143|    |-	
+| 144|    |-	BasicBuffer<CharT> &operator<<(const Color &color)
+| 145|    |-	{
+| 146|    |-		addProperty(m_string.size(), color);
+| 147|    |-		return *this;
+| 148|    |-	}
+| 149|    |-	
+| 150|    |-	BasicBuffer<CharT> &operator<<(const Format &format)
+| 151|    |-	{
+| 152|    |-		addProperty(m_string.size(), format);
+| 153|    |-		return *this;
+| 154|    |-	}
+| 155|    |-
+| 156|    |-	// static variadic initializer. used instead of a proper constructor because
+| 157|    |-	// it's too polymorphic and would end up invoked as a copy/move constructor.
+| 158|    |-	template <typename... Args>
+| 159|    |-	static BasicBuffer init(Args&&... args)
+| 160|    |-	{
+| 161|    |-		BasicBuffer result;
+| 162|    |-		result.construct(std::forward<Args>(args)...);
+| 163|    |-		return result;
+| 164|    |-	}
+| 165|    |-
+| 166|    |-private:
+| 167|    |-	void construct() { }
+| 168|    |-	template <typename ArgT, typename... Args>
+| 169|    |-	void construct(ArgT &&arg, Args&&... args)
+| 170|    |-	{
+| 171|    |-		*this << std::forward<ArgT>(arg);
+| 172|    |-		construct(std::forward<Args>(args)...);
+| 173|    |-	}
+| 174|    |-
+| 175|    |-	StringType m_string;
+| 176|    |-	Properties m_properties;
+| 177|    |-};
+| 178|    |-
+| 179|    |-typedef BasicBuffer<char> Buffer;
+| 180|    |-typedef BasicBuffer<wchar_t> WBuffer;
+| 181|    |-
+| 182|    |-template <typename CharT>
+| 183|    |-bool operator==(const BasicBuffer<CharT> &lhs, const BasicBuffer<CharT> &rhs)
+| 184|    |-{
+| 185|    |-	return lhs.str() == rhs.str()
+| 186|    |-		&& lhs.properties() == rhs.properties();
+|    |  34|+    template < typename CharT > class BasicBuffer
+|    |  35|+    {
+|    |  36|+        struct Property
+|    |  37|+        {
+|    |  38|+            template < typename ArgT >
+|    |  39|+                Property (ArgT
+|    |  40|+                          && arg,
+|    |  41|+                          size_t id_):m_impl (std::forward < ArgT > (arg)),
+|    |  42|+                m_id (id_)
+|    |  43|+            {
+|    |  44|+            }
+|    |  45|+
+|    |  46|+            size_t id () const
+|    |  47|+            {
+|    |  48|+                return m_id;
+|    |  49|+            }
+|    |  50|+
+|    |  51|+            bool operator== (const Property & rhs) const
+|    |  52|+            {
+|    |  53|+                return m_id == rhs.m_id && m_impl == rhs.m_impl;
+|    |  54|+            }
+|    |  55|+
+|    |  56|+            template < typename OutputStreamT >
+|    |  57|+                friend OutputStreamT & operator<< (OutputStreamT & os,
+|    |  58|+                                                   const Property & p)
+|    |  59|+            {
+|    |  60|+                boost::apply_visitor ([&os] (const auto & v)
+|    |  61|+                                      {
+|    |  62|+                                      os << v;
+|    |  63|+                                      }, p.m_impl);
+|    |  64|+                return os;
+|    |  65|+            }
+|    |  66|+
+|    |  67|+          private:
+|    |  68|+            boost::variant < Color,
+|    |  69|+                Format,
+|    |  70|+                FormattedColor,
+|    |  71|+                FormattedColor::End < StorageKind::Value > >m_impl;
+|    |  72|+            size_t m_id;
+|    |  73|+        };
+|    |  74|+
+|    |  75|+      public:
+|    |  76|+        typedef std::basic_string < CharT > StringType;
+|    |  77|+        typedef std::multimap < size_t, Property > Properties;
+|    |  78|+
+|    |  79|+        const StringType & str () const
+|    |  80|+        {
+|    |  81|+            return m_string;
+|    |  82|+        }
+|    |  83|+        const Properties & properties () const
+|    |  84|+        {
+|    |  85|+            return m_properties;
+|    |  86|+        }
+|    |  87|+
+|    |  88|+        template < typename PropertyT >
+|    |  89|+            void addProperty (size_t position, PropertyT
+|    |  90|+                              && property, size_t id = -1)
+|    |  91|+        {
+|    |  92|+            assert (position <= m_string.size ());
+|    |  93|+            m_properties.emplace (position,
+|    |  94|+                                  Property (std::forward < PropertyT >
+|    |  95|+                                            (property), id));
+|    |  96|+        }
+|    |  97|+
+|    |  98|+        void removeProperties (size_t id = -1)
+|    |  99|+        {
+|    | 100|+            auto it = m_properties.begin ();
+|    | 101|+            while (it != m_properties.end ())
+|    | 102|+              {
+|    | 103|+                  if (it->second.id () == id)
+|    | 104|+                      m_properties.erase (it++);
+|    | 105|+                  else
+|    | 106|+                      ++it;
+|    | 107|+              }
+|    | 108|+        }
+|    | 109|+
+|    | 110|+        bool empty () const
+|    | 111|+        {
+|    | 112|+            return m_string.empty () && m_properties.empty ();
+|    | 113|+        }
+|    | 114|+
+|    | 115|+        void clear ()
+|    | 116|+        {
+|    | 117|+            m_string.clear ();
+|    | 118|+            m_properties.clear ();
+|    | 119|+        }
+|    | 120|+
+|    | 121|+        BasicBuffer < CharT > &operator<< (int n)
+|    | 122|+        {
+|    | 123|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 124|+            return *this;
+|    | 125|+        }
+|    | 126|+
+|    | 127|+        BasicBuffer < CharT > &operator<< (long int n)
+|    | 128|+        {
+|    | 129|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 130|+            return *this;
+|    | 131|+        }
+|    | 132|+
+|    | 133|+        BasicBuffer < CharT > &operator<< (unsigned int n)
+|    | 134|+        {
+|    | 135|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 136|+            return *this;
+|    | 137|+        }
+|    | 138|+
+|    | 139|+        BasicBuffer < CharT > &operator<< (unsigned long int n)
+|    | 140|+        {
+|    | 141|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 142|+            return *this;
+|    | 143|+        }
+|    | 144|+
+|    | 145|+        BasicBuffer < CharT > &operator<< (CharT c)
+|    | 146|+        {
+|    | 147|+            m_string += c;
+|    | 148|+            return *this;
+|    | 149|+        }
+|    | 150|+
+|    | 151|+        BasicBuffer < CharT > &operator<< (const CharT * s)
+|    | 152|+        {
+|    | 153|+            m_string += s;
+|    | 154|+            return *this;
+|    | 155|+        }
+|    | 156|+
+|    | 157|+        BasicBuffer < CharT > &operator<< (const StringType & s)
+|    | 158|+        {
+|    | 159|+            m_string += s;
+|    | 160|+            return *this;
+|    | 161|+        }
+|    | 162|+
+|    | 163|+        BasicBuffer < CharT > &operator<< (const Color & color)
+|    | 164|+        {
+|    | 165|+            addProperty (m_string.size (), color);
+|    | 166|+            return *this;
+|    | 167|+        }
+|    | 168|+
+|    | 169|+        BasicBuffer < CharT > &operator<< (const Format & format)
+|    | 170|+        {
+|    | 171|+            addProperty (m_string.size (), format);
+|    | 172|+            return *this;
+|    | 173|+        }
+|    | 174|+
+|    | 175|+        // static variadic initializer. used instead of a proper constructor because
+|    | 176|+        // it's too polymorphic and would end up invoked as a copy/move constructor.
+|    | 177|+        template < typename...Args > static BasicBuffer init (Args && ... args)
+|    | 178|+        {
+|    | 179|+            BasicBuffer result;
+|    | 180|+            result.construct (std::forward < Args > (args)...);
+|    | 181|+            return result;
+|    | 182|+        }
+|    | 183|+
+|    | 184|+      private:
+|    | 185|+        void construct ()
+|    | 186|+        {
+|    | 187|+        }
+|    | 188|+        template < typename ArgT, typename...Args >
+|    | 189|+            void construct (ArgT && arg, Args && ... args)
+|    | 190|+        {
+|    | 191|+            *this << std::forward < ArgT > (arg);
+|    | 192|+            construct (std::forward < Args > (args)...);
+|    | 193|+        }
+|    | 194|+
+|    | 195|+        StringType m_string;
+|    | 196|+        Properties m_properties;
+|    | 197|+    };
+|    | 198|+
+|    | 199|+    typedef BasicBuffer < char >Buffer;
+|    | 200|+    typedef BasicBuffer < wchar_t > WBuffer;
+|    | 201|+
+|    | 202|+    template < typename CharT >
+|    | 203|+        bool operator== (const BasicBuffer < CharT > &lhs,
+|    | 204|+                         const BasicBuffer < CharT > &rhs)
+|    | 205|+    {
+|    | 206|+        return lhs.str () == rhs.str ()
+|    | 207|+            && lhs.properties () == rhs.properties ();
+|    | 208|+    }
+|    | 209|+
+|    | 210|+    template < typename OutputStreamT, typename CharT >
+|    | 211|+        OutputStreamT & operator<< (OutputStreamT & os,
+|    | 212|+                                    const BasicBuffer < CharT > &buffer)
+|    | 213|+    {
+|    | 214|+        if (buffer.properties ().empty ())
+|    | 215|+            os << buffer.str ();
+|    | 216|+        else
+|    | 217|+          {
+|    | 218|+              auto & s = buffer.str ();
+|    | 219|+              auto & ps = buffer.properties ();
+|    | 220|+              auto p = ps.begin ();
+|    | 221|+              for (size_t i = 0;; ++i)
+|    | 222|+                {
+|    | 223|+                    for (; p != ps.end () && p->first == i; ++p)
+|    | 224|+                        os << p->second;
+|    | 225|+                    if (i < s.size ())
+|    | 226|+                        os << s[i];
+|    | 227|+                    else
+|    | 228|+                        break;
+|    | 229|+                }
+|    | 230|+          }
+|    | 231|+        return os;
+|    | 232|+    }
+|    | 233|+
+| 187| 234| }
+| 188| 235| 
+| 189| 236| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+| 186| 186| 		&& lhs.properties() == rhs.properties();
+| 187| 187| }
+| 188| 188| 
+| 189|    |-
+| 190|    |-template <typename OutputStreamT, typename CharT>
+| 191|    |-OutputStreamT &operator<<(OutputStreamT &os, const BasicBuffer<CharT> &buffer)
+| 192|    |-{
+| 193|    |-	if (buffer.properties().empty())
+| 194|    |-		os << buffer.str();
+| 195|    |-	else
+| 196|    |-	{
+| 197|    |-		auto &s = buffer.str();
+| 198|    |-		auto &ps = buffer.properties();
+| 199|    |-		auto p = ps.begin();
+| 200|    |-		for (size_t i = 0;; ++i)
+| 201|    |-		{
+| 202|    |-			for (; p != ps.end() && p->first == i; ++p)
+| 203|    |-				os << p->second;
+| 204|    |-			if (i < s.size())
+| 205|    |-				os << s[i];
+| 206|    |-			else
+| 207|    |-				break;
+| 208|    |-		}
+| 209|    |-	}
+| 210|    |-	return os;
+| 211|    |-}
+| 212|    |-
+| 213|    |-}
+| 214|    |-
+| 215| 189| #endif // NCMPCPP_STRBUFFER_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  30|  30| #include "mpdpp.h"
+|  31|  31| #include "screens/screen.h"
+|  32|  32| 
+|  33|    |-struct Outputs: Screen<NC::Menu<MPD::Output>>, Tabbable
+|    |  33|+struct Outputs:Screen <
+|    |  34|+    NC::Menu <
+|    |  35|+    MPD::Output >>,
+|    |  36|+    Tabbable
+|  34|  37| {
+|  35|    |-	Outputs();
+|  36|    |-	
+|  37|    |-	// Screen< NC::Menu<MPD::Output> > implementation
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	
+|  41|    |-	virtual std::wstring title() override;
+|  42|    |-	virtual ScreenType type() override { return ScreenType::Outputs; }
+|  43|    |-	
+|  44|    |-	virtual void update() override { }
+|  45|    |-	
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// private members
+|  52|    |-	void fetchList();
+|  53|    |-	void toggleOutput();
+|    |  38|+    Outputs ();
+|    |  39|+
+|    |  40|+    // Screen< NC::Menu<MPD::Output> > implementation
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|    |  47|+
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::Outputs;
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    virtual void
+|    |  60|+    update ()
+|    |  61|+        override
+|    |  62|+    {
+|    |  63|+    }
+|    |  64|+
+|    |  65|+    virtual void
+|    |  66|+    mouseButtonPressed (MEVENT me)
+|    |  67|+        override;
+|    |  68|+
+|    |  69|+    virtual bool
+|    |  70|+    isLockable ()
+|    |  71|+        override
+|    |  72|+    {
+|    |  73|+        return true;
+|    |  74|+    }
+|    |  75|+    virtual bool
+|    |  76|+    isMergable ()
+|    |  77|+        override
+|    |  78|+    {
+|    |  79|+        return true;
+|    |  80|+    }
+|    |  81|+
+|    |  82|+    // private members
+|    |  83|+    void
+|    |  84|+    fetchList ();
+|    |  85|+    void
+|    |  86|+    toggleOutput ();
+|  54|  87| };
+|  55|  88| 
+|  56|  89| extern Outputs *myOutputs;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  53|  53| 	void toggleOutput();
+|  54|  54| };
+|  55|  55| 
+|  56|    |-extern Outputs *myOutputs;
+|    |  56|+extern Outputs *
+|    |  57|+    myOutputs;
+|  57|  58| 
+|  58|  59| #endif // ENABLE_OUTPUTS
+|  59|  60| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  58|  58| #endif // ENABLE_OUTPUTS
+|  59|  59| 
+|  60|  60| #endif // NCMPCPP_OUTPUTS_H
+|  61|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/menu_impl.h
+|    |++++| /app/src/curses/menu_impl.h
+|  23|  23| 
+|  24|  24| #include "menu.h"
+|  25|  25| 
+|  26|    |-namespace NC {
+|  27|    |-
+|  28|    |-template <typename ItemT>
+|  29|    |-Menu<ItemT>::Menu()
+|  30|    |-{
+|  31|    |-	m_items = &m_all_items;
+|    |  26|+namespace NC
+|    |  27|+{
+|    |  28|+
+|    |  29|+    template < typename ItemT > Menu < ItemT >::Menu ()
+|    |  30|+    {
+|    |  31|+        m_items = &m_all_items;
+|    |  32|+    }
+|    |  33|+
+|    |  34|+    template < typename ItemT >
+|    |  35|+        Menu < ItemT >::Menu (size_t startx,
+|    |  36|+                              size_t starty,
+|    |  37|+                              size_t width,
+|    |  38|+                              size_t height,
+|    |  39|+                              const std::string & title,
+|    |  40|+                              Color color,
+|    |  41|+                              Border border):Window (startx, starty, width,
+|    |  42|+                                                     height, title, color,
+|    |  43|+                                                     border),
+|    |  44|+        m_item_displayer (nullptr), m_filter_predicate (nullptr),
+|    |  45|+        m_beginning (0), m_highlight (0), m_highlight_enabled (true),
+|    |  46|+        m_cyclic_scroll_enabled (false), m_autocenter_cursor (false)
+|    |  47|+    {
+|    |  48|+        auto fc = FormattedColor (m_base_color, { Format::Reverse });
+|    |  49|+        m_highlight_prefix << fc;
+|    |  50|+        m_highlight_suffix << FormattedColor::End <> (fc);
+|    |  51|+        m_items = &m_all_items;
+|    |  52|+    }
+|    |  53|+
+|    |  54|+    template < typename ItemT >
+|    |  55|+        Menu < ItemT >::Menu (const Menu & rhs):Window (rhs),
+|    |  56|+        m_item_displayer (rhs.m_item_displayer),
+|    |  57|+        m_filter_predicate (rhs.m_filter_predicate),
+|    |  58|+        m_beginning (rhs.m_beginning), m_highlight (rhs.m_highlight),
+|    |  59|+        m_highlight_enabled (rhs.m_highlight_enabled),
+|    |  60|+        m_cyclic_scroll_enabled (rhs.m_cyclic_scroll_enabled),
+|    |  61|+        m_autocenter_cursor (rhs.m_autocenter_cursor),
+|    |  62|+        m_drawn_position (rhs.m_drawn_position),
+|    |  63|+        m_highlight_prefix (rhs.m_highlight_prefix),
+|    |  64|+        m_highlight_suffix (rhs.m_highlight_suffix),
+|    |  65|+        m_selected_prefix (rhs.m_selected_prefix),
+|    |  66|+        m_selected_suffix (rhs.m_selected_suffix)
+|    |  67|+    {
+|    |  68|+        // TODO: move filtered items
+|    |  69|+        m_all_items.reserve (rhs.m_all_items.size ());
+|    |  70|+      for (const auto & item:rhs.m_all_items)
+|    |  71|+            m_all_items.push_back (item.copy ());
+|    |  72|+        m_items = &m_all_items;
+|    |  73|+    }
+|    |  74|+
+|    |  75|+  template < typename ItemT > Menu < ItemT >::Menu (Menu && rhs):Window (rhs), m_item_displayer (std::move (rhs.m_item_displayer)),
+|    |  76|+        m_filter_predicate (std::move (rhs.m_filter_predicate)),
+|    |  77|+        m_all_items (std::move (rhs.m_all_items)),
+|    |  78|+        m_filtered_items (std::move (rhs.m_filtered_items)),
+|    |  79|+        m_beginning (rhs.m_beginning), m_highlight (rhs.m_highlight),
+|    |  80|+        m_highlight_enabled (rhs.m_highlight_enabled),
+|    |  81|+        m_cyclic_scroll_enabled (rhs.m_cyclic_scroll_enabled),
+|    |  82|+        m_autocenter_cursor (rhs.m_autocenter_cursor),
+|    |  83|+        m_drawn_position (rhs.m_drawn_position),
+|    |  84|+        m_highlight_prefix (std::move (rhs.m_highlight_prefix)),
+|    |  85|+        m_highlight_suffix (std::move (rhs.m_highlight_suffix)),
+|    |  86|+        m_selected_prefix (std::move (rhs.m_selected_prefix)),
+|    |  87|+        m_selected_suffix (std::move (rhs.m_selected_suffix))
+|    |  88|+    {
+|    |  89|+        if (rhs.m_items == &rhs.m_all_items)
+|    |  90|+            m_items = &m_all_items;
+|    |  91|+        else
+|    |  92|+            m_items = &m_filtered_items;
+|    |  93|+    }
+|    |  94|+
+|    |  95|+    template < typename ItemT >
+|    |  96|+        Menu < ItemT > &Menu < ItemT >::operator= (Menu rhs)
+|    |  97|+    {
+|    |  98|+        std::swap (static_cast < Window & >(*this),
+|    |  99|+                   static_cast < Window & >(rhs));
+|    | 100|+        std::swap (m_item_displayer, rhs.m_item_displayer);
+|    | 101|+        std::swap (m_filter_predicate, rhs.m_filter_predicate);
+|    | 102|+        std::swap (m_all_items, rhs.m_all_items);
+|    | 103|+        std::swap (m_filtered_items, rhs.m_filtered_items);
+|    | 104|+        std::swap (m_beginning, rhs.m_beginning);
+|    | 105|+        std::swap (m_highlight, rhs.m_highlight);
+|    | 106|+        std::swap (m_highlight_enabled, rhs.m_highlight_enabled);
+|    | 107|+        std::swap (m_cyclic_scroll_enabled, rhs.m_cyclic_scroll_enabled);
+|    | 108|+        std::swap (m_autocenter_cursor, rhs.m_autocenter_cursor);
+|    | 109|+        std::swap (m_drawn_position, rhs.m_drawn_position);
+|    | 110|+        std::swap (m_highlight_prefix, rhs.m_highlight_prefix);
+|    | 111|+        std::swap (m_highlight_suffix, rhs.m_highlight_suffix);
+|    | 112|+        std::swap (m_selected_prefix, rhs.m_selected_prefix);
+|    | 113|+        std::swap (m_selected_suffix, rhs.m_selected_suffix);
+|    | 114|+        if (rhs.m_items == &rhs.m_all_items)
+|    | 115|+            m_items = &m_all_items;
+|    | 116|+        else
+|    | 117|+            m_items = &m_filtered_items;
+|    | 118|+        return *this;
+|    | 119|+    }
+|    | 120|+
+|    | 121|+    template < typename ItemT > template < typename ItemDisplayerT >
+|    | 122|+        void Menu < ItemT >::setItemDisplayer (ItemDisplayerT && displayer)
+|    | 123|+    {
+|    | 124|+        m_item_displayer = std::forward < ItemDisplayerT > (displayer);
+|    | 125|+    }
+|    | 126|+
+|    | 127|+    template < typename ItemT >
+|    | 128|+        void Menu < ItemT >::resizeList (size_t new_size)
+|    | 129|+    {
+|    | 130|+        m_all_items.resize (new_size);
+|    | 131|+    }
+|    | 132|+
+|    | 133|+    template < typename ItemT >
+|    | 134|+        void Menu < ItemT >::addItem (ItemT item, Properties::Type properties)
+|    | 135|+    {
+|    | 136|+        m_all_items.push_back (Item (std::move (item), properties));
+|    | 137|+    }
+|    | 138|+
+|    | 139|+    template < typename ItemT > void Menu < ItemT >::addSeparator ()
+|    | 140|+    {
+|    | 141|+        m_all_items.push_back (Item::mkSeparator ());
+|    | 142|+    }
+|    | 143|+
+|    | 144|+    template < typename ItemT >
+|    | 145|+        void Menu < ItemT >::insertItem (size_t pos, ItemT item,
+|    | 146|+                                         Properties::Type properties)
+|    | 147|+    {
+|    | 148|+        m_all_items.insert (m_all_items.begin () + pos,
+|    | 149|+                            Item (std::move (item), properties));
+|    | 150|+    }
+|    | 151|+
+|    | 152|+    template < typename ItemT >
+|    | 153|+        void Menu < ItemT >::insertSeparator (size_t pos)
+|    | 154|+    {
+|    | 155|+        m_all_items.insert (m_all_items.begin () + pos, Item::mkSeparator ());
+|    | 156|+    }
+|    | 157|+
+|    | 158|+    template < typename ItemT > bool Menu < ItemT >::Goto (size_t y)
+|    | 159|+    {
+|    | 160|+        if (!isHighlightable (m_beginning + y))
+|    | 161|+            return false;
+|    | 162|+        m_highlight = m_beginning + y;
+|    | 163|+        return true;
+|    | 164|+    }
+|    | 165|+
+|    | 166|+    template < typename ItemT > void Menu < ItemT >::refresh ()
+|    | 167|+    {
+|    | 168|+        if (m_items->empty ())
+|    | 169|+          {
+|    | 170|+              Window::clear ();
+|    | 171|+              Window::refresh ();
+|    | 172|+              return;
+|    | 173|+          }
+|    | 174|+
+|    | 175|+        size_t max_beginning = 0;
+|    | 176|+        if (m_items->size () > m_height)
+|    | 177|+            max_beginning = m_items->size () - m_height;
+|    | 178|+        m_beginning = std::min (m_beginning, max_beginning);
+|    | 179|+
+|    | 180|+        // if highlighted position is off the screen, make it visible
+|    | 181|+        m_highlight = std::min (m_highlight, m_beginning + m_height - 1);
+|    | 182|+        // if highlighted position is invalid, correct it
+|    | 183|+        m_highlight = std::min (m_highlight, m_items->size () - 1);
+|    | 184|+
+|    | 185|+        if (!isHighlightable (m_highlight))
+|    | 186|+          {
+|    | 187|+              scroll (Scroll::Up);
+|    | 188|+              if (!isHighlightable (m_highlight))
+|    | 189|+                  scroll (Scroll::Down);
+|    | 190|+          }
+|    | 191|+
+|    | 192|+        size_t line = 0;
+|    | 193|+        const size_t end_ = m_beginning + m_height;
+|    | 194|+        m_drawn_position = m_beginning;
+|    | 195|+        for (; m_drawn_position < end_; ++m_drawn_position, ++line)
+|    | 196|+          {
+|    | 197|+              goToXY (0, line);
+|    | 198|+              if (m_drawn_position >= m_items->size ())
+|    | 199|+                {
+|    | 200|+                    for (; line < m_height; ++line)
+|    | 201|+                        mvwhline (m_window, line, 0, NC::Key::Space, m_width);
+|    | 202|+                    break;
+|    | 203|+                }
+|    | 204|+              if ((*m_items)[m_drawn_position].isSeparator ())
+|    | 205|+                {
+|    | 206|+                    mvwhline (m_window, line, 0, 0, m_width);
+|    | 207|+                    continue;
+|    | 208|+                }
+|    | 209|+              if (m_highlight_enabled && m_drawn_position == m_highlight)
+|    | 210|+                  *this << m_highlight_prefix;
+|    | 211|+              if ((*m_items)[m_drawn_position].isSelected ())
+|    | 212|+                  *this << m_selected_prefix;
+|    | 213|+              *this << NC::TermManip::ClearToEOL;
+|    | 214|+              if (m_item_displayer)
+|    | 215|+                  m_item_displayer (*this);
+|    | 216|+              if ((*m_items)[m_drawn_position].isSelected ())
+|    | 217|+                  *this << m_selected_suffix;
+|    | 218|+              if (m_highlight_enabled && m_drawn_position == m_highlight)
+|    | 219|+                  *this << m_highlight_suffix;
+|    | 220|+          }
+|    | 221|+        Window::refresh ();
+|    | 222|+    }
+|    | 223|+
+|    | 224|+    template < typename ItemT > void Menu < ItemT >::scroll (Scroll where)
+|    | 225|+    {
+|    | 226|+        if (m_items->empty ())
+|    | 227|+            return;
+|    | 228|+        size_t max_highlight = m_items->size () - 1;
+|    | 229|+        size_t max_beginning =
+|    | 230|+            m_items->size () < m_height ? 0 : m_items->size () - m_height;
+|    | 231|+        size_t max_visible_highlight = m_beginning + m_height - 1;
+|    | 232|+        switch (where)
+|    | 233|+          {
+|    | 234|+          case Scroll::Up:
+|    | 235|+              {
+|    | 236|+                  if (m_highlight <= m_beginning && m_highlight > 0)
+|    | 237|+                      --m_beginning;
+|    | 238|+                  if (m_highlight == 0)
+|    | 239|+                    {
+|    | 240|+                        if (m_cyclic_scroll_enabled)
+|    | 241|+                            return scroll (Scroll::End);
+|    | 242|+                        break;
+|    | 243|+                    }
+|    | 244|+                  else
+|    | 245|+                      --m_highlight;
+|    | 246|+                  if (!isHighlightable (m_highlight))
+|    | 247|+                      scroll (m_highlight == 0
+|    | 248|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 249|+                              Down : Scroll::Up);
+|    | 250|+                  break;
+|    | 251|+              }
+|    | 252|+          case Scroll::Down:
+|    | 253|+              {
+|    | 254|+                  if (m_highlight >= max_visible_highlight
+|    | 255|+                      && m_highlight < max_highlight)
+|    | 256|+                      ++m_beginning;
+|    | 257|+                  if (m_highlight == max_highlight)
+|    | 258|+                    {
+|    | 259|+                        if (m_cyclic_scroll_enabled)
+|    | 260|+                            return scroll (Scroll::Home);
+|    | 261|+                        break;
+|    | 262|+                    }
+|    | 263|+                  else
+|    | 264|+                      ++m_highlight;
+|    | 265|+                  if (!isHighlightable (m_highlight))
+|    | 266|+                      scroll (m_highlight == max_highlight
+|    | 267|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 268|+                              Up : Scroll::Down);
+|    | 269|+                  break;
+|    | 270|+              }
+|    | 271|+          case Scroll::PageUp:
+|    | 272|+              {
+|    | 273|+                  if (m_cyclic_scroll_enabled && m_highlight == 0)
+|    | 274|+                      return scroll (Scroll::End);
+|    | 275|+                  if (m_highlight < m_height)
+|    | 276|+                      m_highlight = 0;
+|    | 277|+                  else
+|    | 278|+                      m_highlight -= m_height;
+|    | 279|+                  if (m_beginning < m_height)
+|    | 280|+                      m_beginning = 0;
+|    | 281|+                  else
+|    | 282|+                      m_beginning -= m_height;
+|    | 283|+                  if (!isHighlightable (m_highlight))
+|    | 284|+                      scroll (m_highlight == 0
+|    | 285|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 286|+                              Down : Scroll::Up);
+|    | 287|+                  break;
+|    | 288|+              }
+|    | 289|+          case Scroll::PageDown:
+|    | 290|+              {
+|    | 291|+                  if (m_cyclic_scroll_enabled && m_highlight == max_highlight)
+|    | 292|+                      return scroll (Scroll::Home);
+|    | 293|+                  m_highlight += m_height;
+|    | 294|+                  m_beginning += m_height;
+|    | 295|+                  m_beginning = std::min (m_beginning, max_beginning);
+|    | 296|+                  m_highlight = std::min (m_highlight, max_highlight);
+|    | 297|+                  if (!isHighlightable (m_highlight))
+|    | 298|+                      scroll (m_highlight == max_highlight
+|    | 299|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 300|+                              Up : Scroll::Down);
+|    | 301|+                  break;
+|    | 302|+              }
+|    | 303|+          case Scroll::Home:
+|    | 304|+              {
+|    | 305|+                  m_highlight = 0;
+|    | 306|+                  m_beginning = 0;
+|    | 307|+                  if (!isHighlightable (m_highlight))
+|    | 308|+                      scroll (Scroll::Down);
+|    | 309|+                  break;
+|    | 310|+              }
+|    | 311|+          case Scroll::End:
+|    | 312|+              {
+|    | 313|+                  m_highlight = max_highlight;
+|    | 314|+                  m_beginning = max_beginning;
+|    | 315|+                  if (!isHighlightable (m_highlight))
+|    | 316|+                      scroll (Scroll::Up);
+|    | 317|+                  break;
+|    | 318|+              }
+|    | 319|+          }
+|    | 320|+        if (m_autocenter_cursor)
+|    | 321|+            highlight (m_highlight);
+|    | 322|+    }
+|    | 323|+
+|    | 324|+    template < typename ItemT > void Menu < ItemT >::reset ()
+|    | 325|+    {
+|    | 326|+        m_highlight = 0;
+|    | 327|+        m_beginning = 0;
+|    | 328|+    }
+|    | 329|+
+|    | 330|+    template < typename ItemT > void Menu < ItemT >::clear ()
+|    | 331|+    {
+|    | 332|+        // Don't clear filter related stuff here.
+|    | 333|+        m_all_items.clear ();
+|    | 334|+        m_filtered_items.clear ();
+|    | 335|+    }
+|    | 336|+
+|    | 337|+    template < typename ItemT > void Menu < ItemT >::highlight (size_t pos)
+|    | 338|+    {
+|    | 339|+        assert (pos < m_items->size ());
+|    | 340|+        m_highlight = pos;
+|    | 341|+        size_t half_height = m_height / 2;
+|    | 342|+        if (pos < half_height)
+|    | 343|+            m_beginning = 0;
+|    | 344|+        else
+|    | 345|+            m_beginning = pos - half_height;
+|    | 346|+    }
+|    | 347|+
+|    | 348|+    template < typename ItemT > size_t Menu < ItemT >::choice ()const
+|    | 349|+    {
+|    | 350|+        assert (!empty ());
+|    | 351|+        return m_highlight;
+|    | 352|+    }
+|    | 353|+
+|    | 354|+    template < typename ItemT > template < typename PredicateT >
+|    | 355|+        void Menu < ItemT >::applyFilter (PredicateT && pred)
+|    | 356|+    {
+|    | 357|+        m_filter_predicate = std::forward < PredicateT > (pred);
+|    | 358|+        m_filtered_items.clear ();
+|    | 359|+
+|    | 360|+      for (const auto & item:m_all_items)
+|    | 361|+            if (m_filter_predicate (item))
+|    | 362|+                m_filtered_items.push_back (item);
+|    | 363|+
+|    | 364|+        m_items = &m_filtered_items;
+|    | 365|+    }
+|    | 366|+
+|    | 367|+    template < typename ItemT > void Menu < ItemT >::reapplyFilter ()
+|    | 368|+    {
+|    | 369|+        applyFilter (m_filter_predicate);
+|    | 370|+    }
+|    | 371|+
+|    | 372|+    template < typename ItemT > template < typename TargetT >
+|    | 373|+        const TargetT *Menu < ItemT >::filterPredicate () const
+|    | 374|+    {
+|    | 375|+        return m_filter_predicate.template target < TargetT > ();
+|    | 376|+    }
+|    | 377|+
+|    | 378|+    template < typename ItemT > void Menu < ItemT >::clearFilter ()
+|    | 379|+    {
+|    | 380|+        m_filter_predicate = nullptr;
+|    | 381|+        m_filtered_items.clear ();
+|    | 382|+        m_items = &m_all_items;
+|    | 383|+    }
+|    | 384|+
+|  32| 385| }
+|  33| 386| 
+|  34| 387| template <typename ItemT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/menu_impl.h
+|    |++++| /app/src/curses/menu_impl.h
+|  31|  31| 	m_items = &m_all_items;
+|  32|  32| }
+|  33|  33| 
+|  34|    |-template <typename ItemT>
+|  35|    |-Menu<ItemT>::Menu(size_t startx,
+|  36|    |-                  size_t starty,
+|  37|    |-                  size_t width,
+|  38|    |-                  size_t height,
+|  39|    |-                  const std::string &title,
+|  40|    |-                  Color color,
+|  41|    |-                  Border border)
+|  42|    |-	: Window(startx, starty, width, height, title, color, border)
+|  43|    |-	, m_item_displayer(nullptr)
+|  44|    |-	, m_filter_predicate(nullptr)
+|  45|    |-	, m_beginning(0)
+|  46|    |-	, m_highlight(0)
+|  47|    |-	, m_highlight_enabled(true)
+|  48|    |-	, m_cyclic_scroll_enabled(false)
+|  49|    |-	, m_autocenter_cursor(false)
+|  50|    |-{
+|  51|    |-	auto fc = FormattedColor(m_base_color, {Format::Reverse});
+|  52|    |-	m_highlight_prefix << fc;
+|  53|    |-	m_highlight_suffix << FormattedColor::End<>(fc);
+|  54|    |-	m_items = &m_all_items;
+|  55|    |-}
+|  56|    |-
+|  57|    |-template <typename ItemT>
+|  58|    |-Menu<ItemT>::Menu(const Menu &rhs)
+|  59|    |-	: Window(rhs)
+|  60|    |-	, m_item_displayer(rhs.m_item_displayer)
+|  61|    |-	, m_filter_predicate(rhs.m_filter_predicate)
+|  62|    |-	, m_beginning(rhs.m_beginning)
+|  63|    |-	, m_highlight(rhs.m_highlight)
+|  64|    |-	, m_highlight_enabled(rhs.m_highlight_enabled)
+|  65|    |-	, m_cyclic_scroll_enabled(rhs.m_cyclic_scroll_enabled)
+|  66|    |-	, m_autocenter_cursor(rhs.m_autocenter_cursor)
+|  67|    |-	, m_drawn_position(rhs.m_drawn_position)
+|  68|    |-	, m_highlight_prefix(rhs.m_highlight_prefix)
+|  69|    |-	, m_highlight_suffix(rhs.m_highlight_suffix)
+|  70|    |-	, m_selected_prefix(rhs.m_selected_prefix)
+|  71|    |-	, m_selected_suffix(rhs.m_selected_suffix)
+|  72|    |-{
+|  73|    |-	// TODO: move filtered items
+|  74|    |-	m_all_items.reserve(rhs.m_all_items.size());
+|  75|    |-	for (const auto &item : rhs.m_all_items)
+|  76|    |-		m_all_items.push_back(item.copy());
+|  77|    |-	m_items = &m_all_items;
+|  78|    |-}
+|  79|    |-
+|  80|    |-template <typename ItemT>
+|  81|    |-Menu<ItemT>::Menu(Menu &&rhs)
+|  82|    |-	: Window(rhs)
+|  83|    |-	, m_item_displayer(std::move(rhs.m_item_displayer))
+|  84|    |-	, m_filter_predicate(std::move(rhs.m_filter_predicate))
+|  85|    |-	, m_all_items(std::move(rhs.m_all_items))
+|  86|    |-	, m_filtered_items(std::move(rhs.m_filtered_items))
+|  87|    |-	, m_beginning(rhs.m_beginning)
+|  88|    |-	, m_highlight(rhs.m_highlight)
+|  89|    |-	, m_highlight_enabled(rhs.m_highlight_enabled)
+|  90|    |-	, m_cyclic_scroll_enabled(rhs.m_cyclic_scroll_enabled)
+|  91|    |-	, m_autocenter_cursor(rhs.m_autocenter_cursor)
+|  92|    |-	, m_drawn_position(rhs.m_drawn_position)
+|  93|    |-	, m_highlight_prefix(std::move(rhs.m_highlight_prefix))
+|  94|    |-	, m_highlight_suffix(std::move(rhs.m_highlight_suffix))
+|  95|    |-	, m_selected_prefix(std::move(rhs.m_selected_prefix))
+|  96|    |-	, m_selected_suffix(std::move(rhs.m_selected_suffix))
+|  97|    |-{
+|  98|    |-	if (rhs.m_items == &rhs.m_all_items)
+|  99|    |-		m_items = &m_all_items;
+| 100|    |-	else
+| 101|    |-		m_items = &m_filtered_items;
+| 102|    |-}
+| 103|    |-
+| 104|    |-template <typename ItemT>
+| 105|    |-Menu<ItemT> &Menu<ItemT>::operator=(Menu rhs)
+| 106|    |-{
+| 107|    |-	std::swap(static_cast<Window &>(*this), static_cast<Window &>(rhs));
+| 108|    |-	std::swap(m_item_displayer, rhs.m_item_displayer);
+| 109|    |-	std::swap(m_filter_predicate, rhs.m_filter_predicate);
+| 110|    |-	std::swap(m_all_items, rhs.m_all_items);
+| 111|    |-	std::swap(m_filtered_items, rhs.m_filtered_items);
+| 112|    |-	std::swap(m_beginning, rhs.m_beginning);
+| 113|    |-	std::swap(m_highlight, rhs.m_highlight);
+| 114|    |-	std::swap(m_highlight_enabled, rhs.m_highlight_enabled);
+| 115|    |-	std::swap(m_cyclic_scroll_enabled, rhs.m_cyclic_scroll_enabled);
+| 116|    |-	std::swap(m_autocenter_cursor, rhs.m_autocenter_cursor);
+| 117|    |-	std::swap(m_drawn_position, rhs.m_drawn_position);
+| 118|    |-	std::swap(m_highlight_prefix, rhs.m_highlight_prefix);
+| 119|    |-	std::swap(m_highlight_suffix, rhs.m_highlight_suffix);
+| 120|    |-	std::swap(m_selected_prefix, rhs.m_selected_prefix);
+| 121|    |-	std::swap(m_selected_suffix, rhs.m_selected_suffix);
+| 122|    |-	if (rhs.m_items == &rhs.m_all_items)
+| 123|    |-		m_items = &m_all_items;
+| 124|    |-	else
+| 125|    |-		m_items = &m_filtered_items;
+| 126|    |-	return *this;
+| 127|    |-}
+| 128|    |-
+| 129|    |-template <typename ItemT> template <typename ItemDisplayerT>
+| 130|    |-void Menu<ItemT>::setItemDisplayer(ItemDisplayerT &&displayer)
+| 131|    |-{
+| 132|    |-	m_item_displayer = std::forward<ItemDisplayerT>(displayer);
+| 133|    |-}
+| 134|    |-
+| 135|    |-template <typename ItemT>
+| 136|    |-void Menu<ItemT>::resizeList(size_t new_size)
+| 137|    |-{
+| 138|    |-	m_all_items.resize(new_size);
+| 139|    |-}
+| 140|    |-
+| 141|    |-template <typename ItemT>
+| 142|    |-void Menu<ItemT>::addItem(ItemT item, Properties::Type properties)
+| 143|    |-{
+| 144|    |-	m_all_items.push_back(Item(std::move(item), properties));
+| 145|    |-}
+| 146|    |-
+| 147|    |-template <typename ItemT>
+| 148|    |-void Menu<ItemT>::addSeparator()
+| 149|    |-{
+| 150|    |-	m_all_items.push_back(Item::mkSeparator());
+| 151|    |-}
+| 152|    |-
+| 153|    |-template <typename ItemT>
+| 154|    |-void Menu<ItemT>::insertItem(size_t pos, ItemT item, Properties::Type properties)
+| 155|    |-{
+| 156|    |-	m_all_items.insert(m_all_items.begin()+pos, Item(std::move(item), properties));
+| 157|    |-}
+| 158|    |-
+| 159|    |-template <typename ItemT>
+| 160|    |-void Menu<ItemT>::insertSeparator(size_t pos)
+| 161|    |-{
+| 162|    |-	m_all_items.insert(m_all_items.begin()+pos, Item::mkSeparator());
+| 163|    |-}
+| 164|    |-
+| 165|    |-template <typename ItemT>
+| 166|    |-bool Menu<ItemT>::Goto(size_t y)
+| 167|    |-{
+| 168|    |-	if (!isHighlightable(m_beginning+y))
+| 169|    |-		return false;
+| 170|    |-	m_highlight = m_beginning+y;
+| 171|    |-	return true;
+| 172|    |-}
+| 173|    |-
+| 174|    |-template <typename ItemT>
+| 175|    |-void Menu<ItemT>::refresh()
+| 176|    |-{
+| 177|    |-	if (m_items->empty())
+| 178|    |-	{
+| 179|    |-		Window::clear();
+| 180|    |-		Window::refresh();
+| 181|    |-		return;
+| 182|    |-	}
+| 183|    |-
+| 184|    |-	size_t max_beginning = 0;
+| 185|    |-	if (m_items->size() > m_height)
+| 186|    |-		max_beginning = m_items->size() - m_height;
+| 187|    |-	m_beginning = std::min(m_beginning, max_beginning);
+| 188|    |-
+| 189|    |-	// if highlighted position is off the screen, make it visible
+| 190|    |-	m_highlight = std::min(m_highlight, m_beginning+m_height-1);
+| 191|    |-	// if highlighted position is invalid, correct it
+| 192|    |-	m_highlight = std::min(m_highlight, m_items->size()-1);
+| 193|    |-
+| 194|    |-	if (!isHighlightable(m_highlight))
+| 195|    |-	{
+| 196|    |-		scroll(Scroll::Up);
+| 197|    |-		if (!isHighlightable(m_highlight))
+| 198|    |-			scroll(Scroll::Down);
+| 199|    |-	}
+| 200|    |-
+| 201|    |-	size_t line = 0;
+| 202|    |-	const size_t end_ = m_beginning+m_height;
+| 203|    |-	m_drawn_position = m_beginning;
+| 204|    |-	for (; m_drawn_position < end_; ++m_drawn_position, ++line)
+| 205|    |-	{
+| 206|    |-		goToXY(0, line);
+| 207|    |-		if (m_drawn_position >= m_items->size())
+| 208|    |-		{
+| 209|    |-			for (; line < m_height; ++line)
+| 210|    |-				mvwhline(m_window, line, 0, NC::Key::Space, m_width);
+| 211|    |-			break;
+| 212|    |-		}
+| 213|    |-		if ((*m_items)[m_drawn_position].isSeparator())
+| 214|    |-		{
+| 215|    |-			mvwhline(m_window, line, 0, 0, m_width);
+| 216|    |-			continue;
+| 217|    |-		}
+| 218|    |-		if (m_highlight_enabled && m_drawn_position == m_highlight)
+| 219|    |-			*this << m_highlight_prefix;
+| 220|    |-		if ((*m_items)[m_drawn_position].isSelected())
+| 221|    |-			*this << m_selected_prefix;
+| 222|    |-		*this << NC::TermManip::ClearToEOL;
+| 223|    |-		if (m_item_displayer)
+| 224|    |-			m_item_displayer(*this);
+| 225|    |-		if ((*m_items)[m_drawn_position].isSelected())
+| 226|    |-			*this << m_selected_suffix;
+| 227|    |-		if (m_highlight_enabled && m_drawn_position == m_highlight)
+| 228|    |-			*this << m_highlight_suffix;
+| 229|    |-	}
+| 230|    |-	Window::refresh();
+| 231|    |-}
+| 232|    |-
+| 233|    |-template <typename ItemT>
+| 234|    |-void Menu<ItemT>::scroll(Scroll where)
+| 235|    |-{
+| 236|    |-	if (m_items->empty())
+| 237|    |-		return;
+| 238|    |-	size_t max_highlight = m_items->size()-1;
+| 239|    |-	size_t max_beginning = m_items->size() < m_height ? 0 : m_items->size()-m_height;
+| 240|    |-	size_t max_visible_highlight = m_beginning+m_height-1;
+| 241|    |-	switch (where)
+| 242|    |-	{
+| 243|    |-		case Scroll::Up:
+| 244|    |-		{
+| 245|    |-			if (m_highlight <= m_beginning && m_highlight > 0)
+| 246|    |-				--m_beginning;
+| 247|    |-			if (m_highlight == 0)
+| 248|    |-			{
+| 249|    |-				if (m_cyclic_scroll_enabled)
+| 250|    |-					return scroll(Scroll::End);
+| 251|    |-				break;
+| 252|    |-			}
+| 253|    |-			else
+| 254|    |-				--m_highlight;
+| 255|    |-			if (!isHighlightable(m_highlight))
+| 256|    |-				scroll(m_highlight == 0 && !m_cyclic_scroll_enabled ? Scroll::Down : Scroll::Up);
+| 257|    |-			break;
+| 258|    |-		}
+| 259|    |-		case Scroll::Down:
+| 260|    |-		{
+| 261|    |-			if (m_highlight >= max_visible_highlight && m_highlight < max_highlight)
+| 262|    |-				++m_beginning;
+| 263|    |-			if (m_highlight == max_highlight)
+| 264|    |-			{
+| 265|    |-				if (m_cyclic_scroll_enabled)
+| 266|    |-					return scroll(Scroll::Home);
+| 267|    |-				break;
+| 268|    |-			}
+| 269|    |-			else
+| 270|    |-				++m_highlight;
+| 271|    |-			if (!isHighlightable(m_highlight))
+| 272|    |-				scroll(m_highlight == max_highlight && !m_cyclic_scroll_enabled ? Scroll::Up : Scroll::Down);
+| 273|    |-			break;
+| 274|    |-		}
+| 275|    |-		case Scroll::PageUp:
+| 276|    |-		{
+| 277|    |-			if (m_cyclic_scroll_enabled && m_highlight == 0)
+| 278|    |-				return scroll(Scroll::End);
+| 279|    |-			if (m_highlight < m_height)
+| 280|    |-				m_highlight = 0;
+| 281|    |-			else
+| 282|    |-				m_highlight -= m_height;
+| 283|    |-			if (m_beginning < m_height)
+| 284|    |-				m_beginning = 0;
+| 285|    |-			else
+| 286|    |-				m_beginning -= m_height;
+| 287|    |-			if (!isHighlightable(m_highlight))
+| 288|    |-				scroll(m_highlight == 0 && !m_cyclic_scroll_enabled ? Scroll::Down : Scroll::Up);
+| 289|    |-			break;
+| 290|    |-		}
+| 291|    |-		case Scroll::PageDown:
+| 292|    |-		{
+| 293|    |-			if (m_cyclic_scroll_enabled && m_highlight == max_highlight)
+| 294|    |-				return scroll(Scroll::Home);
+| 295|    |-			m_highlight += m_height;
+| 296|    |-			m_beginning += m_height;
+| 297|    |-			m_beginning = std::min(m_beginning, max_beginning);
+| 298|    |-			m_highlight = std::min(m_highlight, max_highlight);
+| 299|    |-			if (!isHighlightable(m_highlight))
+| 300|    |-				scroll(m_highlight == max_highlight && !m_cyclic_scroll_enabled ? Scroll::Up : Scroll::Down);
+| 301|    |-			break;
+| 302|    |-		}
+| 303|    |-		case Scroll::Home:
+| 304|    |-		{
+| 305|    |-			m_highlight = 0;
+| 306|    |-			m_beginning = 0;
+| 307|    |-			if (!isHighlightable(m_highlight))
+| 308|    |-				scroll(Scroll::Down);
+| 309|    |-			break;
+| 310|    |-		}
+| 311|    |-		case Scroll::End:
+| 312|    |-		{
+| 313|    |-			m_highlight = max_highlight;
+| 314|    |-			m_beginning = max_beginning;
+| 315|    |-			if (!isHighlightable(m_highlight))
+| 316|    |-				scroll(Scroll::Up);
+| 317|    |-			break;
+| 318|    |-		}
+| 319|    |-	}
+| 320|    |-	if (m_autocenter_cursor)
+| 321|    |-		highlight(m_highlight);
+| 322|    |-}
+| 323|    |-
+| 324|    |-template <typename ItemT>
+| 325|    |-void Menu<ItemT>::reset()
+| 326|    |-{
+| 327|    |-	m_highlight = 0;
+| 328|    |-	m_beginning = 0;
+| 329|    |-}
+| 330|    |-
+| 331|    |-template <typename ItemT>
+| 332|    |-void Menu<ItemT>::clear()
+| 333|    |-{
+| 334|    |-	// Don't clear filter related stuff here.
+| 335|    |-	m_all_items.clear();
+| 336|    |-	m_filtered_items.clear();
+| 337|    |-}
+| 338|    |-
+| 339|    |-template <typename ItemT>
+| 340|    |-void Menu<ItemT>::highlight(size_t pos)
+| 341|    |-{
+| 342|    |-	assert(pos < m_items->size());
+| 343|    |-	m_highlight = pos;
+| 344|    |-	size_t half_height = m_height/2;
+| 345|    |-	if (pos < half_height)
+| 346|    |-		m_beginning = 0;
+| 347|    |-	else
+| 348|    |-		m_beginning = pos-half_height;
+| 349|    |-}
+| 350|    |-
+| 351|    |-template <typename ItemT>
+| 352|    |-size_t Menu<ItemT>::choice() const
+| 353|    |-{
+| 354|    |-	assert(!empty());
+| 355|    |-	return m_highlight;
+| 356|    |-}
+| 357|    |-
+| 358|    |-template <typename ItemT> template <typename PredicateT>
+| 359|    |-void Menu<ItemT>::applyFilter(PredicateT &&pred)
+| 360|    |-{
+| 361|    |-	m_filter_predicate = std::forward<PredicateT>(pred);
+| 362|    |-	m_filtered_items.clear();
+| 363|    |-
+| 364|    |-	for (const auto &item : m_all_items)
+| 365|    |-		if (m_filter_predicate(item))
+| 366|    |-			m_filtered_items.push_back(item);
+| 367|    |-
+| 368|    |-	m_items = &m_filtered_items;
+| 369|    |-}
+| 370|    |-
+| 371|    |-template <typename ItemT>
+| 372|    |-void Menu<ItemT>::reapplyFilter()
+| 373|    |-{
+| 374|    |-	applyFilter(m_filter_predicate);
+| 375|    |-}
+| 376|    |-
+| 377|    |-template <typename ItemT> template <typename TargetT>
+| 378|    |-const TargetT *Menu<ItemT>::filterPredicate() const
+| 379|    |-{
+| 380|    |-	return m_filter_predicate.template target<TargetT>();
+| 381|    |-}
+| 382|    |-
+| 383|    |-template <typename ItemT>
+| 384|    |-void Menu<ItemT>::clearFilter()
+| 385|    |-{
+| 386|    |-	m_filter_predicate = nullptr;
+| 387|    |-	m_filtered_items.clear();
+| 388|    |-	m_items = &m_all_items;
+| 389|    |-}
+| 390|    |-
+| 391|    |-}
+| 392|    |-
+| 393|  34| #endif // NCMPCPP_MENU_IMPL_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  27|  27| #include "actions.h"
+|  28|  28| #include "macro_utilities.h"
+|  29|  29| 
+|  30|    |-NC::Key::Type readKey(NC::Window &w);
+|  31|    |-std::wstring keyToWString(const NC::Key::Type key);
+|    |  30|+NC::Key::Type readKey (NC::Window & w);
+|    |  31|+std::wstring keyToWString (const NC::Key::Type key);
+|  32|  32| 
+|  33|  33| /// Represents either single action or chain of actions bound to a certain key
+|  34|  34| struct Binding
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  33|  33| /// Represents either single action or chain of actions bound to a certain key
+|  34|  34| struct Binding
+|  35|  35| {
+|  36|    |-	typedef std::vector<std::shared_ptr<Actions::BaseAction>> ActionChain;
+|    |  36|+    typedef std::vector < std::shared_ptr < Actions::BaseAction >> ActionChain;
+|  37|  37| 
+|  38|    |-	template <typename ArgT>
+|  39|    |-	Binding(ArgT &&actions_)
+|  40|    |-	: m_actions(std::forward<ArgT>(actions_)) {
+|  41|    |-		assert(!m_actions.empty());
+|  42|    |-	}
+|  43|    |-	Binding(Actions::Type at)
+|  44|    |-	: Binding(ActionChain({Actions::get_(at)})) { }
+|    |  38|+      template < typename ArgT >
+|    |  39|+        Binding (ArgT && actions_):m_actions (std::forward < ArgT > (actions_))
+|    |  40|+    {
+|    |  41|+        assert (!m_actions.empty ());
+|    |  42|+    }
+|    |  43|+    Binding (Actions::Type at):Binding (ActionChain (
+|    |  44|+                                                        {
+|    |  45|+                                                        Actions::get_ (at)}))
+|    |  46|+    {
+|    |  47|+    }
+|  45|  48| 
+|  46|    |-	bool execute() const {
+|  47|    |-		return std::all_of(m_actions.begin(), m_actions.end(),
+|  48|    |-			std::bind(&Actions::BaseAction::execute, std::placeholders::_1)
+|  49|    |-		);
+|  50|    |-	}
+|    |  49|+    bool execute () const
+|    |  50|+    {
+|    |  51|+        return std::all_of (m_actions.begin (), m_actions.end (),
+|    |  52|+                            std::bind (&Actions::BaseAction::execute,
+|    |  53|+                                       std::placeholders::_1));
+|    |  54|+    }
+|  51|  55| 
+|  52|    |-	bool isSingle() const {
+|  53|    |-		return m_actions.size() == 1;
+|  54|    |-	}
+|    |  56|+    bool isSingle () const
+|    |  57|+    {
+|    |  58|+        return m_actions.size () == 1;
+|    |  59|+    }
+|  55|  60| 
+|  56|    |-	Actions::BaseAction &action() const {
+|  57|    |-		assert(isSingle());
+|  58|    |-		assert(m_actions[0] != nullptr);
+|  59|    |-		return *m_actions[0];
+|  60|    |-	}
+|    |  61|+    Actions::BaseAction & action () const
+|    |  62|+    {
+|    |  63|+        assert (isSingle ());
+|    |  64|+        assert (m_actions[0] != nullptr);
+|    |  65|+        return *m_actions[0];
+|    |  66|+    }
+|  61|  67| 
+|  62|    |-	const ActionChain &actions() const {
+|  63|    |-		return m_actions;
+|  64|    |-	}
+|    |  68|+    const ActionChain & actions () const
+|    |  69|+    {
+|    |  70|+        return m_actions;
+|    |  71|+    }
+|  65|  72| 
+|  66|    |-private:
+|  67|    |-	ActionChain m_actions;
+|    |  73|+  private:
+|    |  74|+      ActionChain m_actions;
+|  68|  75| };
+|  69|  76| 
+|  70|  77| /// Represents executable command
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  70|  70| /// Represents executable command
+|  71|  71| struct Command
+|  72|  72| {
+|  73|    |-	template <typename ArgT>
+|  74|    |-	Command(ArgT &&binding_, bool immediate_)
+|  75|    |-	: m_impl(std::forward<ArgT>(binding_), immediate_) { }
+|    |  73|+    template < typename ArgT >
+|    |  74|+        Command (ArgT
+|    |  75|+                 && binding_,
+|    |  76|+                 bool immediate_):m_impl (std::forward < ArgT > (binding_),
+|    |  77|+                                          immediate_)
+|    |  78|+    {
+|    |  79|+    }
+|  76|  80| 
+|  77|    |-	const Binding &binding() const { return std::get<0>(m_impl); }
+|  78|    |-	bool immediate() const { return std::get<1>(m_impl); }
+|    |  81|+    const Binding & binding () const
+|    |  82|+    {
+|    |  83|+        return std::get < 0 > (m_impl);
+|    |  84|+    }
+|    |  85|+    bool immediate () const
+|    |  86|+    {
+|    |  87|+        return std::get < 1 > (m_impl);
+|    |  88|+    }
+|  79|  89| 
+|  80|    |-private:
+|  81|    |-	std::tuple<Binding, bool> m_impl;
+|    |  90|+  private:
+|    |  91|+      std::tuple < Binding, bool > m_impl;
+|  82|  92| };
+|  83|  93| 
+|  84|  94| /// Keybindings configuration
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  84|  84| /// Keybindings configuration
+|  85|  85| class BindingsConfiguration
+|  86|  86| {
+|  87|    |-	typedef std::unordered_map<std::string, Command> CommandsSet;
+|  88|    |-	typedef std::unordered_map<NC::Key::Type, std::vector<Binding>> BindingsMap;
+|    |  87|+    typedef std::unordered_map < std::string, Command > CommandsSet;
+|    |  88|+    typedef std::unordered_map < NC::Key::Type,
+|    |  89|+        std::vector < Binding >> BindingsMap;
+|  89|  90| 
+|  90|    |-public:
+|  91|    |-	typedef BindingsMap::value_type::second_type::iterator BindingIterator;
+|  92|    |-	typedef BindingsMap::value_type::second_type::const_iterator ConstBindingIterator;
+|  93|    |-	typedef std::pair<BindingIterator, BindingIterator> BindingIteratorPair;
+|    |  91|+  public:
+|    |  92|+    typedef BindingsMap::value_type::second_type::iterator BindingIterator;
+|    |  93|+    typedef BindingsMap::value_type::second_type::
+|    |  94|+        const_iterator ConstBindingIterator;
+|    |  95|+    typedef std::pair < BindingIterator, BindingIterator > BindingIteratorPair;
+|  94|  96| 
+|  95|    |-	bool read(const std::vector<std::string> &binding_paths);
+|  96|    |-	void generateDefaults();
+|    |  97|+    bool read (const std::vector < std::string > &binding_paths);
+|    |  98|+    void generateDefaults ();
+|  97|  99| 
+|  98|    |-	const Command *findCommand(const std::string &name);
+|  99|    |-	BindingIteratorPair get(const NC::Key::Type &k);
+|    | 100|+    const Command *findCommand (const std::string & name);
+|    | 101|+    BindingIteratorPair get (const NC::Key::Type & k);
+| 100| 102| 
+| 101|    |-	BindingsMap::const_iterator begin() const { return m_bindings.begin(); }
+| 102|    |-	BindingsMap::const_iterator end() const { return m_bindings.end(); }
+|    | 103|+      BindingsMap::const_iterator begin () const
+|    | 104|+    {
+|    | 105|+        return m_bindings.begin ();
+|    | 106|+    }
+|    | 107|+    BindingsMap::const_iterator end () const
+|    | 108|+    {
+|    | 109|+        return m_bindings.end ();
+|    | 110|+    }
+| 103| 111| 
+| 104|    |-private:
+| 105|    |-	bool notBound(const NC::Key::Type &k) const {
+| 106|    |-		return k != NC::Key::None && m_bindings.find(k) == m_bindings.end();
+| 107|    |-	}
+|    | 112|+  private:
+|    | 113|+      bool notBound (const NC::Key::Type & k) const
+|    | 114|+    {
+|    | 115|+        return k != NC::Key::None && m_bindings.find (k) == m_bindings.end ();
+|    | 116|+    }
+| 108| 117| 
+| 109|    |-	template <typename ArgT>
+| 110|    |-	void bind(NC::Key::Type k, ArgT &&t) {
+| 111|    |-		m_bindings[k].push_back(std::forward<ArgT>(t));
+| 112|    |-	}
+|    | 118|+    template < typename ArgT > void bind (NC::Key::Type k, ArgT && t)
+|    | 119|+    {
+|    | 120|+        m_bindings[k].push_back (std::forward < ArgT > (t));
+|    | 121|+    }
+| 113| 122| 
+| 114|    |-	bool read(const std::string &file);
+|    | 123|+    bool read (const std::string & file);
+| 115| 124| 
+| 116|    |-	BindingsMap m_bindings;
+| 117|    |-	CommandsSet m_commands;
+|    | 125|+    BindingsMap m_bindings;
+|    | 126|+    CommandsSet m_commands;
+| 118| 127| };
+| 119| 128| 
+| 120| 129| extern BindingsConfiguration Bindings;
+
+src/bindings.h
+|  95| »   bool•read(const•std::vector<std::string>•&binding_paths);
+|    | [INFO] CSecurityBear (buffer):
+|    | read: Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).
+
+src/bindings.h
+| 114| »   bool•read(const•std::string•&file);
+|    | [INFO] CSecurityBear (buffer):
+|    | read: Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.h
+|    |++++| /app/src/utility/option_parser.h
+|  40|  40| #include <stdexcept>
+|  41|  41| #include <unordered_map>
+|  42|  42| 
+|  43|    |-[[noreturn]] inline void invalid_value(const std::string &v)
+|    |  43|+[[noreturn]]
+|    |  44|+     inline void invalid_value (const std::string & v)
+|  44|  45| {
+|  45|    |-	throw std::runtime_error("invalid value: " + v);
+|    |  46|+    throw std::runtime_error ("invalid value: " + v);
+|  46|  47| }
+|  47|  48| 
+|  48|  49| template <typename DestT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.h
+|    |++++| /app/src/utility/option_parser.h
+|  45|  45| 	throw std::runtime_error("invalid value: " + v);
+|  46|  46| }
+|  47|  47| 
+|  48|    |-template <typename DestT>
+|  49|    |-DestT verbose_lexical_cast(const std::string &v)
+|    |  48|+template < typename DestT > DestT verbose_lexical_cast (const std::string & v)
+|  50|  49| {
+|  51|    |-	try {
+|  52|    |-		return boost::lexical_cast<DestT>(v);
+|  53|    |-	} catch (boost::bad_lexical_cast &) {
+|  54|    |-		invalid_value(v);
+|  55|    |-	}
+|    |  50|+    try
+|    |  51|+    {
+|    |  52|+        return boost::lexical_cast < DestT > (v);
+|    |  53|+    }
+|    |  54|+    catch (boost::bad_lexical_cast &)
+|    |  55|+    {
+|    |  56|+        invalid_value (v);
+|    |  57|+    }
+|  56|  58| }
+|  57|  59| 
+|  58|  60| template <typename ValueT, typename ConvertT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.h
+|    |++++| /app/src/utility/option_parser.h
+|  55|  55| 	}
+|  56|  56| }
+|  57|  57| 
+|  58|    |-template <typename ValueT, typename ConvertT>
+|  59|    |-std::vector<ValueT> list_of(const std::string &v, ConvertT convert)
+|    |  58|+template < typename ValueT, typename ConvertT >
+|    |  59|+    std::vector < ValueT > list_of (const std::string & v, ConvertT convert)
+|  60|  60| {
+|  61|    |-	std::vector<ValueT> result;
+|  62|    |-	boost::tokenizer<boost::escaped_list_separator<char>> elems(v);
+|  63|    |-	for (auto &value : elems)
+|  64|    |-		result.push_back(convert(boost::trim_copy(value)));
+|  65|    |-	if (result.empty())
+|  66|    |-		throw std::runtime_error("empty list");
+|  67|    |-	return result;
+|    |  61|+    std::vector < ValueT > result;
+|    |  62|+    boost::tokenizer < boost::escaped_list_separator < char >>elems (v);
+|    |  63|+  for (auto & value:elems)
+|    |  64|+        result.push_back (convert (boost::trim_copy (value)));
+|    |  65|+    if (result.empty ())
+|    |  66|+        throw std::runtime_error ("empty list");
+|    |  67|+    return result;
+|  68|  68| }
+|  69|  69| 
+|  70|  70| template <typename ValueT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.h
+|    |++++| /app/src/utility/option_parser.h
+|  67|  67| 	return result;
+|  68|  68| }
+|  69|  69| 
+|  70|    |-template <typename ValueT>
+|  71|    |-std::vector<ValueT> list_of(const std::string &v)
+|    |  70|+template < typename ValueT >
+|    |  71|+    std::vector < ValueT > list_of (const std::string & v)
+|  72|  72| {
+|  73|    |-	return list_of<ValueT>(v, verbose_lexical_cast<ValueT>);
+|    |  73|+    return list_of < ValueT > (v, verbose_lexical_cast < ValueT >);
+|  74|  74| }
+|  75|  75| 
+|  76|  76| bool yes_no(const std::string &v);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.h
+|    |++++| /app/src/utility/option_parser.h
+|  73|  73| 	return list_of<ValueT>(v, verbose_lexical_cast<ValueT>);
+|  74|  74| }
+|  75|  75| 
+|  76|    |-bool yes_no(const std::string &v);
+|    |  76|+bool yes_no (const std::string & v);
+|  77|  77| 
+|  78|  78| ////////////////////////////////////////////////////////////////////////////////
+|  79|  79| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.h
+|    |++++| /app/src/utility/option_parser.h
+|  79|  79| 
+|  80|  80| class option_parser
+|  81|  81| {
+|  82|    |-	template <typename DestT>
+|  83|    |-	struct worker
+|  84|    |-	{
+|  85|    |-		template <typename MapT>
+|  86|    |-		worker(DestT *dest, MapT &&map)
+|  87|    |-			: m_dest(dest), m_map(std::forward<MapT>(map)), m_dest_set(false)
+|  88|    |-		{ }
+|    |  82|+    template < typename DestT > struct worker
+|    |  83|+    {
+|    |  84|+        template < typename MapT >
+|    |  85|+            worker (DestT * dest, MapT
+|    |  86|+                    && map):m_dest (dest), m_map (std::forward < MapT > (map)),
+|    |  87|+            m_dest_set (false)
+|    |  88|+        {
+|    |  89|+        }
+|  89|  90| 
+|  90|    |-		void operator()(std::string value)
+|  91|    |-		{
+|  92|    |-			if (m_dest_set)
+|  93|    |-				throw std::runtime_error("option already set");
+|  94|    |-			assign<DestT, void>::apply(m_dest, m_map, value);
+|  95|    |-			m_dest_set = true;
+|  96|    |-		}
+|    |  91|+        void operator () (std::string value)
+|    |  92|+        {
+|    |  93|+            if (m_dest_set)
+|    |  94|+                throw std::runtime_error ("option already set");
+|    |  95|+              assign < DestT, void >::apply (m_dest, m_map, value);
+|    |  96|+              m_dest_set = true;
+|    |  97|+        }
+|  97|  98| 
+|  98|    |-	private:
+|  99|    |-		template <typename ValueT, typename VoidT>
+| 100|    |-		struct assign {
+| 101|    |-			static void apply(ValueT *dest,
+| 102|    |-			                  std::function<DestT(std::string)> &map,
+| 103|    |-			                  std::string &value)	{
+| 104|    |-				*dest = map(std::move(value));
+| 105|    |-			}
+| 106|    |-		};
+| 107|    |-		template <typename VoidT>
+| 108|    |-		struct assign<void, VoidT> {
+| 109|    |-			static void apply(void *,
+| 110|    |-			                  std::function<void(std::string)> &map,
+| 111|    |-			                  std::string &value) {
+| 112|    |-				map(std::move(value));
+| 113|    |-			}
+| 114|    |-		};
+|    |  99|+      private:
+|    | 100|+          template < typename ValueT, typename VoidT > struct assign
+|    | 101|+        {
+|    | 102|+            static void apply (ValueT * dest,
+|    | 103|+                               std::function < DestT (std::string) > &map,
+|    | 104|+                               std::string & value)
+|    | 105|+            {
+|    | 106|+                *dest = map (std::move (value));
+|    | 107|+            }
+|    | 108|+        };
+|    | 109|+        template < typename VoidT > struct assign <void, VoidT >
+|    | 110|+        {
+|    | 111|+            static void apply (void *,
+|    | 112|+                               std::function < void (std::string) > &map,
+|    | 113|+                               std::string & value)
+|    | 114|+            {
+|    | 115|+                map (std::move (value));
+|    | 116|+            }
+|    | 117|+        };
+| 115| 118| 
+| 116|    |-		DestT *m_dest;
+| 117|    |-		std::function<DestT(std::string)> m_map;
+| 118|    |-		bool m_dest_set;
+| 119|    |-	};
+|    | 119|+        DestT *m_dest;
+|    | 120|+        std::function < DestT (std::string) > m_map;
+|    | 121|+        bool m_dest_set;
+|    | 122|+    };
+| 120| 123| 
+| 121|    |-	struct parser {
+| 122|    |-		template <typename StringT, typename SetterT>
+| 123|    |-		parser(StringT &&default_, SetterT &&setter_)
+| 124|    |-			: m_used(false)
+| 125|    |-			, m_default_value(std::forward<StringT>(default_))
+| 126|    |-			, m_worker(std::forward<SetterT>(setter_))
+| 127|    |-		{ }
+|    | 124|+    struct parser
+|    | 125|+    {
+|    | 126|+        template < typename StringT, typename SetterT >
+|    | 127|+            parser (StringT && default_, SetterT
+|    | 128|+                    && setter_):m_used (false),
+|    | 129|+            m_default_value (std::forward < StringT > (default_)),
+|    | 130|+            m_worker (std::forward < SetterT > (setter_))
+|    | 131|+        {
+|    | 132|+        }
+| 128| 133| 
+| 129|    |-		bool used() const
+| 130|    |-		{
+| 131|    |-			return m_used;
+| 132|    |-		}
+|    | 134|+        bool used () const
+|    | 135|+        {
+|    | 136|+            return m_used;
+|    | 137|+        }
+| 133| 138| 
+| 134|    |-		void parse(std::string v)
+| 135|    |-		{
+| 136|    |-			m_worker(std::move(v));
+| 137|    |-			m_used = true;
+| 138|    |-		}
+|    | 139|+        void parse (std::string v)
+|    | 140|+        {
+|    | 141|+            m_worker (std::move (v));
+|    | 142|+            m_used = true;
+|    | 143|+        }
+| 139| 144| 
+| 140|    |-		void parse_default() const
+| 141|    |-		{
+| 142|    |-			assert(!m_used);
+| 143|    |-			m_worker(m_default_value);
+| 144|    |-		}
+|    | 145|+        void parse_default () const
+|    | 146|+        {
+|    | 147|+            assert (!m_used);
+|    | 148|+            m_worker (m_default_value);
+|    | 149|+        }
+| 145| 150| 
+| 146|    |-	private:
+| 147|    |-		bool m_used;
+| 148|    |-		std::string m_default_value;
+| 149|    |-		std::function<void(std::string)> m_worker;
+| 150|    |-	};
+|    | 151|+      private:
+|    | 152|+          bool m_used;
+|    | 153|+        std::string m_default_value;
+|    | 154|+        std::function < void (std::string) > m_worker;
+|    | 155|+    };
+| 151| 156| 
+| 152|    |-	std::unordered_map<std::string, parser> m_parsers;
+|    | 157|+    std::unordered_map < std::string, parser > m_parsers;
+| 153| 158| 
+| 154|    |-public:
+| 155|    |-	template <typename DestT, typename MapT>
+| 156|    |-	void add(std::string option, DestT *dest, std::string default_, MapT &&map)
+| 157|    |-	{
+| 158|    |-		assert(m_parsers.count(option) == 0);
+| 159|    |-		m_parsers.emplace(
+| 160|    |-			std::move(option),
+| 161|    |-			parser(
+| 162|    |-				std::move(default_),
+| 163|    |-				worker<DestT>(dest, std::forward<MapT>(map))));
+| 164|    |-	}
+|    | 159|+  public:
+|    | 160|+    template < typename DestT, typename MapT >
+|    | 161|+        void add (std::string option, DestT * dest, std::string default_, MapT
+|    | 162|+                  && map)
+|    | 163|+    {
+|    | 164|+        assert (m_parsers.count (option) == 0);
+|    | 165|+        m_parsers.emplace (std::move (option),
+|    | 166|+                           parser (std::move (default_),
+|    | 167|+                                   worker < DestT > (dest,
+|    | 168|+                                                     std::forward < MapT >
+|    | 169|+                                                     (map))));
+|    | 170|+    }
+| 165| 171| 
+| 166|    |-	template <typename DestT>
+| 167|    |-	void add(std::string option, DestT *dest, std::string default_)
+| 168|    |-	{
+| 169|    |-		add(std::move(option), dest, std::move(default_), verbose_lexical_cast<DestT>);
+| 170|    |-	}
+|    | 172|+    template < typename DestT >
+|    | 173|+        void add (std::string option, DestT * dest, std::string default_)
+|    | 174|+    {
+|    | 175|+        add (std::move (option), dest, std::move (default_),
+|    | 176|+             verbose_lexical_cast < DestT >);
+|    | 177|+    }
+| 171| 178| 
+| 172|    |-	bool run(std::istream &is, bool warn_on_errors);
+| 173|    |-	bool initialize_undefined(bool warn_on_errors);
+|    | 179|+    bool run (std::istream & is, bool warn_on_errors);
+|    | 180|+    bool initialize_undefined (bool warn_on_errors);
+| 174| 181| };
+| 175| 182| 
+| 176| 183| #endif // NCMPCPP_UTILITY_OPTION_PARSER_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/lastfm_service.h
+|    |++++| /app/src/lastfm_service.h
+|  28|  28| 
+|  29|  29| #include "curses/scrollpad.h"
+|  30|  30| 
+|  31|    |-namespace LastFm {
+|    |  31|+namespace LastFm
+|    |  32|+{
+|  32|  33| 
+|  33|    |-struct Service
+|  34|    |-{
+|  35|    |-	typedef std::map<std::string, std::string> Arguments;
+|  36|    |-	typedef std::pair<bool, std::string> Result;
+|  37|    |-	
+|  38|    |-	Service(Arguments args) : m_arguments(args) { }
+|    |  34|+    struct Service
+|    |  35|+    {
+|    |  36|+        typedef std::map < std::string, std::string > Arguments;
+|    |  37|+        typedef std::pair < bool, std::string > Result;
+|  39|  38| 
+|  40|    |-	virtual const char *name() = 0;
+|  41|    |-	virtual Result fetch();
+|  42|    |-	
+|  43|    |-	virtual void beautifyOutput(NC::Scrollpad &w) = 0;
+|  44|    |-	
+|  45|    |-protected:
+|  46|    |-	virtual bool argumentsOk() = 0;
+|  47|    |-	virtual bool actionFailed(const std::string &data);
+|  48|    |-	
+|  49|    |-	virtual Result processData(const std::string &data) = 0;
+|  50|    |-	
+|  51|    |-	virtual const char *methodName() = 0;
+|  52|    |-	
+|  53|    |-	Arguments m_arguments;
+|  54|    |-};
+|    |  39|+          Service (Arguments args):m_arguments (args)
+|    |  40|+        {
+|    |  41|+        }
+|  55|  42| 
+|  56|    |-struct ArtistInfo : public Service
+|  57|    |-{
+|  58|    |-	ArtistInfo(std::string artist, std::string lang)
+|  59|    |-	: Service({{"artist", artist}, {"lang", lang}}) { }
+|  60|    |-	
+|  61|    |-	virtual const char *name() { return "Artist info"; }
+|  62|    |-	
+|  63|    |-	virtual void beautifyOutput(NC::Scrollpad &w);
+|  64|    |-	
+|  65|    |-	bool operator==(const ArtistInfo &ai) const { return m_arguments == ai.m_arguments; }
+|  66|    |-	
+|  67|    |-protected:
+|  68|    |-	virtual bool argumentsOk();
+|  69|    |-	virtual Result processData(const std::string &data);
+|  70|    |-	
+|  71|    |-	virtual const char *methodName() { return "artist.getinfo"; }
+|  72|    |-};
+|    |  43|+        virtual const char *name () = 0;
+|    |  44|+        virtual Result fetch ();
+|    |  45|+
+|    |  46|+        virtual void beautifyOutput (NC::Scrollpad & w) = 0;
+|    |  47|+
+|    |  48|+      protected:
+|    |  49|+          virtual bool argumentsOk () = 0;
+|    |  50|+        virtual bool actionFailed (const std::string & data);
+|    |  51|+
+|    |  52|+        virtual Result processData (const std::string & data) = 0;
+|    |  53|+
+|    |  54|+        virtual const char *methodName () = 0;
+|    |  55|+
+|    |  56|+        Arguments m_arguments;
+|    |  57|+    };
+|    |  58|+
+|    |  59|+    struct ArtistInfo:public Service
+|    |  60|+    {
+|    |  61|+        ArtistInfo (std::string artist, std::string lang):Service (
+|    |  62|+                                                                      {
+|    |  63|+                                                                      {
+|    |  64|+                                                                      "artist",
+|    |  65|+                                                                      artist},
+|    |  66|+                                                                      {
+|    |  67|+                                                                      "lang",
+|    |  68|+                                                                      lang}})
+|    |  69|+        {
+|    |  70|+        }
+|    |  71|+
+|    |  72|+        virtual const char *name ()
+|    |  73|+        {
+|    |  74|+            return "Artist info";
+|    |  75|+        }
+|    |  76|+
+|    |  77|+        virtual void beautifyOutput (NC::Scrollpad & w);
+|    |  78|+
+|    |  79|+        bool operator== (const ArtistInfo & ai) const
+|    |  80|+        {
+|    |  81|+            return m_arguments == ai.m_arguments;
+|    |  82|+        }
+|    |  83|+
+|    |  84|+      protected:
+|    |  85|+          virtual bool argumentsOk ();
+|    |  86|+        virtual Result processData (const std::string & data);
+|    |  87|+
+|    |  88|+        virtual const char *methodName ()
+|    |  89|+        {
+|    |  90|+            return "artist.getinfo";
+|    |  91|+        }
+|    |  92|+    };
+|  73|  93| 
+|  74|  94| }
+|  75|  95| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sel_items_adder.h
+|    |++++| /app/src/screens/sel_items_adder.h
+|  27|  27| #include "screens/screen.h"
+|  28|  28| #include "song.h"
+|  29|  29| 
+|  30|    |-struct SelectedItemsAdder: Screen<NC::Menu<RunnableItem<std::string, void()>> *>, HasActions, Searchable, Tabbable
+|    |  30|+struct SelectedItemsAdder:Screen <
+|    |  31|+    NC::Menu <
+|    |  32|+    RunnableItem <
+|    |  33|+std::string, void () >> *>,
+|    |  34|+    HasActions,
+|    |  35|+    Searchable,
+|    |  36|+    Tabbable
+|  31|  37| {
+|  32|    |-	typedef SelectedItemsAdder Self;
+|  33|    |-	typedef typename std::remove_pointer<WindowType>::type Component;
+|  34|    |-	typedef Component::Item::Type Entry;
+|  35|    |-	
+|  36|    |-	SelectedItemsAdder();
+|  37|    |-	
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	virtual void refresh() override;
+|  41|    |-	
+|  42|    |-	virtual std::wstring title() override;
+|  43|    |-	virtual ScreenType type() override { return ScreenType::SelectedItemsAdder; }
+|  44|    |-	
+|  45|    |-	virtual void update() override { }
+|  46|    |-	
+|  47|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  48|    |-	
+|  49|    |-	virtual bool isLockable() override { return false; }
+|  50|    |-	virtual bool isMergable() override { return false; }
+|    |  38|+    typedef SelectedItemsAdder
+|    |  39|+        Self;
+|    |  40|+    typedef typename
+|    |  41|+        std::remove_pointer <
+|    |  42|+        WindowType >::type
+|    |  43|+        Component;
+|    |  44|+    typedef
+|    |  45|+        Component::Item::Type
+|    |  46|+        Entry;
+|  51|  47| 
+|  52|    |-	// HasActions implementation
+|  53|    |-	virtual bool actionRunnable() override;
+|  54|    |-	virtual void runAction() override;
+|    |  48|+    SelectedItemsAdder ();
+|  55|  49| 
+|  56|    |-	// Searchable implementation
+|  57|    |-	virtual bool allowsSearching() override;
+|  58|    |-	virtual const std::string &searchConstraint() override;
+|  59|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  60|    |-	virtual void clearSearchConstraint() override;
+|  61|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|    |  50|+    virtual void
+|    |  51|+    switchTo ()
+|    |  52|+        override;
+|    |  53|+    virtual void
+|    |  54|+    resize ()
+|    |  55|+        override;
+|    |  56|+    virtual void
+|    |  57|+    refresh ()
+|    |  58|+        override;
+|  62|  59| 
+|  63|    |-private:
+|  64|    |-	void populatePlaylistSelector(BaseScreen *screen);
+|  65|    |-	
+|  66|    |-	void addToCurrentPlaylist();
+|  67|    |-	void addToNewPlaylist() const;
+|  68|    |-	void addToExistingPlaylist(const std::string &playlist) const;
+|  69|    |-	void addAtTheEndOfPlaylist() const;
+|  70|    |-	void addAtTheBeginningOfPlaylist() const;
+|  71|    |-	void addAfterCurrentSong() const;
+|  72|    |-	void addAfterCurrentAlbum() const;
+|  73|    |-	void addAfterHighlightedSong() const;
+|  74|    |-	void cancel();
+|  75|    |-	void exitSuccessfully(bool success) const;
+|  76|    |-	
+|  77|    |-	void setDimensions();
+|  78|    |-	
+|  79|    |-	size_t m_playlist_selector_width;
+|  80|    |-	size_t m_playlist_selector_height;
+|  81|    |-	
+|  82|    |-	size_t m_position_selector_width;
+|  83|    |-	size_t m_position_selector_height;
+|  84|    |-	
+|  85|    |-	Component m_playlist_selector;
+|  86|    |-	Component m_position_selector;
+|  87|    |-	
+|  88|    |-	std::vector<MPD::Song> m_selected_items;
+|    |  60|+    virtual
+|    |  61|+        std::wstring
+|    |  62|+    title ()
+|    |  63|+        override;
+|    |  64|+    virtual ScreenType
+|    |  65|+    type ()
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+        return ScreenType::SelectedItemsAdder;
+|    |  69|+    }
+|  89|  70| 
+|  90|    |-	Regex::ItemFilter<Entry> m_search_predicate;
+|    |  71|+    virtual void
+|    |  72|+    update ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+    }
+|    |  76|+
+|    |  77|+    virtual void
+|    |  78|+    mouseButtonPressed (MEVENT me)
+|    |  79|+        override;
+|    |  80|+
+|    |  81|+    virtual bool
+|    |  82|+    isLockable ()
+|    |  83|+        override
+|    |  84|+    {
+|    |  85|+        return false;
+|    |  86|+    }
+|    |  87|+    virtual bool
+|    |  88|+    isMergable ()
+|    |  89|+        override
+|    |  90|+    {
+|    |  91|+        return false;
+|    |  92|+    }
+|    |  93|+
+|    |  94|+    // HasActions implementation
+|    |  95|+    virtual bool
+|    |  96|+    actionRunnable ()
+|    |  97|+        override;
+|    |  98|+    virtual void
+|    |  99|+    runAction ()
+|    | 100|+        override;
+|    | 101|+
+|    | 102|+    // Searchable implementation
+|    | 103|+    virtual bool
+|    | 104|+    allowsSearching ()
+|    | 105|+        override;
+|    | 106|+    virtual const
+|    | 107|+        std::string &
+|    | 108|+    searchConstraint ()
+|    | 109|+        override;
+|    | 110|+    virtual void
+|    | 111|+    setSearchConstraint (const std::string & constraint)
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    clearSearchConstraint ()
+|    | 115|+        override;
+|    | 116|+    virtual bool
+|    | 117|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 118|+        override;
+|    | 119|+
+|    | 120|+  private:
+|    | 121|+    void
+|    | 122|+    populatePlaylistSelector (BaseScreen * screen);
+|    | 123|+
+|    | 124|+    void
+|    | 125|+    addToCurrentPlaylist ();
+|    | 126|+    void
+|    | 127|+    addToNewPlaylist () const;
+|    | 128|+    void
+|    | 129|+    addToExistingPlaylist (const std::string & playlist) const;
+|    | 130|+    void
+|    | 131|+    addAtTheEndOfPlaylist () const;
+|    | 132|+    void
+|    | 133|+    addAtTheBeginningOfPlaylist () const;
+|    | 134|+    void
+|    | 135|+    addAfterCurrentSong () const;
+|    | 136|+    void
+|    | 137|+    addAfterCurrentAlbum () const;
+|    | 138|+    void
+|    | 139|+    addAfterHighlightedSong () const;
+|    | 140|+    void
+|    | 141|+    cancel ();
+|    | 142|+    void
+|    | 143|+    exitSuccessfully (bool success) const;
+|    | 144|+
+|    | 145|+    void
+|    | 146|+    setDimensions ();
+|    | 147|+
+|    | 148|+    size_t
+|    | 149|+        m_playlist_selector_width;
+|    | 150|+    size_t
+|    | 151|+        m_playlist_selector_height;
+|    | 152|+
+|    | 153|+    size_t
+|    | 154|+        m_position_selector_width;
+|    | 155|+    size_t
+|    | 156|+        m_position_selector_height;
+|    | 157|+
+|    | 158|+    Component
+|    | 159|+        m_playlist_selector;
+|    | 160|+    Component
+|    | 161|+        m_position_selector;
+|    | 162|+
+|    | 163|+    std::vector < MPD::Song > m_selected_items;
+|    | 164|+
+|    | 165|+    Regex::ItemFilter < Entry > m_search_predicate;
+|  91| 166| };
+|  92| 167| 
+|  93| 168| extern SelectedItemsAdder *mySelectedItemsAdder;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sel_items_adder.h
+|    |++++| /app/src/screens/sel_items_adder.h
+|  90|  90| 	Regex::ItemFilter<Entry> m_search_predicate;
+|  91|  91| };
+|  92|  92| 
+|  93|    |-extern SelectedItemsAdder *mySelectedItemsAdder;
+|    |  93|+extern SelectedItemsAdder *
+|    |  94|+    mySelectedItemsAdder;
+|  94|  95| 
+|  95|  96| #endif // NCMPCPP_SEL_ITEMS_ADDER_H
+|  96|  97| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sel_items_adder.h
+|    |++++| /app/src/screens/sel_items_adder.h
+|  93|  93| extern SelectedItemsAdder *mySelectedItemsAdder;
+|  94|  94| 
+|  95|  95| #endif // NCMPCPP_SEL_ITEMS_ADDER_H
+|  96|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/menu.h
+|    |++++| /app/src/curses/menu.h
+|  34|  34| #include "curses/window.h"
+|  35|  35| #include "utility/const.h"
+|  36|  36| 
+|  37|    |-namespace NC {
+|  38|    |-
+|  39|    |-struct List
+|    |  37|+namespace NC
+|  40|  38| {
+|  41|    |-	struct Properties
+|  42|    |-	{
+|  43|    |-		enum Type {
+|  44|    |-			None       = 0,
+|  45|    |-			Selectable = (1 << 0),
+|  46|    |-			Selected   = (1 << 1),
+|  47|    |-			Inactive   = (1 << 2),
+|  48|    |-			Separator  = (1 << 3)
+|  49|    |-		};
+|  50|    |-
+|  51|    |-		Properties(Type properties = Selectable)
+|  52|    |-		: m_properties(properties)
+|  53|    |-		{ }
+|  54|    |-
+|  55|    |-		void setSelectable(bool is_selectable)
+|  56|    |-		{
+|  57|    |-			if (is_selectable)
+|  58|    |-				m_properties |= Selectable;
+|  59|    |-			else
+|  60|    |-				m_properties &= ~(Selectable | Selected);
+|  61|    |-		}
+|  62|    |-		void setSelected(bool is_selected)
+|  63|    |-		{
+|  64|    |-			if (!isSelectable())
+|  65|    |-				return;
+|  66|    |-			if (is_selected)
+|  67|    |-				m_properties |= Selected;
+|  68|    |-			else
+|  69|    |-				m_properties &= ~Selected;
+|  70|    |-		}
+|  71|    |-		void setInactive(bool is_inactive)
+|  72|    |-		{
+|  73|    |-			if (is_inactive)
+|  74|    |-				m_properties |= Inactive;
+|  75|    |-			else
+|  76|    |-				m_properties &= ~Inactive;
+|  77|    |-		}
+|  78|    |-		void setSeparator(bool is_separator)
+|  79|    |-		{
+|  80|    |-			if (is_separator)
+|  81|    |-				m_properties |= Separator;
+|  82|    |-			else
+|  83|    |-				m_properties &= ~Separator;
+|  84|    |-		}
+|  85|    |-
+|  86|    |-		bool isSelectable() const { return m_properties & Selectable; }
+|  87|    |-		bool isSelected() const { return m_properties & Selected; }
+|  88|    |-		bool isInactive() const { return m_properties & Inactive; }
+|  89|    |-		bool isSeparator() const { return m_properties & Separator; }
+|  90|    |-
+|  91|    |-	private:
+|  92|    |-		unsigned m_properties;
+|  93|    |-	};
+|  94|    |-
+|  95|    |-	template <typename ValueT>
+|  96|    |-	using PropertiesIterator = boost::range_detail::any_iterator<
+|  97|    |-		ValueT,
+|  98|    |-		boost::random_access_traversal_tag,
+|  99|    |-		ValueT &,
+| 100|    |-		std::ptrdiff_t
+| 101|    |-	>;
+| 102|    |-
+| 103|    |-	typedef PropertiesIterator<Properties> Iterator;
+| 104|    |-	typedef PropertiesIterator<const Properties> ConstIterator;
+| 105|    |-
+| 106|    |-	virtual ~List() { }
+| 107|    |-
+| 108|    |-	virtual bool empty() const = 0;
+| 109|    |-	virtual size_t size() const = 0;
+| 110|    |-	virtual size_t choice() const = 0;
+| 111|    |-	virtual void highlight(size_t pos) = 0;
+| 112|    |-
+| 113|    |-	virtual Iterator currentP() = 0;
+| 114|    |-	virtual ConstIterator currentP() const = 0;
+| 115|    |-	virtual Iterator beginP() = 0;
+| 116|    |-	virtual ConstIterator beginP() const = 0;
+| 117|    |-	virtual Iterator endP() = 0;
+| 118|    |-	virtual ConstIterator endP() const = 0;
+| 119|    |-};
+| 120|    |-
+| 121|    |-inline List::Properties::Type operator|(List::Properties::Type lhs, List::Properties::Type rhs)
+| 122|    |-{
+| 123|    |-	return List::Properties::Type(unsigned(lhs) | unsigned(rhs));
+|    |  39|+
+|    |  40|+    struct List
+|    |  41|+    {
+|    |  42|+        struct Properties
+|    |  43|+        {
+|    |  44|+            enum Type
+|    |  45|+            {
+|    |  46|+                None = 0,
+|    |  47|+                Selectable = (1 << 0),
+|    |  48|+                Selected = (1 << 1),
+|    |  49|+                Inactive = (1 << 2),
+|    |  50|+                Separator = (1 << 3)
+|    |  51|+            };
+|    |  52|+
+|    |  53|+            Properties (Type properties = Selectable):m_properties
+|    |  54|+                (properties)
+|    |  55|+            {
+|    |  56|+            }
+|    |  57|+
+|    |  58|+            void setSelectable (bool is_selectable)
+|    |  59|+            {
+|    |  60|+                if (is_selectable)
+|    |  61|+                    m_properties |= Selectable;
+|    |  62|+                else
+|    |  63|+                    m_properties &= ~(Selectable | Selected);
+|    |  64|+            }
+|    |  65|+            void setSelected (bool is_selected)
+|    |  66|+            {
+|    |  67|+                if (!isSelectable ())
+|    |  68|+                    return;
+|    |  69|+                if (is_selected)
+|    |  70|+                    m_properties |= Selected;
+|    |  71|+                else
+|    |  72|+                    m_properties &= ~Selected;
+|    |  73|+            }
+|    |  74|+            void setInactive (bool is_inactive)
+|    |  75|+            {
+|    |  76|+                if (is_inactive)
+|    |  77|+                    m_properties |= Inactive;
+|    |  78|+                else
+|    |  79|+                    m_properties &= ~Inactive;
+|    |  80|+            }
+|    |  81|+            void setSeparator (bool is_separator)
+|    |  82|+            {
+|    |  83|+                if (is_separator)
+|    |  84|+                    m_properties |= Separator;
+|    |  85|+                else
+|    |  86|+                    m_properties &= ~Separator;
+|    |  87|+            }
+|    |  88|+
+|    |  89|+            bool isSelectable () const
+|    |  90|+            {
+|    |  91|+                return m_properties & Selectable;
+|    |  92|+            }
+|    |  93|+            bool isSelected () const
+|    |  94|+            {
+|    |  95|+                return m_properties & Selected;
+|    |  96|+            }
+|    |  97|+            bool isInactive () const
+|    |  98|+            {
+|    |  99|+                return m_properties & Inactive;
+|    | 100|+            }
+|    | 101|+            bool isSeparator () const
+|    | 102|+            {
+|    | 103|+                return m_properties & Separator;
+|    | 104|+            }
+|    | 105|+
+|    | 106|+          private:
+|    | 107|+            unsigned m_properties;
+|    | 108|+        };
+|    | 109|+
+|    | 110|+        template < typename ValueT >
+|    | 111|+            using PropertiesIterator = boost::range_detail::any_iterator <
+|    | 112|+            ValueT,
+|    | 113|+            boost::random_access_traversal_tag, ValueT &, std::ptrdiff_t >;
+|    | 114|+
+|    | 115|+        typedef PropertiesIterator < Properties > Iterator;
+|    | 116|+        typedef PropertiesIterator < const Properties > ConstIterator;
+|    | 117|+
+|    | 118|+        virtual ~ List ()
+|    | 119|+        {
+|    | 120|+        }
+|    | 121|+
+|    | 122|+        virtual bool empty () const = 0;
+|    | 123|+        virtual size_t size () const = 0;
+|    | 124|+        virtual size_t choice () const = 0;
+|    | 125|+        virtual void highlight (size_t pos) = 0;
+|    | 126|+
+|    | 127|+        virtual Iterator currentP () = 0;
+|    | 128|+        virtual ConstIterator currentP () const = 0;
+|    | 129|+        virtual Iterator beginP () = 0;
+|    | 130|+        virtual ConstIterator beginP () const = 0;
+|    | 131|+        virtual Iterator endP () = 0;
+|    | 132|+        virtual ConstIterator endP () const = 0;
+|    | 133|+    };
+|    | 134|+
+|    | 135|+    inline List::Properties::Type operator| (List::Properties::Type lhs,
+|    | 136|+                                             List::Properties::Type rhs)
+|    | 137|+    {
+|    | 138|+        return List::Properties::Type (unsigned (lhs) | unsigned (rhs));
+|    | 139|+    }
+|    | 140|+    inline List::Properties::Type & operator|= (List::Properties::Type & lhs,
+|    | 141|+                                                List::Properties::Type rhs)
+|    | 142|+    {
+|    | 143|+        lhs = lhs | rhs;
+|    | 144|+        return lhs;
+|    | 145|+    }
+|    | 146|+    inline List::Properties::Type operator& (List::Properties::Type lhs,
+|    | 147|+                                             List::Properties::Type rhs)
+|    | 148|+    {
+|    | 149|+        return List::Properties::Type (unsigned (lhs) & unsigned (rhs));
+|    | 150|+    }
+|    | 151|+    inline List::Properties::Type & operator&= (List::Properties::Type & lhs,
+|    | 152|+                                                List::Properties::Type rhs)
+|    | 153|+    {
+|    | 154|+        lhs = lhs & rhs;
+|    | 155|+        return lhs;
+|    | 156|+    }
+|    | 157|+
+|    | 158|+// for range-based for loop
+|    | 159|+    inline List::Iterator begin (List & list)
+|    | 160|+    {
+|    | 161|+        return list.beginP ();
+|    | 162|+    }
+|    | 163|+    inline List::ConstIterator begin (const List & list)
+|    | 164|+    {
+|    | 165|+        return list.beginP ();
+|    | 166|+    }
+|    | 167|+    inline List::Iterator end (List & list)
+|    | 168|+    {
+|    | 169|+        return list.endP ();
+|    | 170|+    }
+|    | 171|+    inline List::ConstIterator end (const List & list)
+|    | 172|+    {
+|    | 173|+        return list.endP ();
+|    | 174|+    }
+|    | 175|+
+|    | 176|+/// Generic menu capable of holding any std::vector compatible values.
+|    | 177|+    template < typename ItemT > struct Menu:Window, List
+|    | 178|+    {
+|    | 179|+        struct Item
+|    | 180|+        {
+|    | 181|+            friend struct Menu <ItemT >;
+|    | 182|+
+|    | 183|+            typedef ItemT Type;
+|    | 184|+
+|    | 185|+              Item ():m_impl (std::make_shared < std::tuple < ItemT,
+|    | 186|+                              Properties >> ())
+|    | 187|+            {
+|    | 188|+            }
+|    | 189|+
+|    | 190|+            template < typename ValueT, typename PropertiesT >
+|    | 191|+                Item (ValueT
+|    | 192|+                      && value_,
+|    | 193|+                      PropertiesT properties_):m_impl (std::make_shared <
+|    | 194|+                                                       std::tuple < ItemT,
+|    | 195|+                                                       List::
+|    | 196|+                                                       Properties >> (std::
+|    | 197|+                                                                      forward <
+|    | 198|+                                                                      ValueT >
+|    | 199|+                                                                      (value_),
+|    | 200|+                                                                      std::
+|    | 201|+                                                                      forward <
+|    | 202|+                                                                      PropertiesT
+|    | 203|+                                                                      >
+|    | 204|+                                                                      (properties_)))
+|    | 205|+            {
+|    | 206|+            }
+|    | 207|+
+|    | 208|+            ItemT & value ()
+|    | 209|+            {
+|    | 210|+                return std::get < 0 > (*m_impl);
+|    | 211|+            }
+|    | 212|+            const ItemT & value () const
+|    | 213|+            {
+|    | 214|+                return std::get < 0 > (*m_impl);
+|    | 215|+            }
+|    | 216|+
+|    | 217|+            Properties & properties ()
+|    | 218|+            {
+|    | 219|+                return std::get < 1 > (*m_impl);
+|    | 220|+            }
+|    | 221|+            const Properties & properties () const
+|    | 222|+            {
+|    | 223|+                return std::get < 1 > (*m_impl);
+|    | 224|+            }
+|    | 225|+
+|    | 226|+            // Forward methods to List::Properties.
+|    | 227|+            void setSelectable (bool is_selectable)
+|    | 228|+            {
+|    | 229|+                properties ().setSelectable (is_selectable);
+|    | 230|+            }
+|    | 231|+            void setSelected (bool is_selected)
+|    | 232|+            {
+|    | 233|+                properties ().setSelected (is_selected);
+|    | 234|+            }
+|    | 235|+            void setInactive (bool is_inactive)
+|    | 236|+            {
+|    | 237|+                properties ().setInactive (is_inactive);
+|    | 238|+            }
+|    | 239|+            void setSeparator (bool is_separator)
+|    | 240|+            {
+|    | 241|+                properties ().setSeparator (is_separator);
+|    | 242|+            }
+|    | 243|+
+|    | 244|+            bool isSelectable () const
+|    | 245|+            {
+|    | 246|+                return properties ().isSelectable ();
+|    | 247|+            }
+|    | 248|+            bool isSelected () const
+|    | 249|+            {
+|    | 250|+                return properties ().isSelected ();
+|    | 251|+            }
+|    | 252|+            bool isInactive () const
+|    | 253|+            {
+|    | 254|+                return properties ().isInactive ();
+|    | 255|+            }
+|    | 256|+            bool isSeparator () const
+|    | 257|+            {
+|    | 258|+                return properties ().isSeparator ();
+|    | 259|+            }
+|    | 260|+
+|    | 261|+            // Make a deep copy of Item.
+|    | 262|+            Item copy () const
+|    | 263|+            {
+|    | 264|+                return Item (value (), properties ());
+|    | 265|+            }
+|    | 266|+
+|    | 267|+          private:
+|    | 268|+              template < Const const_ > struct ExtractProperties
+|    | 269|+            {
+|    | 270|+                typedef ExtractProperties type;
+|    | 271|+
+|    | 272|+                typedef typename std::conditional <
+|    | 273|+                    const_ == Const::Yes,
+|    | 274|+                    const Properties, Properties >::type Properties_;
+|    | 275|+                typedef typename std::conditional <
+|    | 276|+                    const_ == Const::Yes, const Item, Item >::type Item_;
+|    | 277|+
+|    | 278|+                  Properties_ & operator () (Item_ & i) const
+|    | 279|+                {
+|    | 280|+                    return i.properties ();
+|    | 281|+                }
+|    | 282|+            };
+|    | 283|+
+|    | 284|+            template < Const const_ > struct ExtractValue
+|    | 285|+            {
+|    | 286|+                typedef ExtractValue type;
+|    | 287|+
+|    | 288|+                typedef typename std::conditional <
+|    | 289|+                    const_ == Const::Yes, const ItemT, ItemT >::type Value_;
+|    | 290|+                typedef typename std::conditional <
+|    | 291|+                    const_ == Const::Yes, const Item, Item >::type Item_;
+|    | 292|+
+|    | 293|+                  Value_ & operator () (Item_ & i) const
+|    | 294|+                {
+|    | 295|+                    return i.value ();
+|    | 296|+                }
+|    | 297|+            };
+|    | 298|+
+|    | 299|+            static Item mkSeparator ()
+|    | 300|+            {
+|    | 301|+                Item item;
+|    | 302|+                item.setSelectable (false);
+|    | 303|+                item.setSeparator (true);
+|    | 304|+                return item;
+|    | 305|+            }
+|    | 306|+
+|    | 307|+            std::shared_ptr < std::tuple < ItemT, Properties >> m_impl;
+|    | 308|+        };
+|    | 309|+
+|    | 310|+        typedef typename std::vector < Item >::iterator Iterator;
+|    | 311|+        typedef typename std::vector < Item >::const_iterator ConstIterator;
+|    | 312|+        typedef std::reverse_iterator < Iterator > ReverseIterator;
+|    | 313|+        typedef std::reverse_iterator < ConstIterator > ConstReverseIterator;
+|    | 314|+
+|    | 315|+        typedef boost::transform_iterator <
+|    | 316|+            typename Item::template ExtractValue < Const::No >,
+|    | 317|+            Iterator > ValueIterator;
+|    | 318|+        typedef boost::transform_iterator <
+|    | 319|+            typename Item::template ExtractValue < Const::Yes >,
+|    | 320|+            ConstIterator > ConstValueIterator;
+|    | 321|+        typedef std::reverse_iterator < ValueIterator > ReverseValueIterator;
+|    | 322|+        typedef std::reverse_iterator < ConstValueIterator >
+|    | 323|+            ConstReverseValueIterator;
+|    | 324|+
+|    | 325|+        typedef boost::transform_iterator <
+|    | 326|+            typename Item::template ExtractProperties < Const::No >,
+|    | 327|+            Iterator > PropertiesIterator;
+|    | 328|+        typedef boost::transform_iterator <
+|    | 329|+            typename Item::template ExtractProperties < Const::Yes >,
+|    | 330|+            ConstIterator > ConstPropertiesIterator;
+|    | 331|+
+|    | 332|+        // For compliance with boost utilities.
+|    | 333|+        typedef Iterator iterator;
+|    | 334|+        typedef ConstIterator const_iterator;
+|    | 335|+
+|    | 336|+        /// Function helper prototype used to display each option on the screen.
+|    | 337|+        /// If not set by setItemDisplayer(), menu won't display anything.
+|    | 338|+        /// @see setItemDisplayer()
+|    | 339|+        typedef std::function < void (Menu < ItemT > &) > ItemDisplayer;
+|    | 340|+
+|    | 341|+        typedef std::function < bool (const Item &) > FilterPredicate;
+|    | 342|+
+|    | 343|+        Menu ();
+|    | 344|+
+|    | 345|+        Menu (size_t startx, size_t starty, size_t width, size_t height,
+|    | 346|+              const std::string & title, Color color, Border border);
+|    | 347|+
+|    | 348|+        Menu (const Menu & rhs);
+|    | 349|+        Menu (Menu && rhs);
+|    | 350|+        Menu & operator= (Menu rhs);
+|    | 351|+
+|    | 352|+        /// Sets helper function that is responsible for displaying items
+|    | 353|+        /// @param ptr function pointer that matches the ItemDisplayer prototype
+|    | 354|+        template < typename ItemDisplayerT >
+|    | 355|+            void setItemDisplayer (ItemDisplayerT && displayer);
+|    | 356|+
+|    | 357|+        /// Resizes the list to given size (adequate to std::vector::resize())
+|    | 358|+        /// @param size requested size
+|    | 359|+        void resizeList (size_t new_size);
+|    | 360|+
+|    | 361|+        /// Adds a new option to list
+|    | 362|+        void addItem (ItemT item, Properties::Type properties =
+|    | 363|+                      Properties::Selectable);
+|    | 364|+
+|    | 365|+        /// Adds separator to list
+|    | 366|+        void addSeparator ();
+|    | 367|+
+|    | 368|+        /// Inserts a new option to the list at given position
+|    | 369|+        void insertItem (size_t pos, ItemT item, Properties::Type properties =
+|    | 370|+                         Properties::Selectable);
+|    | 371|+
+|    | 372|+        /// Inserts separator to list at given position
+|    | 373|+        /// @param pos initial position of inserted separator
+|    | 374|+        void insertSeparator (size_t pos);
+|    | 375|+
+|    | 376|+        /// Moves the highlighted position to the given line of window
+|    | 377|+        /// @param y Y position of menu window to be highlighted
+|    | 378|+        /// @return true if the position is reachable, false otherwise
+|    | 379|+        bool Goto (size_t y);
+|    | 380|+
+|    | 381|+        /// Checks if list is empty
+|    | 382|+        /// @return true if list is empty, false otherwise
+|    | 383|+        virtual bool empty () const override
+|    | 384|+        {
+|    | 385|+            return m_items->empty ();
+|    | 386|+        }
+|    | 387|+
+|    | 388|+        /// @return size of the list
+|    | 389|+        virtual size_t size () const override
+|    | 390|+        {
+|    | 391|+            return m_items->size ();
+|    | 392|+        }
+|    | 393|+
+|    | 394|+        /// @return currently highlighted position
+|    | 395|+        virtual size_t choice () const override;
+|    | 396|+
+|    | 397|+        /// Highlights given position
+|    | 398|+        /// @param pos position to be highlighted
+|    | 399|+        virtual void highlight (size_t position) override;
+|    | 400|+
+|    | 401|+        /// Refreshes the menu window
+|    | 402|+        /// @see Window::refresh()
+|    | 403|+        virtual void refresh () override;
+|    | 404|+
+|    | 405|+        /// Scrolls by given amount of lines
+|    | 406|+        /// @param where indicated where exactly one wants to go
+|    | 407|+        /// @see Window::scroll()
+|    | 408|+        virtual void scroll (Scroll where) override;
+|    | 409|+
+|    | 410|+        /// Cleares all options, used filters etc. It doesn't reset highlighted position though.
+|    | 411|+        /// @see reset()
+|    | 412|+        virtual void clear () override;
+|    | 413|+
+|    | 414|+        /// Sets highlighted position to 0
+|    | 415|+        void reset ();
+|    | 416|+
+|    | 417|+        /// Apply filter predicate to items in the menu and show the ones for which it
+|    | 418|+        /// returned true.
+|    | 419|+        template < typename PredicateT > void applyFilter (PredicateT && pred);
+|    | 420|+
+|    | 421|+        /// Reapply previously applied filter.
+|    | 422|+        void reapplyFilter ();
+|    | 423|+
+|    | 424|+        /// Get current filter predicate.
+|    | 425|+        template < typename TargetT > const TargetT *filterPredicate () const;
+|    | 426|+
+|    | 427|+        /// Clear results of applyFilter and show all items.
+|    | 428|+        void clearFilter ();
+|    | 429|+
+|    | 430|+        /// @return true if menu is filtered.
+|    | 431|+        bool isFiltered () const
+|    | 432|+        {
+|    | 433|+            return m_items == &m_filtered_items;
+|    | 434|+        }
+|    | 435|+
+|    | 436|+        /// Show all items.
+|    | 437|+        void showAllItems ()
+|    | 438|+        {
+|    | 439|+            m_items = &m_all_items;
+|    | 440|+        }
+|    | 441|+
+|    | 442|+        /// Show filtered items.
+|    | 443|+        void showFilteredItems ()
+|    | 444|+        {
+|    | 445|+            m_items = &m_filtered_items;
+|    | 446|+        }
+|    | 447|+
+|    | 448|+        /// Sets prefix, that is put before each selected item to indicate its selection
+|    | 449|+        /// Note that the passed variable is not deleted along with menu object.
+|    | 450|+        /// @param b pointer to buffer that contains the prefix
+|    | 451|+        void setSelectedPrefix (const Buffer & b)
+|    | 452|+        {
+|    | 453|+            m_selected_prefix = b;
+|    | 454|+        }
+|    | 455|+
+|    | 456|+        /// Sets suffix, that is put after each selected item to indicate its selection
+|    | 457|+        /// Note that the passed variable is not deleted along with menu object.
+|    | 458|+        /// @param b pointer to buffer that contains the suffix
+|    | 459|+        void setSelectedSuffix (const Buffer & b)
+|    | 460|+        {
+|    | 461|+            m_selected_suffix = b;
+|    | 462|+        }
+|    | 463|+
+|    | 464|+        void setHighlightPrefix (const Buffer & b)
+|    | 465|+        {
+|    | 466|+            m_highlight_prefix = b;
+|    | 467|+        }
+|    | 468|+        void setHighlightSuffix (const Buffer & b)
+|    | 469|+        {
+|    | 470|+            m_highlight_suffix = b;
+|    | 471|+        }
+|    | 472|+
+|    | 473|+        const Buffer & highlightPrefix () const
+|    | 474|+        {
+|    | 475|+            return m_highlight_prefix;
+|    | 476|+        }
+|    | 477|+        const Buffer & highlightSuffix () const
+|    | 478|+        {
+|    | 479|+            return m_highlight_suffix;
+|    | 480|+        }
+|    | 481|+
+|    | 482|+        /// @return state of highlighting
+|    | 483|+        bool isHighlighted ()
+|    | 484|+        {
+|    | 485|+            return m_highlight_enabled;
+|    | 486|+        }
+|    | 487|+
+|    | 488|+        /// Turns on/off highlighting
+|    | 489|+        /// @param state state of hihglighting
+|    | 490|+        void setHighlighting (bool state)
+|    | 491|+        {
+|    | 492|+            m_highlight_enabled = state;
+|    | 493|+        }
+|    | 494|+
+|    | 495|+        /// Turns on/off cyclic scrolling
+|    | 496|+        /// @param state state of cyclic scrolling
+|    | 497|+        void cyclicScrolling (bool state)
+|    | 498|+        {
+|    | 499|+            m_cyclic_scroll_enabled = state;
+|    | 500|+        }
+|    | 501|+
+|    | 502|+        /// Turns on/off centered cursor
+|    | 503|+        /// @param state state of centered cursor
+|    | 504|+        void centeredCursor (bool state)
+|    | 505|+        {
+|    | 506|+            m_autocenter_cursor = state;
+|    | 507|+        }
+|    | 508|+
+|    | 509|+        /// @return currently drawn item. The result is defined only within
+|    | 510|+        /// drawing function that is called by refresh()
+|    | 511|+        /// @see refresh()
+|    | 512|+        ConstIterator drawn () const
+|    | 513|+        {
+|    | 514|+            return begin () + m_drawn_position;
+|    | 515|+        }
+|    | 516|+
+|    | 517|+        /// @param pos requested position
+|    | 518|+        /// @return reference to item at given position
+|    | 519|+        /// @throw std::out_of_range if given position is out of range
+|    | 520|+        Menu < ItemT >::Item & at (size_t pos)
+|    | 521|+        {
+|    | 522|+            return m_items->at (pos);
+|    | 523|+        }
+|    | 524|+
+|    | 525|+        /// @param pos requested position
+|    | 526|+        /// @return const reference to item at given position
+|    | 527|+        /// @throw std::out_of_range if given position is out of range
+|    | 528|+        const Menu < ItemT >::Item & at (size_t pos) const
+|    | 529|+        {
+|    | 530|+            return m_items->at (pos);
+|    | 531|+        }
+|    | 532|+
+|    | 533|+        /// @param pos requested position
+|    | 534|+        /// @return const reference to item at given position
+|    | 535|+        const Menu < ItemT >::Item & operator[] (size_t pos) const
+|    | 536|+        {
+|    | 537|+            return (*m_items)[pos];
+|    | 538|+        }
+|    | 539|+
+|    | 540|+        /// @param pos requested position
+|    | 541|+        /// @return const reference to item at given position
+|    | 542|+        Menu < ItemT >::Item & operator[] (size_t pos)
+|    | 543|+        {
+|    | 544|+            return (*m_items)[pos];
+|    | 545|+        }
+|    | 546|+
+|    | 547|+        Iterator current ()
+|    | 548|+        {
+|    | 549|+            return Iterator (m_items->begin () + m_highlight);
+|    | 550|+        }
+|    | 551|+        ConstIterator current () const
+|    | 552|+        {
+|    | 553|+            return ConstIterator (m_items->begin () + m_highlight);
+|    | 554|+        }
+|    | 555|+        ReverseIterator rcurrent ()
+|    | 556|+        {
+|    | 557|+            if (empty ())
+|    | 558|+                return rend ();
+|    | 559|+            else
+|    | 560|+                return ReverseIterator (++current ());
+|    | 561|+        }
+|    | 562|+        ConstReverseIterator rcurrent () const
+|    | 563|+        {
+|    | 564|+            if (empty ())
+|    | 565|+                return rend ();
+|    | 566|+            else
+|    | 567|+                return ConstReverseIterator (++current ());
+|    | 568|+        }
+|    | 569|+
+|    | 570|+        ValueIterator currentV ()
+|    | 571|+        {
+|    | 572|+            return ValueIterator (m_items->begin () + m_highlight);
+|    | 573|+        }
+|    | 574|+        ConstValueIterator currentV () const
+|    | 575|+        {
+|    | 576|+            return ConstValueIterator (m_items->begin () + m_highlight);
+|    | 577|+        }
+|    | 578|+        ReverseValueIterator rcurrentV ()
+|    | 579|+        {
+|    | 580|+            if (empty ())
+|    | 581|+                return rendV ();
+|    | 582|+            else
+|    | 583|+                return ReverseValueIterator (++currentV ());
+|    | 584|+        }
+|    | 585|+        ConstReverseValueIterator rcurrentV () const
+|    | 586|+        {
+|    | 587|+            if (empty ())
+|    | 588|+                return rendV ();
+|    | 589|+            else
+|    | 590|+                return ConstReverseValueIterator (++currentV ());
+|    | 591|+        }
+|    | 592|+
+|    | 593|+        Iterator begin ()
+|    | 594|+        {
+|    | 595|+            return Iterator (m_items->begin ());
+|    | 596|+        }
+|    | 597|+        ConstIterator begin () const
+|    | 598|+        {
+|    | 599|+            return ConstIterator (m_items->begin ());
+|    | 600|+        }
+|    | 601|+        Iterator end ()
+|    | 602|+        {
+|    | 603|+            return Iterator (m_items->end ());
+|    | 604|+        }
+|    | 605|+        ConstIterator end () const
+|    | 606|+        {
+|    | 607|+            return ConstIterator (m_items->end ());
+|    | 608|+        }
+|    | 609|+
+|    | 610|+        ReverseIterator rbegin ()
+|    | 611|+        {
+|    | 612|+            return ReverseIterator (end ());
+|    | 613|+        }
+|    | 614|+        ConstReverseIterator rbegin () const
+|    | 615|+        {
+|    | 616|+            return ConstReverseIterator (end ());
+|    | 617|+        }
+|    | 618|+        ReverseIterator rend ()
+|    | 619|+        {
+|    | 620|+            return ReverseIterator (begin ());
+|    | 621|+        }
+|    | 622|+        ConstReverseIterator rend () const
+|    | 623|+        {
+|    | 624|+            return ConstReverseIterator (begin ());
+|    | 625|+        }
+|    | 626|+
+|    | 627|+        ValueIterator beginV ()
+|    | 628|+        {
+|    | 629|+            return ValueIterator (begin ());
+|    | 630|+        }
+|    | 631|+        ConstValueIterator beginV () const
+|    | 632|+        {
+|    | 633|+            return ConstValueIterator (begin ());
+|    | 634|+        }
+|    | 635|+        ValueIterator endV ()
+|    | 636|+        {
+|    | 637|+            return ValueIterator (end ());
+|    | 638|+        }
+|    | 639|+        ConstValueIterator endV () const
+|    | 640|+        {
+|    | 641|+            return ConstValueIterator (end ());
+|    | 642|+        }
+|    | 643|+
+|    | 644|+        ReverseValueIterator rbeginV ()
+|    | 645|+        {
+|    | 646|+            return ReverseValueIterator (endV ());
+|    | 647|+        }
+|    | 648|+        ConstReverseIterator rbeginV () const
+|    | 649|+        {
+|    | 650|+            return ConstReverseValueIterator (endV ());
+|    | 651|+        }
+|    | 652|+        ReverseValueIterator rendV ()
+|    | 653|+        {
+|    | 654|+            return ReverseValueIterator (beginV ());
+|    | 655|+        }
+|    | 656|+        ConstReverseValueIterator rendV () const
+|    | 657|+        {
+|    | 658|+            return ConstReverseValueIterator (beginV ());
+|    | 659|+        }
+|    | 660|+
+|    | 661|+        virtual List::Iterator currentP () override
+|    | 662|+        {
+|    | 663|+            return List::
+|    | 664|+                Iterator (PropertiesIterator
+|    | 665|+                          (m_items->begin () + m_highlight));
+|    | 666|+        }
+|    | 667|+        virtual List::ConstIterator currentP () const override
+|    | 668|+        {
+|    | 669|+            return List::
+|    | 670|+                ConstIterator (ConstPropertiesIterator
+|    | 671|+                               (m_items->begin () + m_highlight));
+|    | 672|+        }
+|    | 673|+        virtual List::Iterator beginP () override
+|    | 674|+        {
+|    | 675|+            return List::Iterator (PropertiesIterator (m_items->begin ()));
+|    | 676|+        }
+|    | 677|+        virtual List::ConstIterator beginP () const override
+|    | 678|+        {
+|    | 679|+            return List::
+|    | 680|+                ConstIterator (ConstPropertiesIterator (m_items->begin ()));
+|    | 681|+        }
+|    | 682|+        virtual List::Iterator endP () override
+|    | 683|+        {
+|    | 684|+            return List::Iterator (PropertiesIterator (m_items->end ()));
+|    | 685|+        }
+|    | 686|+        virtual List::ConstIterator endP () const override
+|    | 687|+        {
+|    | 688|+            return List::
+|    | 689|+                ConstIterator (ConstPropertiesIterator (m_items->end ()));
+|    | 690|+        }
+|    | 691|+
+|    | 692|+      private:
+|    | 693|+          bool isHighlightable (size_t pos)
+|    | 694|+        {
+|    | 695|+            return !(*m_items)[pos].isSeparator ()
+|    | 696|+                && !(*m_items)[pos].isInactive ();
+|    | 697|+        }
+|    | 698|+
+|    | 699|+        ItemDisplayer m_item_displayer;
+|    | 700|+        FilterPredicate m_filter_predicate;
+|    | 701|+
+|    | 702|+        std::vector < Item > *m_items;
+|    | 703|+        std::vector < Item > m_all_items;
+|    | 704|+        std::vector < Item > m_filtered_items;
+|    | 705|+
+|    | 706|+        size_t m_beginning;
+|    | 707|+        size_t m_highlight;
+|    | 708|+
+|    | 709|+        bool m_highlight_enabled;
+|    | 710|+        bool m_cyclic_scroll_enabled;
+|    | 711|+
+|    | 712|+        bool m_autocenter_cursor;
+|    | 713|+
+|    | 714|+        size_t m_drawn_position;
+|    | 715|+
+|    | 716|+        Buffer m_highlight_prefix;
+|    | 717|+        Buffer m_highlight_suffix;
+|    | 718|+
+|    | 719|+        Buffer m_selected_prefix;
+|    | 720|+        Buffer m_selected_suffix;
+|    | 721|+    };
+|    | 722|+
+| 124| 723| }
+| 125|    |-inline List::Properties::Type &operator|=(List::Properties::Type &lhs, List::Properties::Type rhs)
+| 126|    |-{
+| 127|    |-	lhs = lhs | rhs;
+| 128|    |-	return lhs;
+| 129|    |-}
+| 130|    |-inline List::Properties::Type operator&(List::Properties::Type lhs, List::Properties::Type rhs)
+| 131|    |-{
+| 132|    |-	return List::Properties::Type(unsigned(lhs) & unsigned(rhs));
+| 133|    |-}
+| 134|    |-inline List::Properties::Type &operator&=(List::Properties::Type &lhs, List::Properties::Type rhs)
+| 135|    |-{
+| 136|    |-	lhs = lhs & rhs;
+| 137|    |-	return lhs;
+| 138|    |-}
+| 139|    |-
+| 140|    |-// for range-based for loop
+| 141|    |-inline List::Iterator begin(List &list) { return list.beginP(); }
+| 142|    |-inline List::ConstIterator begin(const List &list) { return list.beginP(); }
+| 143|    |-inline List::Iterator end(List &list) { return list.endP(); }
+| 144|    |-inline List::ConstIterator end(const List &list) { return list.endP(); }
+| 145|    |-
+| 146|    |-/// Generic menu capable of holding any std::vector compatible values.
+| 147|    |-template <typename ItemT>
+| 148|    |-struct Menu: Window, List
+| 149|    |-{
+| 150|    |-	struct Item
+| 151|    |-	{
+| 152|    |-		friend struct Menu<ItemT>;
+| 153|    |-
+| 154|    |-		typedef ItemT Type;
+| 155|    |-
+| 156|    |-		Item()
+| 157|    |-			: m_impl(std::make_shared<std::tuple<ItemT, Properties>>())
+| 158|    |-		{ }
+| 159|    |-
+| 160|    |-		template <typename ValueT, typename PropertiesT>
+| 161|    |-		Item(ValueT &&value_, PropertiesT properties_)
+| 162|    |-			: m_impl(
+| 163|    |-				std::make_shared<std::tuple<ItemT, List::Properties>>(
+| 164|    |-					std::forward<ValueT>(value_),
+| 165|    |-					std::forward<PropertiesT>(properties_)))
+| 166|    |-		{ }
+| 167|    |-
+| 168|    |-		ItemT &value() { return std::get<0>(*m_impl); }
+| 169|    |-		const ItemT &value() const { return std::get<0>(*m_impl); }
+| 170|    |-
+| 171|    |-		Properties &properties() { return std::get<1>(*m_impl); }
+| 172|    |-		const Properties &properties() const { return std::get<1>(*m_impl); }
+| 173|    |-
+| 174|    |-		// Forward methods to List::Properties.
+| 175|    |-		void setSelectable(bool is_selectable) { properties().setSelectable(is_selectable); }
+| 176|    |-		void setSelected (bool is_selected) { properties().setSelected(is_selected); }
+| 177|    |-		void setInactive (bool is_inactive) { properties().setInactive(is_inactive); }
+| 178|    |-		void setSeparator (bool is_separator) { properties().setSeparator(is_separator); }
+| 179|    |-
+| 180|    |-		bool isSelectable() const { return properties().isSelectable(); }
+| 181|    |-		bool isSelected() const { return properties().isSelected(); }
+| 182|    |-		bool isInactive() const { return properties().isInactive(); }
+| 183|    |-		bool isSeparator() const { return properties().isSeparator(); }
+| 184|    |-
+| 185|    |-		// Make a deep copy of Item.
+| 186|    |-		Item copy() const {
+| 187|    |-			return Item(value(), properties());
+| 188|    |-		}
+| 189|    |-
+| 190|    |-	private:
+| 191|    |-		template <Const const_>
+| 192|    |-		struct ExtractProperties
+| 193|    |-		{
+| 194|    |-			typedef ExtractProperties type;
+| 195|    |-
+| 196|    |-			typedef typename std::conditional<
+| 197|    |-				const_ == Const::Yes,
+| 198|    |-				const Properties,
+| 199|    |-				Properties>::type Properties_;
+| 200|    |-			typedef typename std::conditional<
+| 201|    |-				const_ == Const::Yes,
+| 202|    |-				const Item,
+| 203|    |-				Item>::type Item_;
+| 204|    |-
+| 205|    |-			Properties_ &operator()(Item_ &i) const {
+| 206|    |-				return i.properties();
+| 207|    |-			}
+| 208|    |-		};
+| 209|    |-
+| 210|    |-		template <Const const_>
+| 211|    |-		struct ExtractValue
+| 212|    |-		{
+| 213|    |-			typedef ExtractValue type;
+| 214|    |-
+| 215|    |-			typedef typename std::conditional<
+| 216|    |-				const_ == Const::Yes,
+| 217|    |-				const ItemT,
+| 218|    |-				ItemT>::type Value_;
+| 219|    |-			typedef typename std::conditional<
+| 220|    |-				const_ == Const::Yes,
+| 221|    |-				const Item,
+| 222|    |-				Item>::type Item_;
+| 223|    |-
+| 224|    |-			Value_ &operator()(Item_ &i) const {
+| 225|    |-				return i.value();
+| 226|    |-			}
+| 227|    |-		};
+| 228|    |-
+| 229|    |-		static Item mkSeparator()
+| 230|    |-		{
+| 231|    |-			Item item;
+| 232|    |-			item.setSelectable(false);
+| 233|    |-			item.setSeparator(true);
+| 234|    |-			return item;
+| 235|    |-		}
+| 236|    |-		
+| 237|    |-		std::shared_ptr<std::tuple<ItemT, Properties>> m_impl;
+| 238|    |-	};
+| 239|    |-
+| 240|    |-	typedef typename std::vector<Item>::iterator Iterator;
+| 241|    |-	typedef typename std::vector<Item>::const_iterator ConstIterator;
+| 242|    |-	typedef std::reverse_iterator<Iterator> ReverseIterator;
+| 243|    |-	typedef std::reverse_iterator<ConstIterator> ConstReverseIterator;
+| 244|    |-
+| 245|    |-	typedef boost::transform_iterator<
+| 246|    |-		typename Item::template ExtractValue<Const::No>,
+| 247|    |-		Iterator> ValueIterator;
+| 248|    |-	typedef boost::transform_iterator<
+| 249|    |-		typename Item::template ExtractValue<Const::Yes>,
+| 250|    |-		ConstIterator> ConstValueIterator;
+| 251|    |-	typedef std::reverse_iterator<ValueIterator> ReverseValueIterator;
+| 252|    |-	typedef std::reverse_iterator<ConstValueIterator> ConstReverseValueIterator;
+| 253|    |-	
+| 254|    |-	typedef boost::transform_iterator<
+| 255|    |-		typename Item::template ExtractProperties<Const::No>,
+| 256|    |-		Iterator> PropertiesIterator;
+| 257|    |-	typedef boost::transform_iterator<
+| 258|    |-		typename Item::template ExtractProperties<Const::Yes>,
+| 259|    |-		ConstIterator> ConstPropertiesIterator;
+| 260|    |-
+| 261|    |-	// For compliance with boost utilities.
+| 262|    |-	typedef Iterator iterator;
+| 263|    |-	typedef ConstIterator const_iterator;
+| 264|    |-
+| 265|    |-	/// Function helper prototype used to display each option on the screen.
+| 266|    |-	/// If not set by setItemDisplayer(), menu won't display anything.
+| 267|    |-	/// @see setItemDisplayer()
+| 268|    |-	typedef std::function<void(Menu<ItemT> &)> ItemDisplayer;
+| 269|    |-
+| 270|    |-	typedef std::function<bool(const Item &)> FilterPredicate;
+| 271|    |-
+| 272|    |-	Menu();
+| 273|    |-	
+| 274|    |-	Menu(size_t startx, size_t starty, size_t width, size_t height,
+| 275|    |-			const std::string &title, Color color, Border border);
+| 276|    |-	
+| 277|    |-	Menu(const Menu &rhs);
+| 278|    |-	Menu(Menu &&rhs);
+| 279|    |-	Menu &operator=(Menu rhs);
+| 280|    |-	
+| 281|    |-	/// Sets helper function that is responsible for displaying items
+| 282|    |-	/// @param ptr function pointer that matches the ItemDisplayer prototype
+| 283|    |-	template <typename ItemDisplayerT>
+| 284|    |-	void setItemDisplayer(ItemDisplayerT &&displayer);
+| 285|    |-	
+| 286|    |-	/// Resizes the list to given size (adequate to std::vector::resize())
+| 287|    |-	/// @param size requested size
+| 288|    |-	void resizeList(size_t new_size);
+| 289|    |-	
+| 290|    |-	/// Adds a new option to list
+| 291|    |-	void addItem(ItemT item, Properties::Type properties = Properties::Selectable);
+| 292|    |-	
+| 293|    |-	/// Adds separator to list
+| 294|    |-	void addSeparator();
+| 295|    |-	
+| 296|    |-	/// Inserts a new option to the list at given position
+| 297|    |-	void insertItem(size_t pos, ItemT item, Properties::Type properties = Properties::Selectable);
+| 298|    |-	
+| 299|    |-	/// Inserts separator to list at given position
+| 300|    |-	/// @param pos initial position of inserted separator
+| 301|    |-	void insertSeparator(size_t pos);
+| 302|    |-	
+| 303|    |-	/// Moves the highlighted position to the given line of window
+| 304|    |-	/// @param y Y position of menu window to be highlighted
+| 305|    |-	/// @return true if the position is reachable, false otherwise
+| 306|    |-	bool Goto(size_t y);
+| 307|    |-	
+| 308|    |-	/// Checks if list is empty
+| 309|    |-	/// @return true if list is empty, false otherwise
+| 310|    |-	virtual bool empty() const override { return m_items->empty(); }
+| 311|    |-
+| 312|    |-	/// @return size of the list
+| 313|    |-	virtual size_t size() const override { return m_items->size(); }
+| 314|    |-
+| 315|    |-	/// @return currently highlighted position
+| 316|    |-	virtual size_t choice() const override;
+| 317|    |-
+| 318|    |-	/// Highlights given position
+| 319|    |-	/// @param pos position to be highlighted
+| 320|    |-	virtual void highlight(size_t position) override;
+| 321|    |-	
+| 322|    |-	/// Refreshes the menu window
+| 323|    |-	/// @see Window::refresh()
+| 324|    |-	virtual void refresh() override;
+| 325|    |-	
+| 326|    |-	/// Scrolls by given amount of lines
+| 327|    |-	/// @param where indicated where exactly one wants to go
+| 328|    |-	/// @see Window::scroll()
+| 329|    |-	virtual void scroll(Scroll where) override;
+| 330|    |-	
+| 331|    |-	/// Cleares all options, used filters etc. It doesn't reset highlighted position though.
+| 332|    |-	/// @see reset()
+| 333|    |-	virtual void clear() override;
+| 334|    |-	
+| 335|    |-	/// Sets highlighted position to 0
+| 336|    |-	void reset();
+| 337|    |-
+| 338|    |-	/// Apply filter predicate to items in the menu and show the ones for which it
+| 339|    |-	/// returned true.
+| 340|    |-	template <typename PredicateT>
+| 341|    |-	void applyFilter(PredicateT &&pred);
+| 342|    |-
+| 343|    |-	/// Reapply previously applied filter.
+| 344|    |-	void reapplyFilter();
+| 345|    |-
+| 346|    |-	/// Get current filter predicate.
+| 347|    |-	template <typename TargetT>
+| 348|    |-	const TargetT *filterPredicate() const;
+| 349|    |-
+| 350|    |-	/// Clear results of applyFilter and show all items.
+| 351|    |-	void clearFilter();
+| 352|    |-
+| 353|    |-	/// @return true if menu is filtered.
+| 354|    |-	bool isFiltered() const { return m_items == &m_filtered_items; }
+| 355|    |-
+| 356|    |-	/// Show all items.
+| 357|    |-	void showAllItems() { m_items = &m_all_items; }
+| 358|    |-
+| 359|    |-	/// Show filtered items.
+| 360|    |-	void showFilteredItems() { m_items = &m_filtered_items; }
+| 361|    |-
+| 362|    |-	/// Sets prefix, that is put before each selected item to indicate its selection
+| 363|    |-	/// Note that the passed variable is not deleted along with menu object.
+| 364|    |-	/// @param b pointer to buffer that contains the prefix
+| 365|    |-	void setSelectedPrefix(const Buffer &b) { m_selected_prefix = b; }
+| 366|    |-	
+| 367|    |-	/// Sets suffix, that is put after each selected item to indicate its selection
+| 368|    |-	/// Note that the passed variable is not deleted along with menu object.
+| 369|    |-	/// @param b pointer to buffer that contains the suffix
+| 370|    |-	void setSelectedSuffix(const Buffer &b) { m_selected_suffix = b; }
+| 371|    |-
+| 372|    |-	void setHighlightPrefix(const Buffer &b) { m_highlight_prefix = b; }
+| 373|    |-	void setHighlightSuffix(const Buffer &b) { m_highlight_suffix = b; }
+| 374|    |-
+| 375|    |-	const Buffer &highlightPrefix() const { return m_highlight_prefix; }
+| 376|    |-	const Buffer &highlightSuffix() const { return m_highlight_suffix; }
+| 377|    |-
+| 378|    |-	/// @return state of highlighting
+| 379|    |-	bool isHighlighted() { return m_highlight_enabled; }
+| 380|    |-	
+| 381|    |-	/// Turns on/off highlighting
+| 382|    |-	/// @param state state of hihglighting
+| 383|    |-	void setHighlighting(bool state) { m_highlight_enabled = state; }
+| 384|    |-	
+| 385|    |-	/// Turns on/off cyclic scrolling
+| 386|    |-	/// @param state state of cyclic scrolling
+| 387|    |-	void cyclicScrolling(bool state) { m_cyclic_scroll_enabled = state; }
+| 388|    |-	
+| 389|    |-	/// Turns on/off centered cursor
+| 390|    |-	/// @param state state of centered cursor
+| 391|    |-	void centeredCursor(bool state) { m_autocenter_cursor = state; }
+| 392|    |-	
+| 393|    |-	/// @return currently drawn item. The result is defined only within
+| 394|    |-	/// drawing function that is called by refresh()
+| 395|    |-	/// @see refresh()
+| 396|    |-	ConstIterator drawn() const { return begin() + m_drawn_position; }
+| 397|    |-	
+| 398|    |-	/// @param pos requested position
+| 399|    |-	/// @return reference to item at given position
+| 400|    |-	/// @throw std::out_of_range if given position is out of range
+| 401|    |-	Menu<ItemT>::Item &at(size_t pos) { return m_items->at(pos); }
+| 402|    |-	
+| 403|    |-	/// @param pos requested position
+| 404|    |-	/// @return const reference to item at given position
+| 405|    |-	/// @throw std::out_of_range if given position is out of range
+| 406|    |-	const Menu<ItemT>::Item &at(size_t pos) const { return m_items->at(pos); }
+| 407|    |-	
+| 408|    |-	/// @param pos requested position
+| 409|    |-	/// @return const reference to item at given position
+| 410|    |-	const Menu<ItemT>::Item &operator[](size_t pos) const { return (*m_items)[pos]; }
+| 411|    |-	
+| 412|    |-	/// @param pos requested position
+| 413|    |-	/// @return const reference to item at given position
+| 414|    |-	Menu<ItemT>::Item &operator[](size_t pos) { return (*m_items)[pos]; }
+| 415|    |-	
+| 416|    |-	Iterator current() { return Iterator(m_items->begin() + m_highlight); }
+| 417|    |-	ConstIterator current() const { return ConstIterator(m_items->begin() + m_highlight); }
+| 418|    |-	ReverseIterator rcurrent() {
+| 419|    |-		if (empty())
+| 420|    |-			return rend();
+| 421|    |-		else
+| 422|    |-			return ReverseIterator(++current());
+| 423|    |-	}
+| 424|    |-	ConstReverseIterator rcurrent() const {
+| 425|    |-		if (empty())
+| 426|    |-			return rend();
+| 427|    |-		else
+| 428|    |-			return ConstReverseIterator(++current());
+| 429|    |-	}
+| 430|    |-
+| 431|    |-	ValueIterator currentV() { return ValueIterator(m_items->begin() + m_highlight); }
+| 432|    |-	ConstValueIterator currentV() const { return ConstValueIterator(m_items->begin() + m_highlight); }
+| 433|    |-	ReverseValueIterator rcurrentV() {
+| 434|    |-		if (empty())
+| 435|    |-			return rendV();
+| 436|    |-		else
+| 437|    |-			return ReverseValueIterator(++currentV());
+| 438|    |-	}
+| 439|    |-	ConstReverseValueIterator rcurrentV() const {
+| 440|    |-		if (empty())
+| 441|    |-			return rendV();
+| 442|    |-		else
+| 443|    |-			return ConstReverseValueIterator(++currentV());
+| 444|    |-	}
+| 445|    |-	
+| 446|    |-	Iterator begin() { return Iterator(m_items->begin()); }
+| 447|    |-	ConstIterator begin() const { return ConstIterator(m_items->begin()); }
+| 448|    |-	Iterator end() { return Iterator(m_items->end()); }
+| 449|    |-	ConstIterator end() const { return ConstIterator(m_items->end()); }
+| 450|    |-	
+| 451|    |-	ReverseIterator rbegin() { return ReverseIterator(end()); }
+| 452|    |-	ConstReverseIterator rbegin() const { return ConstReverseIterator(end()); }
+| 453|    |-	ReverseIterator rend() { return ReverseIterator(begin()); }
+| 454|    |-	ConstReverseIterator rend() const { return ConstReverseIterator(begin()); }
+| 455|    |-	
+| 456|    |-	ValueIterator beginV() { return ValueIterator(begin()); }
+| 457|    |-	ConstValueIterator beginV() const { return ConstValueIterator(begin()); }
+| 458|    |-	ValueIterator endV() { return ValueIterator(end()); }
+| 459|    |-	ConstValueIterator endV() const { return ConstValueIterator(end()); }
+| 460|    |-	
+| 461|    |-	ReverseValueIterator rbeginV() { return ReverseValueIterator(endV()); }
+| 462|    |-	ConstReverseIterator rbeginV() const { return ConstReverseValueIterator(endV()); }
+| 463|    |-	ReverseValueIterator rendV() { return ReverseValueIterator(beginV()); }
+| 464|    |-	ConstReverseValueIterator rendV() const { return ConstReverseValueIterator(beginV()); }
+| 465|    |-	
+| 466|    |-	virtual List::Iterator currentP() override {
+| 467|    |-		return List::Iterator(PropertiesIterator(m_items->begin() + m_highlight));
+| 468|    |-	}
+| 469|    |-	virtual List::ConstIterator currentP() const override {
+| 470|    |-		return List::ConstIterator(ConstPropertiesIterator(m_items->begin() + m_highlight));
+| 471|    |-	}
+| 472|    |-	virtual List::Iterator beginP() override {
+| 473|    |-		return List::Iterator(PropertiesIterator(m_items->begin()));
+| 474|    |-	}
+| 475|    |-	virtual List::ConstIterator beginP() const override {
+| 476|    |-		return List::ConstIterator(ConstPropertiesIterator(m_items->begin()));
+| 477|    |-	}
+| 478|    |-	virtual List::Iterator endP() override {
+| 479|    |-		return List::Iterator(PropertiesIterator(m_items->end()));
+| 480|    |-	}
+| 481|    |-	virtual List::ConstIterator endP() const override {
+| 482|    |-		return List::ConstIterator(ConstPropertiesIterator(m_items->end()));
+| 483|    |-	}
+| 484|    |-
+| 485|    |-private:
+| 486|    |-	bool isHighlightable(size_t pos)
+| 487|    |-	{
+| 488|    |-		return !(*m_items)[pos].isSeparator()
+| 489|    |-			&& !(*m_items)[pos].isInactive();
+| 490|    |-	}
+| 491|    |-
+| 492|    |-	ItemDisplayer m_item_displayer;
+| 493|    |-	FilterPredicate m_filter_predicate;
+| 494|    |-
+| 495|    |-	std::vector<Item> *m_items;
+| 496|    |-	std::vector<Item> m_all_items;
+| 497|    |-	std::vector<Item> m_filtered_items;
+| 498|    |-	
+| 499|    |-	size_t m_beginning;
+| 500|    |-	size_t m_highlight;
+| 501|    |-	
+| 502|    |-	bool m_highlight_enabled;
+| 503|    |-	bool m_cyclic_scroll_enabled;
+| 504|    |-	
+| 505|    |-	bool m_autocenter_cursor;
+| 506|    |-	
+| 507|    |-	size_t m_drawn_position;
+| 508|    |-
+| 509|    |-	Buffer m_highlight_prefix;
+| 510|    |-	Buffer m_highlight_suffix;
+| 511|    |-
+| 512|    |-	Buffer m_selected_prefix;
+| 513|    |-	Buffer m_selected_suffix;
+| 514|    |-};
+| 515|    |-
+| 516|    |-}
+| 517| 724| 
+| 518| 725| #endif // NCMPCPP_MENU_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+|  28|  28| #include "screens/screen.h"
+|  29|  29| #include "song_list.h"
+|  30|  30| 
+|  31|    |-struct MediaLibrary: Screen<NC::Window *>, Filterable, HasColumns, HasSongs, Searchable, Tabbable
+|    |  31|+struct MediaLibrary:Screen <
+|    |  32|+NC::Window * >,
+|    |  33|+    Filterable,
+|    |  34|+    HasColumns,
+|    |  35|+    HasSongs,
+|    |  36|+    Searchable,
+|    |  37|+    Tabbable
+|  32|  38| {
+|  33|    |-	MediaLibrary();
+|  34|    |-	
+|  35|    |-	virtual void switchTo() override;
+|  36|    |-	virtual void resize() override;
+|  37|    |-	
+|  38|    |-	virtual std::wstring title() override;
+|  39|    |-	virtual ScreenType type() override { return ScreenType::MediaLibrary; }
+|  40|    |-	
+|  41|    |-	virtual void refresh() override;
+|  42|    |-	virtual void update() override;
+|  43|    |-	
+|  44|    |-	virtual int windowTimeout() override;
+|  45|    |-
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// Searchable implementation
+|  52|    |-	virtual bool allowsSearching() override;
+|  53|    |-	virtual const std::string &searchConstraint() override;
+|  54|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  55|    |-	virtual void clearSearchConstraint() override;
+|  56|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|  57|    |-
+|  58|    |-	// Filterable implementation
+|  59|    |-	virtual bool allowsFiltering() override;
+|  60|    |-	virtual std::string currentFilter() override;
+|  61|    |-	virtual void applyFilter(const std::string &filter) override;
+|  62|    |-
+|  63|    |-	// HasSongs implementation
+|  64|    |-	virtual bool itemAvailable() override;
+|  65|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  66|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  67|    |-	
+|  68|    |-	// HasColumns implementation
+|  69|    |-	virtual bool previousColumnAvailable() override;
+|  70|    |-	virtual void previousColumn() override;
+|  71|    |-	
+|  72|    |-	virtual bool nextColumnAvailable() override;
+|  73|    |-	virtual void nextColumn() override;
+|  74|    |-	
+|  75|    |-	// other members
+|  76|    |-	void updateTimer();
+|  77|    |-	void toggleColumnsMode();
+|  78|    |-	int columns();
+|  79|    |-	void locateSong(const MPD::Song &s);
+|  80|    |-	void toggleSortMode();
+|  81|    |-	
+|  82|    |-	void requestTagsUpdate() { m_tags_update_request = true; }
+|  83|    |-	void requestAlbumsUpdate() { m_albums_update_request = true; }
+|  84|    |-	void requestSongsUpdate() { m_songs_update_request = true; }
+|  85|    |-	
+|  86|    |-	struct PrimaryTag
+|  87|    |-	{
+|  88|    |-		PrimaryTag() : m_mtime(0) { }
+|  89|    |-		PrimaryTag(std::string tag_, time_t mtime_)
+|  90|    |-		: m_tag(std::move(tag_)), m_mtime(mtime_) { }
+|  91|    |-		
+|  92|    |-		const std::string &tag() const { return m_tag; }
+|  93|    |-		time_t mtime() const { return m_mtime; }
+|  94|    |-		
+|  95|    |-	private:
+|  96|    |-		std::string m_tag;
+|  97|    |-		time_t m_mtime;
+|  98|    |-	};
+|  99|    |-	
+| 100|    |-	struct Album
+| 101|    |-	{
+| 102|    |-		Album(std::string tag_, std::string album_, std::string date_, time_t mtime_)
+| 103|    |-		: m_tag(std::move(tag_)), m_album(std::move(album_))
+| 104|    |-		, m_date(std::move(date_)), m_mtime(mtime_) { }
+| 105|    |-		
+| 106|    |-		const std::string &tag() const { return m_tag; }
+| 107|    |-		const std::string &album() const { return m_album; }
+| 108|    |-		const std::string &date() const { return m_date; }
+| 109|    |-		time_t mtime() const { return m_mtime; }
+| 110|    |-		
+| 111|    |-	private:
+| 112|    |-		std::string m_tag;
+| 113|    |-		std::string m_album;
+| 114|    |-		std::string m_date;
+| 115|    |-		time_t m_mtime;
+| 116|    |-	};
+| 117|    |-	
+| 118|    |-	struct AlbumEntry
+| 119|    |-	{
+| 120|    |-		AlbumEntry() : m_all_tracks_entry(false), m_album("", "", "", 0) { }
+| 121|    |-		explicit AlbumEntry(Album album_) : m_all_tracks_entry(false), m_album(album_) { }
+| 122|    |-		
+| 123|    |-		const Album &entry() const { return m_album; }
+| 124|    |-		bool isAllTracksEntry() const { return m_all_tracks_entry; }
+| 125|    |-		
+| 126|    |-		static AlbumEntry mkAllTracksEntry(std::string tag) {
+| 127|    |-			auto result = AlbumEntry(Album(tag, "", "", 0));
+| 128|    |-			result.m_all_tracks_entry = true;
+| 129|    |-			return result;
+| 130|    |-		}
+| 131|    |-		
+| 132|    |-	private:
+| 133|    |-		bool m_all_tracks_entry;
+| 134|    |-		Album m_album;
+| 135|    |-	};
+| 136|    |-	
+| 137|    |-	NC::Menu<PrimaryTag> Tags;
+| 138|    |-	NC::Menu<AlbumEntry> Albums;
+| 139|    |-	SongMenu Songs;
+| 140|    |-	
+| 141|    |-private:
+| 142|    |-	bool m_tags_update_request;
+| 143|    |-	bool m_albums_update_request;
+| 144|    |-	bool m_songs_update_request;
+| 145|    |-
+| 146|    |-	boost::posix_time::ptime m_timer;
+| 147|    |-
+| 148|    |-	const int m_window_timeout;
+| 149|    |-	const boost::posix_time::time_duration m_fetching_delay;
+| 150|    |-
+| 151|    |-	Regex::Filter<PrimaryTag> m_tags_search_predicate;
+| 152|    |-	Regex::ItemFilter<AlbumEntry> m_albums_search_predicate;
+| 153|    |-	Regex::Filter<MPD::Song> m_songs_search_predicate;
+|    |  39|+    MediaLibrary ();
+|    |  40|+
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|    |  47|+
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::MediaLibrary;
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    virtual void
+|    |  60|+    refresh ()
+|    |  61|+        override;
+|    |  62|+    virtual void
+|    |  63|+    update ()
+|    |  64|+        override;
+|    |  65|+
+|    |  66|+    virtual int
+|    |  67|+    windowTimeout ()
+|    |  68|+        override;
+|    |  69|+
+|    |  70|+    virtual void
+|    |  71|+    mouseButtonPressed (MEVENT me)
+|    |  72|+        override;
+|    |  73|+
+|    |  74|+    virtual bool
+|    |  75|+    isLockable ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return true;
+|    |  79|+    }
+|    |  80|+    virtual bool
+|    |  81|+    isMergable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|    |  86|+
+|    |  87|+    // Searchable implementation
+|    |  88|+    virtual bool
+|    |  89|+    allowsSearching ()
+|    |  90|+        override;
+|    |  91|+    virtual const
+|    |  92|+        std::string &
+|    |  93|+    searchConstraint ()
+|    |  94|+        override;
+|    |  95|+    virtual void
+|    |  96|+    setSearchConstraint (const std::string & constraint)
+|    |  97|+        override;
+|    |  98|+    virtual void
+|    |  99|+    clearSearchConstraint ()
+|    | 100|+        override;
+|    | 101|+    virtual bool
+|    | 102|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 103|+        override;
+|    | 104|+
+|    | 105|+    // Filterable implementation
+|    | 106|+    virtual bool
+|    | 107|+    allowsFiltering ()
+|    | 108|+        override;
+|    | 109|+    virtual
+|    | 110|+        std::string
+|    | 111|+    currentFilter ()
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    applyFilter (const std::string & filter)
+|    | 115|+        override;
+|    | 116|+
+|    | 117|+    // HasSongs implementation
+|    | 118|+    virtual bool
+|    | 119|+    itemAvailable ()
+|    | 120|+        override;
+|    | 121|+    virtual bool
+|    | 122|+    addItemToPlaylist (bool play)
+|    | 123|+        override;
+|    | 124|+    virtual
+|    | 125|+        std::vector <
+|    | 126|+        MPD::Song >
+|    | 127|+    getSelectedSongs ()
+|    | 128|+        override;
+|    | 129|+
+|    | 130|+    // HasColumns implementation
+|    | 131|+    virtual bool
+|    | 132|+    previousColumnAvailable ()
+|    | 133|+        override;
+|    | 134|+    virtual void
+|    | 135|+    previousColumn ()
+|    | 136|+        override;
+|    | 137|+
+|    | 138|+    virtual bool
+|    | 139|+    nextColumnAvailable ()
+|    | 140|+        override;
+|    | 141|+    virtual void
+|    | 142|+    nextColumn ()
+|    | 143|+        override;
+|    | 144|+
+|    | 145|+    // other members
+|    | 146|+    void
+|    | 147|+    updateTimer ();
+|    | 148|+    void
+|    | 149|+    toggleColumnsMode ();
+|    | 150|+    int
+|    | 151|+    columns ();
+|    | 152|+    void
+|    | 153|+    locateSong (const MPD::Song & s);
+|    | 154|+    void
+|    | 155|+    toggleSortMode ();
+|    | 156|+
+|    | 157|+    void
+|    | 158|+    requestTagsUpdate ()
+|    | 159|+    {
+|    | 160|+        m_tags_update_request = true;
+|    | 161|+    }
+|    | 162|+    void
+|    | 163|+    requestAlbumsUpdate ()
+|    | 164|+    {
+|    | 165|+        m_albums_update_request = true;
+|    | 166|+    }
+|    | 167|+    void
+|    | 168|+    requestSongsUpdate ()
+|    | 169|+    {
+|    | 170|+        m_songs_update_request = true;
+|    | 171|+    }
+|    | 172|+
+|    | 173|+    struct PrimaryTag
+|    | 174|+    {
+|    | 175|+        PrimaryTag ():
+|    | 176|+        m_mtime (0)
+|    | 177|+        {
+|    | 178|+        }
+|    | 179|+        PrimaryTag (std::string tag_, time_t mtime_):
+|    | 180|+        m_tag (std::move (tag_)),
+|    | 181|+        m_mtime (mtime_)
+|    | 182|+        {
+|    | 183|+        }
+|    | 184|+
+|    | 185|+        const
+|    | 186|+            std::string &
+|    | 187|+        tag () const
+|    | 188|+        {
+|    | 189|+            return
+|    | 190|+                m_tag;
+|    | 191|+        }
+|    | 192|+        time_t
+|    | 193|+        mtime () const
+|    | 194|+        {
+|    | 195|+            return
+|    | 196|+                m_mtime;
+|    | 197|+        }
+|    | 198|+
+|    | 199|+      private:
+|    | 200|+        std::string
+|    | 201|+            m_tag;
+|    | 202|+        time_t
+|    | 203|+            m_mtime;
+|    | 204|+    };
+|    | 205|+
+|    | 206|+    struct Album
+|    | 207|+    {
+|    | 208|+        Album (std::string tag_, std::string album_, std::string date_,
+|    | 209|+               time_t mtime_):
+|    | 210|+        m_tag (std::move (tag_)),
+|    | 211|+        m_album (std::move (album_)),
+|    | 212|+        m_date (std::move (date_)),
+|    | 213|+        m_mtime (mtime_)
+|    | 214|+        {
+|    | 215|+        }
+|    | 216|+
+|    | 217|+        const
+|    | 218|+            std::string &
+|    | 219|+        tag () const
+|    | 220|+        {
+|    | 221|+            return
+|    | 222|+                m_tag;
+|    | 223|+        }
+|    | 224|+        const
+|    | 225|+            std::string &
+|    | 226|+        album () const
+|    | 227|+        {
+|    | 228|+            return
+|    | 229|+                m_album;
+|    | 230|+        }
+|    | 231|+        const
+|    | 232|+            std::string &
+|    | 233|+        date () const
+|    | 234|+        {
+|    | 235|+            return
+|    | 236|+                m_date;
+|    | 237|+        }
+|    | 238|+        time_t
+|    | 239|+        mtime () const
+|    | 240|+        {
+|    | 241|+            return
+|    | 242|+                m_mtime;
+|    | 243|+        }
+|    | 244|+
+|    | 245|+      private:
+|    | 246|+        std::string
+|    | 247|+            m_tag;
+|    | 248|+        std::string m_album;
+|    | 249|+        std::string m_date;
+|    | 250|+        time_t
+|    | 251|+            m_mtime;
+|    | 252|+    };
+|    | 253|+
+|    | 254|+    struct AlbumEntry
+|    | 255|+    {
+|    | 256|+        AlbumEntry ():
+|    | 257|+        m_all_tracks_entry (false),
+|    | 258|+        m_album ("", "", "", 0)
+|    | 259|+        {
+|    | 260|+        }
+|    | 261|+        explicit
+|    | 262|+        AlbumEntry (Album album_):
+|    | 263|+        m_all_tracks_entry (false),
+|    | 264|+        m_album (album_)
+|    | 265|+        {
+|    | 266|+        }
+|    | 267|+
+|    | 268|+        const
+|    | 269|+            Album &
+|    | 270|+        entry () const
+|    | 271|+        {
+|    | 272|+            return
+|    | 273|+                m_album;
+|    | 274|+        }
+|    | 275|+        bool
+|    | 276|+        isAllTracksEntry () const
+|    | 277|+        {
+|    | 278|+            return
+|    | 279|+                m_all_tracks_entry;
+|    | 280|+        }
+|    | 281|+
+|    | 282|+        static AlbumEntry
+|    | 283|+        mkAllTracksEntry (std::string tag)
+|    | 284|+        {
+|    | 285|+            auto
+|    | 286|+                result = AlbumEntry (Album (tag, "", "", 0));
+|    | 287|+            result.m_all_tracks_entry = true;
+|    | 288|+            return result;
+|    | 289|+        }
+|    | 290|+
+|    | 291|+      private:
+|    | 292|+        bool m_all_tracks_entry;
+|    | 293|+        Album
+|    | 294|+            m_album;
+|    | 295|+    };
+|    | 296|+
+|    | 297|+    NC::Menu < PrimaryTag > Tags;
+|    | 298|+    NC::Menu < AlbumEntry > Albums;
+|    | 299|+    SongMenu
+|    | 300|+        Songs;
+|    | 301|+
+|    | 302|+  private:
+|    | 303|+    bool m_tags_update_request;
+|    | 304|+    bool
+|    | 305|+        m_albums_update_request;
+|    | 306|+    bool
+|    | 307|+        m_songs_update_request;
+|    | 308|+
+|    | 309|+    boost::posix_time::ptime m_timer;
+|    | 310|+
+|    | 311|+    const int
+|    | 312|+        m_window_timeout;
+|    | 313|+    const
+|    | 314|+        boost::posix_time::time_duration
+|    | 315|+        m_fetching_delay;
+|    | 316|+
+|    | 317|+    Regex::Filter < PrimaryTag > m_tags_search_predicate;
+|    | 318|+    Regex::ItemFilter < AlbumEntry > m_albums_search_predicate;
+|    | 319|+    Regex::Filter < MPD::Song > m_songs_search_predicate;
+| 154| 320| 
+| 155| 321| };
+| 156| 322| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+| 154| 154| 
+| 155| 155| };
+| 156| 156| 
+| 157|    |-extern MediaLibrary *myLibrary;
+|    | 157|+extern MediaLibrary *
+|    | 158|+    myLibrary;
+| 158| 159| 
+| 159| 160| #endif // NCMPCPP_MEDIA_LIBRARY_H
+| 160| 161| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+| 157| 157| extern MediaLibrary *myLibrary;
+| 158| 158| 
+| 159| 159| #endif // NCMPCPP_MEDIA_LIBRARY_H
+| 160|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/const.h
+|    |++++| /app/src/utility/const.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_CONST_H
+|  22|  22| #define NCMPCPP_UTILITY_CONST_H
+|  23|  23| 
+|  24|    |-enum class Const { Yes, No };
+|    |  24|+enum class Const
+|    |  25|+{ Yes, No };
+|  25|  26| 
+|  26|  27| #endif // NCMPCPP_UTILITY_CONST_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/runnable_item.h
+|    |++++| /app/src/runnable_item.h
+|  23|  23| 
+|  24|  24| #include <functional>
+|  25|  25| 
+|  26|    |-template <typename ItemT, typename FunctionT>
+|  27|    |-struct RunnableItem
+|    |  26|+template < typename ItemT, typename FunctionT > struct RunnableItem
+|  28|  27| {
+|  29|    |-	typedef ItemT Item;
+|  30|    |-	typedef std::function<FunctionT> Function;
+|  31|    |-	
+|  32|    |-	RunnableItem() { }
+|  33|    |-	template <typename Arg1, typename Arg2>
+|  34|    |-	RunnableItem(Arg1 &&opt, Arg2 &&f)
+|  35|    |-	: m_item(std::forward<Arg1>(opt)), m_f(std::forward<Arg2>(f)) { }
+|  36|    |-	
+|  37|    |-	template <typename... Args>
+|  38|    |-	typename Function::result_type run(Args&&... args) const
+|  39|    |-	{
+|  40|    |-		return m_f(std::forward<Args>(args)...);
+|  41|    |-	}
+|  42|    |-	
+|  43|    |-	Item &item() { return m_item; }
+|  44|    |-	const Item &item() const { return m_item; }
+|  45|    |-	
+|  46|    |-private:
+|  47|    |-	Item m_item;
+|  48|    |-	Function m_f;
+|    |  28|+    typedef ItemT Item;
+|    |  29|+    typedef std::function < FunctionT > Function;
+|    |  30|+
+|    |  31|+      RunnableItem ()
+|    |  32|+    {
+|    |  33|+    }
+|    |  34|+    template < typename Arg1, typename Arg2 >
+|    |  35|+        RunnableItem (Arg1 && opt, Arg2
+|    |  36|+                      && f):m_item (std::forward < Arg1 > (opt)),
+|    |  37|+        m_f (std::forward < Arg2 > (f))
+|    |  38|+    {
+|    |  39|+    }
+|    |  40|+
+|    |  41|+    template < typename...Args >
+|    |  42|+        typename Function::result_type run (Args &&...args) const
+|    |  43|+    {
+|    |  44|+        return m_f (std::forward < Args > (args) ...);
+|    |  45|+    }
+|    |  46|+
+|    |  47|+    Item & item ()
+|    |  48|+    {
+|    |  49|+        return m_item;
+|    |  50|+    }
+|    |  51|+    const Item & item () const
+|    |  52|+    {
+|    |  53|+        return m_item;
+|    |  54|+    }
+|    |  55|+
+|    |  56|+  private:
+|    |  57|+      Item m_item;
+|    |  58|+    Function m_f;
+|  49|  59| };
+|  50|  60| 
+|  51|  61| #endif // NCMPCPP_EXEC_ITEM_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lyrics.h
+|    |++++| /app/src/screens/lyrics.h
+|  33|  33| #include "song.h"
+|  34|  34| #include "utility/shared_resource.h"
+|  35|  35| 
+|  36|    |-struct Lyrics: Screen<NC::Scrollpad>, Tabbable
+|    |  36|+struct Lyrics:Screen <
+|    |  37|+    NC::Scrollpad >,
+|    |  38|+    Tabbable
+|  37|  39| {
+|  38|    |-	Lyrics();
+|  39|    |-	
+|  40|    |-	// Screen<NC::Scrollpad> implementation
+|  41|    |-	virtual void resize() override;
+|  42|    |-	virtual void switchTo() override;
+|  43|    |-	
+|  44|    |-	virtual std::wstring title() override;
+|  45|    |-	virtual ScreenType type() override { return ScreenType::Lyrics; }
+|  46|    |-	
+|  47|    |-	virtual void update() override;
+|  48|    |-	
+|  49|    |-	virtual bool isLockable() override { return true; }
+|  50|    |-	virtual bool isMergable() override { return true; }
+|    |  40|+    Lyrics ();
+|  51|  41| 
+|  52|    |-	// other members
+|  53|    |-	void fetch(const MPD::Song &s);
+|  54|    |-	void refetchCurrent();
+|  55|    |-	void edit();
+|  56|    |-	void toggleFetcher();
+|    |  42|+    // Screen<NC::Scrollpad> implementation
+|    |  43|+    virtual void
+|    |  44|+    resize ()
+|    |  45|+        override;
+|    |  46|+    virtual void
+|    |  47|+    switchTo ()
+|    |  48|+        override;
+|  57|  49| 
+|  58|    |-	void fetchInBackground(const MPD::Song &s, bool notify_);
+|  59|    |-	boost::optional<std::string> tryTakeConsumerMessage();
+|    |  50|+    virtual
+|    |  51|+        std::wstring
+|    |  52|+    title ()
+|    |  53|+        override;
+|    |  54|+    virtual ScreenType
+|    |  55|+    type ()
+|    |  56|+        override
+|    |  57|+    {
+|    |  58|+        return ScreenType::Lyrics;
+|    |  59|+    }
+|  60|  60| 
+|  61|    |-private:
+|  62|    |-	struct ConsumerState
+|  63|    |-	{
+|  64|    |-		struct Song
+|  65|    |-		{
+|  66|    |-			Song()
+|  67|    |-				: m_notify(false)
+|  68|    |-			{ }
+|    |  61|+    virtual void
+|    |  62|+    update ()
+|    |  63|+        override;
+|  69|  64| 
+|  70|    |-			Song(const MPD::Song &s, bool notify_)
+|  71|    |-				: m_song(s), m_notify(notify_)
+|  72|    |-			{ }
+|    |  65|+    virtual bool
+|    |  66|+    isLockable ()
+|    |  67|+        override
+|    |  68|+    {
+|    |  69|+        return true;
+|    |  70|+    }
+|    |  71|+    virtual bool
+|    |  72|+    isMergable ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+        return true;
+|    |  76|+    }
+|  73|  77| 
+|  74|    |-			const MPD::Song &song() const { return m_song; }
+|  75|    |-			bool notify() const { return m_notify; }
+|    |  78|+    // other members
+|    |  79|+    void
+|    |  80|+    fetch (const MPD::Song & s);
+|    |  81|+    void
+|    |  82|+    refetchCurrent ();
+|    |  83|+    void
+|    |  84|+    edit ();
+|    |  85|+    void
+|    |  86|+    toggleFetcher ();
+|  76|  87| 
+|  77|    |-		private:
+|  78|    |-			MPD::Song m_song;
+|  79|    |-			bool m_notify;
+|  80|    |-		};
+|    |  88|+    void
+|    |  89|+    fetchInBackground (const MPD::Song & s, bool notify_);
+|    |  90|+    boost::optional < std::string > tryTakeConsumerMessage ();
+|  81|  91| 
+|  82|    |-		ConsumerState()
+|  83|    |-			: running(false)
+|  84|    |-		{ }
+|    |  92|+  private:
+|    |  93|+    struct ConsumerState
+|    |  94|+    {
+|    |  95|+        struct Song
+|    |  96|+        {
+|    |  97|+            Song ():
+|    |  98|+            m_notify (false)
+|    |  99|+            {
+|    | 100|+            }
+|  85| 101| 
+|  86|    |-		bool running;
+|  87|    |-		std::queue<Song> songs;
+|  88|    |-		boost::optional<std::string> message;
+|  89|    |-	};
+|    | 102|+            Song (const MPD::Song & s, bool notify_):
+|    | 103|+            m_song (s),
+|    | 104|+            m_notify (notify_)
+|    | 105|+            {
+|    | 106|+            }
+|  90| 107| 
+|  91|    |-	void clearWorker();
+|  92|    |-	void stopDownload();
+|    | 108|+            const
+|    | 109|+                MPD::Song &
+|    | 110|+            song () const
+|    | 111|+            {
+|    | 112|+                return
+|    | 113|+                    m_song;
+|    | 114|+            }
+|    | 115|+            bool
+|    | 116|+            notify () const
+|    | 117|+            {
+|    | 118|+                return
+|    | 119|+                    m_notify;
+|    | 120|+            }
+|  93| 121| 
+|  94|    |-	bool m_refresh_window;
+|  95|    |-	size_t m_scroll_begin;
+|    | 122|+          private:
+|    | 123|+            MPD::Song
+|    | 124|+                m_song;
+|    | 125|+            bool
+|    | 126|+                m_notify;
+|    | 127|+        };
+|  96| 128| 
+|  97|    |-	std::shared_ptr<Shared<NC::Buffer>> m_shared_buffer;
+|  98|    |-	std::shared_ptr<std::atomic<bool>> m_download_stopper;
+|    | 129|+      ConsumerState ():running (false)
+|    | 130|+        {
+|    | 131|+        }
+|  99| 132| 
+| 100|    |-	MPD::Song m_song;
+| 101|    |-	LyricsFetcher *m_fetcher;
+| 102|    |-	boost::BOOST_THREAD_FUTURE<boost::optional<std::string>> m_worker;
+|    | 133|+        bool
+|    | 134|+            running;
+|    | 135|+        std::queue < Song > songs;
+|    | 136|+        boost::optional < std::string > message;
+|    | 137|+    };
+| 103| 138| 
+| 104|    |-	Shared<ConsumerState> m_consumer_state;
+|    | 139|+    void
+|    | 140|+    clearWorker ();
+|    | 141|+    void
+|    | 142|+    stopDownload ();
+|    | 143|+
+|    | 144|+    bool
+|    | 145|+        m_refresh_window;
+|    | 146|+    size_t
+|    | 147|+        m_scroll_begin;
+|    | 148|+
+|    | 149|+    std::shared_ptr < Shared < NC::Buffer >> m_shared_buffer;
+|    | 150|+    std::shared_ptr < std::atomic < bool >> m_download_stopper;
+|    | 151|+
+|    | 152|+    MPD::Song m_song;
+|    | 153|+    LyricsFetcher *
+|    | 154|+        m_fetcher;
+|    | 155|+    boost::BOOST_THREAD_FUTURE < boost::optional < std::string >> m_worker;
+|    | 156|+
+|    | 157|+    Shared < ConsumerState > m_consumer_state;
+| 105| 158| };
+| 106| 159| 
+| 107| 160| extern Lyrics *myLyrics;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lyrics.h
+|    |++++| /app/src/screens/lyrics.h
+| 104| 104| 	Shared<ConsumerState> m_consumer_state;
+| 105| 105| };
+| 106| 106| 
+| 107|    |-extern Lyrics *myLyrics;
+|    | 107|+extern Lyrics *
+|    | 108|+    myLyrics;
+| 108| 109| 
+| 109| 110| #endif // NCMPCPP_LYRICS_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mpdpp.h
+|    |++++| /app/src/mpdpp.h
+|  30|  30| #include <mpd/client.h>
+|  31|  31| #include "song.h"
+|  32|  32| 
+|  33|    |-namespace MPD {
+|  34|    |-
+|  35|    |-void checkConnectionErrors(mpd_connection *conn);
+|  36|    |-
+|  37|    |-enum PlayerState { psUnknown, psStop, psPlay, psPause };
+|  38|    |-enum ReplayGainMode { rgmOff, rgmTrack, rgmAlbum };
+|  39|    |-
+|  40|    |-struct ClientError: public std::exception
+|    |  33|+namespace MPD
+|  41|  34| {
+|  42|    |-	ClientError(mpd_error code_, std::string msg, bool clearable_)
+|  43|    |-	: m_code(code_), m_msg(msg), m_clearable(clearable_) { }
+|  44|    |-	virtual ~ClientError() noexcept { }
+|  45|    |-	
+|  46|    |-	virtual const char *what() const noexcept { return m_msg.c_str(); }
+|  47|    |-	mpd_error code() const { return m_code; }
+|  48|    |-	bool clearable() const { return m_clearable; }
+|  49|    |-	
+|  50|    |-private:
+|  51|    |-	mpd_error m_code;
+|  52|    |-	std::string m_msg;
+|  53|    |-	bool m_clearable;
+|  54|    |-};
+|  55|    |-
+|  56|    |-struct ServerError: public std::exception
+|  57|    |-{
+|  58|    |-	ServerError(mpd_server_error code_, std::string msg, bool clearable_)
+|  59|    |-	: m_code(code_), m_msg(msg), m_clearable(clearable_) { }
+|  60|    |-	virtual ~ServerError() noexcept { }
+|  61|    |-	
+|  62|    |-	virtual const char *what() const noexcept { return m_msg.c_str(); }
+|  63|    |-	mpd_server_error code() const { return m_code; }
+|  64|    |-	bool clearable() const { return m_clearable; }
+|  65|    |-	
+|  66|    |-private:
+|  67|    |-	mpd_server_error m_code;
+|  68|    |-	std::string m_msg;
+|  69|    |-	bool m_clearable;
+|  70|    |-};
+|  71|    |-
+|  72|    |-struct Statistics
+|  73|    |-{
+|  74|    |-	friend struct Connection;
+|  75|    |-	
+|  76|    |-	bool empty() const { return m_stats.get() == nullptr; }
+|  77|    |-	
+|  78|    |-	unsigned artists() const { return mpd_stats_get_number_of_artists(m_stats.get()); }
+|  79|    |-	unsigned albums() const { return mpd_stats_get_number_of_albums(m_stats.get()); }
+|  80|    |-	unsigned songs() const { return mpd_stats_get_number_of_songs(m_stats.get()); }
+|  81|    |-	unsigned long playTime() const { return mpd_stats_get_play_time(m_stats.get()); }
+|  82|    |-	unsigned long uptime() const { return mpd_stats_get_uptime(m_stats.get()); }
+|  83|    |-	unsigned long dbUpdateTime() const { return mpd_stats_get_db_update_time(m_stats.get()); }
+|  84|    |-	unsigned long dbPlayTime() const { return mpd_stats_get_db_play_time(m_stats.get()); }
+|  85|    |-	
+|  86|    |-private:
+|  87|    |-	Statistics(mpd_stats *stats) : m_stats(stats, mpd_stats_free) { }
+|  88|    |-	
+|  89|    |-	std::shared_ptr<mpd_stats> m_stats;
+|  90|    |-};
+|  91|    |-
+|  92|    |-struct Status
+|  93|    |-{
+|  94|    |-	friend struct Connection;
+|  95|    |-	
+|  96|    |-	Status() { }
+|  97|    |-	
+|  98|    |-	void clear() { m_status.reset(); }
+|  99|    |-	bool empty() const { return m_status.get() == nullptr; }
+| 100|    |-	
+| 101|    |-	int volume() const { return mpd_status_get_volume(m_status.get()); }
+| 102|    |-	bool repeat() const { return mpd_status_get_repeat(m_status.get()); }
+| 103|    |-	bool random() const { return mpd_status_get_random(m_status.get()); }
+| 104|    |-	bool single() const { return mpd_status_get_single(m_status.get()); }
+| 105|    |-	bool consume() const { return mpd_status_get_consume(m_status.get()); }
+| 106|    |-	unsigned playlistLength() const { return mpd_status_get_queue_length(m_status.get()); }
+| 107|    |-	unsigned playlistVersion() const { return mpd_status_get_queue_version(m_status.get()); }
+| 108|    |-	PlayerState playerState() const { return PlayerState(mpd_status_get_state(m_status.get())); }
+| 109|    |-	unsigned crossfade() const { return mpd_status_get_crossfade(m_status.get()); }
+| 110|    |-	int currentSongPosition() const { return mpd_status_get_song_pos(m_status.get()); }
+| 111|    |-	int currentSongID() const { return mpd_status_get_song_id(m_status.get()); }
+| 112|    |-	int nextSongPosition() const { return mpd_status_get_next_song_pos(m_status.get()); }
+| 113|    |-	int nextSongID() const { return mpd_status_get_next_song_id(m_status.get()); }
+| 114|    |-	unsigned elapsedTime() const { return mpd_status_get_elapsed_time(m_status.get()); }
+| 115|    |-	unsigned totalTime() const { return mpd_status_get_total_time(m_status.get()); }
+| 116|    |-	unsigned kbps() const { return mpd_status_get_kbit_rate(m_status.get()); }
+| 117|    |-	unsigned updateID() const { return mpd_status_get_update_id(m_status.get()); }
+| 118|    |-	const char *error() const { return mpd_status_get_error(m_status.get()); }
+| 119|    |-	
+| 120|    |-private:
+| 121|    |-	Status(mpd_status *status) : m_status(status, mpd_status_free) { }
+| 122|    |-	
+| 123|    |-	std::shared_ptr<mpd_status> m_status;
+| 124|    |-};
+| 125|    |-
+| 126|    |-struct Directory
+| 127|    |-{
+| 128|    |-	Directory()
+| 129|    |-	: m_last_modified(0)
+| 130|    |-	{ }
+| 131|    |-	Directory(const mpd_directory *directory)
+| 132|    |-	{
+| 133|    |-		assert(directory != nullptr);
+| 134|    |-		m_path = mpd_directory_get_path(directory);
+| 135|    |-		m_last_modified = mpd_directory_get_last_modified(directory);
+| 136|    |-	}
+| 137|    |-	Directory(std::string path_, time_t last_modified = 0)
+| 138|    |-	: m_path(std::move(path_))
+| 139|    |-	, m_last_modified(last_modified)
+| 140|    |-	{ }
+| 141|    |-
+| 142|    |-	bool operator==(const Directory &rhs) const
+| 143|    |-	{
+| 144|    |-		return m_path == rhs.m_path
+| 145|    |-		    && m_last_modified == rhs.m_last_modified;
+| 146|    |-	}
+| 147|    |-	bool operator!=(const Directory &rhs) const
+| 148|    |-	{
+| 149|    |-		return !(*this == rhs);
+| 150|    |-	}
+| 151|    |-
+| 152|    |-	const std::string &path() const
+| 153|    |-	{
+| 154|    |-		return m_path;
+| 155|    |-	}
+| 156|    |-	time_t lastModified() const
+| 157|    |-	{
+| 158|    |-		return m_last_modified;
+| 159|    |-	}
+| 160|    |-
+| 161|    |-private:
+| 162|    |-	std::string m_path;
+| 163|    |-	time_t m_last_modified;
+| 164|    |-};
+| 165|    |-
+| 166|    |-struct Playlist
+| 167|    |-{
+| 168|    |-	Playlist()
+| 169|    |-	: m_last_modified(0)
+| 170|    |-	{ }
+| 171|    |-	Playlist(const mpd_playlist *playlist)
+| 172|    |-	{
+| 173|    |-		assert(playlist != nullptr);
+| 174|    |-		m_path = mpd_playlist_get_path(playlist);
+| 175|    |-		m_last_modified = mpd_playlist_get_last_modified(playlist);
+| 176|    |-	}
+| 177|    |-	Playlist(std::string path_, time_t last_modified = 0)
+| 178|    |-	: m_path(std::move(path_))
+| 179|    |-	, m_last_modified(last_modified)
+| 180|    |-	{
+| 181|    |-		if (m_path.empty())
+| 182|    |-			throw std::runtime_error("empty path");
+| 183|    |-	}
+| 184|    |-
+| 185|    |-	bool operator==(const Playlist &rhs) const
+| 186|    |-	{
+| 187|    |-		return m_path == rhs.m_path
+| 188|    |-		    && m_last_modified == rhs.m_last_modified;
+| 189|    |-	}
+| 190|    |-	bool operator!=(const Playlist &rhs) const
+| 191|    |-	{
+| 192|    |-		return !(*this == rhs);
+| 193|    |-	}
+| 194|    |-
+| 195|    |-	const std::string &path() const
+| 196|    |-	{
+| 197|    |-		return m_path;
+| 198|    |-	}
+| 199|    |-	time_t lastModified() const
+| 200|    |-	{
+| 201|    |-		return m_last_modified;
+| 202|    |-	}
+| 203|    |-
+| 204|    |-private:
+| 205|    |-	std::string m_path;
+| 206|    |-	time_t m_last_modified;
+| 207|    |-};
+| 208|    |-
+| 209|    |-struct Item
+| 210|    |-{
+| 211|    |-	enum class Type { Directory, Song, Playlist };
+| 212|    |-
+| 213|    |-	Item(mpd_entity *entity)
+| 214|    |-	{
+| 215|    |-		assert(entity != nullptr);
+| 216|    |-		switch (mpd_entity_get_type(entity))
+| 217|    |-		{
+| 218|    |-			case MPD_ENTITY_TYPE_DIRECTORY:
+| 219|    |-				m_type = Type::Directory;
+| 220|    |-				m_directory = Directory(mpd_entity_get_directory(entity));
+| 221|    |-				break;
+| 222|    |-			case MPD_ENTITY_TYPE_SONG:
+| 223|    |-				m_type = Type::Song;
+| 224|    |-				m_song = Song(mpd_song_dup(mpd_entity_get_song(entity)));
+| 225|    |-				break;
+| 226|    |-			case MPD_ENTITY_TYPE_PLAYLIST:
+| 227|    |-				m_type = Type::Playlist;
+| 228|    |-				m_playlist = Playlist(mpd_entity_get_playlist(entity));
+| 229|    |-				break;
+| 230|    |-			default:
+| 231|    |-				throw std::runtime_error("unknown mpd_entity type");
+| 232|    |-		}
+| 233|    |-		mpd_entity_free(entity);
+| 234|    |-	}
+| 235|    |-	Item(Directory directory_)
+| 236|    |-	: m_type(Type::Directory)
+| 237|    |-	, m_directory(std::move(directory_))
+| 238|    |-	{ }
+| 239|    |-	Item(Song song_)
+| 240|    |-	: m_type(Type::Song)
+| 241|    |-	, m_song(std::move(song_))
+| 242|    |-	{ }
+| 243|    |-	Item(Playlist playlist_)
+| 244|    |-	: m_type(Type::Playlist)
+| 245|    |-	, m_playlist(std::move(playlist_))
+| 246|    |-	{ }
+| 247|    |-
+| 248|    |-	bool operator==(const Item &rhs) const
+| 249|    |-	{
+| 250|    |-		return m_directory == rhs.m_directory
+| 251|    |-		    && m_song == rhs.m_song
+| 252|    |-		    && m_playlist == rhs.m_playlist;
+| 253|    |-	}
+| 254|    |-	bool operator!=(const Item &rhs) const
+| 255|    |-	{
+| 256|    |-		return !(*this == rhs);
+| 257|    |-	}
+| 258|    |-
+| 259|    |-	Type type() const
+| 260|    |-	{
+| 261|    |-		return m_type;
+| 262|    |-	}
+| 263|    |-
+| 264|    |-	Directory &directory()
+| 265|    |-	{
+| 266|    |-		return const_cast<Directory &>(
+| 267|    |-			static_cast<const Item &>(*this).directory());
+| 268|    |-	}
+| 269|    |-	Song &song()
+| 270|    |-	{
+| 271|    |-		return const_cast<Song &>(
+| 272|    |-			static_cast<const Item &>(*this).song());
+| 273|    |-	}
+| 274|    |-	Playlist &playlist()
+| 275|    |-	{
+| 276|    |-		return const_cast<Playlist &>(
+| 277|    |-			static_cast<const Item &>(*this).playlist());
+| 278|    |-	}
+| 279|    |-
+| 280|    |-	const Directory &directory() const
+| 281|    |-	{
+| 282|    |-		assert(m_type == Type::Directory);
+| 283|    |-		return m_directory;
+| 284|    |-	}
+| 285|    |-	const Song &song() const
+| 286|    |-	{
+| 287|    |-		assert(m_type == Type::Song);
+| 288|    |-		return m_song;
+| 289|    |-	}
+| 290|    |-	const Playlist &playlist() const
+| 291|    |-	{
+| 292|    |-		assert(m_type == Type::Playlist);
+| 293|    |-		return m_playlist;
+| 294|    |-	}
+| 295|    |-
+| 296|    |-private:
+| 297|    |-	Type m_type;
+| 298|    |-	Directory m_directory;
+| 299|    |-	Song m_song;
+| 300|    |-	Playlist m_playlist;
+| 301|    |-};
+| 302|    |-
+| 303|    |-struct Output
+| 304|    |-{
+| 305|    |-	Output() { }
+| 306|    |-	Output(mpd_output *output)
+| 307|    |-	: m_output(output, mpd_output_free)
+| 308|    |-	{ }
+| 309|    |-
+| 310|    |-	bool operator==(const Output &rhs) const
+| 311|    |-	{
+| 312|    |-		if (empty() && rhs.empty())
+| 313|    |-			return true;
+| 314|    |-		else if (!empty() && !rhs.empty())
+| 315|    |-			return id() == rhs.id()
+| 316|    |-			    && strcmp(name(), rhs.name()) == 0
+| 317|    |-			    && enabled() == rhs.enabled();
+| 318|    |-		else
+| 319|    |-			return false;
+| 320|    |-	}
+| 321|    |-	bool operator!=(const Output &rhs) const
+| 322|    |-	{
+| 323|    |-		return !(*this == rhs);
+| 324|    |-	}
+| 325|    |-
+| 326|    |-	unsigned id() const
+| 327|    |-	{
+| 328|    |-		assert(m_output.get() != nullptr);
+| 329|    |-		return mpd_output_get_id(m_output.get());
+| 330|    |-	}
+| 331|    |-	const char *name() const
+| 332|    |-	{
+| 333|    |-		assert(m_output.get() != nullptr);
+| 334|    |-		return mpd_output_get_name(m_output.get());
+| 335|    |-	}
+| 336|    |-	bool enabled() const
+| 337|    |-	{
+| 338|    |-		assert(m_output.get() != nullptr);
+| 339|    |-		return mpd_output_get_enabled(m_output.get());
+| 340|    |-	}
+| 341|    |-
+| 342|    |-	bool empty() const { return m_output.get() == nullptr; }
+| 343|    |-
+| 344|    |-private:
+| 345|    |-	std::shared_ptr<mpd_output> m_output;
+| 346|    |-};
+| 347|    |-
+| 348|    |-template <typename ObjectT>
+| 349|    |-struct Iterator: std::iterator<std::input_iterator_tag, ObjectT>
+| 350|    |-{
+| 351|    |-	// shared state of the iterator
+| 352|    |-	struct State
+| 353|    |-	{
+| 354|    |-		friend Iterator;
+| 355|    |-
+| 356|    |-		typedef std::function<bool(State &)> Fetcher;
+| 357|    |-
+| 358|    |-		State(mpd_connection *connection_, Fetcher fetcher)
+| 359|    |-		: m_connection(connection_)
+| 360|    |-		, m_fetcher(fetcher)
+| 361|    |-		{
+| 362|    |-			assert(m_connection != nullptr);
+| 363|    |-			assert(m_fetcher != nullptr);
+| 364|    |-		}
+| 365|    |-		~State()
+| 366|    |-		{
+| 367|    |-			mpd_response_finish(m_connection);
+| 368|    |-		}
+| 369|    |-
+| 370|    |-		mpd_connection *connection() const
+| 371|    |-		{
+| 372|    |-			return m_connection;
+| 373|    |-		}
+| 374|    |-
+| 375|    |-		void setObject(ObjectT object)
+| 376|    |-		{
+| 377|    |-			if (hasObject())
+| 378|    |-				*m_object = std::move(object);
+| 379|    |-			else
+| 380|    |-				m_object.reset(new ObjectT(std::move(object)));
+| 381|    |-		}
+| 382|    |-
+| 383|    |-	private:
+| 384|    |-		bool operator==(const State &rhs) const
+| 385|    |-		{
+| 386|    |-			return m_connection == rhs.m_connection
+| 387|    |-			    && m_object == m_object;
+| 388|    |-		}
+| 389|    |-		bool operator!=(const State &rhs) const
+| 390|    |-		{
+| 391|    |-			return !(*this == rhs);
+| 392|    |-		}
+| 393|    |-
+| 394|    |-		bool fetch()
+| 395|    |-		{
+| 396|    |-			return m_fetcher(*this);
+| 397|    |-		}
+| 398|    |-		ObjectT &getObject() const
+| 399|    |-		{
+| 400|    |-			return *m_object;
+| 401|    |-		}
+| 402|    |-		bool hasObject() const
+| 403|    |-		{
+| 404|    |-			return m_object.get() != nullptr;
+| 405|    |-		}
+| 406|    |-
+| 407|    |-		mpd_connection *m_connection;
+| 408|    |-		Fetcher m_fetcher;
+| 409|    |-		std::unique_ptr<ObjectT> m_object;
+| 410|    |-	};
+| 411|    |-
+| 412|    |-	Iterator()
+| 413|    |-	: m_state(nullptr)
+| 414|    |-	{ }
+| 415|    |-	Iterator(mpd_connection *connection, typename State::Fetcher fetcher)
+| 416|    |-	: m_state(std::make_shared<State>(connection, std::move(fetcher)))
+| 417|    |-	{
+| 418|    |-		// get the first element
+| 419|    |-		++*this;
+| 420|    |-	}
+| 421|    |-	~Iterator()
+| 422|    |-	{
+| 423|    |-		if (m_state)
+| 424|    |-			checkConnectionErrors(m_state->connection());
+| 425|    |-	}
+| 426|    |-
+| 427|    |-	void finish()
+| 428|    |-	{
+| 429|    |-		assert(m_state);
+| 430|    |-		// check errors and change the iterator into end iterator
+| 431|    |-		checkConnectionErrors(m_state->connection());
+| 432|    |-		m_state = nullptr;
+| 433|    |-	}
+| 434|    |-
+| 435|    |-	ObjectT &operator*() const
+| 436|    |-	{
+| 437|    |-		if (!m_state)
+| 438|    |-			throw std::runtime_error("no object associated with the iterator");
+| 439|    |-		assert(m_state->hasObject());
+| 440|    |-		return m_state->getObject();
+| 441|    |-	}
+| 442|    |-	ObjectT *operator->() const
+| 443|    |-	{
+| 444|    |-		return &**this;
+| 445|    |-	}
+| 446|    |-
+| 447|    |-	Iterator &operator++()
+| 448|    |-	{
+| 449|    |-		assert(m_state);
+| 450|    |-		if (!m_state->fetch())
+| 451|    |-			finish();
+| 452|    |-		return *this;
+| 453|    |-	}
+| 454|    |-	Iterator operator++(int)
+| 455|    |-	{
+| 456|    |-		Iterator it(*this);
+| 457|    |-		++*this;
+| 458|    |-		return it;
+| 459|    |-	}
+| 460|    |-
+| 461|    |-	bool operator==(const Iterator &rhs) const
+| 462|    |-	{
+| 463|    |-		return m_state == rhs.m_state;
+| 464|    |-	}
+| 465|    |-	bool operator!=(const Iterator &rhs) const
+| 466|    |-	{
+| 467|    |-		return !(*this == rhs);
+| 468|    |-	}
+| 469|    |-
+| 470|    |-private:
+| 471|    |-	std::shared_ptr<State> m_state;
+| 472|    |-};
+| 473|    |-
+| 474|    |-typedef Iterator<Directory> DirectoryIterator;
+| 475|    |-typedef Iterator<Item> ItemIterator;
+| 476|    |-typedef Iterator<Output> OutputIterator;
+| 477|    |-typedef Iterator<Playlist> PlaylistIterator;
+| 478|    |-typedef Iterator<Song> SongIterator;
+| 479|    |-typedef Iterator<std::string> StringIterator;
+| 480|    |-
+| 481|    |-struct Connection
+| 482|    |-{
+| 483|    |-	typedef std::function<void(int)> NoidleCallback;
+| 484|    |-
+| 485|    |-	Connection();
+| 486|    |-	
+| 487|    |-	void Connect();
+| 488|    |-	bool Connected() const;
+| 489|    |-	void Disconnect();
+| 490|    |-	
+| 491|    |-	const std::string &GetHostname() { return m_host; }
+| 492|    |-	int GetPort() { return m_port; }
+| 493|    |-	
+| 494|    |-	unsigned Version() const;
+| 495|    |-	
+| 496|    |-	int GetFD() const { return m_fd; }
+| 497|    |-	
+| 498|    |-	void SetHostname(const std::string &);
+| 499|    |-	void SetPort(int port) { m_port = port; }
+| 500|    |-	void SetTimeout(int timeout) { m_timeout = timeout; }
+| 501|    |-	void SetPassword(const std::string &password) { m_password = password; }
+| 502|    |-	void SendPassword();
+| 503|    |-	
+| 504|    |-	Statistics getStatistics();
+| 505|    |-	Status getStatus();
+| 506|    |-	
+| 507|    |-	void UpdateDirectory(const std::string &);
+| 508|    |-	
+| 509|    |-	void Play();
+| 510|    |-	void Play(int);
+| 511|    |-	void PlayID(int);
+| 512|    |-	void Pause(bool);
+| 513|    |-	void Toggle();
+| 514|    |-	void Stop();
+| 515|    |-	void Next();
+| 516|    |-	void Prev();
+| 517|    |-	void Move(unsigned int from, unsigned int to);
+| 518|    |-	void Swap(unsigned, unsigned);
+| 519|    |-	void Seek(unsigned int pos, unsigned int where);
+| 520|    |-	void Shuffle();
+| 521|    |-	void ShuffleRange(unsigned start, unsigned end);
+| 522|    |-	void ClearMainPlaylist();
+| 523|    |-	
+| 524|    |-	SongIterator GetPlaylistChanges(unsigned);
+| 525|    |-	
+| 526|    |-	Song GetCurrentSong();
+| 527|    |-	Song GetSong(const std::string &);
+| 528|    |-	SongIterator GetPlaylistContent(const std::string &name);
+| 529|    |-	SongIterator GetPlaylistContentNoInfo(const std::string &name);
+| 530|    |-	
+| 531|    |-	StringIterator GetSupportedExtensions();
+| 532|    |-	
+| 533|    |-	void SetRepeat(bool);
+| 534|    |-	void SetRandom(bool);
+| 535|    |-	void SetSingle(bool);
+| 536|    |-	void SetConsume(bool);
+| 537|    |-	void SetCrossfade(unsigned);
+| 538|    |-	void SetVolume(unsigned int vol);
+| 539|    |-	void ChangeVolume(int change);
+| 540|    |-
+| 541|    |-	std::string GetReplayGainMode();
+| 542|    |-	void SetReplayGainMode(ReplayGainMode);
+| 543|    |-	
+| 544|    |-	void SetPriority(const MPD::Song &s, int prio);
+| 545|    |-	
+| 546|    |-	int AddSong(const std::string &, int = -1); // returns id of added song
+| 547|    |-	int AddSong(const Song &, int = -1); // returns id of added song
+| 548|    |-	bool AddRandomTag(mpd_tag_type, size_t, std::mt19937 &rng);
+| 549|    |-	bool AddRandomSongs(size_t number, std::mt19937 &rng);
+| 550|    |-	void Add(const std::string &path);
+| 551|    |-	void Delete(unsigned int pos);
+| 552|    |-	void PlaylistDelete(const std::string &playlist, unsigned int pos);
+| 553|    |-	void StartCommandsList();
+| 554|    |-	void CommitCommandsList();
+| 555|    |-	
+| 556|    |-	void DeletePlaylist(const std::string &name);
+| 557|    |-	void LoadPlaylist(const std::string &name);
+| 558|    |-	void SavePlaylist(const std::string &);
+| 559|    |-	void ClearPlaylist(const std::string &playlist);
+| 560|    |-	void AddToPlaylist(const std::string &, const Song &);
+| 561|    |-	void AddToPlaylist(const std::string &, const std::string &);
+| 562|    |-	void PlaylistMove(const std::string &path, int from, int to);
+| 563|    |-	void Rename(const std::string &from, const std::string &to);
+| 564|    |-	
+| 565|    |-	void StartSearch(bool);
+| 566|    |-	void StartFieldSearch(mpd_tag_type);
+| 567|    |-	void AddSearch(mpd_tag_type item, const std::string &str) const;
+| 568|    |-	void AddSearchAny(const std::string &str) const;
+| 569|    |-	void AddSearchURI(const std::string &str) const;
+| 570|    |-	SongIterator CommitSearchSongs();
+| 571|    |-	
+| 572|    |-	PlaylistIterator GetPlaylists();
+| 573|    |-	StringIterator GetList(mpd_tag_type type);
+| 574|    |-	ItemIterator GetDirectory(const std::string &directory);
+| 575|    |-	SongIterator GetDirectoryRecursive(const std::string &directory);
+| 576|    |-	SongIterator GetSongs(const std::string &directory);
+| 577|    |-	DirectoryIterator GetDirectories(const std::string &directory);
+| 578|    |-	
+| 579|    |-	OutputIterator GetOutputs();
+| 580|    |-	void EnableOutput(int id);
+| 581|    |-	void DisableOutput(int id);
+| 582|    |-	
+| 583|    |-	StringIterator GetURLHandlers();
+| 584|    |-	StringIterator GetTagTypes();
+| 585|    |-	
+| 586|    |-	void idle();
+| 587|    |-	int noidle();
+| 588|    |-	void setNoidleCallback(NoidleCallback callback);
+| 589|    |-	
+| 590|    |-private:
+| 591|    |-	struct ConnectionDeleter {
+| 592|    |-		void operator()(mpd_connection *connection) {
+| 593|    |-			mpd_connection_free(connection);
+| 594|    |-		}
+| 595|    |-	};
+| 596|    |-
+| 597|    |-	void checkConnection() const;
+| 598|    |-	void prechecks();
+| 599|    |-	void prechecksNoCommandsList();
+| 600|    |-	void checkErrors() const;
+| 601|    |-
+| 602|    |-	NoidleCallback m_noidle_callback;
+| 603|    |-	std::unique_ptr<mpd_connection, ConnectionDeleter> m_connection;
+| 604|    |-	bool m_command_list_active;
+| 605|    |-	
+| 606|    |-	int m_fd;
+| 607|    |-	bool m_idle;
+| 608|    |-	
+| 609|    |-	std::string m_host;
+| 610|    |-	int m_port;
+| 611|    |-	int m_timeout;
+| 612|    |-	std::string m_password;
+| 613|    |-};
+|    |  35|+
+|    |  36|+    void checkConnectionErrors (mpd_connection * conn);
+|    |  37|+
+|    |  38|+    enum PlayerState
+|    |  39|+    { psUnknown, psStop, psPlay, psPause };
+|    |  40|+    enum ReplayGainMode
+|    |  41|+    { rgmOff, rgmTrack, rgmAlbum };
+|    |  42|+
+|    |  43|+    struct ClientError:public std::exception
+|    |  44|+    {
+|    |  45|+        ClientError (mpd_error code_, std::string msg,
+|    |  46|+                     bool clearable_):m_code (code_), m_msg (msg),
+|    |  47|+            m_clearable (clearable_)
+|    |  48|+        {
+|    |  49|+        }
+|    |  50|+        virtual ~ ClientError () noexcept
+|    |  51|+        {
+|    |  52|+        }
+|    |  53|+
+|    |  54|+        virtual const char *what () const noexcept
+|    |  55|+        {
+|    |  56|+            return m_msg.c_str ();
+|    |  57|+        }
+|    |  58|+        mpd_error code () const
+|    |  59|+        {
+|    |  60|+            return m_code;
+|    |  61|+        }
+|    |  62|+        bool clearable () const
+|    |  63|+        {
+|    |  64|+            return m_clearable;
+|    |  65|+        }
+|    |  66|+
+|    |  67|+      private:
+|    |  68|+          mpd_error m_code;
+|    |  69|+        std::string m_msg;
+|    |  70|+        bool m_clearable;
+|    |  71|+    };
+|    |  72|+
+|    |  73|+    struct ServerError:public std::exception
+|    |  74|+    {
+|    |  75|+        ServerError (mpd_server_error code_, std::string msg,
+|    |  76|+                     bool clearable_):m_code (code_), m_msg (msg),
+|    |  77|+            m_clearable (clearable_)
+|    |  78|+        {
+|    |  79|+        }
+|    |  80|+        virtual ~ ServerError () noexcept
+|    |  81|+        {
+|    |  82|+        }
+|    |  83|+
+|    |  84|+        virtual const char *what () const noexcept
+|    |  85|+        {
+|    |  86|+            return m_msg.c_str ();
+|    |  87|+        }
+|    |  88|+        mpd_server_error code () const
+|    |  89|+        {
+|    |  90|+            return m_code;
+|    |  91|+        }
+|    |  92|+        bool clearable () const
+|    |  93|+        {
+|    |  94|+            return m_clearable;
+|    |  95|+        }
+|    |  96|+
+|    |  97|+      private:
+|    |  98|+          mpd_server_error m_code;
+|    |  99|+        std::string m_msg;
+|    | 100|+        bool m_clearable;
+|    | 101|+    };
+|    | 102|+
+|    | 103|+    struct Statistics
+|    | 104|+    {
+|    | 105|+        friend struct Connection;
+|    | 106|+
+|    | 107|+        bool empty () const
+|    | 108|+        {
+|    | 109|+            return m_stats.get () == nullptr;
+|    | 110|+        }
+|    | 111|+
+|    | 112|+        unsigned artists () const
+|    | 113|+        {
+|    | 114|+            return mpd_stats_get_number_of_artists (m_stats.get ());
+|    | 115|+        }
+|    | 116|+        unsigned albums () const
+|    | 117|+        {
+|    | 118|+            return mpd_stats_get_number_of_albums (m_stats.get ());
+|    | 119|+        }
+|    | 120|+        unsigned songs () const
+|    | 121|+        {
+|    | 122|+            return mpd_stats_get_number_of_songs (m_stats.get ());
+|    | 123|+        }
+|    | 124|+        unsigned long playTime () const
+|    | 125|+        {
+|    | 126|+            return mpd_stats_get_play_time (m_stats.get ());
+|    | 127|+        }
+|    | 128|+        unsigned long uptime () const
+|    | 129|+        {
+|    | 130|+            return mpd_stats_get_uptime (m_stats.get ());
+|    | 131|+        }
+|    | 132|+        unsigned long dbUpdateTime () const
+|    | 133|+        {
+|    | 134|+            return mpd_stats_get_db_update_time (m_stats.get ());
+|    | 135|+        }
+|    | 136|+        unsigned long dbPlayTime () const
+|    | 137|+        {
+|    | 138|+            return mpd_stats_get_db_play_time (m_stats.get ());
+|    | 139|+        }
+|    | 140|+
+|    | 141|+      private:
+|    | 142|+          Statistics (mpd_stats * stats):m_stats (stats, mpd_stats_free)
+|    | 143|+        {
+|    | 144|+        }
+|    | 145|+
+|    | 146|+        std::shared_ptr < mpd_stats > m_stats;
+|    | 147|+    };
+|    | 148|+
+|    | 149|+    struct Status
+|    | 150|+    {
+|    | 151|+        friend struct Connection;
+|    | 152|+
+|    | 153|+          Status ()
+|    | 154|+        {
+|    | 155|+        }
+|    | 156|+
+|    | 157|+        void clear ()
+|    | 158|+        {
+|    | 159|+            m_status.reset ();
+|    | 160|+        }
+|    | 161|+        bool empty () const
+|    | 162|+        {
+|    | 163|+            return m_status.get () == nullptr;
+|    | 164|+        }
+|    | 165|+
+|    | 166|+        int volume () const
+|    | 167|+        {
+|    | 168|+            return mpd_status_get_volume (m_status.get ());
+|    | 169|+        }
+|    | 170|+        bool repeat () const
+|    | 171|+        {
+|    | 172|+            return mpd_status_get_repeat (m_status.get ());
+|    | 173|+        }
+|    | 174|+        bool random () const
+|    | 175|+        {
+|    | 176|+            return mpd_status_get_random (m_status.get ());
+|    | 177|+        }
+|    | 178|+        bool single () const
+|    | 179|+        {
+|    | 180|+            return mpd_status_get_single (m_status.get ());
+|    | 181|+        }
+|    | 182|+        bool consume () const
+|    | 183|+        {
+|    | 184|+            return mpd_status_get_consume (m_status.get ());
+|    | 185|+        }
+|    | 186|+        unsigned playlistLength () const
+|    | 187|+        {
+|    | 188|+            return mpd_status_get_queue_length (m_status.get ());
+|    | 189|+        }
+|    | 190|+        unsigned playlistVersion () const
+|    | 191|+        {
+|    | 192|+            return mpd_status_get_queue_version (m_status.get ());
+|    | 193|+        }
+|    | 194|+        PlayerState playerState () const
+|    | 195|+        {
+|    | 196|+            return PlayerState (mpd_status_get_state (m_status.get ()));
+|    | 197|+        }
+|    | 198|+        unsigned crossfade () const
+|    | 199|+        {
+|    | 200|+            return mpd_status_get_crossfade (m_status.get ());
+|    | 201|+        }
+|    | 202|+        int currentSongPosition () const
+|    | 203|+        {
+|    | 204|+            return mpd_status_get_song_pos (m_status.get ());
+|    | 205|+        }
+|    | 206|+        int currentSongID () const
+|    | 207|+        {
+|    | 208|+            return mpd_status_get_song_id (m_status.get ());
+|    | 209|+        }
+|    | 210|+        int nextSongPosition () const
+|    | 211|+        {
+|    | 212|+            return mpd_status_get_next_song_pos (m_status.get ());
+|    | 213|+        }
+|    | 214|+        int nextSongID () const
+|    | 215|+        {
+|    | 216|+            return mpd_status_get_next_song_id (m_status.get ());
+|    | 217|+        }
+|    | 218|+        unsigned elapsedTime () const
+|    | 219|+        {
+|    | 220|+            return mpd_status_get_elapsed_time (m_status.get ());
+|    | 221|+        }
+|    | 222|+        unsigned totalTime () const
+|    | 223|+        {
+|    | 224|+            return mpd_status_get_total_time (m_status.get ());
+|    | 225|+        }
+|    | 226|+        unsigned kbps () const
+|    | 227|+        {
+|    | 228|+            return mpd_status_get_kbit_rate (m_status.get ());
+|    | 229|+        }
+|    | 230|+        unsigned updateID () const
+|    | 231|+        {
+|    | 232|+            return mpd_status_get_update_id (m_status.get ());
+|    | 233|+        }
+|    | 234|+        const char *error () const
+|    | 235|+        {
+|    | 236|+            return mpd_status_get_error (m_status.get ());
+|    | 237|+        }
+|    | 238|+
+|    | 239|+      private:
+|    | 240|+          Status (mpd_status * status):m_status (status, mpd_status_free)
+|    | 241|+        {
+|    | 242|+        }
+|    | 243|+
+|    | 244|+        std::shared_ptr < mpd_status > m_status;
+|    | 245|+    };
+|    | 246|+
+|    | 247|+    struct Directory
+|    | 248|+    {
+|    | 249|+        Directory ():m_last_modified (0)
+|    | 250|+        {
+|    | 251|+        }
+|    | 252|+        Directory (const mpd_directory * directory)
+|    | 253|+        {
+|    | 254|+            assert (directory != nullptr);
+|    | 255|+            m_path = mpd_directory_get_path (directory);
+|    | 256|+            m_last_modified = mpd_directory_get_last_modified (directory);
+|    | 257|+        }
+|    | 258|+      Directory (std::string path_, time_t last_modified = 0):m_path (std::move (path_)),
+|    | 259|+            m_last_modified
+|    | 260|+            (last_modified)
+|    | 261|+        {
+|    | 262|+        }
+|    | 263|+
+|    | 264|+        bool operator== (const Directory & rhs) const
+|    | 265|+        {
+|    | 266|+            return m_path == rhs.m_path
+|    | 267|+                && m_last_modified == rhs.m_last_modified;
+|    | 268|+        }
+|    | 269|+        bool operator!= (const Directory & rhs) const
+|    | 270|+        {
+|    | 271|+            return !(*this == rhs);
+|    | 272|+        }
+|    | 273|+
+|    | 274|+        const std::string & path () const
+|    | 275|+        {
+|    | 276|+            return m_path;
+|    | 277|+        }
+|    | 278|+        time_t lastModified () const
+|    | 279|+        {
+|    | 280|+            return m_last_modified;
+|    | 281|+        }
+|    | 282|+
+|    | 283|+      private:
+|    | 284|+          std::string m_path;
+|    | 285|+        time_t m_last_modified;
+|    | 286|+    };
+|    | 287|+
+|    | 288|+    struct Playlist
+|    | 289|+    {
+|    | 290|+        Playlist ():m_last_modified (0)
+|    | 291|+        {
+|    | 292|+        }
+|    | 293|+        Playlist (const mpd_playlist * playlist)
+|    | 294|+        {
+|    | 295|+            assert (playlist != nullptr);
+|    | 296|+            m_path = mpd_playlist_get_path (playlist);
+|    | 297|+            m_last_modified = mpd_playlist_get_last_modified (playlist);
+|    | 298|+        }
+|    | 299|+      Playlist (std::string path_, time_t last_modified = 0):m_path (std::move (path_)),
+|    | 300|+            m_last_modified
+|    | 301|+            (last_modified)
+|    | 302|+        {
+|    | 303|+            if (m_path.empty ())
+|    | 304|+                throw std::runtime_error ("empty path");
+|    | 305|+        }
+|    | 306|+
+|    | 307|+        bool operator== (const Playlist & rhs) const
+|    | 308|+        {
+|    | 309|+            return m_path == rhs.m_path
+|    | 310|+                && m_last_modified == rhs.m_last_modified;
+|    | 311|+        }
+|    | 312|+        bool operator!= (const Playlist & rhs) const
+|    | 313|+        {
+|    | 314|+            return !(*this == rhs);
+|    | 315|+        }
+|    | 316|+
+|    | 317|+        const std::string & path () const
+|    | 318|+        {
+|    | 319|+            return m_path;
+|    | 320|+        }
+|    | 321|+        time_t lastModified () const
+|    | 322|+        {
+|    | 323|+            return m_last_modified;
+|    | 324|+        }
+|    | 325|+
+|    | 326|+      private:
+|    | 327|+          std::string m_path;
+|    | 328|+        time_t m_last_modified;
+|    | 329|+    };
+|    | 330|+
+|    | 331|+    struct Item
+|    | 332|+    {
+|    | 333|+        enum class Type
+|    | 334|+        { Directory, Song, Playlist };
+|    | 335|+
+|    | 336|+          Item (mpd_entity * entity)
+|    | 337|+        {
+|    | 338|+            assert (entity != nullptr);
+|    | 339|+            switch (mpd_entity_get_type (entity))
+|    | 340|+              {
+|    | 341|+              case MPD_ENTITY_TYPE_DIRECTORY:
+|    | 342|+                  m_type = Type::Directory;
+|    | 343|+                  m_directory = Directory (mpd_entity_get_directory (entity));
+|    | 344|+                  break;
+|    | 345|+                  case MPD_ENTITY_TYPE_SONG:m_type = Type::Song;
+|    | 346|+                  m_song = Song (mpd_song_dup (mpd_entity_get_song (entity)));
+|    | 347|+                  break;
+|    | 348|+                  case MPD_ENTITY_TYPE_PLAYLIST:m_type = Type::Playlist;
+|    | 349|+                  m_playlist = Playlist (mpd_entity_get_playlist (entity));
+|    | 350|+                  break;
+|    | 351|+                  default:throw std::runtime_error ("unknown mpd_entity type");
+|    | 352|+              }
+|    | 353|+            mpd_entity_free (entity);
+|    | 354|+        }
+|    | 355|+      Item (Directory directory_):m_type (Type::Directory),
+|    | 356|+            m_directory (std::
+|    | 357|+                         move (directory_))
+|    | 358|+        {
+|    | 359|+        }
+|    | 360|+      Item (Song song_):m_type (Type::Song),
+|    | 361|+            m_song (std::move (song_))
+|    | 362|+        {
+|    | 363|+        }
+|    | 364|+      Item (Playlist playlist_):m_type (Type::Playlist),
+|    | 365|+            m_playlist (std::move (playlist_))
+|    | 366|+        {
+|    | 367|+        }
+|    | 368|+
+|    | 369|+        bool operator== (const Item & rhs) const
+|    | 370|+        {
+|    | 371|+            return m_directory == rhs.m_directory
+|    | 372|+                && m_song == rhs.m_song && m_playlist == rhs.m_playlist;
+|    | 373|+        }
+|    | 374|+        bool operator!= (const Item & rhs) const
+|    | 375|+        {
+|    | 376|+            return !(*this == rhs);
+|    | 377|+        }
+|    | 378|+
+|    | 379|+        Type type () const
+|    | 380|+        {
+|    | 381|+            return m_type;
+|    | 382|+        }
+|    | 383|+
+|    | 384|+        Directory & directory ()
+|    | 385|+        {
+|    | 386|+            return const_cast < Directory & >(static_cast <
+|    | 387|+                                              const Item & >(*this).
+|    | 388|+                                              directory ());
+|    | 389|+        }
+|    | 390|+        Song & song ()
+|    | 391|+        {
+|    | 392|+            return const_cast < Song & >(static_cast <
+|    | 393|+                                         const Item & >(*this).song ());
+|    | 394|+        }
+|    | 395|+        Playlist & playlist ()
+|    | 396|+        {
+|    | 397|+            return const_cast < Playlist & >(static_cast <
+|    | 398|+                                             const Item & >(*this).
+|    | 399|+                                             playlist ());
+|    | 400|+        }
+|    | 401|+
+|    | 402|+        const Directory & directory () const
+|    | 403|+        {
+|    | 404|+            assert (m_type == Type::Directory);
+|    | 405|+            return m_directory;
+|    | 406|+        }
+|    | 407|+        const Song & song () const
+|    | 408|+        {
+|    | 409|+            assert (m_type == Type::Song);
+|    | 410|+            return m_song;
+|    | 411|+        }
+|    | 412|+        const Playlist & playlist () const
+|    | 413|+        {
+|    | 414|+            assert (m_type == Type::Playlist);
+|    | 415|+            return m_playlist;
+|    | 416|+        }
+|    | 417|+
+|    | 418|+      private:
+|    | 419|+          Type m_type;
+|    | 420|+        Directory m_directory;
+|    | 421|+        Song m_song;
+|    | 422|+        Playlist m_playlist;
+|    | 423|+    };
+|    | 424|+
+|    | 425|+    struct Output
+|    | 426|+    {
+|    | 427|+        Output ()
+|    | 428|+        {
+|    | 429|+        }
+|    | 430|+        Output (mpd_output * output):m_output (output, mpd_output_free)
+|    | 431|+        {
+|    | 432|+        }
+|    | 433|+
+|    | 434|+        bool operator== (const Output & rhs) const
+|    | 435|+        {
+|    | 436|+            if (empty () && rhs.empty ())
+|    | 437|+                return true;
+|    | 438|+            else if (!empty () && !rhs.empty ())
+|    | 439|+                return id () == rhs.id ()
+|    | 440|+                    && strcmp (name (), rhs.name ()) == 0
+|    | 441|+                    && enabled () == rhs.enabled ();
+|    | 442|+            else
+|    | 443|+                return false;
+|    | 444|+        }
+|    | 445|+        bool operator!= (const Output & rhs) const
+|    | 446|+        {
+|    | 447|+            return !(*this == rhs);
+|    | 448|+        }
+|    | 449|+
+|    | 450|+        unsigned id () const
+|    | 451|+        {
+|    | 452|+            assert (m_output.get () != nullptr);
+|    | 453|+            return mpd_output_get_id (m_output.get ());
+|    | 454|+        }
+|    | 455|+        const char *name () const
+|    | 456|+        {
+|    | 457|+            assert (m_output.get () != nullptr);
+|    | 458|+            return mpd_output_get_name (m_output.get ());
+|    | 459|+        }
+|    | 460|+        bool enabled () const
+|    | 461|+        {
+|    | 462|+            assert (m_output.get () != nullptr);
+|    | 463|+            return mpd_output_get_enabled (m_output.get ());
+|    | 464|+        }
+|    | 465|+
+|    | 466|+        bool empty () const
+|    | 467|+        {
+|    | 468|+            return m_output.get () == nullptr;
+|    | 469|+        }
+|    | 470|+
+|    | 471|+      private:
+|    | 472|+          std::shared_ptr < mpd_output > m_output;
+|    | 473|+    };
+|    | 474|+
+|    | 475|+    template < typename ObjectT >
+|    | 476|+        struct Iterator:std::iterator < std::input_iterator_tag, ObjectT >
+|    | 477|+    {
+|    | 478|+        // shared state of the iterator
+|    | 479|+        struct State
+|    | 480|+        {
+|    | 481|+            friend Iterator;
+|    | 482|+
+|    | 483|+            typedef std::function < bool (State &) > Fetcher;
+|    | 484|+
+|    | 485|+              State (mpd_connection * connection_,
+|    | 486|+                     Fetcher fetcher):m_connection (connection_),
+|    | 487|+                m_fetcher (fetcher)
+|    | 488|+            {
+|    | 489|+                assert (m_connection != nullptr);
+|    | 490|+                assert (m_fetcher != nullptr);
+|    | 491|+            }
+|    | 492|+             ~State ()
+|    | 493|+            {
+|    | 494|+                mpd_response_finish (m_connection);
+|    | 495|+            }
+|    | 496|+
+|    | 497|+            mpd_connection *connection () const
+|    | 498|+            {
+|    | 499|+                return m_connection;
+|    | 500|+            }
+|    | 501|+
+|    | 502|+            void setObject (ObjectT object)
+|    | 503|+            {
+|    | 504|+                if (hasObject ())
+|    | 505|+                    *m_object = std::move (object);
+|    | 506|+                else
+|    | 507|+                    m_object.reset (new ObjectT (std::move (object)));
+|    | 508|+            }
+|    | 509|+
+|    | 510|+          private:
+|    | 511|+            bool operator== (const State & rhs) const
+|    | 512|+            {
+|    | 513|+                return m_connection == rhs.m_connection
+|    | 514|+                    && m_object == m_object;
+|    | 515|+            }
+|    | 516|+            bool operator!= (const State & rhs) const
+|    | 517|+            {
+|    | 518|+                return !(*this == rhs);
+|    | 519|+            }
+|    | 520|+
+|    | 521|+            bool fetch ()
+|    | 522|+            {
+|    | 523|+                return m_fetcher (*this);
+|    | 524|+            }
+|    | 525|+            ObjectT & getObject ()const
+|    | 526|+            {
+|    | 527|+                return *m_object;
+|    | 528|+            }
+|    | 529|+            bool hasObject () const
+|    | 530|+            {
+|    | 531|+                return m_object.get () != nullptr;
+|    | 532|+            }
+|    | 533|+
+|    | 534|+            mpd_connection *m_connection;
+|    | 535|+            Fetcher m_fetcher;
+|    | 536|+            std::unique_ptr < ObjectT > m_object;
+|    | 537|+        };
+|    | 538|+
+|    | 539|+      Iterator ():m_state (nullptr)
+|    | 540|+        {
+|    | 541|+        }
+|    | 542|+      Iterator (mpd_connection * connection, typename State::Fetcher fetcher):m_state (std::make_shared < State >
+|    | 543|+                 (connection,
+|    | 544|+                  std::move (fetcher)))
+|    | 545|+        {
+|    | 546|+            // get the first element
+|    | 547|+            ++*this;
+|    | 548|+        }
+|    | 549|+        ~Iterator ()
+|    | 550|+        {
+|    | 551|+            if (m_state)
+|    | 552|+                checkConnectionErrors (m_state->connection ());
+|    | 553|+        }
+|    | 554|+
+|    | 555|+        void finish ()
+|    | 556|+        {
+|    | 557|+            assert (m_state);
+|    | 558|+            // check errors and change the iterator into end iterator
+|    | 559|+            checkConnectionErrors (m_state->connection ());
+|    | 560|+            m_state = nullptr;
+|    | 561|+        }
+|    | 562|+
+|    | 563|+        ObjectT & operator* ()const
+|    | 564|+        {
+|    | 565|+            if (!m_state)
+|    | 566|+                throw std::
+|    | 567|+                    runtime_error ("no object associated with the iterator");
+|    | 568|+              assert (m_state->hasObject ());
+|    | 569|+              return m_state->getObject ();
+|    | 570|+        }
+|    | 571|+        ObjectT *operator-> () const
+|    | 572|+        {
+|    | 573|+            return &**this;
+|    | 574|+        }
+|    | 575|+
+|    | 576|+        Iterator & operator++ ()
+|    | 577|+        {
+|    | 578|+            assert (m_state);
+|    | 579|+            if (!m_state->fetch ())
+|    | 580|+                finish ();
+|    | 581|+            return *this;
+|    | 582|+        }
+|    | 583|+        Iterator operator++ (int)
+|    | 584|+        {
+|    | 585|+            Iterator it (*this);
+|    | 586|+            ++*this;
+|    | 587|+            return it;
+|    | 588|+        }
+|    | 589|+
+|    | 590|+        bool operator== (const Iterator & rhs) const
+|    | 591|+        {
+|    | 592|+            return m_state == rhs.m_state;
+|    | 593|+        }
+|    | 594|+        bool operator!= (const Iterator & rhs) const
+|    | 595|+        {
+|    | 596|+            return !(*this == rhs);
+|    | 597|+        }
+|    | 598|+
+|    | 599|+      private:
+|    | 600|+          std::shared_ptr < State > m_state;
+|    | 601|+    };
+|    | 602|+
+|    | 603|+    typedef Iterator < Directory > DirectoryIterator;
+|    | 604|+    typedef Iterator < Item > ItemIterator;
+|    | 605|+    typedef Iterator < Output > OutputIterator;
+|    | 606|+    typedef Iterator < Playlist > PlaylistIterator;
+|    | 607|+    typedef Iterator < Song > SongIterator;
+|    | 608|+    typedef Iterator < std::string > StringIterator;
+|    | 609|+
+|    | 610|+    struct Connection
+|    | 611|+    {
+|    | 612|+        typedef std::function < void (int) > NoidleCallback;
+|    | 613|+
+|    | 614|+          Connection ();
+|    | 615|+
+|    | 616|+        void Connect ();
+|    | 617|+        bool Connected () const;
+|    | 618|+        void Disconnect ();
+|    | 619|+
+|    | 620|+        const std::string & GetHostname ()
+|    | 621|+        {
+|    | 622|+            return m_host;
+|    | 623|+        }
+|    | 624|+        int GetPort ()
+|    | 625|+        {
+|    | 626|+            return m_port;
+|    | 627|+        }
+|    | 628|+
+|    | 629|+        unsigned Version () const;
+|    | 630|+
+|    | 631|+        int GetFD () const
+|    | 632|+        {
+|    | 633|+            return m_fd;
+|    | 634|+        }
+|    | 635|+
+|    | 636|+        void SetHostname (const std::string &);
+|    | 637|+        void SetPort (int port)
+|    | 638|+        {
+|    | 639|+            m_port = port;
+|    | 640|+        }
+|    | 641|+        void SetTimeout (int timeout)
+|    | 642|+        {
+|    | 643|+            m_timeout = timeout;
+|    | 644|+        }
+|    | 645|+        void SetPassword (const std::string & password)
+|    | 646|+        {
+|    | 647|+            m_password = password;
+|    | 648|+        }
+|    | 649|+        void SendPassword ();
+|    | 650|+
+|    | 651|+        Statistics getStatistics ();
+|    | 652|+        Status getStatus ();
+|    | 653|+
+|    | 654|+        void UpdateDirectory (const std::string &);
+|    | 655|+
+|    | 656|+        void Play ();
+|    | 657|+        void Play (int);
+|    | 658|+        void PlayID (int);
+|    | 659|+        void Pause (bool);
+|    | 660|+        void Toggle ();
+|    | 661|+        void Stop ();
+|    | 662|+        void Next ();
+|    | 663|+        void Prev ();
+|    | 664|+        void Move (unsigned int from, unsigned int to);
+|    | 665|+        void Swap (unsigned, unsigned);
+|    | 666|+        void Seek (unsigned int pos, unsigned int where);
+|    | 667|+        void Shuffle ();
+|    | 668|+        void ShuffleRange (unsigned start, unsigned end);
+|    | 669|+        void ClearMainPlaylist ();
+|    | 670|+
+|    | 671|+        SongIterator GetPlaylistChanges (unsigned);
+|    | 672|+
+|    | 673|+        Song GetCurrentSong ();
+|    | 674|+        Song GetSong (const std::string &);
+|    | 675|+        SongIterator GetPlaylistContent (const std::string & name);
+|    | 676|+        SongIterator GetPlaylistContentNoInfo (const std::string & name);
+|    | 677|+
+|    | 678|+        StringIterator GetSupportedExtensions ();
+|    | 679|+
+|    | 680|+        void SetRepeat (bool);
+|    | 681|+        void SetRandom (bool);
+|    | 682|+        void SetSingle (bool);
+|    | 683|+        void SetConsume (bool);
+|    | 684|+        void SetCrossfade (unsigned);
+|    | 685|+        void SetVolume (unsigned int vol);
+|    | 686|+        void ChangeVolume (int change);
+|    | 687|+
+|    | 688|+        std::string GetReplayGainMode ();
+|    | 689|+        void SetReplayGainMode (ReplayGainMode);
+|    | 690|+
+|    | 691|+        void SetPriority (const MPD::Song & s, int prio);
+|    | 692|+
+|    | 693|+        int AddSong (const std::string &, int = -1);    // returns id of added song
+|    | 694|+        int AddSong (const Song &, int = -1);   // returns id of added song
+|    | 695|+        bool AddRandomTag (mpd_tag_type, size_t, std::mt19937 & rng);
+|    | 696|+        bool AddRandomSongs (size_t number, std::mt19937 & rng);
+|    | 697|+        void Add (const std::string & path);
+|    | 698|+        void Delete (unsigned int pos);
+|    | 699|+        void PlaylistDelete (const std::string & playlist, unsigned int pos);
+|    | 700|+        void StartCommandsList ();
+|    | 701|+        void CommitCommandsList ();
+|    | 702|+
+|    | 703|+        void DeletePlaylist (const std::string & name);
+|    | 704|+        void LoadPlaylist (const std::string & name);
+|    | 705|+        void SavePlaylist (const std::string &);
+|    | 706|+        void ClearPlaylist (const std::string & playlist);
+|    | 707|+        void AddToPlaylist (const std::string &, const Song &);
+|    | 708|+        void AddToPlaylist (const std::string &, const std::string &);
+|    | 709|+        void PlaylistMove (const std::string & path, int from, int to);
+|    | 710|+        void Rename (const std::string & from, const std::string & to);
+|    | 711|+
+|    | 712|+        void StartSearch (bool);
+|    | 713|+        void StartFieldSearch (mpd_tag_type);
+|    | 714|+        void AddSearch (mpd_tag_type item, const std::string & str) const;
+|    | 715|+        void AddSearchAny (const std::string & str) const;
+|    | 716|+        void AddSearchURI (const std::string & str) const;
+|    | 717|+        SongIterator CommitSearchSongs ();
+|    | 718|+
+|    | 719|+        PlaylistIterator GetPlaylists ();
+|    | 720|+        StringIterator GetList (mpd_tag_type type);
+|    | 721|+        ItemIterator GetDirectory (const std::string & directory);
+|    | 722|+        SongIterator GetDirectoryRecursive (const std::string & directory);
+|    | 723|+        SongIterator GetSongs (const std::string & directory);
+|    | 724|+        DirectoryIterator GetDirectories (const std::string & directory);
+|    | 725|+
+|    | 726|+        OutputIterator GetOutputs ();
+|    | 727|+        void EnableOutput (int id);
+|    | 728|+        void DisableOutput (int id);
+|    | 729|+
+|    | 730|+        StringIterator GetURLHandlers ();
+|    | 731|+        StringIterator GetTagTypes ();
+|    | 732|+
+|    | 733|+        void idle ();
+|    | 734|+        int noidle ();
+|    | 735|+        void setNoidleCallback (NoidleCallback callback);
+|    | 736|+
+|    | 737|+      private:
+|    | 738|+        struct ConnectionDeleter
+|    | 739|+        {
+|    | 740|+            void operator () (mpd_connection * connection)
+|    | 741|+            {
+|    | 742|+                mpd_connection_free (connection);
+|    | 743|+            }
+|    | 744|+        };
+|    | 745|+
+|    | 746|+        void checkConnection () const;
+|    | 747|+        void prechecks ();
+|    | 748|+        void prechecksNoCommandsList ();
+|    | 749|+        void checkErrors () const;
+|    | 750|+
+|    | 751|+        NoidleCallback m_noidle_callback;
+|    | 752|+        std::unique_ptr < mpd_connection, ConnectionDeleter > m_connection;
+|    | 753|+        bool m_command_list_active;
+|    | 754|+
+|    | 755|+        int m_fd;
+|    | 756|+        bool m_idle;
+|    | 757|+
+|    | 758|+        std::string m_host;
+|    | 759|+        int m_port;
+|    | 760|+        int m_timeout;
+|    | 761|+        std::string m_password;
+|    | 762|+    };
+| 614| 763| 
+| 615| 764| }
+| 616| 765| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mpdpp.h
+|    |++++| /app/src/mpdpp.h
+| 614| 614| 
+| 615| 615| }
+| 616| 616| 
+| 617|    |-extern MPD::Connection Mpd;
+|    | 617|+extern
+|    | 618|+    MPD::Connection
+|    | 619|+    Mpd;
+| 618| 620| 
+| 619| 621| #endif // NCMPCPP_MPDPP_H
+
+src/mpdpp.h
+| 103| »   bool•random()•const•{•return•mpd_status_get_random(m_status.get());•}
+|    | [NORMAL] CSecurityBear (random):
+|    | random: This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).  use a more secure technique for acquiring random values.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.h
+|    |++++| /app/src/screens/search_engine.h
+|  31|  31| 
+|  32|  32| struct SEItem
+|  33|  33| {
+|  34|    |-	SEItem() : m_is_song(false), m_buffer(0) { }
+|  35|    |-	SEItem(NC::Buffer *buf) : m_is_song(false), m_buffer(buf) { }
+|  36|    |-	SEItem(const MPD::Song &s) : m_is_song(true), m_song(s) { }
+|  37|    |-	SEItem(const SEItem &ei) { *this = ei; }
+|  38|    |-	~SEItem() {
+|  39|    |-		if (!m_is_song)
+|  40|    |-			delete m_buffer;
+|  41|    |-	}
+|    |  34|+    SEItem ():m_is_song (false), m_buffer (0)
+|    |  35|+    {
+|    |  36|+    }
+|    |  37|+    SEItem (NC::Buffer * buf):m_is_song (false), m_buffer (buf)
+|    |  38|+    {
+|    |  39|+    }
+|    |  40|+    SEItem (const MPD::Song & s):m_is_song (true), m_song (s)
+|    |  41|+    {
+|    |  42|+    }
+|    |  43|+    SEItem (const SEItem & ei)
+|    |  44|+    {
+|    |  45|+        *this = ei;
+|    |  46|+    }
+|    |  47|+    ~SEItem ()
+|    |  48|+    {
+|    |  49|+        if (!m_is_song)
+|    |  50|+            delete m_buffer;
+|    |  51|+    }
+|  42|  52| 
+|  43|    |-	NC::Buffer &mkBuffer() {
+|  44|    |-		assert(!m_is_song);
+|  45|    |-		delete m_buffer;
+|  46|    |-		m_buffer = new NC::Buffer();
+|  47|    |-		return *m_buffer;
+|  48|    |-	}
+|    |  53|+    NC::Buffer & mkBuffer ()
+|    |  54|+    {
+|    |  55|+        assert (!m_is_song);
+|    |  56|+        delete m_buffer;
+|    |  57|+        m_buffer = new NC::Buffer ();
+|    |  58|+        return *m_buffer;
+|    |  59|+    }
+|  49|  60| 
+|  50|    |-	bool isSong() const { return m_is_song; }
+|    |  61|+    bool isSong () const
+|    |  62|+    {
+|    |  63|+        return m_is_song;
+|    |  64|+    }
+|  51|  65| 
+|  52|    |-	NC::Buffer &buffer() { assert(!m_is_song && m_buffer); return *m_buffer; }
+|  53|    |-	MPD::Song &song() { assert(m_is_song); return m_song; }
+|    |  66|+    NC::Buffer & buffer ()
+|    |  67|+    {
+|    |  68|+        assert (!m_is_song && m_buffer);
+|    |  69|+        return *m_buffer;
+|    |  70|+    }
+|    |  71|+    MPD::Song & song ()
+|    |  72|+    {
+|    |  73|+        assert (m_is_song);
+|    |  74|+        return m_song;
+|    |  75|+    }
+|  54|  76| 
+|  55|    |-	const NC::Buffer &buffer() const { assert(!m_is_song && m_buffer); return *m_buffer; }
+|  56|    |-	const MPD::Song &song() const { assert(m_is_song); return m_song; }
+|    |  77|+    const NC::Buffer & buffer () const
+|    |  78|+    {
+|    |  79|+        assert (!m_is_song && m_buffer);
+|    |  80|+        return *m_buffer;
+|    |  81|+    }
+|    |  82|+    const MPD::Song & song () const
+|    |  83|+    {
+|    |  84|+        assert (m_is_song);
+|    |  85|+        return m_song;
+|    |  86|+    }
+|  57|  87| 
+|  58|    |-	SEItem &operator=(const SEItem &se) {
+|  59|    |-		if (this == &se)
+|  60|    |-			return *this;
+|  61|    |-		m_is_song = se.m_is_song;
+|  62|    |-		if (se.m_is_song)
+|  63|    |-			m_song = se.m_song;
+|  64|    |-		else if (se.m_buffer)
+|  65|    |-			m_buffer = new NC::Buffer(*se.m_buffer);
+|  66|    |-		else
+|  67|    |-			m_buffer = 0;
+|  68|    |-		return *this;
+|  69|    |-	}
+|    |  88|+    SEItem & operator= (const SEItem & se)
+|    |  89|+    {
+|    |  90|+        if (this == &se)
+|    |  91|+            return *this;
+|    |  92|+        m_is_song = se.m_is_song;
+|    |  93|+        if (se.m_is_song)
+|    |  94|+            m_song = se.m_song;
+|    |  95|+        else if (se.m_buffer)
+|    |  96|+            m_buffer = new NC::Buffer (*se.m_buffer);
+|    |  97|+        else
+|    |  98|+            m_buffer = 0;
+|    |  99|+        return *this;
+|    | 100|+    }
+|  70| 101| 
+|  71|    |-private:
+|  72|    |-	bool m_is_song;
+|    | 102|+  private:
+|    | 103|+    bool m_is_song;
+|  73| 104| 
+|  74|    |-	NC::Buffer *m_buffer;
+|  75|    |-	MPD::Song m_song;
+|    | 105|+    NC::Buffer * m_buffer;
+|    | 106|+    MPD::Song m_song;
+|  76| 107| };
+|  77| 108| 
+|  78| 109| struct SearchEngineWindow: NC::Menu<SEItem>, SongList
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.h
+|    |++++| /app/src/screens/search_engine.h
+|  75|  75| 	MPD::Song m_song;
+|  76|  76| };
+|  77|  77| 
+|  78|    |-struct SearchEngineWindow: NC::Menu<SEItem>, SongList
+|    |  78|+struct SearchEngineWindow:
+|    |  79|+    NC::Menu <
+|    |  80|+    SEItem >,
+|    |  81|+    SongList
+|  79|  82| {
+|  80|    |-	SearchEngineWindow() { }
+|  81|    |-	SearchEngineWindow(NC::Menu<SEItem> &&base)
+|  82|    |-	: NC::Menu<SEItem>(std::move(base)) { }
+|    |  83|+    SearchEngineWindow ()
+|    |  84|+    {
+|    |  85|+    }
+|    |  86|+    SearchEngineWindow (NC::Menu < SEItem > &&base):
+|    |  87|+        NC::Menu <
+|    |  88|+    SEItem > (std::move (base))
+|    |  89|+    {
+|    |  90|+    }
+|  83|  91| 
+|  84|    |-	virtual SongIterator currentS() override;
+|  85|    |-	virtual ConstSongIterator currentS() const override;
+|  86|    |-	virtual SongIterator beginS() override;
+|  87|    |-	virtual ConstSongIterator beginS() const override;
+|  88|    |-	virtual SongIterator endS() override;
+|  89|    |-	virtual ConstSongIterator endS() const override;
+|    |  92|+    virtual SongIterator
+|    |  93|+    currentS ()
+|    |  94|+        override;
+|    |  95|+    virtual ConstSongIterator
+|    |  96|+    currentS () const
+|    |  97|+        override;
+|    |  98|+    virtual SongIterator
+|    |  99|+    beginS ()
+|    | 100|+        override;
+|    | 101|+    virtual ConstSongIterator
+|    | 102|+    beginS () const
+|    | 103|+        override;
+|    | 104|+    virtual SongIterator
+|    | 105|+    endS ()
+|    | 106|+        override;
+|    | 107|+    virtual ConstSongIterator
+|    | 108|+    endS () const
+|    | 109|+        override;
+|  90| 110| 
+|  91|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|    | 111|+    virtual
+|    | 112|+        std::vector <
+|    | 113|+        MPD::Song >
+|    | 114|+    getSelectedSongs ()
+|    | 115|+        override;
+|  92| 116| };
+|  93| 117| 
+|  94| 118| struct SearchEngine: Screen<SearchEngineWindow>, Filterable, HasActions, HasSongs, Searchable, Tabbable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.h
+|    |++++| /app/src/screens/search_engine.h
+|  91|  91| 	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  92|  92| };
+|  93|  93| 
+|  94|    |-struct SearchEngine: Screen<SearchEngineWindow>, Filterable, HasActions, HasSongs, Searchable, Tabbable
+|    |  94|+struct SearchEngine:
+|    |  95|+    Screen <
+|    |  96|+    SearchEngineWindow >,
+|    |  97|+    Filterable,
+|    |  98|+    HasActions,
+|    |  99|+    HasSongs,
+|    | 100|+    Searchable,
+|    | 101|+    Tabbable
+|  95| 102| {
+|  96|    |-	SearchEngine();
+|  97|    |-	
+|  98|    |-	// Screen<SearchEngineWindow> implementation
+|  99|    |-	virtual void resize() override;
+| 100|    |-	virtual void switchTo() override;
+| 101|    |-	
+| 102|    |-	virtual std::wstring title() override;
+| 103|    |-	virtual ScreenType type() override { return ScreenType::SearchEngine; }
+| 104|    |-	
+| 105|    |-	virtual void update() override { }
+| 106|    |-	
+| 107|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+| 108|    |-	
+| 109|    |-	virtual bool isLockable() override { return true; }
+| 110|    |-	virtual bool isMergable() override { return true; }
+| 111|    |-	
+| 112|    |-	// Searchable implementation
+| 113|    |-	virtual bool allowsSearching() override;
+| 114|    |-	virtual const std::string &searchConstraint() override;
+| 115|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+| 116|    |-	virtual void clearSearchConstraint() override;
+| 117|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+| 118|    |-
+| 119|    |-	// Filterable implementation
+| 120|    |-	virtual bool allowsFiltering() override;
+| 121|    |-	virtual std::string currentFilter() override;
+| 122|    |-	virtual void applyFilter(const std::string &filter) override;
+| 123|    |-
+| 124|    |-	// HasActions implementation
+| 125|    |-	virtual bool actionRunnable() override;
+| 126|    |-	virtual void runAction() override;
+| 127|    |-
+| 128|    |-	// HasSongs implementation
+| 129|    |-	virtual bool itemAvailable() override;
+| 130|    |-	virtual bool addItemToPlaylist(bool play) override;
+| 131|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+| 132|    |-	
+| 133|    |-	// private members
+| 134|    |-	void reset();
+| 135|    |-	
+| 136|    |-	static size_t StaticOptions;
+| 137|    |-	static size_t SearchButton;
+| 138|    |-	static size_t ResetButton;
+| 139|    |-	
+| 140|    |-private:
+| 141|    |-	void Prepare();
+| 142|    |-	void Search();
+| 143|    |-
+| 144|    |-	Regex::ItemFilter<SEItem> m_search_predicate;
+| 145|    |-	
+| 146|    |-	const char **SearchMode;
+| 147|    |-	
+| 148|    |-	static const char *SearchModes[];
+| 149|    |-	
+| 150|    |-	static const size_t ConstraintsNumber = 11;
+| 151|    |-	static const char *ConstraintsNames[];
+| 152|    |-	std::string itsConstraints[ConstraintsNumber];
+| 153|    |-	
+| 154|    |-	static bool MatchToPattern;
+|    | 103|+    SearchEngine ();
+|    | 104|+
+|    | 105|+    // Screen<SearchEngineWindow> implementation
+|    | 106|+    virtual void
+|    | 107|+    resize ()
+|    | 108|+        override;
+|    | 109|+    virtual void
+|    | 110|+    switchTo ()
+|    | 111|+        override;
+|    | 112|+
+|    | 113|+    virtual
+|    | 114|+        std::wstring
+|    | 115|+    title ()
+|    | 116|+        override;
+|    | 117|+    virtual ScreenType
+|    | 118|+    type ()
+|    | 119|+        override
+|    | 120|+    {
+|    | 121|+        return ScreenType::SearchEngine;
+|    | 122|+    }
+|    | 123|+
+|    | 124|+    virtual void
+|    | 125|+    update ()
+|    | 126|+        override
+|    | 127|+    {
+|    | 128|+    }
+|    | 129|+
+|    | 130|+    virtual void
+|    | 131|+    mouseButtonPressed (MEVENT me)
+|    | 132|+        override;
+|    | 133|+
+|    | 134|+    virtual bool
+|    | 135|+    isLockable ()
+|    | 136|+        override
+|    | 137|+    {
+|    | 138|+        return true;
+|    | 139|+    }
+|    | 140|+    virtual bool
+|    | 141|+    isMergable ()
+|    | 142|+        override
+|    | 143|+    {
+|    | 144|+        return true;
+|    | 145|+    }
+|    | 146|+
+|    | 147|+    // Searchable implementation
+|    | 148|+    virtual bool
+|    | 149|+    allowsSearching ()
+|    | 150|+        override;
+|    | 151|+    virtual const
+|    | 152|+        std::string &
+|    | 153|+    searchConstraint ()
+|    | 154|+        override;
+|    | 155|+    virtual void
+|    | 156|+    setSearchConstraint (const std::string & constraint)
+|    | 157|+        override;
+|    | 158|+    virtual void
+|    | 159|+    clearSearchConstraint ()
+|    | 160|+        override;
+|    | 161|+    virtual bool
+|    | 162|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 163|+        override;
+|    | 164|+
+|    | 165|+    // Filterable implementation
+|    | 166|+    virtual bool
+|    | 167|+    allowsFiltering ()
+|    | 168|+        override;
+|    | 169|+    virtual
+|    | 170|+        std::string
+|    | 171|+    currentFilter ()
+|    | 172|+        override;
+|    | 173|+    virtual void
+|    | 174|+    applyFilter (const std::string & filter)
+|    | 175|+        override;
+|    | 176|+
+|    | 177|+    // HasActions implementation
+|    | 178|+    virtual bool
+|    | 179|+    actionRunnable ()
+|    | 180|+        override;
+|    | 181|+    virtual void
+|    | 182|+    runAction ()
+|    | 183|+        override;
+|    | 184|+
+|    | 185|+    // HasSongs implementation
+|    | 186|+    virtual bool
+|    | 187|+    itemAvailable ()
+|    | 188|+        override;
+|    | 189|+    virtual bool
+|    | 190|+    addItemToPlaylist (bool play)
+|    | 191|+        override;
+|    | 192|+    virtual
+|    | 193|+        std::vector <
+|    | 194|+        MPD::Song >
+|    | 195|+    getSelectedSongs ()
+|    | 196|+        override;
+|    | 197|+
+|    | 198|+    // private members
+|    | 199|+    void
+|    | 200|+    reset ();
+|    | 201|+
+|    | 202|+    static size_t
+|    | 203|+        StaticOptions;
+|    | 204|+    static size_t
+|    | 205|+        SearchButton;
+|    | 206|+    static size_t
+|    | 207|+        ResetButton;
+|    | 208|+
+|    | 209|+  private:
+|    | 210|+    void
+|    | 211|+    Prepare ();
+|    | 212|+    void
+|    | 213|+    Search ();
+|    | 214|+
+|    | 215|+    Regex::ItemFilter < SEItem > m_search_predicate;
+|    | 216|+
+|    | 217|+    const char **
+|    | 218|+        SearchMode;
+|    | 219|+
+|    | 220|+    static const char *
+|    | 221|+        SearchModes[];
+|    | 222|+
+|    | 223|+    static const size_t
+|    | 224|+        ConstraintsNumber = 11;
+|    | 225|+    static const char *
+|    | 226|+        ConstraintsNames[];
+|    | 227|+    std::string itsConstraints[ConstraintsNumber];
+|    | 228|+
+|    | 229|+    static bool
+|    | 230|+        MatchToPattern;
+| 155| 231| };
+| 156| 232| 
+| 157| 233| extern SearchEngine *mySearcher;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.h
+|    |++++| /app/src/screens/search_engine.h
+| 154| 154| 	static bool MatchToPattern;
+| 155| 155| };
+| 156| 156| 
+| 157|    |-extern SearchEngine *mySearcher;
+|    | 157|+extern SearchEngine *
+|    | 158|+    mySearcher;
+| 158| 159| 
+| 159| 160| #endif // NCMPCPP_SEARCH_ENGINE_H
+| 160| 161| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.h
+|    |++++| /app/src/screens/search_engine.h
+| 157| 157| extern SearchEngine *mySearcher;
+| 158| 158| 
+| 159| 159| #endif // NCMPCPP_SEARCH_ENGINE_H
+| 160|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sort_playlist.h
+|    |++++| /app/src/screens/sort_playlist.h
+|  26|  26| #include "screens/screen.h"
+|  27|  27| #include "song.h"
+|  28|  28| 
+|  29|    |-struct SortPlaylistDialog
+|  30|    |-	: Screen<NC::Menu<RunnableItem<std::pair<std::string, MPD::Song::GetFunction>, void()>>>, HasActions, Tabbable
+|    |  29|+struct SortPlaylistDialog:Screen <
+|    |  30|+    NC::Menu <
+|    |  31|+    RunnableItem <
+|    |  32|+    std::pair <
+|    |  33|+    std::string,
+|    |  34|+MPD::Song::GetFunction >, void () >>>,
+|    |  35|+    HasActions,
+|    |  36|+    Tabbable
+|  31|  37| {
+|  32|    |-	typedef SortPlaylistDialog Self;
+|  33|    |-	
+|  34|    |-	SortPlaylistDialog();
+|  35|    |-	
+|  36|    |-	virtual void switchTo() override;
+|  37|    |-	virtual void resize() override;
+|  38|    |-	
+|  39|    |-	virtual std::wstring title() override;
+|  40|    |-	virtual ScreenType type() override { return ScreenType::SortPlaylistDialog; }
+|  41|    |-	
+|  42|    |-	virtual void update() override { }
+|  43|    |-	
+|  44|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  45|    |-	
+|  46|    |-	virtual bool isLockable() override { return false; }
+|  47|    |-	virtual bool isMergable() override { return false; }
+|    |  38|+    typedef SortPlaylistDialog
+|    |  39|+        Self;
+|  48|  40| 
+|  49|    |-	// HasActions implementation
+|  50|    |-	virtual bool actionRunnable() override;
+|  51|    |-	virtual void runAction() override;
+|    |  41|+    SortPlaylistDialog ();
+|  52|  42| 
+|  53|    |-	// private members
+|  54|    |-	void moveSortOrderUp();
+|  55|    |-	void moveSortOrderDown();
+|  56|    |-	
+|  57|    |-private:
+|  58|    |-	void moveSortOrderHint() const;
+|  59|    |-	void sort() const;
+|  60|    |-	void cancel() const;
+|  61|    |-	
+|  62|    |-	void setDimensions();
+|  63|    |-	
+|  64|    |-	size_t m_height;
+|  65|    |-	size_t m_width;
+|    |  43|+    virtual void
+|    |  44|+    switchTo ()
+|    |  45|+        override;
+|    |  46|+    virtual void
+|    |  47|+    resize ()
+|    |  48|+        override;
+|    |  49|+
+|    |  50|+    virtual
+|    |  51|+        std::wstring
+|    |  52|+    title ()
+|    |  53|+        override;
+|    |  54|+    virtual ScreenType
+|    |  55|+    type ()
+|    |  56|+        override
+|    |  57|+    {
+|    |  58|+        return ScreenType::SortPlaylistDialog;
+|    |  59|+    }
+|    |  60|+
+|    |  61|+    virtual void
+|    |  62|+    update ()
+|    |  63|+        override
+|    |  64|+    {
+|    |  65|+    }
+|    |  66|+
+|    |  67|+    virtual void
+|    |  68|+    mouseButtonPressed (MEVENT me)
+|    |  69|+        override;
+|    |  70|+
+|    |  71|+    virtual bool
+|    |  72|+    isLockable ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+        return false;
+|    |  76|+    }
+|    |  77|+    virtual bool
+|    |  78|+    isMergable ()
+|    |  79|+        override
+|    |  80|+    {
+|    |  81|+        return false;
+|    |  82|+    }
+|    |  83|+
+|    |  84|+    // HasActions implementation
+|    |  85|+    virtual bool
+|    |  86|+    actionRunnable ()
+|    |  87|+        override;
+|    |  88|+    virtual void
+|    |  89|+    runAction ()
+|    |  90|+        override;
+|    |  91|+
+|    |  92|+    // private members
+|    |  93|+    void
+|    |  94|+    moveSortOrderUp ();
+|    |  95|+    void
+|    |  96|+    moveSortOrderDown ();
+|    |  97|+
+|    |  98|+  private:
+|    |  99|+    void
+|    | 100|+    moveSortOrderHint () const;
+|    | 101|+    void
+|    | 102|+    sort () const;
+|    | 103|+    void
+|    | 104|+    cancel () const;
+|    | 105|+
+|    | 106|+    void
+|    | 107|+    setDimensions ();
+|    | 108|+
+|    | 109|+    size_t
+|    | 110|+        m_height;
+|    | 111|+    size_t
+|    | 112|+        m_width;
+|  66| 113| };
+|  67| 114| 
+|  68| 115| extern SortPlaylistDialog *mySortPlaylistDialog;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sort_playlist.h
+|    |++++| /app/src/screens/sort_playlist.h
+|  65|  65| 	size_t m_width;
+|  66|  66| };
+|  67|  67| 
+|  68|    |-extern SortPlaylistDialog *mySortPlaylistDialog;
+|    |  68|+extern SortPlaylistDialog *
+|    |  69|+    mySortPlaylistDialog;
+|  69|  70| 
+|  70|  71| #endif // NCMPCPP_SORT_PLAYLIST_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/macro_utilities.h
+|    |++++| /app/src/macro_utilities.h
+|  25|  25| #include "actions.h"
+|  26|  26| #include "screens/screen_type.h"
+|  27|  27| 
+|  28|    |-namespace Actions {
+|    |  28|+namespace Actions
+|    |  29|+{
+|  29|  30| 
+|  30|    |-struct PushCharacters: BaseAction
+|  31|    |-{
+|  32|    |-	PushCharacters(NC::Window **w, std::vector<NC::Key::Type> &&queue);
+|    |  31|+    struct PushCharacters:BaseAction
+|    |  32|+    {
+|    |  33|+        PushCharacters (NC::Window ** w,
+|    |  34|+                        std::vector < NC::Key::Type > &&queue);
+|  33|  35| 
+|  34|    |-private:
+|  35|    |-	virtual void run() override;
+|  36|    |-	
+|  37|    |-	NC::Window **m_window;
+|  38|    |-	std::vector<NC::Key::Type> m_queue;
+|  39|    |-};
+|    |  36|+      private:
+|    |  37|+        virtual void run () override;
+|  40|  38| 
+|  41|    |-struct RequireRunnable: BaseAction
+|  42|    |-{
+|  43|    |-	RequireRunnable(std::shared_ptr<BaseAction> action);
+|  44|    |-	
+|  45|    |-private:
+|  46|    |-	virtual bool canBeRun() override;
+|  47|    |-	virtual void run() override { }
+|  48|    |-	
+|  49|    |-	std::shared_ptr<BaseAction> m_action;
+|  50|    |-};
+|    |  39|+          NC::Window ** m_window;
+|    |  40|+          std::vector < NC::Key::Type > m_queue;
+|    |  41|+    };
+|  51|  42| 
+|  52|    |-struct RequireScreen: BaseAction
+|  53|    |-{
+|  54|    |-	RequireScreen(ScreenType screen_type);
+|  55|    |-	
+|  56|    |-private:
+|  57|    |-	virtual bool canBeRun() override;
+|  58|    |-	virtual void run() override { }
+|  59|    |-	
+|  60|    |-	ScreenType m_screen_type;
+|  61|    |-};
+|    |  43|+    struct RequireRunnable:BaseAction
+|    |  44|+    {
+|    |  45|+        RequireRunnable (std::shared_ptr < BaseAction > action);
+|  62|  46| 
+|  63|    |-struct RunExternalCommand: BaseAction
+|  64|    |-{
+|  65|    |-	RunExternalCommand(std::string &&command);
+|  66|    |-	
+|  67|    |-private:
+|  68|    |-	virtual void run() override;
+|  69|    |-	
+|  70|    |-	std::string m_command;
+|  71|    |-};
+|    |  47|+      private:
+|    |  48|+        virtual bool canBeRun () override;
+|    |  49|+        virtual void run () override
+|    |  50|+        {
+|    |  51|+        }
+|    |  52|+
+|    |  53|+        std::shared_ptr < BaseAction > m_action;
+|    |  54|+    };
+|    |  55|+
+|    |  56|+    struct RequireScreen:BaseAction
+|    |  57|+    {
+|    |  58|+        RequireScreen (ScreenType screen_type);
+|    |  59|+
+|    |  60|+      private:
+|    |  61|+        virtual bool canBeRun () override;
+|    |  62|+        virtual void run () override
+|    |  63|+        {
+|    |  64|+        }
+|    |  65|+
+|    |  66|+        ScreenType m_screen_type;
+|    |  67|+    };
+|    |  68|+
+|    |  69|+    struct RunExternalCommand:BaseAction
+|    |  70|+    {
+|    |  71|+        RunExternalCommand (std::string && command);
+|    |  72|+
+|    |  73|+      private:
+|    |  74|+        virtual void run () override;
+|    |  75|+
+|    |  76|+          std::string m_command;
+|    |  77|+    };
+|  72|  78| 
+|  73|  79| }
+|  74|  80| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  27|  27| #include "gcc.h"
+|  28|  28| #include "interfaces.h"
+|  29|  29| 
+|  30|    |-namespace Progressbar {
+|    |  30|+namespace Progressbar
+|    |  31|+{
+|  31|  32| 
+|  32|    |-struct ScopedLock
+|  33|    |-{
+|  34|    |-	ScopedLock() noexcept;
+|  35|    |-	~ScopedLock() noexcept;
+|  36|    |-};
+|    |  33|+    struct ScopedLock
+|    |  34|+    {
+|    |  35|+        ScopedLock () noexcept;
+|    |  36|+        ~ScopedLock () noexcept;
+|    |  37|+    };
+|  37|  38| 
+|  38|  39| /// @return true if progressbar is unlocked
+|  39|  40| bool isUnlocked();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  36|  36| };
+|  37|  37| 
+|  38|  38| /// @return true if progressbar is unlocked
+|  39|    |-bool isUnlocked();
+|    |  39|+    bool isUnlocked ();
+|  40|  40| 
+|  41|  41| /// draws progressbar
+|  42|  42| void draw(unsigned elapsed, unsigned time);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  39|  39| bool isUnlocked();
+|  40|  40| 
+|  41|  41| /// draws progressbar
+|  42|    |-void draw(unsigned elapsed, unsigned time);
+|    |  42|+    void draw (unsigned elapsed, unsigned time);
+|  43|  43| 
+|  44|  44| }
+|  45|  45| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  43|  43| 
+|  44|  44| }
+|  45|  45| 
+|  46|    |-namespace Statusbar {
+|    |  46|+namespace Statusbar
+|    |  47|+{
+|  47|  48| 
+|  48|    |-struct ScopedLock
+|  49|    |-{
+|  50|    |-	ScopedLock() noexcept;
+|  51|    |-	~ScopedLock() noexcept;
+|  52|    |-};
+|    |  49|+    struct ScopedLock
+|    |  50|+    {
+|    |  51|+        ScopedLock () noexcept;
+|    |  52|+        ~ScopedLock () noexcept;
+|    |  53|+    };
+|  53|  54| 
+|  54|  55| /// @return true if statusbar is unlocked
+|  55|  56| bool isUnlocked();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  52|  52| };
+|  53|  53| 
+|  54|  54| /// @return true if statusbar is unlocked
+|  55|    |-bool isUnlocked();
+|    |  55|+    bool isUnlocked ();
+|  56|  56| 
+|  57|  57| /// tries to clear current message put there using Statusbar::printf if there is any
+|  58|  58| void tryRedraw();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  55|  55| bool isUnlocked();
+|  56|  56| 
+|  57|  57| /// tries to clear current message put there using Statusbar::printf if there is any
+|  58|    |-void tryRedraw();
+|    |  58|+    void tryRedraw ();
+|  59|  59| 
+|  60|  60| /// clears statusbar and move cursor to beginning of line
+|  61|  61| /// @return window object that represents statusbar
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  59|  59| 
+|  60|  60| /// clears statusbar and move cursor to beginning of line
+|  61|  61| /// @return window object that represents statusbar
+|  62|    |-NC::Window &put();
+|    |  62|+      NC::Window & put ();
+|  63|  63| 
+|  64|    |-namespace Helpers {
+|    |  64|+    namespace Helpers
+|    |  65|+    {
+|  65|  66| 
+|  66|  67| /// called when statusbar window detects incoming idle notification
+|  67|  68| void mpd();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  64|  64| namespace Helpers {
+|  65|  65| 
+|  66|  66| /// called when statusbar window detects incoming idle notification
+|  67|    |-void mpd();
+|    |  67|+        void mpd ();
+|  68|  68| 
+|  69|  69| /// called each time user types another character while inside Window::getString
+|  70|  70| bool mainHook(const char *);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  67|  67| void mpd();
+|  68|  68| 
+|  69|  69| /// called each time user types another character while inside Window::getString
+|  70|    |-bool mainHook(const char *);
+|    |  70|+        bool mainHook (const char *);
+|  71|  71| 
+|  72|  72| /// prompt and return one of the characters specified in the vector
+|  73|  73| char promptReturnOneOf(const std::vector<char> &values);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+|  70|  70| bool mainHook(const char *);
+|  71|  71| 
+|  72|  72| /// prompt and return one of the characters specified in the vector
+|  73|    |-char promptReturnOneOf(const std::vector<char> &values);
+|    |  73|+        char promptReturnOneOf (const std::vector < char >&values);
+|  74|  74| 
+|  75|    |-struct ImmediatelyReturnOneOf
+|  76|    |-{
+|  77|    |-	ImmediatelyReturnOneOf(std::vector<std::string> arg)
+|  78|    |-	: m_values(std::move(arg))
+|  79|    |-	{ }
+|    |  75|+        struct ImmediatelyReturnOneOf
+|    |  76|+        {
+|    |  77|+            ImmediatelyReturnOneOf (std::vector < std::string >
+|    |  78|+                                    arg):m_values (std::move (arg))
+|    |  79|+            {
+|    |  80|+            }
+|  80|  81| 
+|  81|    |-	bool operator()(const char *s) const;
+|    |  82|+            bool operator () (const char *s) const;
+|  82|  83| 
+|  83|    |-	template <typename StringT>
+|  84|    |-	bool isOneOf(StringT &&s) const {
+|  85|    |-		return std::find(m_values.begin(), m_values.end(), std::forward<StringT>(s)) != m_values.end();
+|  86|    |-	}
+|    |  84|+              template < typename StringT > bool isOneOf (StringT && s) const
+|    |  85|+            {
+|    |  86|+                return std::find (m_values.begin (), m_values.end (),
+|    |  87|+                                  std::forward < StringT > (s)) !=
+|    |  88|+                    m_values.end ();
+|    |  89|+            }
+|  87|  90| 
+|  88|    |-private:
+|  89|    |-	std::vector<std::string> m_values;
+|  90|    |-};
+|    |  91|+          private:
+|    |  92|+              std::vector < std::string > m_values;
+|    |  93|+        };
+|  91|  94| 
+|  92|    |-struct ApplyFilterImmediately
+|  93|    |-{
+|  94|    |-	ApplyFilterImmediately(Filterable *w)
+|  95|    |-		: m_w(w)
+|  96|    |-	{ }
+|    |  95|+        struct ApplyFilterImmediately
+|    |  96|+        {
+|    |  97|+            ApplyFilterImmediately (Filterable * w):m_w (w)
+|    |  98|+            {
+|    |  99|+            }
+|  97| 100| 
+|  98|    |-	bool operator()(const char *s);
+|    | 101|+            bool operator () (const char *s);
+|  99| 102| 
+| 100|    |-private:
+| 101|    |-	Filterable *m_w;
+| 102|    |-};
+|    | 103|+          private:
+|    | 104|+              Filterable * m_w;
+|    | 105|+        };
+| 103| 106| 
+| 104|    |-struct FindImmediately
+| 105|    |-{
+| 106|    |-	FindImmediately(Searchable *w, SearchDirection direction)
+| 107|    |-		: m_w(w), m_direction(direction)
+| 108|    |-	{ }
+|    | 107|+        struct FindImmediately
+|    | 108|+        {
+|    | 109|+            FindImmediately (Searchable * w,
+|    | 110|+                             SearchDirection direction):m_w (w),
+|    | 111|+                m_direction (direction)
+|    | 112|+            {
+|    | 113|+            }
+| 109| 114| 
+| 110|    |-	bool operator()(const char *s);
+|    | 115|+            bool operator () (const char *s);
+| 111| 116| 
+| 112|    |-private:
+| 113|    |-	Searchable *m_w;
+| 114|    |-	const SearchDirection m_direction;
+| 115|    |-};
+|    | 117|+          private:
+|    | 118|+            Searchable * m_w;
+|    | 119|+            const SearchDirection m_direction;
+|    | 120|+        };
+| 116| 121| 
+| 117|    |-struct TryExecuteImmediateCommand
+| 118|    |-{
+| 119|    |-	bool operator()(const char *s);
+| 120|    |-	
+| 121|    |-private:
+| 122|    |-	std::string m_s;
+| 123|    |-};
+|    | 122|+        struct TryExecuteImmediateCommand
+|    | 123|+        {
+|    | 124|+            bool operator () (const char *s);
+| 124| 125| 
+| 125|    |-}
+|    | 126|+          private:
+|    | 127|+              std::string m_s;
+|    | 128|+        };
+|    | 129|+
+|    | 130|+    }
+| 126| 131| 
+| 127| 132| /// displays message in statusbar for a given period of time
+| 128| 133| void print(int delay, const std::string& message);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+| 125| 125| }
+| 126| 126| 
+| 127| 127| /// displays message in statusbar for a given period of time
+| 128|    |-void print(int delay, const std::string& message);
+|    | 128|+    void print (int delay, const std::string & message);
+| 129| 129| 
+| 130| 130| /// displays message in statusbar for period of time set in configuration file
+| 131| 131| inline void print(const std::string &message)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+| 128| 128| void print(int delay, const std::string& message);
+| 129| 129| 
+| 130| 130| /// displays message in statusbar for period of time set in configuration file
+| 131|    |-inline void print(const std::string &message)
+| 132|    |-{
+| 133|    |-	print(Config.message_delay_time, message);
+| 134|    |-}
+|    | 131|+    inline void print (const std::string & message)
+|    | 132|+    {
+|    | 133|+        print (Config.message_delay_time, message);
+|    | 134|+    }
+| 135| 135| 
+| 136| 136| /// displays formatted message in statusbar for period of time set in configuration file
+| 137| 137| template <typename FormatT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+| 134| 134| }
+| 135| 135| 
+| 136| 136| /// displays formatted message in statusbar for period of time set in configuration file
+| 137|    |-template <typename FormatT>
+| 138|    |-void printf(FormatT &&fmt)
+| 139|    |-{
+| 140|    |-	print(Config.message_delay_time, boost::format(std::forward<FormatT>(fmt)).str());
+| 141|    |-}
+| 142|    |-template <typename FormatT, typename ArgT, typename... Args>
+| 143|    |-void printf(FormatT &&fmt, ArgT &&arg, Args&&... args)
+| 144|    |-{
+| 145|    |-	printf(boost::format(std::forward<FormatT>(fmt)) % std::forward<ArgT>(arg),
+| 146|    |-		std::forward<Args>(args)...
+| 147|    |-	);
+| 148|    |-}
+|    | 137|+    template < typename FormatT > void printf (FormatT && fmt)
+|    | 138|+    {
+|    | 139|+        print (Config.message_delay_time,
+|    | 140|+               boost::format (std::forward < FormatT > (fmt)).str ());
+|    | 141|+    }
+|    | 142|+    template < typename FormatT, typename ArgT, typename...Args >
+|    | 143|+        void printf (FormatT && fmt, ArgT && arg, Args && ... args)
+|    | 144|+    {
+|    | 145|+        printf (boost::format (std::forward < FormatT > (fmt)) % std::forward <
+|    | 146|+                ArgT > (arg), std::forward < Args > (args)...);
+|    | 147|+    }
+| 149| 148| 
+| 150| 149| /// displays formatted message in statusbar for a given period of time
+| 151| 150| template <typename FormatT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/statusbar.h
+|    |++++| /app/src/statusbar.h
+| 148| 148| }
+| 149| 149| 
+| 150| 150| /// displays formatted message in statusbar for a given period of time
+| 151|    |-template <typename FormatT>
+| 152|    |-void printf(int delay, FormatT &&fmt)
+| 153|    |-{
+| 154|    |-	print(delay, boost::format(std::forward<FormatT>(fmt)).str());
+| 155|    |-}
+| 156|    |-template <typename FormatT, typename ArgT, typename... Args>
+| 157|    |-void printf(int delay, FormatT &&fmt, ArgT &&arg, Args&&... args)
+| 158|    |-{
+| 159|    |-	printf(delay, boost::format(std::forward<FormatT>(fmt)) % std::forward<ArgT>(arg),
+| 160|    |-		std::forward<Args>(args)...
+| 161|    |-	);
+| 162|    |-}
+|    | 151|+    template < typename FormatT > void printf (int delay, FormatT && fmt)
+|    | 152|+    {
+|    | 153|+        print (delay, boost::format (std::forward < FormatT > (fmt)).str ());
+|    | 154|+    }
+|    | 155|+    template < typename FormatT, typename ArgT, typename...Args >
+|    | 156|+        void printf (int delay, FormatT && fmt, ArgT && arg, Args && ... args)
+|    | 157|+    {
+|    | 158|+        printf (delay,
+|    | 159|+                boost::format (std::forward < FormatT > (fmt)) % std::forward <
+|    | 160|+                ArgT > (arg), std::forward < Args > (args)...);
+|    | 161|+    }
+| 163| 162| 
+| 164| 163| }
+| 165| 164| 
+
+src/statusbar.h
+| 138| void•printf(FormatT•&&fmt)
+|    | [NORMAL] CSecurityBear (format):
+|    | printf: If format strings can be influenced by an attacker, they can be exploited (CWE-134).  Use a constant for the format specification.
+
+src/statusbar.h
+| 143| void•printf(FormatT•&&fmt,•ArgT•&&arg,•Args&&...•args)
+|    | [NORMAL] CSecurityBear (format):
+|    | printf: If format strings can be influenced by an attacker, they can be exploited (CWE-134).  Use a constant for the format specification.
+
+src/statusbar.h
+| 145| »   printf(boost::format(std::forward<FormatT>(fmt))•%•std::forward<ArgT>(arg),
+|    | [NORMAL] CSecurityBear (format):
+|    | printf: If format strings can be influenced by an attacker, they can be exploited (CWE-134).  Use a constant for the format specification.
+
+src/statusbar.h
+| 152| void•printf(int•delay,•FormatT•&&fmt)
+|    | [NORMAL] CSecurityBear (format):
+|    | printf: If format strings can be influenced by an attacker, they can be exploited (CWE-134).  Use a constant for the format specification.
+
+src/statusbar.h
+| 157| void•printf(int•delay,•FormatT•&&fmt,•ArgT•&&arg,•Args&&...•args)
+|    | [NORMAL] CSecurityBear (format):
+|    | printf: If format strings can be influenced by an attacker, they can be exploited (CWE-134).  Use a constant for the format specification.
+
+src/statusbar.h
+| 159| »   printf(delay,•boost::format(std::forward<FormatT>(fmt))•%•std::forward<ArgT>(arg),
+|    | [NORMAL] CSecurityBear (format):
+|    | printf: If format strings can be influenced by an attacker, they can be exploited (CWE-134).  Use a constant for the format specification.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers/song_iterator_maker.h
+|    |++++| /app/src/helpers/song_iterator_maker.h
+|  25|  25| #include "curses/menu.h"
+|  26|  26| #include "song_list.h"
+|  27|  27| 
+|  28|    |-template <typename SongT>
+|  29|    |-struct SongPropertiesExtractor
+|    |  28|+template < typename SongT > struct SongPropertiesExtractor
+|  30|  29| {
+|  31|    |-	template <typename ItemT>
+|  32|    |-	auto &operator()(ItemT &item) const
+|  33|    |-	{
+|  34|    |-		return m_cache.assign(&item.properties(), &item.value());
+|  35|    |-	}
+|    |  30|+    template < typename ItemT > auto & operator () (ItemT & item) const
+|    |  31|+    {
+|    |  32|+        return m_cache.assign (&item.properties (), &item.value ());
+|    |  33|+    }
+|  36|  34| 
+|  37|    |-private:
+|  38|    |-	mutable SongProperties m_cache;
+|    |  35|+  private:
+|    |  36|+      mutable SongProperties m_cache;
+|  39|  37| };
+|  40|  38| 
+|  41|  39| template <typename IteratorT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers/song_iterator_maker.h
+|    |++++| /app/src/helpers/song_iterator_maker.h
+|  38|  38| 	mutable SongProperties m_cache;
+|  39|  39| };
+|  40|  40| 
+|  41|    |-template <typename IteratorT>
+|  42|    |-SongIterator makeSongIterator(IteratorT it)
+|    |  41|+template < typename IteratorT > SongIterator makeSongIterator (IteratorT it)
+|  43|  42| {
+|  44|    |-	typedef SongPropertiesExtractor<
+|  45|    |-		typename IteratorT::value_type::Type
+|  46|    |-		> Extractor;
+|  47|    |-	static_assert(
+|  48|    |-		std::is_convertible<
+|  49|    |-		  typename std::result_of<Extractor(typename IteratorT::reference)>::type,
+|  50|    |-		  SongProperties &
+|  51|    |-		>::value, "invalid result type of SongPropertiesExtractor");
+|  52|    |-	return SongIterator(boost::make_transform_iterator(it, Extractor{}));
+|    |  43|+    typedef SongPropertiesExtractor <
+|    |  44|+        typename IteratorT::value_type::Type > Extractor;
+|    |  45|+    static_assert (std::is_convertible <
+|    |  46|+                   typename std::result_of <
+|    |  47|+                   Extractor (typename IteratorT::reference) >::type,
+|    |  48|+                   SongProperties & >::value,
+|    |  49|+                   "invalid result type of SongPropertiesExtractor");
+|    |  50|+    return SongIterator (boost::make_transform_iterator (it, Extractor
+|    |  51|+                                                         {
+|    |  52|+                                                         }
+|    |  53|+                         ));
+|  53|  54| }
+|  54|  55| 
+|  55|  56| template <typename ConstIteratorT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers/song_iterator_maker.h
+|    |++++| /app/src/helpers/song_iterator_maker.h
+|  52|  52| 	return SongIterator(boost::make_transform_iterator(it, Extractor{}));
+|  53|  53| }
+|  54|  54| 
+|  55|    |-template <typename ConstIteratorT>
+|  56|    |-ConstSongIterator makeConstSongIterator(ConstIteratorT it)
+|    |  55|+template < typename ConstIteratorT >
+|    |  56|+    ConstSongIterator makeConstSongIterator (ConstIteratorT it)
+|  57|  57| {
+|  58|    |-	typedef SongPropertiesExtractor<
+|  59|    |-		typename ConstIteratorT::value_type::Type
+|  60|    |-		> Extractor;
+|  61|    |-	static_assert(
+|  62|    |-		std::is_convertible<
+|  63|    |-		  typename std::result_of<Extractor(typename ConstIteratorT::reference)>::type,
+|  64|    |-		  const SongProperties &
+|  65|    |-		>::value, "invalid result type of SongPropertiesExtractor");
+|  66|    |-	return ConstSongIterator(boost::make_transform_iterator(it, Extractor{}));
+|    |  58|+    typedef SongPropertiesExtractor <
+|    |  59|+        typename ConstIteratorT::value_type::Type > Extractor;
+|    |  60|+    static_assert (std::is_convertible <
+|    |  61|+                   typename std::result_of <
+|    |  62|+                   Extractor (typename ConstIteratorT::reference) >::type,
+|    |  63|+                   const SongProperties & >::value,
+|    |  64|+                   "invalid result type of SongPropertiesExtractor");
+|    |  65|+    return ConstSongIterator (boost::make_transform_iterator (it, Extractor
+|    |  66|+                                                              {
+|    |  67|+                                                              }
+|    |  68|+                              ));
+|  67|  69| }
+|  68|  70| 
+|  69|  71| #endif // NCMPCPP_HELPERS_SONG_ITERATOR_MAKER_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/tags.h
+|    |++++| /app/src/tags.h
+|  28|  28| #include <tfile.h>
+|  29|  29| #include "mutable_song.h"
+|  30|  30| 
+|  31|    |-namespace Tags {
+|    |  31|+namespace Tags
+|    |  32|+{
+|  32|  33| 
+|  33|    |-struct ReplayGainInfo
+|  34|    |-{
+|  35|    |-	ReplayGainInfo() { }
+|  36|    |-	ReplayGainInfo(std::string reference_loudness, std::string track_gain,
+|  37|    |-				   std::string track_peak, std::string album_gain,
+|  38|    |-				   std::string album_peak)
+|  39|    |-	: m_reference_loudness(reference_loudness), m_track_gain(track_gain)
+|  40|    |-	, m_track_peak(track_peak), m_album_gain(album_gain), m_album_peak(album_peak) { }
+|  41|    |-	
+|  42|    |-	bool empty() const
+|  43|    |-	{
+|  44|    |-		return m_reference_loudness.empty()
+|  45|    |-		    && m_track_gain.empty()
+|  46|    |-		    && m_track_peak.empty()
+|  47|    |-		    && m_album_gain.empty()
+|  48|    |-		    && m_album_peak.empty();
+|  49|    |-	}
+|  50|    |-	
+|  51|    |-	const std::string &referenceLoudness() const { return m_reference_loudness; }
+|  52|    |-	const std::string &trackGain() const { return m_track_gain; }
+|  53|    |-	const std::string &trackPeak() const { return m_track_peak; }
+|  54|    |-	const std::string &albumGain() const { return m_album_gain; }
+|  55|    |-	const std::string &albumPeak() const { return m_album_peak; }
+|  56|    |-	
+|  57|    |-private:
+|  58|    |-	std::string m_reference_loudness;
+|  59|    |-	std::string m_track_gain;
+|  60|    |-	std::string m_track_peak;
+|  61|    |-	std::string m_album_gain;
+|  62|    |-	std::string m_album_peak;
+|  63|    |-};
+|    |  34|+    struct ReplayGainInfo
+|    |  35|+    {
+|    |  36|+        ReplayGainInfo ()
+|    |  37|+        {
+|    |  38|+        }
+|    |  39|+        ReplayGainInfo (std::string reference_loudness, std::string track_gain,
+|    |  40|+                        std::string track_peak, std::string album_gain,
+|    |  41|+                        std::
+|    |  42|+                        string
+|    |  43|+                        album_peak):m_reference_loudness (reference_loudness),
+|    |  44|+            m_track_gain (track_gain), m_track_peak (track_peak),
+|    |  45|+            m_album_gain (album_gain), m_album_peak (album_peak)
+|    |  46|+        {
+|    |  47|+        }
+|  64|  48| 
+|  65|    |-void setAttribute(mpd_song *s, const char *name, const std::string &value);
+|    |  49|+        bool empty () const
+|    |  50|+        {
+|    |  51|+            return m_reference_loudness.empty ()
+|    |  52|+                && m_track_gain.empty ()
+|    |  53|+                && m_track_peak.empty ()
+|    |  54|+                && m_album_gain.empty () && m_album_peak.empty ();
+|    |  55|+        }
+|  66|  56| 
+|  67|    |-ReplayGainInfo readReplayGain(TagLib::File *f);
+|    |  57|+        const std::string & referenceLoudness () const
+|    |  58|+        {
+|    |  59|+            return m_reference_loudness;
+|    |  60|+        }
+|    |  61|+        const std::string & trackGain () const
+|    |  62|+        {
+|    |  63|+            return m_track_gain;
+|    |  64|+        }
+|    |  65|+        const std::string & trackPeak () const
+|    |  66|+        {
+|    |  67|+            return m_track_peak;
+|    |  68|+        }
+|    |  69|+        const std::string & albumGain () const
+|    |  70|+        {
+|    |  71|+            return m_album_gain;
+|    |  72|+        }
+|    |  73|+        const std::string & albumPeak () const
+|    |  74|+        {
+|    |  75|+            return m_album_peak;
+|    |  76|+        }
+|  68|  77| 
+|  69|    |-bool extendedSetSupported(const TagLib::File *f);
+|    |  78|+      private:
+|    |  79|+          std::string m_reference_loudness;
+|    |  80|+        std::string m_track_gain;
+|    |  81|+        std::string m_track_peak;
+|    |  82|+        std::string m_album_gain;
+|    |  83|+        std::string m_album_peak;
+|    |  84|+    };
+|  70|  85| 
+|  71|    |-void read(mpd_song *s);
+|  72|    |-bool write(MPD::MutableSong &);
+|    |  86|+    void setAttribute (mpd_song * s, const char *name,
+|    |  87|+                       const std::string & value);
+|    |  88|+
+|    |  89|+    ReplayGainInfo readReplayGain (TagLib::File * f);
+|    |  90|+
+|    |  91|+    bool extendedSetSupported (const TagLib::File * f);
+|    |  92|+
+|    |  93|+    void read (mpd_song * s);
+|    |  94|+    bool write (MPD::MutableSong &);
+|  73|  95| 
+|  74|  96| }
+|  75|  97| 
+
+src/tags.h
+|  71| void•read(mpd_song•*s);
+|    | [INFO] CSecurityBear (buffer):
+|    | read: Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/type_conversions.h
+|    |++++| /app/src/utility/type_conversions.h
+|  28|  28| #include "mutable_song.h"
+|  29|  29| #include "enums.h"
+|  30|  30| 
+|  31|    |-std::string channelsToString(int channels);
+|    |  31|+std::string channelsToString (int channels);
+|  32|  32| 
+|  33|    |-NC::Color charToColor(char c);
+|    |  33|+NC::Color charToColor (char c);
+|  34|  34| 
+|  35|    |-std::string tagTypeToString(mpd_tag_type tag);
+|  36|    |-MPD::MutableSong::SetFunction tagTypeToSetFunction(mpd_tag_type tag);
+|    |  35|+std::string tagTypeToString (mpd_tag_type tag);
+|    |  36|+MPD::MutableSong::SetFunction tagTypeToSetFunction (mpd_tag_type tag);
+|  37|  37| 
+|  38|    |-mpd_tag_type charToTagType(char c);
+|  39|    |-MPD::Song::GetFunction charToGetFunction(char c);
+|    |  38|+mpd_tag_type
+|    |  39|+charToTagType (char c);
+|    |  40|+MPD::Song::GetFunction charToGetFunction (char c);
+|  40|  41| 
+|  41|    |-boost::optional<mpd_tag_type> getFunctionToTagType(MPD::Song::GetFunction f);
+|    |  42|+boost::optional < mpd_tag_type >
+|    |  43|+getFunctionToTagType (MPD::Song::GetFunction f);
+|  42|  44| 
+|  43|    |-std::string itemTypeToString(MPD::Item::Type type);
+|    |  45|+std::string itemTypeToString (MPD::Item::Type type);
+|  44|  46| 
+|  45|  47| #endif // NCMPCPP_UTILITY_TYPE_CONVERSIONS_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.h
+|    |++++| /app/src/screens/lastfm.h
+|  31|  31| #include "screens/screen.h"
+|  32|  32| #include "utility/wide_string.h"
+|  33|  33| 
+|  34|    |-struct Lastfm: Screen<NC::Scrollpad>, Tabbable
+|    |  34|+struct Lastfm:Screen <
+|    |  35|+    NC::Scrollpad >,
+|    |  36|+    Tabbable
+|  35|  37| {
+|  36|    |-	Lastfm();
+|  37|    |-	
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	
+|  41|    |-	virtual std::wstring title() override;
+|  42|    |-	virtual ScreenType type() override { return ScreenType::Lastfm; }
+|  43|    |-	
+|  44|    |-	virtual void update() override;
+|  45|    |-	
+|  46|    |-	virtual bool isLockable() override { return true; }
+|  47|    |-	virtual bool isMergable() override { return true; }
+|  48|    |-	
+|  49|    |-	template <typename ServiceT>
+|  50|    |-	void queueJob(ServiceT *service)
+|  51|    |-	{
+|  52|    |-		auto old_service = dynamic_cast<ServiceT *>(m_service.get());
+|  53|    |-		// if the same service and arguments were used, leave old info
+|  54|    |-		if (old_service != nullptr && *old_service == *service)
+|  55|    |-			return;
+|    |  38|+    Lastfm ();
+|  56|  39| 
+|  57|    |-		m_service = std::shared_ptr<ServiceT>(service);
+|  58|    |-		m_worker = boost::async(
+|  59|    |-			boost::launch::async,
+|  60|    |-			std::bind(&LastFm::Service::fetch, m_service));
+|    |  40|+    virtual void
+|    |  41|+    switchTo ()
+|    |  42|+        override;
+|    |  43|+    virtual void
+|    |  44|+    resize ()
+|    |  45|+        override;
+|  61|  46| 
+|  62|    |-		w.clear();
+|  63|    |-		w << "Fetching information...";
+|  64|    |-		m_refresh_window = true;
+|  65|    |-		m_title = ToWString(m_service->name());
+|  66|    |-	}
+|    |  47|+    virtual
+|    |  48|+        std::wstring
+|    |  49|+    title ()
+|    |  50|+        override;
+|    |  51|+    virtual ScreenType
+|    |  52|+    type ()
+|    |  53|+        override
+|    |  54|+    {
+|    |  55|+        return ScreenType::Lastfm;
+|    |  56|+    }
+|  67|  57| 
+|  68|    |-private:
+|  69|    |-	std::wstring m_title;
+|  70|    |-	bool m_refresh_window;
+|  71|    |-	
+|  72|    |-	std::shared_ptr<LastFm::Service> m_service;
+|  73|    |-	boost::BOOST_THREAD_FUTURE<LastFm::Service::Result> m_worker;
+|    |  58|+    virtual void
+|    |  59|+    update ()
+|    |  60|+        override;
+|    |  61|+
+|    |  62|+    virtual bool
+|    |  63|+    isLockable ()
+|    |  64|+        override
+|    |  65|+    {
+|    |  66|+        return true;
+|    |  67|+    }
+|    |  68|+    virtual bool
+|    |  69|+    isMergable ()
+|    |  70|+        override
+|    |  71|+    {
+|    |  72|+        return true;
+|    |  73|+    }
+|    |  74|+
+|    |  75|+    template < typename ServiceT > void
+|    |  76|+    queueJob (ServiceT * service)
+|    |  77|+    {
+|    |  78|+        auto
+|    |  79|+            old_service = dynamic_cast < ServiceT * >(m_service.get ());
+|    |  80|+        // if the same service and arguments were used, leave old info
+|    |  81|+        if (old_service != nullptr && *old_service == *service)
+|    |  82|+            return;
+|    |  83|+
+|    |  84|+        m_service = std::shared_ptr < ServiceT > (service);
+|    |  85|+        m_worker = boost::async (boost::launch::async,
+|    |  86|+                                 std::bind (&LastFm::Service::fetch,
+|    |  87|+                                            m_service));
+|    |  88|+
+|    |  89|+        w.clear ();
+|    |  90|+        w << "Fetching information...";
+|    |  91|+        m_refresh_window = true;
+|    |  92|+        m_title = ToWString (m_service->name ());
+|    |  93|+    }
+|    |  94|+
+|    |  95|+  private:
+|    |  96|+    std::wstring m_title;
+|    |  97|+    bool
+|    |  98|+        m_refresh_window;
+|    |  99|+
+|    | 100|+    std::shared_ptr < LastFm::Service > m_service;
+|    | 101|+    boost::BOOST_THREAD_FUTURE < LastFm::Service::Result > m_worker;
+|  74| 102| };
+|  75| 103| 
+|  76| 104| extern Lastfm *myLastfm;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.h
+|    |++++| /app/src/screens/lastfm.h
+|  73|  73| 	boost::BOOST_THREAD_FUTURE<LastFm::Service::Result> m_worker;
+|  74|  74| };
+|  75|  75| 
+|  76|    |-extern Lastfm *myLastfm;
+|    |  76|+extern Lastfm *
+|    |  77|+    myLastfm;
+|  77|  78| 
+|  78|  79| #endif // NCMPCPP_LASTFM_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format_impl.h
+|    |++++| /app/src/format_impl.h
+|  30|  30| #include "utility/functional.h"
+|  31|  31| #include "utility/wide_string.h"
+|  32|  32| 
+|  33|    |-namespace Format {
+|    |  33|+namespace Format
+|    |  34|+{
+|  34|  35| 
+|  35|  36| // Commutative binary operation such that:
+|  36|  37| // - Empty + Empty = Empty
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format_impl.h
+|    |++++| /app/src/format_impl.h
+|  39|  39| // - Missing + Missing = Missing
+|  40|  40| // - Missing + Ok = Missing
+|  41|  41| // - Ok + Ok = Ok
+|  42|    |-inline Result &operator+=(Result &base, Result result)
+|  43|    |-{
+|  44|    |-	if (base == Result::Missing || result == Result::Missing)
+|  45|    |-		base = Result::Missing;
+|  46|    |-	else if (base == Result::Ok || result == Result::Ok)
+|  47|    |-		base = Result::Ok;
+|  48|    |-	return base;
+|  49|    |-}
+|    |  42|+    inline Result & operator+= (Result & base, Result result)
+|    |  43|+    {
+|    |  44|+        if (base == Result::Missing || result == Result::Missing)
+|    |  45|+            base = Result::Missing;
+|    |  46|+        else if (base == Result::Ok || result == Result::Ok)
+|    |  47|+            base = Result::Ok;
+|    |  48|+        return base;
+|    |  49|+    }
+|  50|  50| 
+|  51|  51| /*inline std::ostream &operator<<(std::ostream &os, Result r)
+|  52|  52| {
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format_impl.h
+|    |++++| /app/src/format_impl.h
+| 260| 260| 		boost::apply_visitor(visitor, ex);
+| 261| 261| }
+| 262| 262| 
+| 263|    |-template <typename CharT, typename ItemT>
+| 264|    |-void print(const AST<CharT> &ast, NC::Menu<ItemT> &menu, const MPD::Song *song,
+| 265|    |-           NC::BasicBuffer<CharT> *buffer, const unsigned flags)
+| 266|    |-{
+| 267|    |-	Printer<CharT, NC::Menu<ItemT>, NC::Buffer> printer(menu, song, buffer, flags);
+| 268|    |-	visit(printer, ast);
+| 269|    |-}
+| 270|    |-
+| 271|    |-template <typename CharT>
+| 272|    |-void print(const AST<CharT> &ast, NC::BasicBuffer<CharT> &buffer,
+| 273|    |-           const MPD::Song *song, const unsigned flags)
+| 274|    |-{
+| 275|    |-	Printer<CharT, NC::BasicBuffer<CharT>> printer(buffer, song, &buffer, flags);
+| 276|    |-	visit(printer, ast);
+| 277|    |-}
+| 278|    |-
+| 279|    |-template <typename CharT>
+| 280|    |-std::basic_string<CharT> stringify(const AST<CharT> &ast, const MPD::Song *song)
+| 281|    |-{
+| 282|    |-	std::basic_string<CharT> result;
+| 283|    |-	Printer<CharT, std::basic_string<CharT>> printer(result, song, &result, Flags::Tag);
+| 284|    |-	visit(printer, ast);
+| 285|    |-	return result;
+| 286|    |-}
+| 287|    |-
+| 288|    |-template <typename CharT>
+| 289|    |-TagVector<CharT> flatten(const AST<CharT> &ast, const MPD::Song &song)
+| 290|    |-{
+| 291|    |-	TagVector<CharT> result;
+| 292|    |-	Printer<CharT, TagVector<CharT>> printer(result, &song, &result, Flags::Tag);
+| 293|    |-	visit(printer, ast);
+| 294|    |-	return result;
+| 295|    |-}
+| 296|    |-
+| 297|    |-}
+| 298|    |-
+| 299| 263| #endif // NCMPCPP_HAVE_FORMAT__IMPL_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song.h
+|    |++++| /app/src/song.h
+|  29|  29| 
+|  30|  30| #include <mpd/client.h>
+|  31|  31| 
+|  32|    |-namespace MPD {
+|    |  32|+namespace MPD
+|    |  33|+{
+|  33|  34| 
+|  34|    |-struct Song
+|  35|    |-{
+|  36|    |-	struct Hash {
+|  37|    |-		size_t operator()(const Song &s) const { return s.m_hash; }
+|  38|    |-	};
+|    |  35|+    struct Song
+|    |  36|+    {
+|    |  37|+        struct Hash
+|    |  38|+        {
+|    |  39|+            size_t operator () (const Song & s) const
+|    |  40|+            {
+|    |  41|+                return s.m_hash;
+|    |  42|+            }
+|    |  43|+        };
+|  39|  44| 
+|  40|    |-	typedef std::string (Song::*GetFunction)(unsigned) const;
+|  41|    |-	
+|  42|    |-	Song() : m_hash(0) { }
+|  43|    |-	virtual ~Song() { }
+|  44|    |-	
+|  45|    |-	Song(mpd_song *s);
+|    |  45|+        typedef std::string (Song::*GetFunction) (unsigned) const;
+|  46|  46| 
+|  47|    |-	Song(const Song &rhs) : m_song(rhs.m_song), m_hash(rhs.m_hash) { }
+|  48|    |-	Song(Song &&rhs) : m_song(std::move(rhs.m_song)), m_hash(rhs.m_hash) { }
+|  49|    |-	Song &operator=(Song rhs)
+|  50|    |-	{
+|  51|    |-		m_song = std::move(rhs.m_song);
+|  52|    |-		m_hash = rhs.m_hash;
+|  53|    |-		return *this;
+|  54|    |-	}
+|  55|    |-	
+|  56|    |-	std::string get(mpd_tag_type type, unsigned idx = 0) const;
+|  57|    |-	
+|  58|    |-	virtual std::string getURI(unsigned idx = 0) const;
+|  59|    |-	virtual std::string getName(unsigned idx = 0) const;
+|  60|    |-	virtual std::string getDirectory(unsigned idx = 0) const;
+|  61|    |-	virtual std::string getArtist(unsigned idx = 0) const;
+|  62|    |-	virtual std::string getTitle(unsigned idx = 0) const;
+|  63|    |-	virtual std::string getAlbum(unsigned idx = 0) const;
+|  64|    |-	virtual std::string getAlbumArtist(unsigned idx = 0) const;
+|  65|    |-	virtual std::string getTrack(unsigned idx = 0) const;
+|  66|    |-	virtual std::string getTrackNumber(unsigned idx = 0) const;
+|  67|    |-	virtual std::string getDate(unsigned idx = 0) const;
+|  68|    |-	virtual std::string getGenre(unsigned idx = 0) const;
+|  69|    |-	virtual std::string getComposer(unsigned idx = 0) const;
+|  70|    |-	virtual std::string getPerformer(unsigned idx = 0) const;
+|  71|    |-	virtual std::string getDisc(unsigned idx = 0) const;
+|  72|    |-	virtual std::string getComment(unsigned idx = 0) const;
+|  73|    |-	virtual std::string getLength(unsigned idx = 0) const;
+|  74|    |-	virtual std::string getPriority(unsigned idx = 0) const;
+|  75|    |-	
+|  76|    |-	virtual std::string getTags(GetFunction f) const;
+|  77|    |-	
+|  78|    |-	virtual unsigned getDuration() const;
+|  79|    |-	virtual unsigned getPosition() const;
+|  80|    |-	virtual unsigned getID() const;
+|  81|    |-	virtual unsigned getPrio() const;
+|  82|    |-	virtual time_t getMTime() const;
+|  83|    |-	
+|  84|    |-	virtual bool isFromDatabase() const;
+|  85|    |-	virtual bool isStream() const;
+|  86|    |-	
+|  87|    |-	virtual bool empty() const;
+|  88|    |-	
+|  89|    |-	bool operator==(const Song &rhs) const
+|  90|    |-	{
+|  91|    |-		if (m_hash != rhs.m_hash)
+|  92|    |-			return false;
+|  93|    |-		return strcmp(c_uri(), rhs.c_uri()) == 0;
+|  94|    |-	}
+|  95|    |-	bool operator!=(const Song &rhs) const
+|  96|    |-	{
+|  97|    |-		return !(operator==(rhs));
+|  98|    |-	}
+|    |  47|+          Song ():m_hash (0)
+|    |  48|+        {
+|    |  49|+        }
+|    |  50|+        virtual ~ Song ()
+|    |  51|+        {
+|    |  52|+        }
+|  99|  53| 
+| 100|    |-	const char *c_uri() const { return m_song ? mpd_song_get_uri(m_song.get()) : ""; }
+|    |  54|+        Song (mpd_song * s);
+| 101|  55| 
+| 102|    |-	static std::string ShowTime(unsigned length);
+|    |  56|+        Song (const Song & rhs):m_song (rhs.m_song), m_hash (rhs.m_hash)
+|    |  57|+        {
+|    |  58|+        }
+|    |  59|+      Song (Song && rhs):m_song (std::move (rhs.m_song)),
+|    |  60|+            m_hash (rhs.m_hash)
+|    |  61|+        {
+|    |  62|+        }
+|    |  63|+        Song & operator= (Song rhs)
+|    |  64|+        {
+|    |  65|+            m_song = std::move (rhs.m_song);
+|    |  66|+            m_hash = rhs.m_hash;
+|    |  67|+            return *this;
+|    |  68|+        }
+| 103|  69| 
+| 104|    |-	static std::string TagsSeparator;
+|    |  70|+        std::string get (mpd_tag_type type, unsigned idx = 0) const;
+| 105|  71| 
+| 106|    |-	static bool ShowDuplicateTags;
+|    |  72|+        virtual std::string getURI (unsigned idx = 0) const;
+|    |  73|+        virtual std::string getName (unsigned idx = 0) const;
+|    |  74|+        virtual std::string getDirectory (unsigned idx = 0) const;
+|    |  75|+        virtual std::string getArtist (unsigned idx = 0) const;
+|    |  76|+        virtual std::string getTitle (unsigned idx = 0) const;
+|    |  77|+        virtual std::string getAlbum (unsigned idx = 0) const;
+|    |  78|+        virtual std::string getAlbumArtist (unsigned idx = 0) const;
+|    |  79|+        virtual std::string getTrack (unsigned idx = 0) const;
+|    |  80|+        virtual std::string getTrackNumber (unsigned idx = 0) const;
+|    |  81|+        virtual std::string getDate (unsigned idx = 0) const;
+|    |  82|+        virtual std::string getGenre (unsigned idx = 0) const;
+|    |  83|+        virtual std::string getComposer (unsigned idx = 0) const;
+|    |  84|+        virtual std::string getPerformer (unsigned idx = 0) const;
+|    |  85|+        virtual std::string getDisc (unsigned idx = 0) const;
+|    |  86|+        virtual std::string getComment (unsigned idx = 0) const;
+|    |  87|+        virtual std::string getLength (unsigned idx = 0) const;
+|    |  88|+        virtual std::string getPriority (unsigned idx = 0) const;
+| 107|  89| 
+| 108|    |-private:
+| 109|    |-	std::shared_ptr<mpd_song> m_song;
+| 110|    |-	size_t m_hash;
+| 111|    |-};
+|    |  90|+        virtual std::string getTags (GetFunction f) const;
+|    |  91|+
+|    |  92|+        virtual unsigned getDuration () const;
+|    |  93|+        virtual unsigned getPosition () const;
+|    |  94|+        virtual unsigned getID () const;
+|    |  95|+        virtual unsigned getPrio () const;
+|    |  96|+        virtual time_t getMTime () const;
+|    |  97|+
+|    |  98|+        virtual bool isFromDatabase () const;
+|    |  99|+        virtual bool isStream () const;
+|    | 100|+
+|    | 101|+        virtual bool empty () const;
+|    | 102|+
+|    | 103|+        bool operator== (const Song & rhs) const
+|    | 104|+        {
+|    | 105|+            if (m_hash != rhs.m_hash)
+|    | 106|+                return false;
+|    | 107|+            return strcmp (c_uri (), rhs.c_uri ()) == 0;
+|    | 108|+        }
+|    | 109|+        bool operator!= (const Song & rhs) const
+|    | 110|+        {
+|    | 111|+            return !(operator== (rhs));
+|    | 112|+        }
+|    | 113|+
+|    | 114|+        const char *c_uri () const
+|    | 115|+        {
+|    | 116|+            return m_song ? mpd_song_get_uri (m_song.get ()) : "";
+|    | 117|+        }
+|    | 118|+
+|    | 119|+        static std::string ShowTime (unsigned length);
+|    | 120|+
+|    | 121|+        static std::string TagsSeparator;
+|    | 122|+
+|    | 123|+        static bool ShowDuplicateTags;
+|    | 124|+
+|    | 125|+      private:
+|    | 126|+        std::shared_ptr < mpd_song > m_song;
+|    | 127|+        size_t m_hash;
+|    | 128|+    };
+| 112| 129| 
+| 113| 130| }
+| 114| 131| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song.h
+|    |++++| /app/src/song.h
+| 113| 113| }
+| 114| 114| 
+| 115| 115| #endif // NCMPCPP_SONG_H
+| 116|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/charset.h
+|    |++++| /app/src/charset.h
+|  24|  24| #include <locale>
+|  25|  25| #include <string>
+|  26|  26| 
+|  27|    |-namespace Charset {
+|    |  27|+namespace Charset
+|    |  28|+{
+|  28|  29| 
+|  29|    |-std::locale internalLocale();
+|    |  30|+    std::locale internalLocale ();
+|  30|  31| 
+|  31|    |-std::string toUtf8From(const std::string &s, const char *charset);
+|  32|    |-std::string fromUtf8To(const std::string &s, const char *charset);
+|    |  32|+    std::string toUtf8From (const std::string & s, const char *charset);
+|    |  33|+      std::string fromUtf8To (const std::string & s, const char *charset);
+|  33|  34| 
+|  34|    |-std::string utf8ToLocale(const std::string &s);
+|  35|    |-std::string utf8ToLocale(std::string &&s);
+|  36|    |-std::string localeToUtf8(const std::string &s);
+|  37|    |-std::string localeToUtf8(std::string &&s);
+|    |  35|+      std::string utf8ToLocale (const std::string & s);
+|    |  36|+      std::string utf8ToLocale (std::string && s);
+|    |  37|+      std::string localeToUtf8 (const std::string & s);
+|    |  38|+      std::string localeToUtf8 (std::string && s);
+|  38|  39| 
+|  39|  40| }
+|  40|  41| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/charset.h
+|    |++++| /app/src/charset.h
+|  38|  38| 
+|  39|  39| }
+|  40|  40| 
+|  41|    |-#endif // NCMPCPP_CHARSET_H
+|    |  41|+#endif                          // NCMPCPP_CHARSET_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.h
+|    |++++| /app/src/screens/playlist_editor.h
+|  28|  28| #include "screens/screen.h"
+|  29|  29| #include "song_list.h"
+|  30|  30| 
+|  31|    |-struct PlaylistEditor: Screen<NC::Window *>, Filterable, HasColumns, HasSongs, Searchable, Tabbable
+|    |  31|+struct PlaylistEditor:Screen <
+|    |  32|+NC::Window * >,
+|    |  33|+    Filterable,
+|    |  34|+    HasColumns,
+|    |  35|+    HasSongs,
+|    |  36|+    Searchable,
+|    |  37|+    Tabbable
+|  32|  38| {
+|  33|    |-	PlaylistEditor();
+|  34|    |-	
+|  35|    |-	virtual void switchTo() override;
+|  36|    |-	virtual void resize() override;
+|  37|    |-	
+|  38|    |-	virtual std::wstring title() override;
+|  39|    |-	virtual ScreenType type() override { return ScreenType::PlaylistEditor; }
+|  40|    |-	
+|  41|    |-	virtual void refresh() override;
+|  42|    |-	virtual void update() override;
+|  43|    |-	
+|  44|    |-	virtual int windowTimeout() override;
+|    |  39|+    PlaylistEditor ();
+|  45|  40| 
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// Searchable implementation
+|  52|    |-	virtual bool allowsSearching() override;
+|  53|    |-	virtual const std::string &searchConstraint() override;
+|  54|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  55|    |-	virtual void clearSearchConstraint() override;
+|  56|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|  57|  47| 
+|  58|    |-	// Filterable implementation
+|  59|    |-	virtual bool allowsFiltering() override;
+|  60|    |-	virtual std::string currentFilter() override;
+|  61|    |-	virtual void applyFilter(const std::string &filter) override;
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::PlaylistEditor;
+|    |  57|+    }
+|  62|  58| 
+|  63|    |-	// HasSongs implementation
+|  64|    |-	virtual bool itemAvailable() override;
+|  65|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  66|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  67|    |-	
+|  68|    |-	// HasColumns implementation
+|  69|    |-	virtual bool previousColumnAvailable() override;
+|  70|    |-	virtual void previousColumn() override;
+|  71|    |-	
+|  72|    |-	virtual bool nextColumnAvailable() override;
+|  73|    |-	virtual void nextColumn() override;
+|  74|    |-	
+|  75|    |-	// private members
+|  76|    |-	void updateTimer();
+|    |  59|+    virtual void
+|    |  60|+    refresh ()
+|    |  61|+        override;
+|    |  62|+    virtual void
+|    |  63|+    update ()
+|    |  64|+        override;
+|  77|  65| 
+|  78|    |-	void requestPlaylistsUpdate() { m_playlists_update_requested = true; }
+|  79|    |-	void requestContentUpdate() { m_content_update_requested = true; }
+|  80|    |-	
+|  81|    |-	void locatePlaylist(const MPD::Playlist &playlist);
+|  82|    |-	void locateSong(const MPD::Song &s);
+|    |  66|+    virtual int
+|    |  67|+    windowTimeout ()
+|    |  68|+        override;
+|  83|  69| 
+|  84|    |-	NC::Menu<MPD::Playlist> Playlists;
+|  85|    |-	SongMenu Content;
+|  86|    |-	
+|  87|    |-private:
+|  88|    |-	bool m_playlists_update_requested;
+|  89|    |-	bool m_content_update_requested;
+|    |  70|+    virtual void
+|    |  71|+    mouseButtonPressed (MEVENT me)
+|    |  72|+        override;
+|  90|  73| 
+|  91|    |-	boost::posix_time::ptime m_timer;
+|    |  74|+    virtual bool
+|    |  75|+    isLockable ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return true;
+|    |  79|+    }
+|    |  80|+    virtual bool
+|    |  81|+    isMergable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|  92|  86| 
+|  93|    |-	const int m_window_timeout;
+|  94|    |-	const boost::posix_time::time_duration m_fetching_delay;
+|    |  87|+    // Searchable implementation
+|    |  88|+    virtual bool
+|    |  89|+    allowsSearching ()
+|    |  90|+        override;
+|    |  91|+    virtual const
+|    |  92|+        std::string &
+|    |  93|+    searchConstraint ()
+|    |  94|+        override;
+|    |  95|+    virtual void
+|    |  96|+    setSearchConstraint (const std::string & constraint)
+|    |  97|+        override;
+|    |  98|+    virtual void
+|    |  99|+    clearSearchConstraint ()
+|    | 100|+        override;
+|    | 101|+    virtual bool
+|    | 102|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 103|+        override;
+|  95| 104| 
+|  96|    |-	Regex::Filter<MPD::Playlist> m_playlists_search_predicate;
+|  97|    |-	Regex::Filter<MPD::Song> m_content_search_predicate;
+|    | 105|+    // Filterable implementation
+|    | 106|+    virtual bool
+|    | 107|+    allowsFiltering ()
+|    | 108|+        override;
+|    | 109|+    virtual
+|    | 110|+        std::string
+|    | 111|+    currentFilter ()
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    applyFilter (const std::string & filter)
+|    | 115|+        override;
+|    | 116|+
+|    | 117|+    // HasSongs implementation
+|    | 118|+    virtual bool
+|    | 119|+    itemAvailable ()
+|    | 120|+        override;
+|    | 121|+    virtual bool
+|    | 122|+    addItemToPlaylist (bool play)
+|    | 123|+        override;
+|    | 124|+    virtual
+|    | 125|+        std::vector <
+|    | 126|+        MPD::Song >
+|    | 127|+    getSelectedSongs ()
+|    | 128|+        override;
+|    | 129|+
+|    | 130|+    // HasColumns implementation
+|    | 131|+    virtual bool
+|    | 132|+    previousColumnAvailable ()
+|    | 133|+        override;
+|    | 134|+    virtual void
+|    | 135|+    previousColumn ()
+|    | 136|+        override;
+|    | 137|+
+|    | 138|+    virtual bool
+|    | 139|+    nextColumnAvailable ()
+|    | 140|+        override;
+|    | 141|+    virtual void
+|    | 142|+    nextColumn ()
+|    | 143|+        override;
+|    | 144|+
+|    | 145|+    // private members
+|    | 146|+    void
+|    | 147|+    updateTimer ();
+|    | 148|+
+|    | 149|+    void
+|    | 150|+    requestPlaylistsUpdate ()
+|    | 151|+    {
+|    | 152|+        m_playlists_update_requested = true;
+|    | 153|+    }
+|    | 154|+    void
+|    | 155|+    requestContentUpdate ()
+|    | 156|+    {
+|    | 157|+        m_content_update_requested = true;
+|    | 158|+    }
+|    | 159|+
+|    | 160|+    void
+|    | 161|+    locatePlaylist (const MPD::Playlist & playlist);
+|    | 162|+    void
+|    | 163|+    locateSong (const MPD::Song & s);
+|    | 164|+
+|    | 165|+    NC::Menu < MPD::Playlist > Playlists;
+|    | 166|+    SongMenu
+|    | 167|+        Content;
+|    | 168|+
+|    | 169|+  private:
+|    | 170|+    bool m_playlists_update_requested;
+|    | 171|+    bool
+|    | 172|+        m_content_update_requested;
+|    | 173|+
+|    | 174|+    boost::posix_time::ptime m_timer;
+|    | 175|+
+|    | 176|+    const int
+|    | 177|+        m_window_timeout;
+|    | 178|+    const
+|    | 179|+        boost::posix_time::time_duration
+|    | 180|+        m_fetching_delay;
+|    | 181|+
+|    | 182|+    Regex::Filter < MPD::Playlist > m_playlists_search_predicate;
+|    | 183|+    Regex::Filter < MPD::Song > m_content_search_predicate;
+|  98| 184| };
+|  99| 185| 
+| 100| 186| extern PlaylistEditor *myPlaylistEditor;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.h
+|    |++++| /app/src/screens/playlist_editor.h
+|  97|  97| 	Regex::Filter<MPD::Song> m_content_search_predicate;
+|  98|  98| };
+|  99|  99| 
+| 100|    |-extern PlaylistEditor *myPlaylistEditor;
+|    | 100|+extern PlaylistEditor *
+|    | 101|+    myPlaylistEditor;
+| 101| 102| 
+| 102| 103| #endif // NCMPCPP_PLAYLIST_EDITOR_H
+| 103| 104| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.h
+|    |++++| /app/src/screens/playlist_editor.h
+| 100| 100| extern PlaylistEditor *myPlaylistEditor;
+| 101| 101| 
+| 102| 102| #endif // NCMPCPP_PLAYLIST_EDITOR_H
+| 103|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/wide_string.h
+|    |++++| /app/src/utility/wide_string.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_WIDE_STRING_H
+|  22|  22| #define NCMPCPP_UTILITY_WIDE_STRING_H
+|  23|  23| 
+|  24|    |-#include <string> // include before boost to compile on MACOSX
+|    |  24|+#include <string>               // include before boost to compile on MACOSX
+|  25|  25| #include <boost/locale/encoding_utf.hpp>
+|  26|  26| 
+|  27|  27| template <typename StringT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/wide_string.h
+|    |++++| /app/src/utility/wide_string.h
+|  24|  24| #include <string> // include before boost to compile on MACOSX
+|  25|  25| #include <boost/locale/encoding_utf.hpp>
+|  26|  26| 
+|  27|    |-template <typename StringT>
+|  28|    |-std::string ToString(StringT &&s)
+|    |  27|+template < typename StringT > std::string ToString (StringT && s)
+|  29|  28| {
+|  30|    |-	return boost::locale::conv::utf_to_utf<char>(std::forward<StringT>(s));
+|    |  29|+    return boost::locale::conv::utf_to_utf < char >(std::forward < StringT >
+|    |  30|+                                                    (s));
+|  31|  31| }
+|  32|    |-template <typename StringT>
+|  33|    |-std::wstring ToWString(StringT &&s)
+|    |  32|+template < typename StringT > std::wstring ToWString (StringT && s)
+|  34|  33| {
+|  35|    |-	return boost::locale::conv::utf_to_utf<wchar_t>(std::forward<StringT>(s));
+|    |  34|+    return boost::locale::conv::utf_to_utf < wchar_t > (std::forward <
+|    |  35|+                                                        StringT > (s));
+|  36|  36| }
+|  37|  37| 
+|  38|  38| size_t wideLength(const std::wstring &ws);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/wide_string.h
+|    |++++| /app/src/utility/wide_string.h
+|  35|  35| 	return boost::locale::conv::utf_to_utf<wchar_t>(std::forward<StringT>(s));
+|  36|  36| }
+|  37|  37| 
+|  38|    |-size_t wideLength(const std::wstring &ws);
+|  39|    |-void wideCut(std::wstring &ws, size_t max_length);
+|    |  38|+size_t
+|    |  39|+wideLength (const std::wstring & ws);
+|    |  40|+void
+|    |  41|+wideCut (std::wstring & ws, size_t max_length);
+|  40|  42| 
+|  41|    |-std::wstring wideShorten(const std::wstring &ws, size_t max_length);
+|  42|    |-inline std::string wideShorten(const std::string &s, size_t max_length)
+|    |  43|+std::wstring wideShorten (const std::wstring & ws, size_t max_length);
+|    |  44|+inline
+|    |  45|+    std::string
+|    |  46|+wideShorten (const std::string & s, size_t max_length)
+|  43|  47| {
+|  44|    |-	return ToString(wideShorten(ToWString(s), max_length));
+|    |  48|+    return ToString (wideShorten (ToWString (s), max_length));
+|  45|  49| }
+|  46|  50| 
+|  47|  51| #endif // NCMPCPP_UTILITY_WIDE_STRING_h
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/lyrics_fetcher.h
+|    |++++| /app/src/lyrics_fetcher.h
+|  28|  28| 
+|  29|  29| struct LyricsFetcher
+|  30|  30| {
+|  31|    |-	typedef std::pair<bool, std::string> Result;
+|    |  31|+    typedef std::pair < bool, std::string > Result;
+|  32|  32| 
+|  33|    |-	virtual ~LyricsFetcher() { }
+|    |  33|+      virtual ~ LyricsFetcher ()
+|    |  34|+    {
+|    |  35|+    }
+|  34|  36| 
+|  35|    |-	virtual const char *name() const = 0;
+|  36|    |-	virtual Result fetch(const std::string &artist, const std::string &title);
+|  37|    |-	
+|  38|    |-protected:
+|  39|    |-	virtual const char *urlTemplate() const = 0;
+|  40|    |-	virtual const char *regex() const = 0;
+|  41|    |-	
+|  42|    |-	virtual bool notLyrics(const std::string &) const { return false; }
+|  43|    |-	virtual void postProcess(std::string &data) const;
+|  44|    |-	
+|  45|    |-	std::vector<std::string> getContent(const char *regex, const std::string &data);
+|  46|    |-	
+|  47|    |-	static const char msgNotFound[];
+|    |  37|+    virtual const char *name () const = 0;
+|    |  38|+    virtual Result fetch (const std::string & artist,
+|    |  39|+                          const std::string & title);
+|    |  40|+
+|    |  41|+  protected:
+|    |  42|+    virtual const char *urlTemplate () const = 0;
+|    |  43|+    virtual const char *regex () const = 0;
+|    |  44|+
+|    |  45|+    virtual bool notLyrics (const std::string &) const
+|    |  46|+    {
+|    |  47|+        return false;
+|    |  48|+    }
+|    |  49|+    virtual void postProcess (std::string & data) const;
+|    |  50|+
+|    |  51|+    std::vector < std::string > getContent (const char *regex,
+|    |  52|+                                            const std::string & data);
+|    |  53|+
+|    |  54|+    static const char msgNotFound[];
+|  48|  55| };
+|  49|  56| 
+|  50|    |-typedef std::unique_ptr<LyricsFetcher> LyricsFetcher_;
+|    |  57|+typedef
+|    |  58|+    std::unique_ptr <
+|    |  59|+    LyricsFetcher >
+|    |  60|+    LyricsFetcher_;
+|  51|  61| 
+|  52|    |-typedef std::vector<LyricsFetcher_> LyricsFetchers;
+|    |  62|+typedef
+|    |  63|+    std::vector <
+|    |  64|+    LyricsFetcher_ >
+|    |  65|+    LyricsFetchers;
+|  53|  66| 
+|  54|    |-std::istream &operator>>(std::istream &is, LyricsFetcher_ &fetcher);
+|    |  67|+std::istream & operator>> (std::istream & is, LyricsFetcher_ & fetcher);
+|  55|  68| 
+|  56|  69| /**********************************************************************/
+|  57|  70| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/lyrics_fetcher.h
+|    |++++| /app/src/lyrics_fetcher.h
+|  55|  55| 
+|  56|  56| /**********************************************************************/
+|  57|  57| 
+|  58|    |-struct LyricwikiFetcher : public LyricsFetcher
+|    |  58|+struct LyricwikiFetcher:public LyricsFetcher
+|  59|  59| {
+|  60|    |-	virtual const char *name() const override { return "lyricwiki.com"; }
+|  61|    |-	virtual Result fetch(const std::string &artist, const std::string &title) override;
+|  62|    |-	
+|  63|    |-protected:
+|  64|    |-	virtual const char *urlTemplate() const override { return "http://lyrics.wikia.com/api.php?action=lyrics&fmt=xml&func=getSong&artist=%artist%&song=%title%"; }
+|  65|    |-	virtual const char *regex() const override { return "<url>(.*?)</url>"; }
+|  66|    |-	
+|  67|    |-	virtual bool notLyrics(const std::string &data) const override;
+|    |  60|+    virtual const char *name () const override
+|    |  61|+    {
+|    |  62|+        return "lyricwiki.com";
+|    |  63|+    }
+|    |  64|+    virtual Result fetch (const std::string & artist,
+|    |  65|+                          const std::string & title) override;
+|    |  66|+
+|    |  67|+  protected:
+|    |  68|+      virtual const char *urlTemplate () const override
+|    |  69|+    {
+|    |  70|+        return
+|    |  71|+            "http://lyrics.wikia.com/api.php?action=lyrics&fmt=xml&func=getSong&artist=%artist%&song=%title%";
+|    |  72|+    }
+|    |  73|+    virtual const char *regex () const override
+|    |  74|+    {
+|    |  75|+        return "<url>(.*?)</url>";
+|    |  76|+    }
+|    |  77|+
+|    |  78|+    virtual bool notLyrics (const std::string & data) const override;
+|  68|  79| };
+|  69|  80| 
+|  70|  81| /**********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/lyrics_fetcher.h
+|    |++++| /app/src/lyrics_fetcher.h
+|  69|  69| 
+|  70|  70| /**********************************************************************/
+|  71|  71| 
+|  72|    |-struct GoogleLyricsFetcher : public LyricsFetcher
+|  73|    |-{
+|  74|    |-	virtual Result fetch(const std::string &artist, const std::string &title);
+|  75|    |-	
+|  76|    |-protected:
+|  77|    |-	virtual const char *urlTemplate() const { return URL; }
+|  78|    |-	virtual const char *siteKeyword() const { return name(); }
+|  79|    |-	
+|  80|    |-	virtual bool isURLOk(const std::string &url);
+|  81|    |-	
+|  82|    |-private:
+|  83|    |-	const char *URL;
+|  84|    |-};
+|  85|    |-
+|  86|    |-struct MetrolyricsFetcher : public GoogleLyricsFetcher
+|  87|    |-{
+|  88|    |-	virtual const char *name() const override { return "metrolyrics.com"; }
+|  89|    |-	
+|  90|    |-protected:
+|  91|    |-	virtual const char *regex() const override { return "<div class=\"lyrics-body\">(.*?)</div>"; }
+|  92|    |-	
+|  93|    |-	virtual bool isURLOk(const std::string &url) override;
+|  94|    |-};
+|  95|    |-
+|  96|    |-struct LyricsmaniaFetcher : public GoogleLyricsFetcher
+|  97|    |-{
+|  98|    |-	virtual const char *name() const override { return "lyricsmania.com"; }
+|  99|    |-	
+| 100|    |-protected:
+| 101|    |-	virtual const char *regex() const override { return "<div class=\"lyrics-body\".*?</strong>(.*?)</div>"; }
+| 102|    |-};
+| 103|    |-
+| 104|    |-struct Sing365Fetcher : public GoogleLyricsFetcher
+| 105|    |-{
+| 106|    |-	virtual const char *name() const override { return "sing365.com"; }
+| 107|    |-	
+| 108|    |-protected:
+| 109|    |-	virtual const char *regex() const override { return "<div class=\"content\">.*?</script>(.*?)<script>"; }
+| 110|    |-};
+| 111|    |-
+| 112|    |-struct JustSomeLyricsFetcher : public GoogleLyricsFetcher
+| 113|    |-{
+| 114|    |-	virtual const char *name() const override { return "justsomelyrics.com"; }
+| 115|    |-	
+| 116|    |-protected:
+| 117|    |-	virtual const char *regex() const override { return "<div class=\"content.*?</div>(.*?)See also"; }
+| 118|    |-};
+| 119|    |-
+| 120|    |-struct AzLyricsFetcher : public GoogleLyricsFetcher
+| 121|    |-{
+| 122|    |-	virtual const char *name() const override { return "azlyrics.com"; }
+| 123|    |-	
+| 124|    |-protected:
+| 125|    |-	virtual const char *regex() const override { return "<div class=\"lyricsh\">.*?</h2>.*<div>(.*?)</div>"; }
+| 126|    |-};
+| 127|    |-
+| 128|    |-struct GeniusFetcher : public GoogleLyricsFetcher
+| 129|    |-{
+| 130|    |-	virtual const char *name() const override { return "genius.com"; }
+| 131|    |-
+| 132|    |-protected:
+| 133|    |-	virtual const char *regex() const override { return "<div class=\"lyrics\">(.*?)</div>"; }
+| 134|    |-};
+| 135|    |-
+| 136|    |-struct JahLyricsFetcher : public GoogleLyricsFetcher
+| 137|    |-{
+| 138|    |-	virtual const char *name() const override { return "jah-lyrics.com"; }
+| 139|    |-
+| 140|    |-protected:
+| 141|    |-	virtual const char *regex() const override { return "<div class=\"song-header\">.*?</div>(.*?)<p class=\"disclaimer\">"; }
+| 142|    |-};
+| 143|    |-
+| 144|    |-struct PLyricsFetcher : public GoogleLyricsFetcher
+| 145|    |-{
+| 146|    |-	virtual const char *name() const override { return "plyrics.com"; }
+| 147|    |-
+| 148|    |-protected:
+| 149|    |-	virtual const char *regex() const override { return "<!-- start of lyrics -->(.*?)<!-- end of lyrics -->"; }
+| 150|    |-};
+| 151|    |-
+| 152|    |-struct TekstowoFetcher : public GoogleLyricsFetcher
+| 153|    |-{
+| 154|    |-	virtual const char *name() const override { return "tekstowo.pl"; }
+| 155|    |-
+| 156|    |-protected:
+| 157|    |-	virtual const char *regex() const override { return "<div class=\"song-text\">.*?</h2>(.*?)<a"; }
+| 158|    |-};
+| 159|    |-
+| 160|    |-struct InternetLyricsFetcher : public GoogleLyricsFetcher
+| 161|    |-{
+| 162|    |-	virtual const char *name() const override { return "the Internet"; }
+| 163|    |-	virtual Result fetch(const std::string &artist, const std::string &title) override;
+| 164|    |-	
+| 165|    |-protected:
+| 166|    |-	virtual const char *siteKeyword() const override { return nullptr; }
+| 167|    |-	virtual const char *regex() const override { return ""; }
+| 168|    |-	
+| 169|    |-	virtual bool isURLOk(const std::string &url) override;
+| 170|    |-	
+| 171|    |-private:
+| 172|    |-	std::string URL;
+|    |  72|+struct GoogleLyricsFetcher:public LyricsFetcher
+|    |  73|+{
+|    |  74|+    virtual Result fetch (const std::string & artist,
+|    |  75|+                          const std::string & title);
+|    |  76|+
+|    |  77|+  protected:
+|    |  78|+      virtual const char *urlTemplate () const
+|    |  79|+    {
+|    |  80|+        return URL;
+|    |  81|+    }
+|    |  82|+    virtual const char *siteKeyword () const
+|    |  83|+    {
+|    |  84|+        return name ();
+|    |  85|+    }
+|    |  86|+
+|    |  87|+    virtual bool isURLOk (const std::string & url);
+|    |  88|+
+|    |  89|+  private:
+|    |  90|+    const char *URL;
+|    |  91|+};
+|    |  92|+
+|    |  93|+struct MetrolyricsFetcher:public GoogleLyricsFetcher
+|    |  94|+{
+|    |  95|+    virtual const char *name () const override
+|    |  96|+    {
+|    |  97|+        return "metrolyrics.com";
+|    |  98|+    }
+|    |  99|+
+|    | 100|+  protected:
+|    | 101|+      virtual const char *regex () const override
+|    | 102|+    {
+|    | 103|+        return "<div class=\"lyrics-body\">(.*?)</div>";
+|    | 104|+    }
+|    | 105|+
+|    | 106|+    virtual bool isURLOk (const std::string & url) override;
+|    | 107|+};
+|    | 108|+
+|    | 109|+struct LyricsmaniaFetcher:public GoogleLyricsFetcher
+|    | 110|+{
+|    | 111|+    virtual const char *name () const override
+|    | 112|+    {
+|    | 113|+        return "lyricsmania.com";
+|    | 114|+    }
+|    | 115|+
+|    | 116|+  protected:
+|    | 117|+      virtual const char *regex () const override
+|    | 118|+    {
+|    | 119|+        return "<div class=\"lyrics-body\".*?</strong>(.*?)</div>";
+|    | 120|+    }
+|    | 121|+};
+|    | 122|+
+|    | 123|+struct Sing365Fetcher:public GoogleLyricsFetcher
+|    | 124|+{
+|    | 125|+    virtual const char *name () const override
+|    | 126|+    {
+|    | 127|+        return "sing365.com";
+|    | 128|+    }
+|    | 129|+
+|    | 130|+  protected:
+|    | 131|+      virtual const char *regex () const override
+|    | 132|+    {
+|    | 133|+        return "<div class=\"content\">.*?</script>(.*?)<script>";
+|    | 134|+    }
+|    | 135|+};
+|    | 136|+
+|    | 137|+struct JustSomeLyricsFetcher:public GoogleLyricsFetcher
+|    | 138|+{
+|    | 139|+    virtual const char *name () const override
+|    | 140|+    {
+|    | 141|+        return "justsomelyrics.com";
+|    | 142|+    }
+|    | 143|+
+|    | 144|+  protected:
+|    | 145|+      virtual const char *regex () const override
+|    | 146|+    {
+|    | 147|+        return "<div class=\"content.*?</div>(.*?)See also";
+|    | 148|+    }
+|    | 149|+};
+|    | 150|+
+|    | 151|+struct AzLyricsFetcher:public GoogleLyricsFetcher
+|    | 152|+{
+|    | 153|+    virtual const char *name () const override
+|    | 154|+    {
+|    | 155|+        return "azlyrics.com";
+|    | 156|+    }
+|    | 157|+
+|    | 158|+  protected:
+|    | 159|+      virtual const char *regex () const override
+|    | 160|+    {
+|    | 161|+        return "<div class=\"lyricsh\">.*?</h2>.*<div>(.*?)</div>";
+|    | 162|+    }
+|    | 163|+};
+|    | 164|+
+|    | 165|+struct GeniusFetcher:public GoogleLyricsFetcher
+|    | 166|+{
+|    | 167|+    virtual const char *name () const override
+|    | 168|+    {
+|    | 169|+        return "genius.com";
+|    | 170|+    }
+|    | 171|+
+|    | 172|+  protected:
+|    | 173|+      virtual const char *regex () const override
+|    | 174|+    {
+|    | 175|+        return "<div class=\"lyrics\">(.*?)</div>";
+|    | 176|+    }
+|    | 177|+};
+|    | 178|+
+|    | 179|+struct JahLyricsFetcher:public GoogleLyricsFetcher
+|    | 180|+{
+|    | 181|+    virtual const char *name () const override
+|    | 182|+    {
+|    | 183|+        return "jah-lyrics.com";
+|    | 184|+    }
+|    | 185|+
+|    | 186|+  protected:
+|    | 187|+      virtual const char *regex () const override
+|    | 188|+    {
+|    | 189|+        return
+|    | 190|+            "<div class=\"song-header\">.*?</div>(.*?)<p class=\"disclaimer\">";
+|    | 191|+    }
+|    | 192|+};
+|    | 193|+
+|    | 194|+struct PLyricsFetcher:public GoogleLyricsFetcher
+|    | 195|+{
+|    | 196|+    virtual const char *name () const override
+|    | 197|+    {
+|    | 198|+        return "plyrics.com";
+|    | 199|+    }
+|    | 200|+
+|    | 201|+  protected:
+|    | 202|+      virtual const char *regex () const override
+|    | 203|+    {
+|    | 204|+        return "<!-- start of lyrics -->(.*?)<!-- end of lyrics -->";
+|    | 205|+    }
+|    | 206|+};
+|    | 207|+
+|    | 208|+struct TekstowoFetcher:public GoogleLyricsFetcher
+|    | 209|+{
+|    | 210|+    virtual const char *name () const override
+|    | 211|+    {
+|    | 212|+        return "tekstowo.pl";
+|    | 213|+    }
+|    | 214|+
+|    | 215|+  protected:
+|    | 216|+      virtual const char *regex () const override
+|    | 217|+    {
+|    | 218|+        return "<div class=\"song-text\">.*?</h2>(.*?)<a";
+|    | 219|+    }
+|    | 220|+};
+|    | 221|+
+|    | 222|+struct InternetLyricsFetcher:public GoogleLyricsFetcher
+|    | 223|+{
+|    | 224|+    virtual const char *name () const override
+|    | 225|+    {
+|    | 226|+        return "the Internet";
+|    | 227|+    }
+|    | 228|+    virtual Result fetch (const std::string & artist,
+|    | 229|+                          const std::string & title) override;
+|    | 230|+
+|    | 231|+  protected:
+|    | 232|+      virtual const char *siteKeyword () const override
+|    | 233|+    {
+|    | 234|+        return nullptr;
+|    | 235|+    }
+|    | 236|+    virtual const char *regex () const override
+|    | 237|+    {
+|    | 238|+        return "";
+|    | 239|+    }
+|    | 240|+
+|    | 241|+    virtual bool isURLOk (const std::string & url) override;
+|    | 242|+
+|    | 243|+  private:
+|    | 244|+      std::string URL;
+| 173| 245| };
+| 174| 246| 
+| 175| 247| #endif // NCMPCPP_LYRICS_FETCHER_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen_switcher.h
+|    |++++| /app/src/screens/screen_switcher.h
+|  25|  25| 
+|  26|  26| class SwitchTo
+|  27|  27| {
+|  28|    |-	template <bool ToBeExecuted, typename ScreenT> struct TabbableAction_ {
+|  29|    |-		static void execute(ScreenT *) { }
+|  30|    |-	};
+|  31|    |-	template <typename ScreenT> struct TabbableAction_<true, ScreenT> {
+|  32|    |-		static void execute(ScreenT *screen) {
+|  33|    |-			using Global::myScreen;
+|  34|    |-			// it has to work only if both current and previous screens are Tabbable
+|  35|    |-			if (dynamic_cast<Tabbable *>(myScreen))
+|  36|    |-				screen->setPreviousScreen(myScreen);
+|  37|    |-		}
+|  38|    |-	};
+|  39|    |-	
+|  40|    |-public:
+|  41|    |-	template <typename ScreenT>
+|  42|    |-	static void execute(ScreenT *screen)
+|  43|    |-	{
+|  44|    |-		using Global::myScreen;
+|  45|    |-		using Global::myLockedScreen;
+|  46|    |-		
+|  47|    |-		const bool isScreenMergable = screen->isMergable() && myLockedScreen;
+|  48|    |-		const bool isScreenTabbable = std::is_base_of<Tabbable, ScreenT>::value;
+|  49|    |-		
+|  50|    |-		assert(myScreen != screen);
+|  51|    |-		if (isScreenMergable)
+|  52|    |-			updateInactiveScreen(screen);
+|  53|    |-		if (screen->hasToBeResized || isScreenMergable)
+|  54|    |-			screen->resize();
+|  55|    |-		TabbableAction_<isScreenTabbable, ScreenT>::execute(screen);
+|  56|    |-		myScreen = screen;
+|  57|    |-	}
+|    |  28|+    template < bool ToBeExecuted, typename ScreenT > struct TabbableAction_
+|    |  29|+    {
+|    |  30|+        static void execute (ScreenT *)
+|    |  31|+        {
+|    |  32|+        }
+|    |  33|+    };
+|    |  34|+    template < typename ScreenT > struct TabbableAction_ <true, ScreenT >
+|    |  35|+    {
+|    |  36|+        static void execute (ScreenT * screen)
+|    |  37|+        {
+|    |  38|+            using Global::myScreen;
+|    |  39|+            // it has to work only if both current and previous screens are Tabbable
+|    |  40|+            if (dynamic_cast < Tabbable * >(myScreen))
+|    |  41|+                  screen->setPreviousScreen (myScreen);
+|    |  42|+        }
+|    |  43|+    };
+|    |  44|+
+|    |  45|+  public:
+|    |  46|+    template < typename ScreenT > static void execute (ScreenT * screen)
+|    |  47|+    {
+|    |  48|+        using Global::myScreen;
+|    |  49|+        using Global::myLockedScreen;
+|    |  50|+
+|    |  51|+        const bool isScreenMergable = screen->isMergable () && myLockedScreen;
+|    |  52|+        const bool isScreenTabbable =
+|    |  53|+            std::is_base_of < Tabbable, ScreenT >::value;
+|    |  54|+
+|    |  55|+        assert (myScreen != screen);
+|    |  56|+        if (isScreenMergable)
+|    |  57|+            updateInactiveScreen (screen);
+|    |  58|+        if (screen->hasToBeResized || isScreenMergable)
+|    |  59|+            screen->resize ();
+|    |  60|+        TabbableAction_ < isScreenTabbable, ScreenT >::execute (screen);
+|    |  61|+        myScreen = screen;
+|    |  62|+    }
+|  58|  63| };
+|  59|  64| 
+|  60|  65| #endif // NCMPCPP_SCREEN_SWITCHER_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/title.h
+|    |++++| /app/src/title.h
+|  23|  23| 
+|  24|  24| #include "curses/window.h"
+|  25|  25| 
+|  26|    |-void windowTitle(const std::string &title);
+|    |  26|+void windowTitle (const std::string & title);
+|  27|  27| 
+|  28|    |-void drawHeader();
+|    |  28|+void drawHeader ();
+|  29|  29| 
+|  30|  30| #endif // NCMPCPP_TITLE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/comparators.h
+|    |++++| /app/src/utility/comparators.h
+|  29|  29| 
+|  30|  30| class LocaleStringComparison
+|  31|  31| {
+|  32|    |-	std::locale m_locale;
+|  33|    |-	bool m_ignore_the;
+|  34|    |-	
+|  35|    |-public:
+|  36|    |-	LocaleStringComparison(const std::locale &loc, bool ignore_the)
+|  37|    |-	: m_locale(loc), m_ignore_the(ignore_the) { }
+|    |  32|+    std::locale m_locale;
+|    |  33|+    bool m_ignore_the;
+|  38|  34| 
+|  39|    |-	int operator()(const char *a, const char *b) const {
+|  40|    |-		return compare(a, strlen(a), b, strlen(b));
+|  41|    |-	}
+|  42|    |-	int operator()(const std::string &a, const std::string &b) const {
+|  43|    |-		return compare(a.c_str(), a.length(), b.c_str(), b.length());
+|  44|    |-	}
+|    |  35|+  public:
+|    |  36|+      LocaleStringComparison (const std::locale & loc,
+|    |  37|+                              bool ignore_the):m_locale (loc),
+|    |  38|+        m_ignore_the (ignore_the)
+|    |  39|+    {
+|    |  40|+    }
+|  45|  41| 
+|  46|    |-	int compare(const char *a, size_t a_len, const char *b, size_t b_len) const;
+|    |  42|+    int operator () (const char *a, const char *b) const
+|    |  43|+    {
+|    |  44|+        return compare (a, strlen (a), b, strlen (b));
+|    |  45|+    }
+|    |  46|+    int operator () (const std::string & a, const std::string & b) const
+|    |  47|+    {
+|    |  48|+        return compare (a.c_str (), a.length (), b.c_str (), b.length ());
+|    |  49|+    }
+|    |  50|+
+|    |  51|+    int compare (const char *a, size_t a_len, const char *b,
+|    |  52|+                 size_t b_len) const;
+|  47|  53| };
+|  48|  54| 
+|  49|  55| class LocaleBasedSorting
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/comparators.h
+|    |++++| /app/src/utility/comparators.h
+|  48|  48| 
+|  49|  49| class LocaleBasedSorting
+|  50|  50| {
+|  51|    |-	LocaleStringComparison m_cmp;
+|  52|    |-	
+|  53|    |-public:
+|  54|    |-	LocaleBasedSorting(const std::locale &loc, bool ignore_the) : m_cmp(loc, ignore_the) { }
+|  55|    |-	
+|  56|    |-	bool operator()(const std::string &a, const std::string &b) const {
+|  57|    |-		return m_cmp(a, b) < 0;
+|  58|    |-	}
+|  59|    |-	
+|  60|    |-	bool operator()(const MPD::Playlist &a, const MPD::Playlist &b) const {
+|  61|    |-		return m_cmp(a.path(), b.path()) < 0;
+|  62|    |-	}
+|    |  51|+    LocaleStringComparison m_cmp;
+|  63|  52| 
+|  64|    |-	bool operator()(const MPD::Song &a, const MPD::Song &b) const {
+|  65|    |-		return m_cmp(a.getName(), b.getName()) < 0;
+|  66|    |-	}
+|  67|    |-	
+|  68|    |-	template <typename A, typename B>
+|  69|    |-	bool operator()(const std::pair<A, B> &a, const std::pair<A, B> &b) const {
+|  70|    |-		return m_cmp(a.first, b.first) < 0;
+|  71|    |-	}
+|  72|    |-	
+|  73|    |-	template <typename ItemT, typename FunT>
+|  74|    |-	bool operator()(const RunnableItem<ItemT, FunT> &a, const RunnableItem<ItemT, FunT> &b) const {
+|  75|    |-		return m_cmp(a.item(), b.item()) < 0;
+|  76|    |-	}
+|    |  53|+  public:
+|    |  54|+      LocaleBasedSorting (const std::locale & loc, bool ignore_the):m_cmp (loc,
+|    |  55|+                                                                           ignore_the)
+|    |  56|+    {
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    bool operator () (const std::string & a, const std::string & b) const
+|    |  60|+    {
+|    |  61|+        return m_cmp (a, b) < 0;
+|    |  62|+    }
+|    |  63|+
+|    |  64|+    bool operator () (const MPD::Playlist & a, const MPD::Playlist & b) const
+|    |  65|+    {
+|    |  66|+        return m_cmp (a.path (), b.path ()) < 0;
+|    |  67|+    }
+|    |  68|+
+|    |  69|+    bool operator () (const MPD::Song & a, const MPD::Song & b) const
+|    |  70|+    {
+|    |  71|+        return m_cmp (a.getName (), b.getName ()) < 0;
+|    |  72|+    }
+|    |  73|+
+|    |  74|+    template < typename A, typename B >
+|    |  75|+        bool operator () (const std::pair < A, B > &a, const std::pair < A,
+|    |  76|+                          B > &b) const
+|    |  77|+    {
+|    |  78|+        return m_cmp (a.first, b.first) < 0;
+|    |  79|+    }
+|    |  80|+
+|    |  81|+    template < typename ItemT, typename FunT >
+|    |  82|+        bool operator () (const RunnableItem < ItemT, FunT > &a,
+|    |  83|+                          const RunnableItem < ItemT, FunT > &b) const
+|    |  84|+    {
+|    |  85|+        return m_cmp (a.item (), b.item ()) < 0;
+|    |  86|+    }
+|  77|  87| };
+|  78|  88| 
+|  79|  89| class LocaleBasedItemSorting
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/comparators.h
+|    |++++| /app/src/utility/comparators.h
+|  78|  78| 
+|  79|  79| class LocaleBasedItemSorting
+|  80|  80| {
+|  81|    |-	LocaleBasedSorting m_cmp;
+|  82|    |-	SortMode m_sort_mode;
+|  83|    |-	
+|  84|    |-public:
+|  85|    |-	LocaleBasedItemSorting(const std::locale &loc, bool ignore_the, SortMode mode)
+|  86|    |-	: m_cmp(loc, ignore_the), m_sort_mode(mode) { }
+|  87|    |-	
+|  88|    |-	bool operator()(const MPD::Item &a, const MPD::Item &b) const;
+|  89|    |-	
+|  90|    |-	bool operator()(const NC::Menu<MPD::Item>::Item &a,
+|  91|    |-	                const NC::Menu<MPD::Item>::Item &b) const
+|  92|    |-	{
+|  93|    |-		return (*this)(a.value(), b.value());
+|  94|    |-	}
+|    |  81|+    LocaleBasedSorting m_cmp;
+|    |  82|+    SortMode m_sort_mode;
+|    |  83|+
+|    |  84|+  public:
+|    |  85|+      LocaleBasedItemSorting (const std::locale & loc, bool ignore_the,
+|    |  86|+                              SortMode mode):m_cmp (loc, ignore_the),
+|    |  87|+        m_sort_mode (mode)
+|    |  88|+    {
+|    |  89|+    }
+|    |  90|+
+|    |  91|+    bool operator () (const MPD::Item & a, const MPD::Item & b) const;
+|    |  92|+
+|    |  93|+    bool operator () (const NC::Menu < MPD::Item >::Item & a,
+|    |  94|+                      const NC::Menu < MPD::Item >::Item & b) const
+|    |  95|+    {
+|    |  96|+        return (*this) (a.value (), b.value ());
+|    |  97|+    }
+|  95|  98| };
+|  96|  99| 
+|  97| 100| #endif // NCMPCPP_UTILITY_COMPARATORS_H
+
+src/utility/comparators.h
+|  40| »   »   return•compare(a,•strlen(a),•b,•strlen(b));
+|    | [INFO] CSecurityBear (buffer) strlen: Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected):
+|    | (CWE-126).
+
+src/utility/comparators.h
+|  40| »   »   return•compare(a,•strlen(a),•b,•strlen(b));
+|    | [INFO] CSecurityBear (buffer) strlen: Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected):
+|    | (CWE-126).
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.h
+|    |++++| /app/src/screens/server_info.h
+|  26|  26| #include "interfaces.h"
+|  27|  27| #include "screens/screen.h"
+|  28|  28| 
+|  29|    |-struct ServerInfo: Screen<NC::Scrollpad>, Tabbable
+|    |  29|+struct ServerInfo:Screen <
+|    |  30|+    NC::Scrollpad >,
+|    |  31|+    Tabbable
+|  30|  32| {
+|  31|    |-	ServerInfo();
+|  32|    |-	
+|  33|    |-	// Screen<NC::Scrollpad> implementation
+|  34|    |-	virtual void switchTo() override;
+|  35|    |-	virtual void resize() override;
+|  36|    |-	
+|  37|    |-	virtual std::wstring title() override;
+|  38|    |-	virtual ScreenType type() override { return ScreenType::ServerInfo; }
+|  39|    |-	
+|  40|    |-	virtual void update() override;
+|  41|    |-	
+|  42|    |-	virtual bool isLockable() override { return false; }
+|  43|    |-	virtual bool isMergable() override { return false; }
+|  44|    |-	
+|  45|    |-private:
+|  46|    |-	void SetDimensions();
+|  47|    |-	
+|  48|    |-	boost::posix_time::ptime m_timer;
+|    |  33|+    ServerInfo ();
+|  49|  34| 
+|  50|    |-	std::vector<std::string> m_url_handlers;
+|  51|    |-	std::vector<std::string> m_tag_types;
+|  52|    |-	
+|  53|    |-	size_t m_width;
+|  54|    |-	size_t m_height;
+|    |  35|+    // Screen<NC::Scrollpad> implementation
+|    |  36|+    virtual void
+|    |  37|+    switchTo ()
+|    |  38|+        override;
+|    |  39|+    virtual void
+|    |  40|+    resize ()
+|    |  41|+        override;
+|    |  42|+
+|    |  43|+    virtual
+|    |  44|+        std::wstring
+|    |  45|+    title ()
+|    |  46|+        override;
+|    |  47|+    virtual ScreenType
+|    |  48|+    type ()
+|    |  49|+        override
+|    |  50|+    {
+|    |  51|+        return ScreenType::ServerInfo;
+|    |  52|+    }
+|    |  53|+
+|    |  54|+    virtual void
+|    |  55|+    update ()
+|    |  56|+        override;
+|    |  57|+
+|    |  58|+    virtual bool
+|    |  59|+    isLockable ()
+|    |  60|+        override
+|    |  61|+    {
+|    |  62|+        return false;
+|    |  63|+    }
+|    |  64|+    virtual bool
+|    |  65|+    isMergable ()
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+        return false;
+|    |  69|+    }
+|    |  70|+
+|    |  71|+  private:
+|    |  72|+    void
+|    |  73|+    SetDimensions ();
+|    |  74|+
+|    |  75|+    boost::posix_time::ptime m_timer;
+|    |  76|+
+|    |  77|+    std::vector < std::string > m_url_handlers;
+|    |  78|+    std::vector < std::string > m_tag_types;
+|    |  79|+
+|    |  80|+    size_t
+|    |  81|+        m_width;
+|    |  82|+    size_t
+|    |  83|+        m_height;
+|  55|  84| };
+|  56|  85| 
+|  57|  86| extern ServerInfo *myServerInfo;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.h
+|    |++++| /app/src/screens/server_info.h
+|  54|  54| 	size_t m_height;
+|  55|  55| };
+|  56|  56| 
+|  57|    |-extern ServerInfo *myServerInfo;
+|    |  57|+extern ServerInfo *
+|    |  58|+    myServerInfo;
+|  58|  59| 
+|  59|  60| #endif // NCMPCPP_SERVER_INFO_H
+|  60|  61| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.h
+|    |++++| /app/src/screens/server_info.h
+|  57|  57| extern ServerInfo *myServerInfo;
+|  58|  58| 
+|  59|  59| #endif // NCMPCPP_SERVER_INFO_H
+|  60|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mutable_song.h
+|    |++++| /app/src/mutable_song.h
+|  25|  25| #include "config.h"
+|  26|  26| #include "song.h"
+|  27|  27| 
+|  28|    |-namespace MPD {
+|    |  28|+namespace MPD
+|    |  29|+{
+|  29|  30| 
+|  30|    |-struct MutableSong : public Song
+|  31|    |-{
+|  32|    |-	typedef void (MutableSong::*SetFunction)(const std::string &, unsigned);
+|  33|    |-	
+|  34|    |-	MutableSong() : m_mtime(0), m_duration(0) { }
+|  35|    |-	MutableSong(Song s) : Song(s), m_mtime(0), m_duration(0) { }
+|  36|    |-	
+|  37|    |-	virtual std::string getArtist(unsigned idx = 0) const override;
+|  38|    |-	virtual std::string getTitle(unsigned idx = 0) const override;
+|  39|    |-	virtual std::string getAlbum(unsigned idx = 0) const override;
+|  40|    |-	virtual std::string getAlbumArtist(unsigned idx = 0) const override;
+|  41|    |-	virtual std::string getTrack(unsigned idx = 0) const override;
+|  42|    |-	virtual std::string getDate(unsigned idx = 0) const override;
+|  43|    |-	virtual std::string getGenre(unsigned idx = 0) const override;
+|  44|    |-	virtual std::string getComposer(unsigned idx = 0) const override;
+|  45|    |-	virtual std::string getPerformer(unsigned idx = 0) const override;
+|  46|    |-	virtual std::string getDisc(unsigned idx = 0) const override;
+|  47|    |-	virtual std::string getComment(unsigned idx = 0) const override;
+|  48|    |-	
+|  49|    |-	void setArtist(const std::string &value, unsigned idx = 0);
+|  50|    |-	void setTitle(const std::string &value, unsigned idx = 0);
+|  51|    |-	void setAlbum(const std::string &value, unsigned idx = 0);
+|  52|    |-	void setAlbumArtist(const std::string &value, unsigned idx = 0);
+|  53|    |-	void setTrack(const std::string &value, unsigned idx = 0);
+|  54|    |-	void setDate(const std::string &value, unsigned idx = 0);
+|  55|    |-	void setGenre(const std::string &value, unsigned idx = 0);
+|  56|    |-	void setComposer(const std::string &value, unsigned idx = 0);
+|  57|    |-	void setPerformer(const std::string &value, unsigned idx = 0);
+|  58|    |-	void setDisc(const std::string &value, unsigned idx = 0);
+|  59|    |-	void setComment(const std::string &value, unsigned idx = 0);
+|  60|    |-	
+|  61|    |-	const std::string &getNewName() const;
+|  62|    |-	void setNewName(const std::string &value);
+|  63|    |-	
+|  64|    |-	virtual unsigned getDuration() const override;
+|  65|    |-	virtual time_t getMTime() const override;
+|  66|    |-	void setDuration(unsigned duration);
+|  67|    |-	void setMTime(time_t mtime);
+|  68|    |-	
+|  69|    |-	void setTags(SetFunction set, const std::string &value);
+|  70|    |-	
+|  71|    |-	bool isModified() const;
+|  72|    |-	void clearModifications();
+|  73|    |-	
+|  74|    |-private:
+|  75|    |-	struct Tag
+|  76|    |-	{
+|  77|    |-		Tag(mpd_tag_type type_, unsigned idx_) : m_type(type_), m_idx(idx_) { }
+|  78|    |-		
+|  79|    |-		mpd_tag_type type() const { return m_type; }
+|  80|    |-		unsigned idx() const { return m_idx; }
+|  81|    |-		
+|  82|    |-		bool operator<(const Tag &t) const
+|  83|    |-		{
+|  84|    |-			if (m_type != t.m_type)
+|  85|    |-				return m_type < t.m_type;
+|  86|    |-			return m_idx < t.m_idx;
+|  87|    |-		}
+|  88|    |-		
+|  89|    |-	private:
+|  90|    |-		mpd_tag_type m_type;
+|  91|    |-		unsigned m_idx;
+|  92|    |-	};
+|  93|    |-	
+|  94|    |-	void replaceTag(mpd_tag_type tag_type, std::string orig_value,
+|  95|    |-	                const std::string &value, unsigned idx);
+|  96|    |-	
+|  97|    |-	template <typename F>
+|  98|    |-	std::string getTag(mpd_tag_type tag_type, F orig_value, unsigned idx) const {
+|  99|    |-		auto it = m_tags.find(Tag(tag_type, idx));
+| 100|    |-		std::string result;
+| 101|    |-		if (it == m_tags.end())
+| 102|    |-			result = orig_value();
+| 103|    |-		else
+| 104|    |-			result = it->second;
+| 105|    |-		return result;
+| 106|    |-	}
+| 107|    |-	
+| 108|    |-	std::string m_name;
+| 109|    |-	time_t m_mtime;
+| 110|    |-	unsigned m_duration;
+| 111|    |-	std::map<Tag, std::string> m_tags;
+| 112|    |-};
+|    |  31|+    struct MutableSong:public Song
+|    |  32|+    {
+|    |  33|+        typedef void (MutableSong::*SetFunction) (const std::string &,
+|    |  34|+                                                  unsigned);
+|    |  35|+
+|    |  36|+          MutableSong ():m_mtime (0), m_duration (0)
+|    |  37|+        {
+|    |  38|+        }
+|    |  39|+        MutableSong (Song s):Song (s), m_mtime (0), m_duration (0)
+|    |  40|+        {
+|    |  41|+        }
+|    |  42|+
+|    |  43|+        virtual std::string getArtist (unsigned idx = 0) const override;
+|    |  44|+        virtual std::string getTitle (unsigned idx = 0) const override;
+|    |  45|+        virtual std::string getAlbum (unsigned idx = 0) const override;
+|    |  46|+        virtual std::string getAlbumArtist (unsigned idx = 0) const override;
+|    |  47|+        virtual std::string getTrack (unsigned idx = 0) const override;
+|    |  48|+        virtual std::string getDate (unsigned idx = 0) const override;
+|    |  49|+        virtual std::string getGenre (unsigned idx = 0) const override;
+|    |  50|+        virtual std::string getComposer (unsigned idx = 0) const override;
+|    |  51|+        virtual std::string getPerformer (unsigned idx = 0) const override;
+|    |  52|+        virtual std::string getDisc (unsigned idx = 0) const override;
+|    |  53|+        virtual std::string getComment (unsigned idx = 0) const override;
+|    |  54|+
+|    |  55|+        void setArtist (const std::string & value, unsigned idx = 0);
+|    |  56|+        void setTitle (const std::string & value, unsigned idx = 0);
+|    |  57|+        void setAlbum (const std::string & value, unsigned idx = 0);
+|    |  58|+        void setAlbumArtist (const std::string & value, unsigned idx = 0);
+|    |  59|+        void setTrack (const std::string & value, unsigned idx = 0);
+|    |  60|+        void setDate (const std::string & value, unsigned idx = 0);
+|    |  61|+        void setGenre (const std::string & value, unsigned idx = 0);
+|    |  62|+        void setComposer (const std::string & value, unsigned idx = 0);
+|    |  63|+        void setPerformer (const std::string & value, unsigned idx = 0);
+|    |  64|+        void setDisc (const std::string & value, unsigned idx = 0);
+|    |  65|+        void setComment (const std::string & value, unsigned idx = 0);
+|    |  66|+
+|    |  67|+        const std::string & getNewName () const;
+|    |  68|+        void setNewName (const std::string & value);
+|    |  69|+
+|    |  70|+        virtual unsigned getDuration () const override;
+|    |  71|+        virtual time_t getMTime () const override;
+|    |  72|+        void setDuration (unsigned duration);
+|    |  73|+        void setMTime (time_t mtime);
+|    |  74|+
+|    |  75|+        void setTags (SetFunction set, const std::string & value);
+|    |  76|+
+|    |  77|+        bool isModified () const;
+|    |  78|+        void clearModifications ();
+|    |  79|+
+|    |  80|+      private:
+|    |  81|+        struct Tag
+|    |  82|+        {
+|    |  83|+            Tag (mpd_tag_type type_, unsigned idx_):m_type (type_),
+|    |  84|+                m_idx (idx_)
+|    |  85|+            {
+|    |  86|+            }
+|    |  87|+
+|    |  88|+            mpd_tag_type type () const
+|    |  89|+            {
+|    |  90|+                return m_type;
+|    |  91|+            }
+|    |  92|+            unsigned idx () const
+|    |  93|+            {
+|    |  94|+                return m_idx;
+|    |  95|+            }
+|    |  96|+
+|    |  97|+            bool operator< (const Tag & t) const
+|    |  98|+            {
+|    |  99|+                if (m_type != t.m_type)
+|    | 100|+                    return m_type < t.m_type;
+|    | 101|+                return m_idx < t.m_idx;
+|    | 102|+            }
+|    | 103|+
+|    | 104|+          private:
+|    | 105|+              mpd_tag_type m_type;
+|    | 106|+            unsigned m_idx;
+|    | 107|+        };
+|    | 108|+
+|    | 109|+        void replaceTag (mpd_tag_type tag_type, std::string orig_value,
+|    | 110|+                         const std::string & value, unsigned idx);
+|    | 111|+
+|    | 112|+        template < typename F >
+|    | 113|+            std::string getTag (mpd_tag_type tag_type, F orig_value,
+|    | 114|+                                unsigned idx) const
+|    | 115|+        {
+|    | 116|+            auto it = m_tags.find (Tag (tag_type, idx));
+|    | 117|+              std::string result;
+|    | 118|+            if (it == m_tags.end ())
+|    | 119|+                result = orig_value ();
+|    | 120|+            else
+|    | 121|+                  result = it->second;
+|    | 122|+              return result;
+|    | 123|+        }
+|    | 124|+
+|    | 125|+        std::string m_name;
+|    | 126|+        time_t m_mtime;
+|    | 127|+        unsigned m_duration;
+|    | 128|+        std::map < Tag, std::string > m_tags;
+|    | 129|+    };
+| 113| 130| 
+| 114| 131| }
+| 115| 132| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.h
+|    |++++| /app/src/screens/screen.h
+|  25|  25| #include "curses/scrollpad.h"
+|  26|  26| #include "screens/screen_type.h"
+|  27|  27| 
+|  28|    |-void drawSeparator(int x);
+|  29|    |-void genericMouseButtonPressed(NC::Window &w, MEVENT me);
+|  30|    |-void scrollpadMouseButtonPressed(NC::Scrollpad &w, MEVENT me);
+|    |  28|+void drawSeparator (int x);
+|    |  29|+void genericMouseButtonPressed (NC::Window & w, MEVENT me);
+|    |  30|+void scrollpadMouseButtonPressed (NC::Scrollpad & w, MEVENT me);
+|  31|  31| 
+|  32|  32| /// An interface for various instantiations of Screen template class. Since C++ doesn't like
+|  33|  33| /// comparison of two different instantiations of the same template class we need the most
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.h
+|    |++++| /app/src/screens/screen.h
+|  34|  34| /// basic class to be non-template to allow it.
+|  35|  35| struct BaseScreen
+|  36|  36| {
+|  37|    |-	BaseScreen() : hasToBeResized(false) { }
+|  38|    |-	virtual ~BaseScreen() { }
+|  39|    |-	
+|  40|    |-	/// @see Screen::isActiveWindow()
+|  41|    |-	virtual bool isActiveWindow(const NC::Window &w_) const = 0;
+|  42|    |-	
+|  43|    |-	/// @see Screen::activeWindow()
+|  44|    |-	virtual NC::Window *activeWindow() = 0;
+|  45|    |-	virtual const NC::Window *activeWindow() const = 0;
+|  46|    |-	
+|  47|    |-	/// @see Screen::refresh()
+|  48|    |-	virtual void refresh() = 0;
+|  49|    |-	
+|  50|    |-	/// @see Screen::refreshWindow()
+|  51|    |-	virtual void refreshWindow() = 0;
+|  52|    |-	
+|  53|    |-	/// @see Screen::scroll()
+|  54|    |-	virtual void scroll(NC::Scroll where) = 0;
+|  55|    |-	
+|  56|    |-	/// Method used for switching to screen
+|  57|    |-	virtual void switchTo() = 0;
+|  58|    |-	
+|  59|    |-	/// Method that should resize screen
+|  60|    |-	/// if requested by hasToBeResized
+|  61|    |-	virtual void resize() = 0;
+|  62|    |-
+|  63|    |-	/// @return ncurses timeout parameter for the screen
+|  64|    |-	virtual int windowTimeout() = 0;
+|  65|    |-	
+|  66|    |-	/// @return title of the screen
+|  67|    |-	virtual std::wstring title() = 0;
+|  68|    |-	
+|  69|    |-	/// @return type of the screen
+|  70|    |-	virtual ScreenType type() = 0;
+|  71|    |-	
+|  72|    |-	/// If the screen contantly has to update itself
+|  73|    |-	/// somehow, it should be called by this function.
+|  74|    |-	virtual void update() = 0;
+|  75|    |-	
+|  76|    |-	/// @see Screen::mouseButtonPressed()
+|  77|    |-	virtual void mouseButtonPressed(MEVENT me) = 0;
+|  78|    |-
+|  79|    |-	/// @return true if screen can be locked. Note that returning
+|  80|    |-	/// false here doesn't neccesarily mean that screen is also not
+|  81|    |-	/// mergable (eg. lyrics screen is not lockable since that wouldn't
+|  82|    |-	/// make much sense, but it's perfectly fine to merge it).
+|  83|    |-	virtual bool isLockable() = 0;
+|  84|    |-	
+|  85|    |-	/// @return true if screen is mergable, ie. can be "proper" subwindow
+|  86|    |-	/// if one of the screens is locked. Screens that somehow resemble popups
+|  87|    |-	/// will want to return false here.
+|  88|    |-	virtual bool isMergable() = 0;
+|  89|    |-	
+|  90|    |-	/// Locks current screen.
+|  91|    |-	/// @return true if lock was successful, false otherwise. Note that
+|  92|    |-	/// if there is already locked screen, it'll not overwrite it.
+|  93|    |-	bool lock();
+|  94|    |-	
+|  95|    |-	/// Should be set to true each time screen needs resize
+|  96|    |-	bool hasToBeResized;
+|  97|    |-	
+|  98|    |-	/// Unlocks a screen, ie. hides merged window (if there is one set).
+|  99|    |-	static void unlock();
+| 100|    |-	
+| 101|    |-	const static int defaultWindowTimeout = 500;
+| 102|    |-
+| 103|    |-protected:
+| 104|    |-	/// Gets X offset and width of current screen to be used eg. in resize() function.
+| 105|    |-	/// @param adjust_locked_screen indicates whether this function should
+| 106|    |-	/// automatically adjust locked screen's dimensions (if there is one set)
+| 107|    |-	/// if current screen is going to be subwindow.
+| 108|    |-	void getWindowResizeParams(size_t &x_offset, size_t &width, bool adjust_locked_screen = true);
+|    |  37|+    BaseScreen ():hasToBeResized (false)
+|    |  38|+    {
+|    |  39|+    }
+|    |  40|+    virtual ~ BaseScreen ()
+|    |  41|+    {
+|    |  42|+    }
+|    |  43|+
+|    |  44|+    /// @see Screen::isActiveWindow()
+|    |  45|+    virtual bool isActiveWindow (const NC::Window & w_) const = 0;
+|    |  46|+
+|    |  47|+    /// @see Screen::activeWindow()
+|    |  48|+    virtual NC::Window * activeWindow () = 0;
+|    |  49|+    virtual const NC::Window * activeWindow () const = 0;
+|    |  50|+
+|    |  51|+    /// @see Screen::refresh()
+|    |  52|+    virtual void refresh () = 0;
+|    |  53|+
+|    |  54|+    /// @see Screen::refreshWindow()
+|    |  55|+    virtual void refreshWindow () = 0;
+|    |  56|+
+|    |  57|+    /// @see Screen::scroll()
+|    |  58|+    virtual void scroll (NC::Scroll where) = 0;
+|    |  59|+
+|    |  60|+    /// Method used for switching to screen
+|    |  61|+    virtual void switchTo () = 0;
+|    |  62|+
+|    |  63|+    /// Method that should resize screen
+|    |  64|+    /// if requested by hasToBeResized
+|    |  65|+    virtual void resize () = 0;
+|    |  66|+
+|    |  67|+    /// @return ncurses timeout parameter for the screen
+|    |  68|+    virtual int windowTimeout () = 0;
+|    |  69|+
+|    |  70|+    /// @return title of the screen
+|    |  71|+    virtual std::wstring title () = 0;
+|    |  72|+
+|    |  73|+    /// @return type of the screen
+|    |  74|+    virtual ScreenType type () = 0;
+|    |  75|+
+|    |  76|+    /// If the screen contantly has to update itself
+|    |  77|+    /// somehow, it should be called by this function.
+|    |  78|+    virtual void update () = 0;
+|    |  79|+
+|    |  80|+    /// @see Screen::mouseButtonPressed()
+|    |  81|+    virtual void mouseButtonPressed (MEVENT me) = 0;
+|    |  82|+
+|    |  83|+    /// @return true if screen can be locked. Note that returning
+|    |  84|+    /// false here doesn't neccesarily mean that screen is also not
+|    |  85|+    /// mergable (eg. lyrics screen is not lockable since that wouldn't
+|    |  86|+    /// make much sense, but it's perfectly fine to merge it).
+|    |  87|+    virtual bool isLockable () = 0;
+|    |  88|+
+|    |  89|+    /// @return true if screen is mergable, ie. can be "proper" subwindow
+|    |  90|+    /// if one of the screens is locked. Screens that somehow resemble popups
+|    |  91|+    /// will want to return false here.
+|    |  92|+    virtual bool isMergable () = 0;
+|    |  93|+
+|    |  94|+    /// Locks current screen.
+|    |  95|+    /// @return true if lock was successful, false otherwise. Note that
+|    |  96|+    /// if there is already locked screen, it'll not overwrite it.
+|    |  97|+    bool lock ();
+|    |  98|+
+|    |  99|+    /// Should be set to true each time screen needs resize
+|    | 100|+    bool hasToBeResized;
+|    | 101|+
+|    | 102|+    /// Unlocks a screen, ie. hides merged window (if there is one set).
+|    | 103|+    static void unlock ();
+|    | 104|+
+|    | 105|+    const static int defaultWindowTimeout = 500;
+|    | 106|+
+|    | 107|+  protected:
+|    | 108|+    /// Gets X offset and width of current screen to be used eg. in resize() function.
+|    | 109|+    /// @param adjust_locked_screen indicates whether this function should
+|    | 110|+    /// automatically adjust locked screen's dimensions (if there is one set)
+|    | 111|+    /// if current screen is going to be subwindow.
+|    | 112|+    void getWindowResizeParams (size_t & x_offset, size_t & width,
+|    | 113|+                                bool adjust_locked_screen = true);
+| 109| 114| };
+| 110| 115| 
+| 111| 116| void applyToVisibleWindows(std::function<void(BaseScreen *)> f);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.h
+|    |++++| /app/src/screens/screen.h
+| 108| 108| 	void getWindowResizeParams(size_t &x_offset, size_t &width, bool adjust_locked_screen = true);
+| 109| 109| };
+| 110| 110| 
+| 111|    |-void applyToVisibleWindows(std::function<void(BaseScreen *)> f);
+| 112|    |-void updateInactiveScreen(BaseScreen *screen_to_be_set);
+| 113|    |-bool isVisible(BaseScreen *screen);
+|    | 111|+void applyToVisibleWindows (std::function < void (BaseScreen *) > f);
+|    | 112|+void updateInactiveScreen (BaseScreen * screen_to_be_set);
+|    | 113|+bool isVisible (BaseScreen * screen);
+| 114| 114| 
+| 115| 115| /// Class that all screens should derive from. It provides basic interface
+| 116| 116| /// for the screen to be working properly and assumes that we didn't forget
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.h
+|    |++++| /app/src/screens/screen.h
+| 116| 116| /// for the screen to be working properly and assumes that we didn't forget
+| 117| 117| /// about anything vital.
+| 118| 118| ///
+| 119|    |-template <typename WindowT> struct Screen : public BaseScreen
+|    | 119|+template < typename WindowT > struct Screen:public BaseScreen
+| 120| 120| {
+| 121|    |-	typedef WindowT WindowType;
+| 122|    |-	typedef typename std::add_lvalue_reference<
+| 123|    |-		WindowType
+| 124|    |-	>::type WindowReference;
+| 125|    |-	typedef typename std::add_lvalue_reference<
+| 126|    |-		typename std::add_const<WindowType>::type
+| 127|    |-	>::type ConstWindowReference;
+| 128|    |-	
+| 129|    |-private:
+| 130|    |-	template <bool IsPointer, typename Result, typename ConstResult>
+| 131|    |-	struct getObject {
+| 132|    |-		static Result &apply(WindowReference w) { return w; }
+| 133|    |-		static ConstResult &constApply(ConstWindowReference w) { return w; }
+| 134|    |-	};
+| 135|    |-	template <typename Result, typename ConstResult>
+| 136|    |-	struct getObject<true, Result, ConstResult> {
+| 137|    |-		static Result &apply(WindowType w) { return *w; }
+| 138|    |-		static ConstResult &constApply(const WindowType w) { return *w; }
+| 139|    |-	};
+| 140|    |-	
+| 141|    |-	typedef getObject<
+| 142|    |-		std::is_pointer<WindowT>::value,
+| 143|    |-		typename std::remove_pointer<WindowT>::type,
+| 144|    |-		typename std::add_const<
+| 145|    |-			typename std::remove_pointer<WindowT>::type
+| 146|    |-		>::type
+| 147|    |-	> Accessor;
+| 148|    |-	
+| 149|    |-public:
+| 150|    |-	Screen() { }
+| 151|    |-	Screen(WindowT w_) : w(w_) { }
+| 152|    |-	
+| 153|    |-	virtual ~Screen() { }
+| 154|    |-	
+| 155|    |-	virtual bool isActiveWindow(const NC::Window &w_) const override {
+| 156|    |-		return &Accessor::constApply(w) == &w_;
+| 157|    |-	}
+| 158|    |-	
+| 159|    |-	/// Since some screens contain more that one window
+| 160|    |-	/// it's useful to determine the one that is being
+| 161|    |-	/// active
+| 162|    |-	/// @return address to window object cast to void *
+| 163|    |-	virtual NC::Window *activeWindow() override {
+| 164|    |-		return &Accessor::apply(w);
+| 165|    |-	}
+| 166|    |-	virtual const NC::Window *activeWindow() const override {
+| 167|    |-		return &Accessor::constApply(w);
+| 168|    |-	}
+| 169|    |-	
+| 170|    |-	/// Refreshes whole screen
+| 171|    |-	virtual void refresh() override {
+| 172|    |-		Accessor::apply(w).display();
+| 173|    |-	}
+| 174|    |-	
+| 175|    |-	/// Refreshes active window of the screen
+| 176|    |-	virtual void refreshWindow() override {
+| 177|    |-		Accessor::apply(w).display();
+| 178|    |-	}
+| 179|    |-	
+| 180|    |-	/// Scrolls the screen by given amount of lines and
+| 181|    |-	/// if fancy scrolling feature is disabled, enters the
+| 182|    |-	/// loop that holds main loop until user releases the key
+| 183|    |-	/// @param where indicates where one wants to scroll
+| 184|    |-	virtual void scroll(NC::Scroll where) override {
+| 185|    |-		Accessor::apply(w).scroll(where);
+| 186|    |-	}
+| 187|    |-	
+| 188|    |-	/// @return timeout parameter used for the screen (in ms)
+| 189|    |-	/// @default defaultWindowTimeout
+| 190|    |-	virtual int windowTimeout() override {
+| 191|    |-		return defaultWindowTimeout;
+| 192|    |-	}
+| 193|    |-
+| 194|    |-	/// Invoked after there was one of mouse buttons pressed
+| 195|    |-	/// @param me struct that contains coords of where the click
+| 196|    |-	/// had its place and button actions
+| 197|    |-	virtual void mouseButtonPressed(MEVENT me) override {
+| 198|    |-		genericMouseButtonPressed(Accessor::apply(w), me);
+| 199|    |-	}
+| 200|    |-	
+| 201|    |-	/// @return currently active window
+| 202|    |-	WindowReference main() {
+| 203|    |-		return w;
+| 204|    |-	}
+| 205|    |-	ConstWindowReference main() const {
+| 206|    |-		return w;
+| 207|    |-	}
+| 208|    |-	
+| 209|    |-protected:
+| 210|    |-	/// Template parameter that should indicate the main type
+| 211|    |-	/// of window used by the screen. What is more, it should
+| 212|    |-	/// always be assigned to the currently active window (if
+| 213|    |-	/// acreen contains more that one)
+| 214|    |-	WindowT w;
+|    | 121|+    typedef WindowT WindowType;
+|    | 122|+    typedef typename std::add_lvalue_reference <
+|    | 123|+        WindowType >::type WindowReference;
+|    | 124|+    typedef typename std::add_lvalue_reference <
+|    | 125|+        typename std::add_const < WindowType >::type
+|    | 126|+        >::type ConstWindowReference;
+|    | 127|+
+|    | 128|+  private:
+|    | 129|+      template < bool IsPointer, typename Result, typename ConstResult > struct getObject
+|    | 130|+    {
+|    | 131|+        static Result & apply (WindowReference w)
+|    | 132|+        {
+|    | 133|+            return w;
+|    | 134|+        }
+|    | 135|+        static ConstResult & constApply (ConstWindowReference w)
+|    | 136|+        {
+|    | 137|+            return w;
+|    | 138|+        }
+|    | 139|+    };
+|    | 140|+    template < typename Result, typename ConstResult >
+|    | 141|+        struct getObject <true, Result, ConstResult >
+|    | 142|+    {
+|    | 143|+        static Result & apply (WindowType w)
+|    | 144|+        {
+|    | 145|+            return *w;
+|    | 146|+        }
+|    | 147|+        static ConstResult & constApply (const WindowType w)
+|    | 148|+        {
+|    | 149|+            return *w;
+|    | 150|+        }
+|    | 151|+    };
+|    | 152|+
+|    | 153|+    typedef getObject <
+|    | 154|+        std::is_pointer < WindowT >::value,
+|    | 155|+        typename std::remove_pointer < WindowT >::type,
+|    | 156|+        typename std::add_const <
+|    | 157|+        typename std::remove_pointer < WindowT >::type >::type > Accessor;
+|    | 158|+
+|    | 159|+  public:
+|    | 160|+    Screen ()
+|    | 161|+    {
+|    | 162|+    }
+|    | 163|+  Screen (WindowT w_):w (w_)
+|    | 164|+    {
+|    | 165|+    }
+|    | 166|+
+|    | 167|+    virtual ~ Screen ()
+|    | 168|+    {
+|    | 169|+    }
+|    | 170|+
+|    | 171|+    virtual bool isActiveWindow (const NC::Window & w_) const override
+|    | 172|+    {
+|    | 173|+        return &Accessor::constApply (w) == &w_;
+|    | 174|+    }
+|    | 175|+
+|    | 176|+    /// Since some screens contain more that one window
+|    | 177|+    /// it's useful to determine the one that is being
+|    | 178|+    /// active
+|    | 179|+    /// @return address to window object cast to void *
+|    | 180|+    virtual NC::Window * activeWindow () override
+|    | 181|+    {
+|    | 182|+        return &Accessor::apply (w);
+|    | 183|+    }
+|    | 184|+    virtual const NC::Window * activeWindow () const override
+|    | 185|+    {
+|    | 186|+        return &Accessor::constApply (w);
+|    | 187|+    }
+|    | 188|+
+|    | 189|+    /// Refreshes whole screen
+|    | 190|+    virtual void refresh () override
+|    | 191|+    {
+|    | 192|+        Accessor::apply (w).display ();
+|    | 193|+    }
+|    | 194|+
+|    | 195|+    /// Refreshes active window of the screen
+|    | 196|+    virtual void refreshWindow () override
+|    | 197|+    {
+|    | 198|+        Accessor::apply (w).display ();
+|    | 199|+    }
+|    | 200|+
+|    | 201|+    /// Scrolls the screen by given amount of lines and
+|    | 202|+    /// if fancy scrolling feature is disabled, enters the
+|    | 203|+    /// loop that holds main loop until user releases the key
+|    | 204|+    /// @param where indicates where one wants to scroll
+|    | 205|+    virtual void scroll (NC::Scroll where) override
+|    | 206|+    {
+|    | 207|+        Accessor::apply (w).scroll (where);
+|    | 208|+    }
+|    | 209|+
+|    | 210|+    /// @return timeout parameter used for the screen (in ms)
+|    | 211|+    /// @default defaultWindowTimeout
+|    | 212|+    virtual int windowTimeout () override
+|    | 213|+    {
+|    | 214|+        return defaultWindowTimeout;
+|    | 215|+    }
+|    | 216|+
+|    | 217|+    /// Invoked after there was one of mouse buttons pressed
+|    | 218|+    /// @param me struct that contains coords of where the click
+|    | 219|+    /// had its place and button actions
+|    | 220|+    virtual void mouseButtonPressed (MEVENT me) override
+|    | 221|+    {
+|    | 222|+        genericMouseButtonPressed (Accessor::apply (w), me);
+|    | 223|+    }
+|    | 224|+
+|    | 225|+    /// @return currently active window
+|    | 226|+    WindowReference main ()
+|    | 227|+    {
+|    | 228|+        return w;
+|    | 229|+    }
+|    | 230|+    ConstWindowReference main () const
+|    | 231|+    {
+|    | 232|+        return w;
+|    | 233|+    }
+|    | 234|+
+|    | 235|+  protected:
+|    | 236|+    /// Template parameter that should indicate the main type
+|    | 237|+    /// of window used by the screen. What is more, it should
+|    | 238|+    /// always be assigned to the currently active window (if
+|    | 239|+    /// acreen contains more that one)
+|    | 240|+      WindowT w;
+| 215| 241| };
+| 216| 242| 
+| 217| 243| /// Specialization for Screen<Scrollpad>::mouseButtonPressed that should
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.h
+|    |++++| /app/src/screens/screen.h
+| 217| 217| /// Specialization for Screen<Scrollpad>::mouseButtonPressed that should
+| 218| 218| /// not scroll whole page, but rather a few lines (the number of them is
+| 219| 219| /// defined in the config)
+| 220|    |-template <> inline void Screen<NC::Scrollpad>::mouseButtonPressed(MEVENT me) {
+| 221|    |-	scrollpadMouseButtonPressed(w, me);
+|    | 220|+template <> inline void Screen <
+|    | 221|+NC::Scrollpad >::mouseButtonPressed (MEVENT me)
+|    | 222|+{
+|    | 223|+    scrollpadMouseButtonPressed (w, me);
+| 222| 224| }
+| 223| 225| 
+| 224| 226| #endif // NCMPCPP_SCREEN_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.h
+|    |++++| /app/src/screens/screen.h
+| 222| 222| }
+| 223| 223| 
+| 224| 224| #endif // NCMPCPP_SCREEN_H
+| 225|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  31|  31| 
+|  32|  32| struct Searchable
+|  33|  33| {
+|  34|    |-	virtual bool allowsSearching() = 0;
+|    |  34|+    virtual bool allowsSearching () = 0;
+|  35|  35| 
+|  36|    |-	virtual const std::string &searchConstraint() = 0;
+|  37|    |-	virtual void setSearchConstraint(const std::string &constraint) = 0;
+|  38|    |-	virtual void clearSearchConstraint() = 0;
+|  39|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) = 0;
+|    |  36|+    virtual const std::string & searchConstraint () = 0;
+|    |  37|+    virtual void setSearchConstraint (const std::string & constraint) = 0;
+|    |  38|+    virtual void clearSearchConstraint () = 0;
+|    |  39|+    virtual bool search (SearchDirection direction, bool wrap,
+|    |  40|+                         bool skip_current) = 0;
+|  40|  41| };
+|  41|  42| 
+|  42|  43| struct Filterable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  41|  41| 
+|  42|  42| struct Filterable
+|  43|  43| {
+|  44|    |-	virtual bool allowsFiltering() = 0;
+|  45|    |-	virtual std::string currentFilter() = 0;
+|  46|    |-	virtual void applyFilter(const std::string &constraint) = 0;
+|    |  44|+    virtual bool allowsFiltering () = 0;
+|    |  45|+    virtual std::string currentFilter () = 0;
+|    |  46|+    virtual void applyFilter (const std::string & constraint) = 0;
+|  47|  47| };
+|  48|  48| 
+|  49|  49| struct HasActions
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  48|  48| 
+|  49|  49| struct HasActions
+|  50|  50| {
+|  51|    |-	virtual bool actionRunnable() = 0;
+|  52|    |-	virtual void runAction() = 0;
+|    |  51|+    virtual bool actionRunnable () = 0;
+|    |  52|+    virtual void runAction () = 0;
+|  53|  53| };
+|  54|  54| 
+|  55|  55| struct HasSongs
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  54|  54| 
+|  55|  55| struct HasSongs
+|  56|  56| {
+|  57|    |-	virtual bool itemAvailable() = 0;
+|  58|    |-	virtual bool addItemToPlaylist(bool play) = 0;
+|  59|    |-	virtual std::vector<MPD::Song> getSelectedSongs() = 0;
+|    |  57|+    virtual bool itemAvailable () = 0;
+|    |  58|+    virtual bool addItemToPlaylist (bool play) = 0;
+|    |  59|+    virtual std::vector < MPD::Song > getSelectedSongs () = 0;
+|  60|  60| };
+|  61|  61| 
+|  62|  62| struct HasColumns
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  61|  61| 
+|  62|  62| struct HasColumns
+|  63|  63| {
+|  64|    |-	virtual bool previousColumnAvailable() = 0;
+|  65|    |-	virtual void previousColumn() = 0;
+|  66|    |-	
+|  67|    |-	virtual bool nextColumnAvailable() = 0;
+|  68|    |-	virtual void nextColumn() = 0;
+|    |  64|+    virtual bool previousColumnAvailable () = 0;
+|    |  65|+    virtual void previousColumn () = 0;
+|    |  66|+
+|    |  67|+    virtual bool nextColumnAvailable () = 0;
+|    |  68|+    virtual void nextColumn () = 0;
+|  69|  69| };
+|  70|  70| 
+|  71|  71| struct Tabbable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  70|  70| 
+|  71|  71| struct Tabbable
+|  72|  72| {
+|  73|    |-	Tabbable() : m_previous_screen(0) { }
+|  74|    |-	
+|  75|    |-	void switchToPreviousScreen() const {
+|  76|    |-		if (m_previous_screen)
+|  77|    |-			m_previous_screen->switchTo();
+|  78|    |-	}
+|  79|    |-	void setPreviousScreen(BaseScreen *screen) {
+|  80|    |-		m_previous_screen = screen;
+|  81|    |-	}
+|  82|    |-	BaseScreen *previousScreen() const {
+|  83|    |-		return m_previous_screen;
+|  84|    |-	}
+|  85|    |-	
+|  86|    |-private:
+|  87|    |-	BaseScreen *m_previous_screen;
+|    |  73|+    Tabbable ():m_previous_screen (0)
+|    |  74|+    {
+|    |  75|+    }
+|    |  76|+
+|    |  77|+    void switchToPreviousScreen () const
+|    |  78|+    {
+|    |  79|+        if (m_previous_screen)
+|    |  80|+            m_previous_screen->switchTo ();
+|    |  81|+    }
+|    |  82|+    void setPreviousScreen (BaseScreen * screen)
+|    |  83|+    {
+|    |  84|+        m_previous_screen = screen;
+|    |  85|+    }
+|    |  86|+    BaseScreen *previousScreen () const
+|    |  87|+    {
+|    |  88|+        return m_previous_screen;
+|    |  89|+    }
+|    |  90|+
+|    |  91|+  private:
+|    |  92|+      BaseScreen * m_previous_screen;
+|  88|  93| };
+|  89|  94| 
+|  90|  95| #endif // NCMPCPP_INTERFACES_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format.h
+|    |++++| /app/src/format.h
+|  26|  26| #include "curses/menu.h"
+|  27|  27| #include "song.h"
+|  28|  28| 
+|  29|    |-namespace Format {
+|    |  29|+namespace Format
+|    |  30|+{
+|  30|  31| 
+|  31|    |-namespace Flags {
+|  32|    |-const unsigned None = 0;
+|  33|    |-const unsigned Color = 1;
+|  34|    |-const unsigned Format = 2;
+|  35|    |-const unsigned OutputSwitch = 4;
+|  36|    |-const unsigned Tag = 8;
+|  37|    |-const unsigned All = Color | Format | OutputSwitch | Tag;
+|  38|    |-}
+|    |  32|+    namespace Flags
+|    |  33|+    {
+|    |  34|+        const unsigned None = 0;
+|    |  35|+        const unsigned Color = 1;
+|    |  36|+        const unsigned Format = 2;
+|    |  37|+        const unsigned OutputSwitch = 4;
+|    |  38|+        const unsigned Tag = 8;
+|    |  39|+        const unsigned All = Color | Format | OutputSwitch | Tag;
+|    |  40|+    }
+|  39|  41| 
+|  40|    |-enum class ListType { Group, FirstOf, AST };
+|    |  42|+    enum class ListType
+|    |  43|+    { Group, FirstOf, AST };
+|  41|  44| 
+|  42|    |-template <ListType, typename> struct List;
+|  43|    |-template <typename CharT> using Group = List<ListType::Group, CharT>;
+|  44|    |-template <typename CharT> using FirstOf = List<ListType::FirstOf, CharT>;
+|  45|    |-template <typename CharT> using AST = List<ListType::AST, CharT>;
+|    |  45|+      template < ListType, typename > struct List;
+|    |  46|+      template < typename CharT > using Group =
+|    |  47|+        List < ListType::Group, CharT >;
+|    |  48|+      template < typename CharT > using FirstOf =
+|    |  49|+        List < ListType::FirstOf, CharT >;
+|    |  50|+      template < typename CharT > using AST = List < ListType::AST, CharT >;
+|  46|  51| 
+|  47|    |-struct OutputSwitch { };
+|    |  52|+    struct OutputSwitch
+|    |  53|+    {
+|    |  54|+    };
+|  48|  55| 
+|  49|    |-struct SongTag
+|  50|    |-{
+|  51|    |-	SongTag(MPD::Song::GetFunction function_, unsigned delimiter_ = 0)
+|  52|    |-	: m_function(function_), m_delimiter(delimiter_)
+|  53|    |-	{ }
+|    |  56|+    struct SongTag
+|    |  57|+    {
+|    |  58|+      SongTag (MPD::Song::GetFunction function_, unsigned delimiter_ = 0):m_function (function_),
+|    |  59|+            m_delimiter
+|    |  60|+            (delimiter_)
+|    |  61|+        {
+|    |  62|+        }
+|  54|  63| 
+|  55|    |-	MPD::Song::GetFunction function() const { return m_function; }
+|  56|    |-	unsigned delimiter() const { return m_delimiter; }
+|    |  64|+        MPD::Song::GetFunction function () const
+|    |  65|+        {
+|    |  66|+            return m_function;
+|    |  67|+        }
+|    |  68|+        unsigned delimiter () const
+|    |  69|+        {
+|    |  70|+            return m_delimiter;
+|    |  71|+        }
+|  57|  72| 
+|  58|    |-private:
+|  59|    |-	MPD::Song::GetFunction m_function;
+|  60|    |-	unsigned m_delimiter;
+|  61|    |-};
+|    |  73|+      private:
+|    |  74|+          MPD::Song::GetFunction m_function;
+|    |  75|+        unsigned m_delimiter;
+|    |  76|+    };
+|  62|  77| 
+|  63|    |-inline bool operator==(const SongTag &lhs, const SongTag &rhs) {
+|  64|    |-	return lhs.function() == rhs.function()
+|  65|    |-		&& lhs.delimiter() == rhs.delimiter();
+|  66|    |-}
+|  67|    |-inline bool operator!=(const SongTag &lhs, const SongTag &rhs) {
+|  68|    |-	return !(lhs == rhs);
+|  69|    |-}
+|    |  78|+    inline bool operator== (const SongTag & lhs, const SongTag & rhs)
+|    |  79|+    {
+|    |  80|+        return lhs.function () == rhs.function ()
+|    |  81|+            && lhs.delimiter () == rhs.delimiter ();
+|    |  82|+    }
+|    |  83|+    inline bool operator!= (const SongTag & lhs, const SongTag & rhs)
+|    |  84|+    {
+|    |  85|+        return !(lhs == rhs);
+|    |  86|+    }
+|  70|  87| 
+|  71|    |-template <typename CharT>
+|  72|    |-using TagVector = std::vector<
+|  73|    |-	std::pair<
+|  74|    |-		boost::optional<SongTag>,
+|  75|    |-		std::basic_string<CharT>
+|  76|    |-		>
+|  77|    |-	>;
+|    |  88|+    template < typename CharT >
+|    |  89|+        using TagVector = std::vector <
+|    |  90|+        std::pair <
+|    |  91|+        boost::optional < SongTag >, std::basic_string < CharT > >>;
+|  78|  92| 
+|  79|    |-enum class Result { Empty, Missing, Ok };
+|    |  93|+    enum class Result
+|    |  94|+    { Empty, Missing, Ok };
+|  80|  95| 
+|  81|    |-template <typename CharT>
+|  82|    |-using Expression = boost::variant<
+|  83|    |-	std::basic_string<CharT>,
+|  84|    |-	NC::Color,
+|  85|    |-	NC::Format,
+|  86|    |-	OutputSwitch,
+|  87|    |-	SongTag,
+|  88|    |-	boost::recursive_wrapper<FirstOf<CharT>>,
+|  89|    |-	boost::recursive_wrapper<Group<CharT>>
+|  90|    |->;
+|    |  96|+    template < typename CharT >
+|    |  97|+        using Expression = boost::variant <
+|    |  98|+        std::basic_string < CharT >,
+|    |  99|+        NC::Color,
+|    | 100|+        NC::Format,
+|    | 101|+        OutputSwitch,
+|    | 102|+        SongTag,
+|    | 103|+        boost::recursive_wrapper < FirstOf < CharT >>,
+|    | 104|+        boost::recursive_wrapper < Group < CharT >> >;
+|  91| 105| 
+|  92|    |-template <ListType Type, typename CharT>
+|  93|    |-struct List
+|  94|    |-{
+|  95|    |-	typedef std::vector<Expression<CharT>> Base;
+|    | 106|+    template < ListType Type, typename CharT > struct List
+|    | 107|+    {
+|    | 108|+        typedef std::vector < Expression < CharT >> Base;
+|  96| 109| 
+|  97|    |-	List() { }
+|  98|    |-	List(Base &&base_)
+|  99|    |-	: m_base(std::move(base_))
+| 100|    |-	{ }
+|    | 110|+          List ()
+|    | 111|+        {
+|    | 112|+        }
+|    | 113|+        List (Base && base_):m_base (std::move (base_))
+|    | 114|+        {
+|    | 115|+        }
+| 101| 116| 
+| 102|    |-	Base &base() { return m_base; }
+| 103|    |-	const Base &base() const { return m_base; }
+|    | 117|+        Base & base ()
+|    | 118|+        {
+|    | 119|+            return m_base;
+|    | 120|+        }
+|    | 121|+        const Base & base () const
+|    | 122|+        {
+|    | 123|+            return m_base;
+|    | 124|+        }
+| 104| 125| 
+| 105|    |-private:
+| 106|    |-	Base m_base;
+| 107|    |-};
+|    | 126|+      private:
+|    | 127|+          Base m_base;
+|    | 128|+    };
+| 108| 129| 
+| 109|    |-template <typename CharT, typename VisitorT>
+| 110|    |-void visit(VisitorT &visitor, const AST<CharT> &ast);
+|    | 130|+    template < typename CharT, typename VisitorT >
+|    | 131|+        void visit (VisitorT & visitor, const AST < CharT > &ast);
+| 111| 132| 
+| 112|    |-template <typename CharT, typename ItemT>
+| 113|    |-void print(const AST<CharT> &ast, NC::Menu<ItemT> &menu, const MPD::Song *song,
+| 114|    |-           NC::BasicBuffer<CharT> *buffer, const unsigned flags = Flags::All);
+|    | 133|+    template < typename CharT, typename ItemT >
+|    | 134|+        void print (const AST < CharT > &ast, NC::Menu < ItemT > &menu,
+|    | 135|+                    const MPD::Song * song, NC::BasicBuffer < CharT > *buffer,
+|    | 136|+                    const unsigned flags = Flags::All);
+| 115| 137| 
+| 116|    |-template <typename CharT>
+| 117|    |-void print(const AST<CharT> &ast, NC::BasicBuffer<CharT> &buffer,
+| 118|    |-           const MPD::Song *song, const unsigned flags = Flags::All);
+|    | 138|+    template < typename CharT >
+|    | 139|+        void print (const AST < CharT > &ast,
+|    | 140|+                    NC::BasicBuffer < CharT > &buffer, const MPD::Song * song,
+|    | 141|+                    const unsigned flags = Flags::All);
+| 119| 142| 
+| 120|    |-template <typename CharT>
+| 121|    |-std::basic_string<CharT> stringify(const AST<CharT> &ast, const MPD::Song *song);
+|    | 143|+    template < typename CharT >
+|    | 144|+        std::basic_string < CharT > stringify (const AST < CharT > &ast,
+|    | 145|+                                               const MPD::Song * song);
+| 122| 146| 
+| 123|    |-template <typename CharT>
+| 124|    |-TagVector<CharT> flatten(const AST<CharT> &ast, const MPD::Song &song);
+|    | 147|+    template < typename CharT >
+|    | 148|+        TagVector < CharT > flatten (const AST < CharT > &ast,
+|    | 149|+                                     const MPD::Song & song);
+| 125| 150| 
+| 126|    |-AST<char> parse(const std::string &s, const unsigned flags = Flags::All);
+| 127|    |-AST<wchar_t> parse(const std::wstring &ws, const unsigned flags = Flags::All);
+|    | 151|+    AST < char >parse (const std::string & s, const unsigned flags =
+|    | 152|+                       Flags::All);
+|    | 153|+    AST < wchar_t > parse (const std::wstring & ws, const unsigned flags =
+|    | 154|+                           Flags::All);
+| 128| 155| 
+| 129| 156| }
+| 130| 157| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/settings.h
+|    |++++| /app/src/settings.h
+|  37|  37| 
+|  38|  38| struct Column
+|  39|  39| {
+|  40|    |-	Column() : stretch_limit(-1), right_alignment(0), display_empty_tag(1) { }
+|  41|    |-
+|  42|    |-	std::wstring name;
+|  43|    |-	std::string type;
+|  44|    |-	int width;
+|  45|    |-	int stretch_limit;
+|  46|    |-	NC::Color color;
+|  47|    |-	bool fixed;
+|  48|    |-	bool right_alignment;
+|  49|    |-	bool display_empty_tag;
+|    |  40|+    Column ():stretch_limit (-1), right_alignment (0), display_empty_tag (1)
+|    |  41|+    {
+|    |  42|+    }
+|    |  43|+
+|    |  44|+    std::wstring name;
+|    |  45|+    std::string type;
+|    |  46|+    int width;
+|    |  47|+    int stretch_limit;
+|    |  48|+    NC::Color color;
+|    |  49|+    bool fixed;
+|    |  50|+    bool right_alignment;
+|    |  51|+    bool display_empty_tag;
+|  50|  52| };
+|  51|  53| 
+|  52|  54| struct Configuration
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/settings.h
+|    |++++| /app/src/settings.h
+|  51|  51| 
+|  52|  52| struct Configuration
+|  53|  53| {
+|  54|    |-	Configuration()
+|  55|    |-	: playlist_disable_highlight_delay(0), visualizer_sync_interval(0)
+|  56|    |-	{ }
+|  57|    |-
+|  58|    |-	bool read(const std::vector<std::string> &config_paths, bool ignore_errors);
+|  59|    |-
+|  60|    |-	std::string ncmpcpp_directory;
+|  61|    |-	std::string lyrics_directory;
+|  62|    |-
+|  63|    |-	std::string mpd_music_dir;
+|  64|    |-	std::string visualizer_fifo_path;
+|  65|    |-	std::string visualizer_output_name;
+|  66|    |-	std::string empty_tag;
+|  67|    |-
+|  68|    |-	Format::AST<char> song_list_format;
+|  69|    |-	Format::AST<char> song_window_title_format;
+|  70|    |-	Format::AST<char> song_library_format;
+|  71|    |-	Format::AST<char> song_columns_mode_format;
+|  72|    |-	Format::AST<char> browser_sort_format;
+|  73|    |-	Format::AST<char> song_status_format;
+|  74|    |-	Format::AST<wchar_t> song_status_wformat;
+|  75|    |-	Format::AST<wchar_t> new_header_first_line;
+|  76|    |-	Format::AST<wchar_t> new_header_second_line;
+|  77|    |-
+|  78|    |-	std::string external_editor;
+|  79|    |-	std::string system_encoding;
+|  80|    |-	std::string execute_on_song_change;
+|  81|    |-	std::string execute_on_player_state_change;
+|  82|    |-	std::string lastfm_preferred_language;
+|  83|    |-	std::wstring progressbar;
+|  84|    |-	std::wstring visualizer_chars;
+|  85|    |-
+|  86|    |-	std::string pattern;
+|  87|    |-
+|  88|    |-	std::vector<Column> columns;
+|  89|    |-
+|  90|    |-	DisplayMode playlist_display_mode;
+|  91|    |-	DisplayMode browser_display_mode;
+|  92|    |-	DisplayMode search_engine_display_mode;
+|  93|    |-	DisplayMode playlist_editor_display_mode;
+|  94|    |-
+|  95|    |-	NC::Buffer browser_playlist_prefix;
+|  96|    |-	NC::Buffer selected_item_prefix;
+|  97|    |-	NC::Buffer selected_item_suffix;
+|  98|    |-	NC::Buffer now_playing_prefix;
+|  99|    |-	NC::Buffer now_playing_suffix;
+| 100|    |-	NC::Buffer modified_item_prefix;
+| 101|    |-	NC::Buffer current_item_prefix;
+| 102|    |-	NC::Buffer current_item_suffix;
+| 103|    |-	NC::Buffer current_item_inactive_column_prefix;
+| 104|    |-	NC::Buffer current_item_inactive_column_suffix;
+| 105|    |-
+| 106|    |-	NC::Color header_color;
+| 107|    |-	NC::Color main_color;
+| 108|    |-	NC::Color statusbar_color;
+| 109|    |-
+| 110|    |-	NC::FormattedColor color1;
+| 111|    |-	NC::FormattedColor color2;
+| 112|    |-	NC::FormattedColor empty_tags_color;
+| 113|    |-	NC::FormattedColor volume_color;
+| 114|    |-	NC::FormattedColor state_line_color;
+| 115|    |-	NC::FormattedColor state_flags_color;
+| 116|    |-	NC::FormattedColor progressbar_color;
+| 117|    |-	NC::FormattedColor progressbar_elapsed_color;
+| 118|    |-	NC::FormattedColor player_state_color;
+| 119|    |-	NC::FormattedColor statusbar_time_color;
+| 120|    |-	NC::FormattedColor alternative_ui_separator_color;
+| 121|    |-
+| 122|    |-	std::vector<NC::FormattedColor> visualizer_colors;
+| 123|    |-	VisualizerType visualizer_type;
+| 124|    |-
+| 125|    |-	NC::Border window_border;
+| 126|    |-	NC::Border active_window_border;
+| 127|    |-
+| 128|    |-	Design design;
+| 129|    |-
+| 130|    |-	SpaceAddMode space_add_mode;
+| 131|    |-
+| 132|    |-	mpd_tag_type media_lib_primary_tag;
+| 133|    |-
+| 134|    |-	bool colors_enabled;
+| 135|    |-	bool playlist_show_mpd_host;
+| 136|    |-	bool playlist_show_remaining_time;
+| 137|    |-	bool playlist_shorten_total_times;
+| 138|    |-	bool playlist_separate_albums;
+| 139|    |-	bool set_window_title;
+| 140|    |-	bool header_visibility;
+| 141|    |-	bool header_text_scrolling;
+| 142|    |-	bool statusbar_visibility;
+| 143|    |-	bool titles_visibility;
+| 144|    |-	bool centered_cursor;
+| 145|    |-	bool screen_switcher_previous;
+| 146|    |-	bool autocenter_mode;
+| 147|    |-	bool wrapped_search;
+| 148|    |-	bool incremental_seeking;
+| 149|    |-	bool now_playing_lyrics;
+| 150|    |-	bool fetch_lyrics_in_background;
+| 151|    |-	bool local_browser_show_hidden_files;
+| 152|    |-	bool search_in_db;
+| 153|    |-	bool jump_to_now_playing_song_at_start;
+| 154|    |-	bool clock_display_seconds;
+| 155|    |-	bool display_volume_level;
+| 156|    |-	bool display_bitrate;
+| 157|    |-	bool display_remaining_time;
+| 158|    |-	bool ignore_leading_the;
+| 159|    |-	bool ignore_diacritics;
+| 160|    |-	bool block_search_constraints_change;
+| 161|    |-	bool use_console_editor;
+| 162|    |-	bool use_cyclic_scrolling;
+| 163|    |-	bool ask_before_clearing_playlists;
+| 164|    |-	bool ask_before_shuffling_playlists;
+| 165|    |-	bool mouse_support;
+| 166|    |-	bool mouse_list_scroll_whole_page;
+| 167|    |-	bool visualizer_in_stereo;
+| 168|    |-	bool data_fetching_delay;
+| 169|    |-	bool media_library_sort_by_mtime;
+| 170|    |-	bool tag_editor_extended_numeration;
+| 171|    |-	bool discard_colors_if_item_is_selected;
+| 172|    |-	bool store_lyrics_in_song_dir;
+| 173|    |-	bool generate_win32_compatible_filenames;
+| 174|    |-	bool ask_for_locked_screen_width_part;
+| 175|    |-	bool allow_for_physical_item_deletion;
+| 176|    |-	bool media_library_albums_split_by_date;
+| 177|    |-	bool startup_slave_screen_focus;
+| 178|    |-
+| 179|    |-	unsigned mpd_connection_timeout;
+| 180|    |-	unsigned crossfade_time;
+| 181|    |-	unsigned seek_time;
+| 182|    |-	unsigned volume_change_step;
+| 183|    |-	unsigned message_delay_time;
+| 184|    |-	unsigned lyrics_db;
+| 185|    |-	unsigned lines_scrolled;
+| 186|    |-	unsigned search_engine_default_search_mode;
+| 187|    |-
+| 188|    |-	boost::regex::flag_type regex_type;
+| 189|    |-
+| 190|    |-	boost::posix_time::seconds playlist_disable_highlight_delay;
+| 191|    |-	boost::posix_time::seconds visualizer_sync_interval;
+| 192|    |-
+| 193|    |-	double locked_screen_width_part;
+| 194|    |-
+| 195|    |-	size_t selected_item_prefix_length;
+| 196|    |-	size_t selected_item_suffix_length;
+| 197|    |-	size_t now_playing_prefix_length;
+| 198|    |-	size_t now_playing_suffix_length;
+| 199|    |-	size_t current_item_prefix_length;
+| 200|    |-	size_t current_item_suffix_length;
+| 201|    |-	size_t current_item_inactive_column_prefix_length;
+| 202|    |-	size_t current_item_inactive_column_suffix_length;
+| 203|    |-
+| 204|    |-	ScreenType startup_screen_type;
+| 205|    |-	boost::optional<ScreenType> startup_slave_screen_type;
+| 206|    |-	std::vector<ScreenType> screen_sequence;
+| 207|    |-
+| 208|    |-	SortMode browser_sort_mode;
+| 209|    |-
+| 210|    |-	LyricsFetchers lyrics_fetchers;
+|    |  54|+    Configuration ():playlist_disable_highlight_delay (0),
+|    |  55|+        visualizer_sync_interval (0)
+|    |  56|+    {
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    bool read (const std::vector < std::string > &config_paths,
+|    |  60|+               bool ignore_errors);
+|    |  61|+
+|    |  62|+    std::string ncmpcpp_directory;
+|    |  63|+    std::string lyrics_directory;
+|    |  64|+
+|    |  65|+    std::string mpd_music_dir;
+|    |  66|+    std::string visualizer_fifo_path;
+|    |  67|+    std::string visualizer_output_name;
+|    |  68|+    std::string empty_tag;
+|    |  69|+
+|    |  70|+    Format::AST < char >song_list_format;
+|    |  71|+    Format::AST < char >song_window_title_format;
+|    |  72|+    Format::AST < char >song_library_format;
+|    |  73|+    Format::AST < char >song_columns_mode_format;
+|    |  74|+    Format::AST < char >browser_sort_format;
+|    |  75|+    Format::AST < char >song_status_format;
+|    |  76|+    Format::AST < wchar_t > song_status_wformat;
+|    |  77|+    Format::AST < wchar_t > new_header_first_line;
+|    |  78|+    Format::AST < wchar_t > new_header_second_line;
+|    |  79|+
+|    |  80|+    std::string external_editor;
+|    |  81|+    std::string system_encoding;
+|    |  82|+    std::string execute_on_song_change;
+|    |  83|+    std::string execute_on_player_state_change;
+|    |  84|+    std::string lastfm_preferred_language;
+|    |  85|+    std::wstring progressbar;
+|    |  86|+    std::wstring visualizer_chars;
+|    |  87|+
+|    |  88|+    std::string pattern;
+|    |  89|+
+|    |  90|+    std::vector < Column > columns;
+|    |  91|+
+|    |  92|+    DisplayMode playlist_display_mode;
+|    |  93|+    DisplayMode browser_display_mode;
+|    |  94|+    DisplayMode search_engine_display_mode;
+|    |  95|+    DisplayMode playlist_editor_display_mode;
+|    |  96|+
+|    |  97|+    NC::Buffer browser_playlist_prefix;
+|    |  98|+    NC::Buffer selected_item_prefix;
+|    |  99|+    NC::Buffer selected_item_suffix;
+|    | 100|+    NC::Buffer now_playing_prefix;
+|    | 101|+    NC::Buffer now_playing_suffix;
+|    | 102|+    NC::Buffer modified_item_prefix;
+|    | 103|+    NC::Buffer current_item_prefix;
+|    | 104|+    NC::Buffer current_item_suffix;
+|    | 105|+    NC::Buffer current_item_inactive_column_prefix;
+|    | 106|+    NC::Buffer current_item_inactive_column_suffix;
+|    | 107|+
+|    | 108|+    NC::Color header_color;
+|    | 109|+    NC::Color main_color;
+|    | 110|+    NC::Color statusbar_color;
+|    | 111|+
+|    | 112|+    NC::FormattedColor color1;
+|    | 113|+    NC::FormattedColor color2;
+|    | 114|+    NC::FormattedColor empty_tags_color;
+|    | 115|+    NC::FormattedColor volume_color;
+|    | 116|+    NC::FormattedColor state_line_color;
+|    | 117|+    NC::FormattedColor state_flags_color;
+|    | 118|+    NC::FormattedColor progressbar_color;
+|    | 119|+    NC::FormattedColor progressbar_elapsed_color;
+|    | 120|+    NC::FormattedColor player_state_color;
+|    | 121|+    NC::FormattedColor statusbar_time_color;
+|    | 122|+    NC::FormattedColor alternative_ui_separator_color;
+|    | 123|+
+|    | 124|+    std::vector < NC::FormattedColor > visualizer_colors;
+|    | 125|+    VisualizerType visualizer_type;
+|    | 126|+
+|    | 127|+    NC::Border window_border;
+|    | 128|+    NC::Border active_window_border;
+|    | 129|+
+|    | 130|+    Design design;
+|    | 131|+
+|    | 132|+    SpaceAddMode space_add_mode;
+|    | 133|+
+|    | 134|+    mpd_tag_type media_lib_primary_tag;
+|    | 135|+
+|    | 136|+    bool colors_enabled;
+|    | 137|+    bool playlist_show_mpd_host;
+|    | 138|+    bool playlist_show_remaining_time;
+|    | 139|+    bool playlist_shorten_total_times;
+|    | 140|+    bool playlist_separate_albums;
+|    | 141|+    bool set_window_title;
+|    | 142|+    bool header_visibility;
+|    | 143|+    bool header_text_scrolling;
+|    | 144|+    bool statusbar_visibility;
+|    | 145|+    bool titles_visibility;
+|    | 146|+    bool centered_cursor;
+|    | 147|+    bool screen_switcher_previous;
+|    | 148|+    bool autocenter_mode;
+|    | 149|+    bool wrapped_search;
+|    | 150|+    bool incremental_seeking;
+|    | 151|+    bool now_playing_lyrics;
+|    | 152|+    bool fetch_lyrics_in_background;
+|    | 153|+    bool local_browser_show_hidden_files;
+|    | 154|+    bool search_in_db;
+|    | 155|+    bool jump_to_now_playing_song_at_start;
+|    | 156|+    bool clock_display_seconds;
+|    | 157|+    bool display_volume_level;
+|    | 158|+    bool display_bitrate;
+|    | 159|+    bool display_remaining_time;
+|    | 160|+    bool ignore_leading_the;
+|    | 161|+    bool ignore_diacritics;
+|    | 162|+    bool block_search_constraints_change;
+|    | 163|+    bool use_console_editor;
+|    | 164|+    bool use_cyclic_scrolling;
+|    | 165|+    bool ask_before_clearing_playlists;
+|    | 166|+    bool ask_before_shuffling_playlists;
+|    | 167|+    bool mouse_support;
+|    | 168|+    bool mouse_list_scroll_whole_page;
+|    | 169|+    bool visualizer_in_stereo;
+|    | 170|+    bool data_fetching_delay;
+|    | 171|+    bool media_library_sort_by_mtime;
+|    | 172|+    bool tag_editor_extended_numeration;
+|    | 173|+    bool discard_colors_if_item_is_selected;
+|    | 174|+    bool store_lyrics_in_song_dir;
+|    | 175|+    bool generate_win32_compatible_filenames;
+|    | 176|+    bool ask_for_locked_screen_width_part;
+|    | 177|+    bool allow_for_physical_item_deletion;
+|    | 178|+    bool media_library_albums_split_by_date;
+|    | 179|+    bool startup_slave_screen_focus;
+|    | 180|+
+|    | 181|+    unsigned mpd_connection_timeout;
+|    | 182|+    unsigned crossfade_time;
+|    | 183|+    unsigned seek_time;
+|    | 184|+    unsigned volume_change_step;
+|    | 185|+    unsigned message_delay_time;
+|    | 186|+    unsigned lyrics_db;
+|    | 187|+    unsigned lines_scrolled;
+|    | 188|+    unsigned search_engine_default_search_mode;
+|    | 189|+
+|    | 190|+    boost::regex::flag_type regex_type;
+|    | 191|+
+|    | 192|+    boost::posix_time::seconds playlist_disable_highlight_delay;
+|    | 193|+    boost::posix_time::seconds visualizer_sync_interval;
+|    | 194|+
+|    | 195|+    double locked_screen_width_part;
+|    | 196|+
+|    | 197|+    size_t selected_item_prefix_length;
+|    | 198|+    size_t selected_item_suffix_length;
+|    | 199|+    size_t now_playing_prefix_length;
+|    | 200|+    size_t now_playing_suffix_length;
+|    | 201|+    size_t current_item_prefix_length;
+|    | 202|+    size_t current_item_suffix_length;
+|    | 203|+    size_t current_item_inactive_column_prefix_length;
+|    | 204|+    size_t current_item_inactive_column_suffix_length;
+|    | 205|+
+|    | 206|+    ScreenType startup_screen_type;
+|    | 207|+    boost::optional < ScreenType > startup_slave_screen_type;
+|    | 208|+    std::vector < ScreenType > screen_sequence;
+|    | 209|+
+|    | 210|+    SortMode browser_sort_mode;
+|    | 211|+
+|    | 212|+    LyricsFetchers lyrics_fetchers;
+| 211| 213| };
+| 212| 214| 
+| 213| 215| extern Configuration Config;
+
+src/settings.h
+|  58| »   bool•read(const•std::vector<std::string>•&config_paths,•bool•ignore_errors);
+|    | [INFO] CSecurityBear (buffer):
+|    | read: Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist.h
+|    |++++| /app/src/screens/playlist.h
+|  30|  30| #include "song.h"
+|  31|  31| #include "song_list.h"
+|  32|  32| 
+|  33|    |-struct Playlist: Screen<SongMenu>, Filterable, HasSongs, Searchable, Tabbable
+|    |  33|+struct Playlist:Screen < SongMenu >, Filterable, HasSongs, Searchable, Tabbable
+|  34|  34| {
+|  35|    |-	Playlist();
+|  36|    |-	
+|  37|    |-	// Screen<SongMenu> implementation
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	
+|  41|    |-	virtual std::wstring title() override;
+|  42|    |-	virtual ScreenType type() override { return ScreenType::Playlist; }
+|  43|    |-	
+|  44|    |-	virtual void update() override;
+|  45|    |-	
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// Searchable implementation
+|  52|    |-	virtual bool allowsSearching() override;
+|  53|    |-	virtual const std::string &searchConstraint() override;
+|  54|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  55|    |-	virtual void clearSearchConstraint() override;
+|  56|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|    |  35|+    Playlist ();
+|  57|  36| 
+|  58|    |-	// Filterable implementation
+|  59|    |-	virtual bool allowsFiltering() override;
+|  60|    |-	virtual std::string currentFilter() override;
+|  61|    |-	virtual void applyFilter(const std::string &filter) override;
+|  62|    |-	
+|  63|    |-	// HasSongs implementation
+|  64|    |-	virtual bool itemAvailable() override;
+|  65|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  66|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  67|    |-	
+|  68|    |-	// other members
+|  69|    |-	MPD::Song nowPlayingSong();
+|    |  37|+    // Screen<SongMenu> implementation
+|    |  38|+    virtual void switchTo () override;
+|    |  39|+    virtual void resize () override;
+|  70|  40| 
+|  71|    |-	// Locate song in playlist.
+|  72|    |-	void locateSong(const MPD::Song &s);
+|    |  41|+    virtual std::wstring title () override;
+|    |  42|+    virtual ScreenType type () override
+|    |  43|+    {
+|    |  44|+        return ScreenType::Playlist;
+|    |  45|+    }
+|  73|  46| 
+|  74|    |-	void enableHighlighting();
+|  75|    |-	
+|  76|    |-	void setSelectedItemsPriority(int prio);
+|    |  47|+    virtual void update () override;
+|  77|  48| 
+|  78|    |-	bool checkForSong(const MPD::Song &s);
+|  79|    |-	void registerSong(const MPD::Song &s);
+|  80|    |-	void unregisterSong(const MPD::Song &s);
+|  81|    |-	
+|  82|    |-	void reloadTotalLength() { m_reload_total_length = true; }
+|  83|    |-	void reloadRemaining() { m_reload_remaining = true; }
+|  84|    |-	
+|  85|    |-private:
+|  86|    |-	std::string getTotalLength();
+|    |  49|+    virtual void mouseButtonPressed (MEVENT me) override;
+|  87|  50| 
+|  88|    |-	std::string m_stats;
+|  89|    |-	
+|  90|    |-	std::unordered_map<MPD::Song, int, MPD::Song::Hash> m_song_refs;
+|  91|    |-	
+|  92|    |-	size_t m_total_length;;
+|  93|    |-	size_t m_remaining_time;
+|  94|    |-	size_t m_scroll_begin;
+|  95|    |-	
+|  96|    |-	boost::posix_time::ptime m_timer;
+|    |  51|+    virtual bool isLockable () override
+|    |  52|+    {
+|    |  53|+        return true;
+|    |  54|+    }
+|    |  55|+    virtual bool isMergable () override
+|    |  56|+    {
+|    |  57|+        return true;
+|    |  58|+    }
+|  97|  59| 
+|  98|    |-	bool m_reload_total_length;
+|  99|    |-	bool m_reload_remaining;
+|    |  60|+    // Searchable implementation
+|    |  61|+    virtual bool allowsSearching () override;
+|    |  62|+    virtual const std::string & searchConstraint () override;
+|    |  63|+    virtual void setSearchConstraint (const std::string & constraint) override;
+|    |  64|+    virtual void clearSearchConstraint () override;
+|    |  65|+    virtual bool search (SearchDirection direction, bool wrap,
+|    |  66|+                         bool skip_current) override;
+| 100|  67| 
+| 101|    |-	Regex::Filter<MPD::Song> m_search_predicate;
+|    |  68|+    // Filterable implementation
+|    |  69|+    virtual bool allowsFiltering () override;
+|    |  70|+    virtual std::string currentFilter () override;
+|    |  71|+    virtual void applyFilter (const std::string & filter) override;
+|    |  72|+
+|    |  73|+    // HasSongs implementation
+|    |  74|+    virtual bool itemAvailable () override;
+|    |  75|+    virtual bool addItemToPlaylist (bool play) override;
+|    |  76|+    virtual std::vector < MPD::Song > getSelectedSongs () override;
+|    |  77|+
+|    |  78|+    // other members
+|    |  79|+    MPD::Song nowPlayingSong ();
+|    |  80|+
+|    |  81|+    // Locate song in playlist.
+|    |  82|+    void locateSong (const MPD::Song & s);
+|    |  83|+
+|    |  84|+    void enableHighlighting ();
+|    |  85|+
+|    |  86|+    void setSelectedItemsPriority (int prio);
+|    |  87|+
+|    |  88|+    bool checkForSong (const MPD::Song & s);
+|    |  89|+    void registerSong (const MPD::Song & s);
+|    |  90|+    void unregisterSong (const MPD::Song & s);
+|    |  91|+
+|    |  92|+    void reloadTotalLength ()
+|    |  93|+    {
+|    |  94|+        m_reload_total_length = true;
+|    |  95|+    }
+|    |  96|+    void reloadRemaining ()
+|    |  97|+    {
+|    |  98|+        m_reload_remaining = true;
+|    |  99|+    }
+|    | 100|+
+|    | 101|+  private:
+|    | 102|+    std::string getTotalLength ();
+|    | 103|+
+|    | 104|+    std::string m_stats;
+|    | 105|+
+|    | 106|+    std::unordered_map < MPD::Song, int, MPD::Song::Hash > m_song_refs;
+|    | 107|+
+|    | 108|+    size_t m_total_length;;
+|    | 109|+    size_t m_remaining_time;
+|    | 110|+    size_t m_scroll_begin;
+|    | 111|+
+|    | 112|+    boost::posix_time::ptime m_timer;
+|    | 113|+
+|    | 114|+    bool m_reload_total_length;
+|    | 115|+    bool m_reload_remaining;
+|    | 116|+
+|    | 117|+    Regex::Filter < MPD::Song > m_search_predicate;
+| 102| 118| };
+| 103| 119| 
+| 104| 120| extern Playlist *myPlaylist;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist.h
+|    |++++| /app/src/screens/playlist.h
+| 104| 104| extern Playlist *myPlaylist;
+| 105| 105| 
+| 106| 106| #endif // NCMPCPP_PLAYLIST_H
+| 107|    |-
+
+src/gcc.h
+|  24| #•define•GNUC_PRINTF(a,•b)•__attribute__((format(printf,•a,•b)))
+|    | [NORMAL] CSecurityBear (format):
+|    | printf: If format strings can be influenced by an attacker, they can be exploited (CWE-134).  Use a constant for the format specification.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen_type.h
+|    |++++| /app/src/screens/screen_type.h
+|  27|  27| // forward declaration
+|  28|  28| struct BaseScreen;
+|  29|  29| 
+|  30|    |-enum class ScreenType {
+|  31|    |-	Browser,
+|    |  30|+enum class ScreenType
+|    |  31|+{
+|    |  32|+    Browser,
+|  32|  33| #	ifdef ENABLE_CLOCK
+|  33|    |-	Clock,
+|  34|    |-#	endif // ENABLE_CLOCK
+|  35|    |-	Help,
+|  36|    |-	Lastfm,
+|  37|    |-	Lyrics,
+|  38|    |-	MediaLibrary,
+|    |  34|+    Clock,
+|    |  35|+#	endif                       // ENABLE_CLOCK
+|    |  36|+    Help,
+|    |  37|+    Lastfm,
+|    |  38|+    Lyrics,
+|    |  39|+    MediaLibrary,
+|  39|  40| #	ifdef ENABLE_OUTPUTS
+|  40|    |-	Outputs,
+|  41|    |-#	endif // ENABLE_OUTPUTS
+|  42|    |-	Playlist,
+|  43|    |-	PlaylistEditor,
+|  44|    |-	SearchEngine,
+|  45|    |-	SelectedItemsAdder,
+|  46|    |-	ServerInfo,
+|  47|    |-	SongInfo,
+|  48|    |-	SortPlaylistDialog,
+|    |  41|+    Outputs,
+|    |  42|+#	endif                       // ENABLE_OUTPUTS
+|    |  43|+    Playlist,
+|    |  44|+    PlaylistEditor,
+|    |  45|+    SearchEngine,
+|    |  46|+    SelectedItemsAdder,
+|    |  47|+    ServerInfo,
+|    |  48|+    SongInfo,
+|    |  49|+    SortPlaylistDialog,
+|  49|  50| #	ifdef HAVE_TAGLIB_H
+|  50|    |-	TagEditor,
+|  51|    |-	TinyTagEditor,
+|  52|    |-#	endif // HAVE_TAGLIB_H
+|  53|    |-	Unknown,
+|    |  51|+    TagEditor,
+|    |  52|+    TinyTagEditor,
+|    |  53|+#	endif                       // HAVE_TAGLIB_H
+|    |  54|+    Unknown,
+|  54|  55| #	ifdef ENABLE_VISUALIZER
+|  55|    |-	Visualizer,
+|  56|    |-#	endif // ENABLE_VISUALIZER
+|    |  56|+    Visualizer,
+|    |  57|+#	endif                       // ENABLE_VISUALIZER
+|  57|  58| };
+|  58|  59| 
+|  59|  60| std::string screenTypeToString(ScreenType st);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen_type.h
+|    |++++| /app/src/screens/screen_type.h
+|  56|  56| #	endif // ENABLE_VISUALIZER
+|  57|  57| };
+|  58|  58| 
+|  59|    |-std::string screenTypeToString(ScreenType st);
+|    |  59|+std::string screenTypeToString (ScreenType st);
+|  60|  60| 
+|  61|    |-ScreenType stringtoStartupScreenType(const std::string &s);
+|  62|    |-ScreenType stringToScreenType(const std::string &s);
+|    |  61|+ScreenType stringtoStartupScreenType (const std::string & s);
+|    |  62|+ScreenType stringToScreenType (const std::string & s);
+|  63|  63| 
+|  64|    |-BaseScreen *toScreen(ScreenType st);
+|    |  64|+BaseScreen *toScreen (ScreenType st);
+|  65|  65| 
+|  66|  66| #endif // NCMPCPP_SCREEN_TYPE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tiny_tag_editor.h
+|    |++++| /app/src/screens/tiny_tag_editor.h
+|  29|  29| #include "mutable_song.h"
+|  30|  30| #include "screens/screen.h"
+|  31|  31| 
+|  32|    |-struct TinyTagEditor: Screen<NC::Menu<NC::Buffer>>, HasActions
+|    |  32|+struct TinyTagEditor:Screen <
+|    |  33|+    NC::Menu <
+|    |  34|+    NC::Buffer >>,
+|    |  35|+    HasActions
+|  33|  36| {
+|  34|    |-	TinyTagEditor();
+|  35|    |-	
+|  36|    |-	// Screen< NC::Menu<NC::Buffer> > implementation
+|  37|    |-	virtual void resize() override;
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	
+|  40|    |-	virtual std::wstring title() override;
+|  41|    |-	virtual ScreenType type() override { return ScreenType::TinyTagEditor; }
+|  42|    |-	
+|  43|    |-	virtual void update() override { }
+|  44|    |-	
+|  45|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  46|    |-	
+|  47|    |-	virtual bool isLockable() override { return false; }
+|  48|    |-	virtual bool isMergable() override { return true; }
+|    |  37|+    TinyTagEditor ();
+|  49|  38| 
+|  50|    |-	// HasActions implementation
+|  51|    |-	virtual bool actionRunnable() override;
+|  52|    |-	virtual void runAction() override;
+|    |  39|+    // Screen< NC::Menu<NC::Buffer> > implementation
+|    |  40|+    virtual void
+|    |  41|+    resize ()
+|    |  42|+        override;
+|    |  43|+    virtual void
+|    |  44|+    switchTo ()
+|    |  45|+        override;
+|  53|  46| 
+|  54|    |-	// private members
+|  55|    |-	void SetEdited(const MPD::Song &);
+|  56|    |-	
+|  57|    |-private:
+|  58|    |-	bool getTags();
+|  59|    |-	MPD::MutableSong itsEdited;
+|  60|    |-	BaseScreen *m_previous_screen;
+|    |  47|+    virtual
+|    |  48|+        std::wstring
+|    |  49|+    title ()
+|    |  50|+        override;
+|    |  51|+    virtual ScreenType
+|    |  52|+    type ()
+|    |  53|+        override
+|    |  54|+    {
+|    |  55|+        return ScreenType::TinyTagEditor;
+|    |  56|+    }
+|    |  57|+
+|    |  58|+    virtual void
+|    |  59|+    update ()
+|    |  60|+        override
+|    |  61|+    {
+|    |  62|+    }
+|    |  63|+
+|    |  64|+    virtual void
+|    |  65|+    mouseButtonPressed (MEVENT me)
+|    |  66|+        override;
+|    |  67|+
+|    |  68|+    virtual bool
+|    |  69|+    isLockable ()
+|    |  70|+        override
+|    |  71|+    {
+|    |  72|+        return false;
+|    |  73|+    }
+|    |  74|+    virtual bool
+|    |  75|+    isMergable ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return true;
+|    |  79|+    }
+|    |  80|+
+|    |  81|+    // HasActions implementation
+|    |  82|+    virtual bool
+|    |  83|+    actionRunnable ()
+|    |  84|+        override;
+|    |  85|+    virtual void
+|    |  86|+    runAction ()
+|    |  87|+        override;
+|    |  88|+
+|    |  89|+    // private members
+|    |  90|+    void
+|    |  91|+    SetEdited (const MPD::Song &);
+|    |  92|+
+|    |  93|+  private:
+|    |  94|+    bool getTags ();
+|    |  95|+    MPD::MutableSong itsEdited;
+|    |  96|+    BaseScreen *
+|    |  97|+        m_previous_screen;
+|  61|  98| };
+|  62|  99| 
+|  63| 100| extern TinyTagEditor *myTinyTagEditor;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tiny_tag_editor.h
+|    |++++| /app/src/screens/tiny_tag_editor.h
+|  60|  60| 	BaseScreen *m_previous_screen;
+|  61|  61| };
+|  62|  62| 
+|  63|    |-extern TinyTagEditor *myTinyTagEditor;
+|    |  63|+extern TinyTagEditor *
+|    |  64|+    myTinyTagEditor;
+|  64|  65| 
+|  65|  66| #endif // HAVE_TAGLIB_H
+|  66|  67| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tiny_tag_editor.h
+|    |++++| /app/src/screens/tiny_tag_editor.h
+|  65|  65| #endif // HAVE_TAGLIB_H
+|  66|  66| 
+|  67|  67| #endif // NCMPCPP_TINY_TAG_EDITOR_H
+|  68|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.h
+|    |++++| /app/src/screens/song_info.h
+|  25|  25| #include "mutable_song.h"
+|  26|  26| #include "screens/screen.h"
+|  27|  27| 
+|  28|    |-struct SongInfo: Screen<NC::Scrollpad>, Tabbable
+|    |  28|+struct SongInfo:Screen <
+|    |  29|+    NC::Scrollpad >,
+|    |  30|+    Tabbable
+|  29|  31| {
+|  30|    |-	struct Metadata
+|  31|    |-	{
+|  32|    |-		const char *Name;
+|  33|    |-		MPD::Song::GetFunction Get;
+|  34|    |-		MPD::MutableSong::SetFunction Set;
+|  35|    |-	};
+|  36|    |-	
+|  37|    |-	SongInfo();
+|  38|    |-	
+|  39|    |-	// Screen<NC::Scrollpad> implementation
+|  40|    |-	virtual void switchTo() override;
+|  41|    |-	virtual void resize() override;
+|  42|    |-	
+|  43|    |-	virtual std::wstring title() override;
+|  44|    |-	virtual ScreenType type() override { return ScreenType::SongInfo; }
+|  45|    |-	
+|  46|    |-	virtual void update() override { }
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return false; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// private members
+|  52|    |-	static const Metadata Tags[];
+|  53|    |-	
+|  54|    |-private:
+|  55|    |-	void PrepareSong(const MPD::Song &s);
+|    |  32|+    struct Metadata
+|    |  33|+    {
+|    |  34|+        const char *
+|    |  35|+            Name;
+|    |  36|+        MPD::Song::GetFunction
+|    |  37|+            Get;
+|    |  38|+        MPD::MutableSong::SetFunction
+|    |  39|+            Set;
+|    |  40|+    };
+|    |  41|+
+|    |  42|+    SongInfo ();
+|    |  43|+
+|    |  44|+    // Screen<NC::Scrollpad> implementation
+|    |  45|+    virtual void
+|    |  46|+    switchTo ()
+|    |  47|+        override;
+|    |  48|+    virtual void
+|    |  49|+    resize ()
+|    |  50|+        override;
+|    |  51|+
+|    |  52|+    virtual
+|    |  53|+        std::wstring
+|    |  54|+    title ()
+|    |  55|+        override;
+|    |  56|+    virtual ScreenType
+|    |  57|+    type ()
+|    |  58|+        override
+|    |  59|+    {
+|    |  60|+        return ScreenType::SongInfo;
+|    |  61|+    }
+|    |  62|+
+|    |  63|+    virtual void
+|    |  64|+    update ()
+|    |  65|+        override
+|    |  66|+    {
+|    |  67|+    }
+|    |  68|+
+|    |  69|+    virtual bool
+|    |  70|+    isLockable ()
+|    |  71|+        override
+|    |  72|+    {
+|    |  73|+        return false;
+|    |  74|+    }
+|    |  75|+    virtual bool
+|    |  76|+    isMergable ()
+|    |  77|+        override
+|    |  78|+    {
+|    |  79|+        return true;
+|    |  80|+    }
+|    |  81|+
+|    |  82|+    // private members
+|    |  83|+    static const Metadata
+|    |  84|+        Tags[];
+|    |  85|+
+|    |  86|+  private:
+|    |  87|+    void
+|    |  88|+    PrepareSong (const MPD::Song & s);
+|  56|  89| };
+|  57|  90| 
+|  58|  91| extern SongInfo *mySongInfo;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.h
+|    |++++| /app/src/screens/song_info.h
+|  55|  55| 	void PrepareSong(const MPD::Song &s);
+|  56|  56| };
+|  57|  57| 
+|  58|    |-extern SongInfo *mySongInfo;
+|    |  58|+extern SongInfo *
+|    |  59|+    mySongInfo;
+|  59|  60| 
+|  60|  61| #endif // NCMPCPP_SONG_INFO_H
+|  61|  62| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.h
+|    |++++| /app/src/screens/song_info.h
+|  58|  58| extern SongInfo *mySongInfo;
+|  59|  59| 
+|  60|  60| #endif // NCMPCPP_SONG_INFO_H
+|  61|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/storage_kind.h
+|    |++++| /app/src/utility/storage_kind.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_STORAGE_KIND_H
+|  22|  22| #define NCMPCPP_UTILITY_STORAGE_KIND_H
+|  23|  23| 
+|  24|    |-enum class StorageKind { Reference, Value };
+|    |  24|+enum class StorageKind
+|    |  25|+{ Reference, Value };
+|  25|  26| 
+|  26|  27| #endif // NCMPCPP_UTILITY_VALUE_TYPE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+|  28|  28| 
+|  29|  29| struct SongProperties
+|  30|  30| {
+|  31|    |-	enum class State { Undefined, Const, Mutable };
+|    |  31|+    enum class State
+|    |  32|+    { Undefined, Const, Mutable };
+|  32|  33| 
+|  33|    |-	SongProperties()
+|  34|    |-		: m_state(State::Undefined)
+|  35|    |-	{ }
+|    |  34|+      SongProperties ():m_state (State::Undefined)
+|    |  35|+    {
+|    |  36|+    }
+|  36|  37| 
+|  37|    |-	SongProperties &assign(NC::List::Properties *properties_, MPD::Song *song_)
+|  38|    |-	{
+|  39|    |-		m_state = State::Mutable;
+|  40|    |-		m_properties = properties_;
+|  41|    |-		m_song = song_;
+|  42|    |-		return *this;
+|  43|    |-	}
+|    |  38|+    SongProperties & assign (NC::List::Properties * properties_,
+|    |  39|+                             MPD::Song * song_)
+|    |  40|+    {
+|    |  41|+        m_state = State::Mutable;
+|    |  42|+        m_properties = properties_;
+|    |  43|+        m_song = song_;
+|    |  44|+        return *this;
+|    |  45|+    }
+|  44|  46| 
+|  45|    |-	SongProperties &assign(const NC::List::Properties *properties_, const MPD::Song *song_)
+|  46|    |-	{
+|  47|    |-		m_state = State::Const;
+|  48|    |-		m_const_properties = properties_;
+|  49|    |-		m_const_song = song_;
+|  50|    |-		return *this;
+|  51|    |-	}
+|    |  47|+    SongProperties & assign (const NC::List::Properties * properties_,
+|    |  48|+                             const MPD::Song * song_)
+|    |  49|+    {
+|    |  50|+        m_state = State::Const;
+|    |  51|+        m_const_properties = properties_;
+|    |  52|+        m_const_song = song_;
+|    |  53|+        return *this;
+|    |  54|+    }
+|  52|  55| 
+|  53|    |-	const NC::List::Properties &properties() const
+|  54|    |-	{
+|  55|    |-		assert(m_state != State::Undefined);
+|  56|    |-		return *m_const_properties;
+|  57|    |-	}
+|  58|    |-	const MPD::Song *song() const
+|  59|    |-	{
+|  60|    |-		assert(m_state != State::Undefined);
+|  61|    |-		return m_const_song;
+|  62|    |-	}
+|    |  56|+    const NC::List::Properties & properties () const
+|    |  57|+    {
+|    |  58|+        assert (m_state != State::Undefined);
+|    |  59|+        return *m_const_properties;
+|    |  60|+    }
+|    |  61|+    const MPD::Song * song () const
+|    |  62|+    {
+|    |  63|+        assert (m_state != State::Undefined);
+|    |  64|+        return m_const_song;
+|    |  65|+    }
+|  63|  66| 
+|  64|    |-	NC::List::Properties &properties()
+|  65|    |-	{
+|  66|    |-		assert(m_state == State::Mutable);
+|  67|    |-		return *m_properties;
+|  68|    |-	}
+|  69|    |-	MPD::Song *song()
+|  70|    |-	{
+|  71|    |-		assert(m_state == State::Mutable);
+|  72|    |-		return m_song;
+|  73|    |-	}
+|    |  67|+    NC::List::Properties & properties ()
+|    |  68|+    {
+|    |  69|+        assert (m_state == State::Mutable);
+|    |  70|+        return *m_properties;
+|    |  71|+    }
+|    |  72|+    MPD::Song * song ()
+|    |  73|+    {
+|    |  74|+        assert (m_state == State::Mutable);
+|    |  75|+        return m_song;
+|    |  76|+    }
+|  74|  77| 
+|  75|    |-private:
+|  76|    |-	State m_state;
+|    |  78|+  private:
+|    |  79|+    State m_state;
+|  77|  80| 
+|  78|    |-	union {
+|  79|    |-		NC::List::Properties *m_properties;
+|  80|    |-		const NC::List::Properties *m_const_properties;
+|  81|    |-	};
+|  82|    |-	union {
+|  83|    |-		MPD::Song *m_song;
+|  84|    |-		const MPD::Song *m_const_song;
+|  85|    |-	};
+|    |  81|+    union
+|    |  82|+    {
+|    |  83|+        NC::List::Properties * m_properties;
+|    |  84|+        const NC::List::Properties * m_const_properties;
+|    |  85|+    };
+|    |  86|+    union
+|    |  87|+    {
+|    |  88|+        MPD::Song * m_song;
+|    |  89|+        const MPD::Song * m_const_song;
+|    |  90|+    };
+|  86|  91| };
+|  87|  92| 
+|  88|  93| template <Const const_>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+|  85|  85| 	};
+|  86|  86| };
+|  87|  87| 
+|  88|    |-template <Const const_>
+|  89|    |-using SongIteratorT = boost::range_detail::any_iterator<
+|  90|    |-	typename std::conditional<
+|  91|    |-		const_ == Const::Yes,
+|  92|    |-		const SongProperties,
+|  93|    |-		SongProperties>::type,
+|  94|    |-	boost::random_access_traversal_tag,
+|  95|    |-	typename std::conditional<
+|  96|    |-		const_ == Const::Yes,
+|  97|    |-		const SongProperties &,
+|  98|    |-		SongProperties &>::type,
+|  99|    |-	std::ptrdiff_t
+| 100|    |-	>;
+|    |  88|+template < Const const_ >
+|    |  89|+    using SongIteratorT = boost::range_detail::any_iterator <
+|    |  90|+    typename std::conditional < const_ == Const::Yes, const
+|    |  91|+    SongProperties,
+|    |  92|+    SongProperties >::type,
+|    |  93|+    boost::random_access_traversal_tag,
+|    |  94|+    typename
+|    |  95|+    std::conditional <
+|    |  96|+    const_ == Const::Yes, const
+|    |  97|+    SongProperties &,
+|    |  98|+SongProperties & >::type,
+|    |  99|+    std::ptrdiff_t >;
+| 101| 100| 
+| 102|    |-typedef SongIteratorT<Const::No> SongIterator;
+| 103|    |-typedef SongIteratorT<Const::Yes> ConstSongIterator;
+|    | 101|+typedef
+|    | 102|+    SongIteratorT <
+|    | 103|+    Const::No >
+|    | 104|+    SongIterator;
+|    | 105|+typedef
+|    | 106|+    SongIteratorT <
+|    | 107|+    Const::Yes >
+|    | 108|+    ConstSongIterator;
+| 104| 109| 
+| 105| 110| struct SongList
+| 106| 111| {
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+| 104| 104| 
+| 105| 105| struct SongList
+| 106| 106| {
+| 107|    |-	virtual SongIterator currentS() = 0;
+| 108|    |-	virtual ConstSongIterator currentS() const = 0;
+| 109|    |-	virtual SongIterator beginS() = 0;
+| 110|    |-	virtual ConstSongIterator beginS() const = 0;
+| 111|    |-	virtual SongIterator endS() = 0;
+| 112|    |-	virtual ConstSongIterator endS() const = 0;
+|    | 107|+    virtual SongIterator
+|    | 108|+    currentS () = 0;
+|    | 109|+    virtual ConstSongIterator
+|    | 110|+    currentS () const = 0;
+|    | 111|+    virtual SongIterator
+|    | 112|+    beginS () = 0;
+|    | 113|+    virtual ConstSongIterator
+|    | 114|+    beginS () const = 0;
+|    | 115|+    virtual SongIterator
+|    | 116|+    endS () = 0;
+|    | 117|+    virtual ConstSongIterator
+|    | 118|+    endS () const = 0;
+| 113| 119| 
+| 114|    |-	virtual std::vector<MPD::Song> getSelectedSongs() = 0;
+|    | 120|+    virtual
+|    | 121|+        std::vector <
+|    | 122|+        MPD::Song >
+|    | 123|+    getSelectedSongs () = 0;
+| 115| 124| };
+| 116| 125| 
+| 117| 126| inline SongIterator begin(SongList &list) { return list.beginS(); }
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+| 114| 114| 	virtual std::vector<MPD::Song> getSelectedSongs() = 0;
+| 115| 115| };
+| 116| 116| 
+| 117|    |-inline SongIterator begin(SongList &list) { return list.beginS(); }
+| 118|    |-inline ConstSongIterator begin(const SongList &list) { return list.beginS(); }
+| 119|    |-inline SongIterator end(SongList &list) { return list.endS(); }
+| 120|    |-inline ConstSongIterator end(const SongList &list) { return list.endS(); }
+|    | 117|+inline SongIterator
+|    | 118|+begin (SongList & list)
+|    | 119|+{
+|    | 120|+    return list.beginS ();
+|    | 121|+}
+|    | 122|+inline ConstSongIterator
+|    | 123|+begin (const SongList & list)
+|    | 124|+{
+|    | 125|+    return list.beginS ();
+|    | 126|+}
+|    | 127|+inline SongIterator
+|    | 128|+end (SongList & list)
+|    | 129|+{
+|    | 130|+    return list.endS ();
+|    | 131|+}
+|    | 132|+inline ConstSongIterator
+|    | 133|+end (const SongList & list)
+|    | 134|+{
+|    | 135|+    return list.endS ();
+|    | 136|+}
+| 121| 137| 
+| 122|    |-struct SongMenu: NC::Menu<MPD::Song>, SongList
+|    | 138|+struct SongMenu:
+|    | 139|+    NC::Menu <
+|    | 140|+    MPD::Song >,
+|    | 141|+    SongList
+| 123| 142| {
+| 124|    |-	SongMenu() { }
+| 125|    |-	SongMenu(NC::Menu<MPD::Song> &&base)
+| 126|    |-	: NC::Menu<MPD::Song>(std::move(base)) { }
+|    | 143|+    SongMenu ()
+|    | 144|+    {
+|    | 145|+    }
+|    | 146|+    SongMenu (NC::Menu < MPD::Song > &&base):NC::Menu < MPD::Song >
+|    | 147|+        (std::move (base))
+|    | 148|+    {
+|    | 149|+    }
+| 127| 150| 
+| 128|    |-	virtual SongIterator currentS() override;
+| 129|    |-	virtual ConstSongIterator currentS() const override;
+| 130|    |-	virtual SongIterator beginS() override;
+| 131|    |-	virtual ConstSongIterator beginS() const override;
+| 132|    |-	virtual SongIterator endS() override;
+| 133|    |-	virtual ConstSongIterator endS() const override;
+|    | 151|+    virtual SongIterator currentS () override;
+|    | 152|+    virtual ConstSongIterator currentS () const override;
+|    | 153|+    virtual SongIterator beginS () override;
+|    | 154|+    virtual ConstSongIterator beginS () const override;
+|    | 155|+    virtual SongIterator endS () override;
+|    | 156|+    virtual ConstSongIterator endS () const override;
+| 134| 157| 
+| 135|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|    | 158|+    virtual std::vector < MPD::Song > getSelectedSongs () override;
+| 136| 159| };
+| 137| 160| 
+| 138| 161| #endif // NCMPCPP_SONG_LIST_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/regex_filter.h
+|    |++++| /app/src/regex_filter.h
+|  36|  36| 
+|  37|  37| #include "utility/functional.h"
+|  38|  38| 
+|  39|    |-namespace {
+|  40|    |-
+|  41|    |-#ifdef BOOST_REGEX_ICU
+|  42|    |-
+|  43|    |-struct StripDiacritics
+|  44|    |-{
+|  45|    |-	static void convert(UnicodeString &s)
+|  46|    |-	{
+|  47|    |-		if (m_converter == nullptr)
+|  48|    |-		{
+|  49|    |-			ErrorCode result;
+|  50|    |-			m_converter = Transliterator::createInstance(
+|  51|    |-				"NFD; [:M:] Remove; NFC", UTRANS_FORWARD, result);
+|  52|    |-			if (result.isFailure())
+|  53|    |-				throw std::runtime_error(
+|  54|    |-					"instantiation of transliterator instance failed with "
+|  55|    |-					+ std::string(result.errorName()));
+|  56|    |-		}
+|  57|    |-		m_converter->transliterate(s);
+|  58|    |-	}
+|  59|    |-
+|  60|    |-private:
+|  61|    |-	static Transliterator *m_converter;
+|  62|    |-};
+|  63|    |-
+|  64|    |-Transliterator *StripDiacritics::m_converter;
+|    |  39|+namespace
+|    |  40|+{
+|    |  41|+
+|    |  42|+#ifdef BOOST_REGEX_ICU
+|    |  43|+
+|    |  44|+    struct StripDiacritics
+|    |  45|+    {
+|    |  46|+        static void convert (UnicodeString & s)
+|    |  47|+        {
+|    |  48|+            if (m_converter == nullptr)
+|    |  49|+              {
+|    |  50|+                  ErrorCode result;
+|    |  51|+                    m_converter =
+|    |  52|+                      Transliterator::createInstance ("NFD; [:M:] Remove; NFC",
+|    |  53|+                                                      UTRANS_FORWARD, result);
+|    |  54|+                  if (result.isFailure ())
+|    |  55|+                      throw std::
+|    |  56|+                          runtime_error
+|    |  57|+                          ("instantiation of transliterator instance failed with "
+|    |  58|+                           + std::string (result.errorName ()));
+|    |  59|+              }
+|    |  60|+            m_converter->transliterate (s);
+|    |  61|+        }
+|    |  62|+
+|    |  63|+      private:
+|    |  64|+        static Transliterator *m_converter;
+|    |  65|+    };
+|    |  66|+
+|    |  67|+    Transliterator *StripDiacritics::m_converter;
+|  65|  68| 
+|  66|  69| #endif // BOOST_REGEX_ICU
+|  67|  70| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/regex_filter.h
+|    |++++| /app/src/regex_filter.h
+|  67|  67| 
+|  68|  68| }
+|  69|  69| 
+|  70|    |-namespace Regex {
+|  71|    |-
+|  72|    |-typedef
+|  73|    |-#ifdef BOOST_REGEX_ICU
+|  74|    |-	boost::u32regex
+|  75|    |-#else
+|  76|    |-	boost::regex
+|  77|    |-#endif // BOOST_REGEX_ICU
+|  78|    |-Regex;
+|  79|    |-
+|  80|    |-template <typename StringT>
+|  81|    |-inline Regex make(StringT &&s,
+|  82|    |-                  boost::regex_constants::syntax_option_type flags)
+|  83|    |-{
+|  84|    |-	return
+|  85|    |-#ifdef BOOST_REGEX_ICU
+|  86|    |-	boost::make_u32regex
+|  87|    |-#else
+|  88|    |-	boost::regex
+|  89|    |-#endif // BOOST_REGEX_ICU
+|  90|    |-	(std::forward<StringT>(s), flags);
+|    |  70|+namespace Regex
+|    |  71|+{
+|    |  72|+
+|    |  73|+    typedef
+|    |  74|+#ifdef BOOST_REGEX_ICU
+|    |  75|+      boost::u32regex
+|    |  76|+#else
+|    |  77|+      boost::regex
+|    |  78|+#endif                          // BOOST_REGEX_ICU
+|    |  79|+      Regex;
+|    |  80|+
+|    |  81|+      template < typename StringT >
+|    |  82|+        inline Regex make (StringT && s,
+|    |  83|+                           boost::regex_constants::syntax_option_type flags)
+|    |  84|+    {
+|    |  85|+        return
+|    |  86|+#ifdef BOOST_REGEX_ICU
+|    |  87|+            boost::make_u32regex
+|    |  88|+#else
+|    |  89|+            boost::regex
+|    |  90|+#endif // BOOST_REGEX_ICU
+|    |  91|+            (std::forward < StringT > (s), flags);
+|    |  92|+    }
+|    |  93|+
+|    |  94|+    template < typename CharT >
+|    |  95|+        inline bool search (const std::basic_string < CharT > &s,
+|    |  96|+                            const Regex & rx, bool ignore_diacritics)
+|    |  97|+    {
+|    |  98|+        try
+|    |  99|+        {
+|    | 100|+#ifdef BOOST_REGEX_ICU
+|    | 101|+            if (ignore_diacritics)
+|    | 102|+              {
+|    | 103|+                  auto us =
+|    | 104|+                      UnicodeString::
+|    | 105|+                      fromUTF8 (StringPiece
+|    | 106|+                                (convertString < char, CharT >::apply (s)));
+|    | 107|+                  StripDiacritics::convert (us);
+|    | 108|+                  return boost::u32regex_search (us, rx);
+|    | 109|+              }
+|    | 110|+            else
+|    | 111|+                return boost::u32regex_search (s, rx);
+|    | 112|+#else
+|    | 113|+            return boost::regex_search (s, rx);
+|    | 114|+#endif // BOOST_REGEX_ICU
+|    | 115|+        }
+|    | 116|+        catch (std::out_of_range & e)
+|    | 117|+        {
+|    | 118|+            // Invalid UTF-8 sequence, ignore the string.
+|    | 119|+            std::cerr << "Regex::search: error while processing \""
+|    | 120|+                << s << "\": " << e.what () << "\n";
+|    | 121|+            return false;
+|    | 122|+        }
+|    | 123|+    }
+|    | 124|+
+|    | 125|+    template < typename T > struct Filter
+|    | 126|+    {
+|    | 127|+        typedef NC::Menu < T > MenuT;
+|    | 128|+        typedef typename NC::Menu < T >::Item Item;
+|    | 129|+        typedef std::function < bool (const Regex &,
+|    | 130|+                                      const T &) > FilterFunction;
+|    | 131|+
+|    | 132|+          Filter ()
+|    | 133|+        {
+|    | 134|+        }
+|    | 135|+
+|    | 136|+        template < typename FilterT >
+|    | 137|+            Filter (const std::string & constraint_,
+|    | 138|+                    boost::regex_constants::syntax_option_type flags,
+|    | 139|+                    FilterT
+|    | 140|+                    && filter):m_rx (make (constraint_, flags)),
+|    | 141|+            m_constraint (constraint_),
+|    | 142|+            m_filter (std::forward < FilterT > (filter))
+|    | 143|+        {
+|    | 144|+        }
+|    | 145|+
+|    | 146|+        void clear ()
+|    | 147|+        {
+|    | 148|+            m_filter = nullptr;
+|    | 149|+        }
+|    | 150|+
+|    | 151|+        const std::string & constraint () const
+|    | 152|+        {
+|    | 153|+            return m_constraint;
+|    | 154|+        }
+|    | 155|+
+|    | 156|+        bool operator () (const Item & item) const
+|    | 157|+        {
+|    | 158|+            assert (defined ());
+|    | 159|+            return m_filter (m_rx, item.value ());
+|    | 160|+        }
+|    | 161|+
+|    | 162|+        bool defined () const
+|    | 163|+        {
+|    | 164|+            return m_filter.operator  bool ();
+|    | 165|+        }
+|    | 166|+
+|    | 167|+      private:
+|    | 168|+          Regex m_rx;
+|    | 169|+        std::string m_constraint;
+|    | 170|+        FilterFunction m_filter;
+|    | 171|+    };
+|    | 172|+
+|    | 173|+    template < typename T > struct ItemFilter
+|    | 174|+    {
+|    | 175|+        typedef NC::Menu < T > MenuT;
+|    | 176|+        typedef typename NC::Menu < T >::Item Item;
+|    | 177|+        typedef std::function < bool (const Regex &,
+|    | 178|+                                      const Item &) > FilterFunction;
+|    | 179|+
+|    | 180|+          ItemFilter ()
+|    | 181|+        {
+|    | 182|+        }
+|    | 183|+
+|    | 184|+        template < typename FilterT >
+|    | 185|+            ItemFilter (const std::string & constraint_,
+|    | 186|+                        boost::regex_constants::syntax_option_type flags,
+|    | 187|+                        FilterT
+|    | 188|+                        && filter):m_rx (make (constraint_, flags)),
+|    | 189|+            m_constraint (constraint_),
+|    | 190|+            m_filter (std::forward < FilterT > (filter))
+|    | 191|+        {
+|    | 192|+        }
+|    | 193|+
+|    | 194|+        void clear ()
+|    | 195|+        {
+|    | 196|+            m_filter = nullptr;
+|    | 197|+        }
+|    | 198|+
+|    | 199|+        const std::string & constraint () const
+|    | 200|+        {
+|    | 201|+            return m_constraint;
+|    | 202|+        }
+|    | 203|+
+|    | 204|+        bool operator () (const Item & item)
+|    | 205|+        {
+|    | 206|+            return m_filter (m_rx, item);
+|    | 207|+        }
+|    | 208|+
+|    | 209|+        bool defined () const
+|    | 210|+        {
+|    | 211|+            return m_filter.operator  bool ();
+|    | 212|+        }
+|    | 213|+
+|    | 214|+      private:
+|    | 215|+          Regex m_rx;
+|    | 216|+        std::string m_constraint;
+|    | 217|+        FilterFunction m_filter;
+|    | 218|+    };
+|    | 219|+
+|  91| 220| }
+|  92| 221| 
+|  93| 222| template <typename CharT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/regex_filter.h
+|    |++++| /app/src/regex_filter.h
+|  90|  90| 	(std::forward<StringT>(s), flags);
+|  91|  91| }
+|  92|  92| 
+|  93|    |-template <typename CharT>
+|  94|    |-inline bool search(const std::basic_string<CharT> &s,
+|  95|    |-                   const Regex &rx,
+|  96|    |-                   bool ignore_diacritics)
+|  97|    |-{
+|  98|    |-	try {
+|  99|    |-#ifdef BOOST_REGEX_ICU
+| 100|    |-		if (ignore_diacritics)
+| 101|    |-		{
+| 102|    |-			auto us = UnicodeString::fromUTF8(
+| 103|    |-				StringPiece(convertString<char, CharT>::apply(s)));
+| 104|    |-			StripDiacritics::convert(us);
+| 105|    |-			return boost::u32regex_search(us, rx);
+| 106|    |-		}
+| 107|    |-		else
+| 108|    |-			return boost::u32regex_search(s, rx);
+| 109|    |-#else
+| 110|    |-		return boost::regex_search(s, rx);
+| 111|    |-#endif // BOOST_REGEX_ICU
+| 112|    |-	} catch (std::out_of_range &e) {
+| 113|    |-		// Invalid UTF-8 sequence, ignore the string.
+| 114|    |-		std::cerr << "Regex::search: error while processing \""
+| 115|    |-		          << s
+| 116|    |-		          << "\": "
+| 117|    |-		          << e.what()
+| 118|    |-		          << "\n";
+| 119|    |-		return false;
+| 120|    |-	}
+| 121|    |-}
+| 122|    |-
+| 123|    |-template <typename T>
+| 124|    |-struct Filter
+| 125|    |-{
+| 126|    |-	typedef NC::Menu<T> MenuT;
+| 127|    |-	typedef typename NC::Menu<T>::Item Item;
+| 128|    |-	typedef std::function<bool(const Regex &, const T &)> FilterFunction;
+| 129|    |-
+| 130|    |-	Filter() { }
+| 131|    |-
+| 132|    |-	template <typename FilterT>
+| 133|    |-	Filter(const std::string &constraint_,
+| 134|    |-	       boost::regex_constants::syntax_option_type flags,
+| 135|    |-	       FilterT &&filter)
+| 136|    |-		: m_rx(make(constraint_, flags))
+| 137|    |-		, m_constraint(constraint_)
+| 138|    |-		, m_filter(std::forward<FilterT>(filter))
+| 139|    |-	{ }
+| 140|    |-
+| 141|    |-	void clear()
+| 142|    |-	{
+| 143|    |-		m_filter = nullptr;
+| 144|    |-	}
+| 145|    |-
+| 146|    |-	const std::string &constraint() const {
+| 147|    |-		return m_constraint;
+| 148|    |-	}
+| 149|    |-
+| 150|    |-	bool operator()(const Item &item) const {
+| 151|    |-		assert(defined());
+| 152|    |-		return m_filter(m_rx, item.value());
+| 153|    |-	}
+| 154|    |-
+| 155|    |-	bool defined() const
+| 156|    |-	{
+| 157|    |-		return m_filter.operator bool();
+| 158|    |-	}
+| 159|    |-
+| 160|    |-private:
+| 161|    |-	Regex m_rx;
+| 162|    |-	std::string m_constraint;
+| 163|    |-	FilterFunction m_filter;
+| 164|    |-};
+| 165|    |-
+| 166|    |-template <typename T> struct ItemFilter
+| 167|    |-{
+| 168|    |-	typedef NC::Menu<T> MenuT;
+| 169|    |-	typedef typename NC::Menu<T>::Item Item;
+| 170|    |-	typedef std::function<bool(const Regex &, const Item &)> FilterFunction;
+| 171|    |-	
+| 172|    |-	ItemFilter() { }
+| 173|    |-
+| 174|    |-	template <typename FilterT>
+| 175|    |-	ItemFilter(const std::string &constraint_,
+| 176|    |-	           boost::regex_constants::syntax_option_type flags,
+| 177|    |-	           FilterT &&filter)
+| 178|    |-		: m_rx(make(constraint_, flags))
+| 179|    |-		, m_constraint(constraint_)
+| 180|    |-		, m_filter(std::forward<FilterT>(filter))
+| 181|    |-	{ }
+| 182|    |-	
+| 183|    |-	void clear()
+| 184|    |-	{
+| 185|    |-		m_filter = nullptr;
+| 186|    |-	}
+| 187|    |-
+| 188|    |-	const std::string &constraint() const {
+| 189|    |-		return m_constraint;
+| 190|    |-	}
+| 191|    |-
+| 192|    |-	bool operator()(const Item &item) {
+| 193|    |-		return m_filter(m_rx, item);
+| 194|    |-	}
+| 195|    |-	
+| 196|    |-	bool defined() const
+| 197|    |-	{
+| 198|    |-		return m_filter.operator bool();
+| 199|    |-	}
+| 200|    |-
+| 201|    |-private:
+| 202|    |-	Regex m_rx;
+| 203|    |-	std::string m_constraint;
+| 204|    |-	FilterFunction m_filter;
+| 205|    |-};
+| 206|    |-
+| 207|    |-}
+| 208|    |-
+| 209|  93| #endif // NCMPCPP_REGEX_FILTER_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/formatted_color.h
+|    |++++| /app/src/curses/formatted_color.h
+|  26|  26| #include "curses/window.h"
+|  27|  27| #include "utility/storage_kind.h"
+|  28|  28| 
+|  29|    |-namespace NC {
+|    |  29|+namespace NC
+|    |  30|+{
+|  30|  31| 
+|  31|    |-struct FormattedColor
+|  32|    |-{
+|  33|    |-	template <StorageKind storage = StorageKind::Reference>
+|  34|    |-	struct End
+|  35|    |-	{
+|  36|    |-		explicit End(const FormattedColor &fc)
+|  37|    |-			: m_fc(fc)
+|  38|    |-		{ }
+|    |  32|+    struct FormattedColor
+|    |  33|+    {
+|    |  34|+        template < StorageKind storage = StorageKind::Reference > struct End
+|    |  35|+        {
+|    |  36|+            explicit End (const FormattedColor & fc):m_fc (fc)
+|    |  37|+            {
+|    |  38|+            }
+|  39|  39| 
+|  40|    |-		const FormattedColor &base() const { return m_fc; }
+|    |  40|+            const FormattedColor & base () const
+|    |  41|+            {
+|    |  42|+                return m_fc;
+|    |  43|+            }
+|  41|  44| 
+|  42|    |-		template <StorageKind otherStorage>
+|  43|    |-		bool operator==(const End<otherStorage> &rhs) const
+|  44|    |-		{
+|  45|    |-			return m_fc == rhs.m_fc;
+|  46|    |-		}
+|    |  45|+            template < StorageKind otherStorage >
+|    |  46|+                bool operator== (const End < otherStorage > &rhs) const
+|    |  47|+            {
+|    |  48|+                return m_fc == rhs.m_fc;
+|    |  49|+            }
+|  47|  50| 
+|  48|    |-		explicit operator End<StorageKind::Value>() const
+|  49|    |-		{
+|  50|    |-			return End<StorageKind::Value>(m_fc);
+|  51|    |-		}
+|    |  51|+            explicit operator  End < StorageKind::Value > () const
+|    |  52|+            {
+|    |  53|+                return End < StorageKind::Value > (m_fc);
+|    |  54|+            }
+|  52|  55| 
+|  53|    |-	private:
+|  54|    |-		typename std::conditional<storage == StorageKind::Reference,
+|  55|    |-		                          const FormattedColor &,
+|  56|    |-		                          FormattedColor>::type m_fc;
+|  57|    |-	};
+|    |  56|+          private:
+|    |  57|+              typename std::conditional < storage == StorageKind::Reference,
+|    |  58|+                const FormattedColor &, FormattedColor >::type m_fc;
+|    |  59|+        };
+|  58|  60| 
+|  59|    |-	typedef std::vector<Format> Formats;
+|    |  61|+        typedef std::vector < Format > Formats;
+|  60|  62| 
+|  61|    |-	FormattedColor() { }
+|    |  63|+          FormattedColor ()
+|    |  64|+        {
+|    |  65|+        }
+|  62|  66| 
+|  63|    |-	FormattedColor(Color color_, Formats formats_);
+|    |  67|+        FormattedColor (Color color_, Formats formats_);
+|  64|  68| 
+|  65|    |-	const Color &color() const { return m_color; }
+|  66|    |-	const Formats &formats() const { return m_formats; }
+|    |  69|+        const Color & color () const
+|    |  70|+        {
+|    |  71|+            return m_color;
+|    |  72|+        }
+|    |  73|+        const Formats & formats () const
+|    |  74|+        {
+|    |  75|+            return m_formats;
+|    |  76|+        }
+|  67|  77| 
+|  68|    |-private:
+|  69|    |-	Color m_color;
+|  70|    |-	Formats m_formats;
+|  71|    |-};
+|    |  78|+      private:
+|    |  79|+          Color m_color;
+|    |  80|+        Formats m_formats;
+|    |  81|+    };
+|  72|  82| 
+|  73|    |-inline bool operator==(const FormattedColor &lhs, const FormattedColor &rhs)
+|  74|    |-{
+|  75|    |-	return lhs.color() == rhs.color()
+|  76|    |-		&& lhs.formats() == rhs.formats();
+|  77|    |-}
+|    |  83|+    inline bool operator== (const FormattedColor & lhs,
+|    |  84|+                            const FormattedColor & rhs)
+|    |  85|+    {
+|    |  86|+        return lhs.color () == rhs.color ()
+|    |  87|+            && lhs.formats () == rhs.formats ();
+|    |  88|+    }
+|  78|  89| 
+|  79|    |-std::istream &operator>>(std::istream &is, FormattedColor &fc);
+|    |  90|+    std::istream & operator>> (std::istream & is, FormattedColor & fc);
+|  80|  91| 
+|  81|    |-template <typename OutputStreamT>
+|  82|    |-OutputStreamT &operator<<(OutputStreamT &os, const FormattedColor &fc)
+|  83|    |-{
+|  84|    |-	os << fc.color();
+|  85|    |-	for (auto &fmt : fc.formats())
+|  86|    |-		os << fmt;
+|  87|    |-	return os;
+|  88|    |-}
+|    |  92|+    template < typename OutputStreamT >
+|    |  93|+        OutputStreamT & operator<< (OutputStreamT & os,
+|    |  94|+                                    const FormattedColor & fc)
+|    |  95|+    {
+|    |  96|+        os << fc.color ();
+|    |  97|+      for (auto & fmt:fc.formats ())
+|    |  98|+            os << fmt;
+|    |  99|+        return os;
+|    | 100|+    }
+|  89| 101| 
+|  90|    |-template <typename OutputStreamT, StorageKind storage>
+|  91|    |-OutputStreamT &operator<<(OutputStreamT &os,
+|  92|    |-                          const FormattedColor::End<storage> &rfc)
+|  93|    |-{
+|  94|    |-	if (rfc.base().color() != Color::Default)
+|  95|    |-		os << Color::End;
+|  96|    |-	for (auto &fmt : boost::adaptors::reverse(rfc.base().formats()))
+|  97|    |-		os << reverseFormat(fmt);
+|  98|    |-	return os;
+|  99|    |-}
+|    | 102|+    template < typename OutputStreamT, StorageKind storage >
+|    | 103|+        OutputStreamT & operator<< (OutputStreamT & os,
+|    | 104|+                                    const FormattedColor::End < storage > &rfc)
+|    | 105|+    {
+|    | 106|+        if (rfc.base ().color () != Color::Default)
+|    | 107|+            os << Color::End;
+|    | 108|+      for (auto & fmt:boost::adaptors::reverse (rfc.base ().
+|    | 109|+                                  formats ()))
+|    | 110|+            os << reverseFormat (fmt);
+|    | 111|+        return os;
+|    | 112|+    }
+| 100| 113| 
+| 101| 114| }
+| 102| 115| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/conversion.h
+|    |++++| /app/src/utility/conversion.h
+|  30|  30| 
+|  31|  31| struct ConversionError
+|  32|  32| {
+|  33|    |-	ConversionError(std::string source) : m_source_value(source) { }
+|  34|    |-	
+|  35|    |-	const std::string &value() { return m_source_value; }
+|  36|    |-	
+|  37|    |-private:
+|  38|    |-	std::string m_target_type;
+|  39|    |-	std::string m_source_value;
+|    |  33|+    ConversionError (std::string source):m_source_value (source)
+|    |  34|+    {
+|    |  35|+    }
+|    |  36|+
+|    |  37|+    const std::string & value ()
+|    |  38|+    {
+|    |  39|+        return m_source_value;
+|    |  40|+    }
+|    |  41|+
+|    |  42|+  private:
+|    |  43|+    std::string m_target_type;
+|    |  44|+    std::string m_source_value;
+|  40|  45| };
+|  41|  46| 
+|  42|  47| struct OutOfBounds : std::exception
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/conversion.h
+|    |++++| /app/src/utility/conversion.h
+|  39|  39| 	std::string m_source_value;
+|  40|  40| };
+|  41|  41| 
+|  42|    |-struct OutOfBounds : std::exception
+|    |  42|+struct OutOfBounds:
+|    |  43|+    std::exception
+|  43|  44| {
+|  44|    |-	const std::string &errorMessage() { return m_error_message; }
+|  45|    |-	
+|  46|    |-	template <typename Type>
+|  47|    |-	GNUC_NORETURN static void raise(const Type &value, const Type &lbound, const Type &ubound)
+|  48|    |-	{
+|  49|    |-		throw OutOfBounds((boost::format(
+|  50|    |-			"value is out of bounds ([%1%, %2%] expected, %3% given)") % lbound % ubound % value).str());
+|  51|    |-	}
+|  52|    |-	
+|  53|    |-	template <typename Type>
+|  54|    |-	GNUC_NORETURN static void raiseLower(const Type &value, const Type &lbound)
+|  55|    |-	{
+|  56|    |-		throw OutOfBounds((boost::format(
+|  57|    |-			"value is out of bounds ([%1%, ->) expected, %2% given)") % lbound % value).str());
+|  58|    |-	}
+|  59|    |-	
+|  60|    |-	template <typename Type>
+|  61|    |-	GNUC_NORETURN static void raiseUpper(const Type &value, const Type &ubound)
+|  62|    |-	{
+|  63|    |-		throw OutOfBounds((boost::format(
+|  64|    |-			"value is out of bounds ((<-, %1%] expected, %2% given)") % ubound % value).str());
+|  65|    |-	}
+|  66|    |-	
+|  67|    |-	virtual const char *what() const noexcept override { return m_error_message.c_str(); }
+|    |  45|+    const
+|    |  46|+        std::string &
+|    |  47|+    errorMessage ()
+|    |  48|+    {
+|    |  49|+        return m_error_message;
+|    |  50|+    }
+|  68|  51| 
+|  69|    |-private:
+|  70|    |-	OutOfBounds(std::string msg) : m_error_message(msg) { }
+|  71|    |-	
+|  72|    |-	std::string m_error_message;
+|    |  52|+    template <
+|    |  53|+        typename
+|    |  54|+        Type >
+|    |  55|+        GNUC_NORETURN static void
+|    |  56|+    raise (const Type & value, const Type & lbound, const Type & ubound)
+|    |  57|+    {
+|    |  58|+        throw
+|    |  59|+        OutOfBounds ((boost::
+|    |  60|+                      format
+|    |  61|+                      ("value is out of bounds ([%1%, %2%] expected, %3% given)")
+|    |  62|+                      % lbound % ubound % value).str ());
+|    |  63|+    }
+|    |  64|+
+|    |  65|+    template < typename Type > GNUC_NORETURN static void
+|    |  66|+    raiseLower (const Type & value, const Type & lbound)
+|    |  67|+    {
+|    |  68|+        throw
+|    |  69|+        OutOfBounds ((boost::
+|    |  70|+                      format
+|    |  71|+                      ("value is out of bounds ([%1%, ->) expected, %2% given)")
+|    |  72|+                      % lbound % value).str ());
+|    |  73|+    }
+|    |  74|+
+|    |  75|+    template < typename Type > GNUC_NORETURN static void
+|    |  76|+    raiseUpper (const Type & value, const Type & ubound)
+|    |  77|+    {
+|    |  78|+        throw
+|    |  79|+        OutOfBounds ((boost::
+|    |  80|+                      format
+|    |  81|+                      ("value is out of bounds ((<-, %1%] expected, %2% given)")
+|    |  82|+                      % ubound % value).str ());
+|    |  83|+    }
+|    |  84|+
+|    |  85|+    virtual const char *
+|    |  86|+    what () const noexcept
+|    |  87|+        override
+|    |  88|+    {
+|    |  89|+        return
+|    |  90|+            m_error_message.
+|    |  91|+        c_str ();
+|    |  92|+    }
+|    |  93|+
+|    |  94|+  private:
+|    |  95|+    OutOfBounds (std::string msg):
+|    |  96|+    m_error_message (msg)
+|    |  97|+    {
+|    |  98|+    }
+|    |  99|+
+|    | 100|+    std::string m_error_message;
+|  73| 101| };
+|  74| 102| 
+|  75| 103| template <typename TargetT, bool isUnsigned>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/conversion.h
+|    |++++| /app/src/utility/conversion.h
+|  72|  72| 	std::string m_error_message;
+|  73|  73| };
+|  74|  74| 
+|  75|    |-template <typename TargetT, bool isUnsigned>
+|  76|    |-struct unsigned_checker
+|    |  75|+template < typename TargetT, bool isUnsigned > struct unsigned_checker
+|  77|  76| {
+|  78|    |-	static void apply(const std::string &) { }
+|    |  77|+    static void
+|    |  78|+    apply (const std::string &)
+|    |  79|+    {
+|    |  80|+    }
+|  79|  81| };
+|  80|    |-template <typename TargetT>
+|  81|    |-struct unsigned_checker<TargetT, true>
+|    |  82|+template < typename TargetT > struct unsigned_checker <
+|    |  83|+    TargetT,
+|    |  84|+    true >
+|  82|  85| {
+|  83|    |-	static void apply(const std::string &s)
+|  84|    |-	{
+|  85|    |-		if (s[0] == '-')
+|  86|    |-			throw ConversionError(s);
+|  87|    |-	}
+|    |  86|+    static void
+|    |  87|+    apply (const std::string & s)
+|    |  88|+    {
+|    |  89|+        if (s[0] == '-')
+|    |  90|+            throw
+|    |  91|+            ConversionError (s);
+|    |  92|+    }
+|  88|  93| };
+|  89|  94| 
+|  90|  95| template <typename TargetT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/conversion.h
+|    |++++| /app/src/utility/conversion.h
+|  87|  87| 	}
+|  88|  88| };
+|  89|  89| 
+|  90|    |-template <typename TargetT>
+|  91|    |-TargetT fromString(const std::string &source)
+|    |  90|+template < typename TargetT > TargetT fromString (const std::string & source)
+|  92|  91| {
+|  93|    |-	unsigned_checker<TargetT, boost::is_unsigned<TargetT>::value>::apply(source);
+|  94|    |-	try
+|  95|    |-	{
+|  96|    |-		return boost::lexical_cast<TargetT>(source);
+|  97|    |-	}
+|  98|    |-	catch (boost::bad_lexical_cast &)
+|  99|    |-	{
+| 100|    |-		throw ConversionError(source);
+| 101|    |-	}
+|    |  92|+    unsigned_checker < TargetT,
+|    |  93|+        boost::is_unsigned < TargetT >::value >::apply (source);
+|    |  94|+    try
+|    |  95|+    {
+|    |  96|+        return boost::lexical_cast < TargetT > (source);
+|    |  97|+    }
+|    |  98|+    catch (boost::bad_lexical_cast &)
+|    |  99|+    {
+|    | 100|+        throw
+|    | 101|+        ConversionError (source);
+|    | 102|+    }
+| 102| 103| }
+| 103| 104| 
+| 104| 105| template <typename Type>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/conversion.h
+|    |++++| /app/src/utility/conversion.h
+| 101| 101| 	}
+| 102| 102| }
+| 103| 103| 
+| 104|    |-template <typename Type>
+| 105|    |-void boundsCheck(const Type &value, const Type &lbound, const Type &ubound)
+|    | 104|+template < typename Type > void
+|    | 105|+boundsCheck (const Type & value, const Type & lbound, const Type & ubound)
+| 106| 106| {
+| 107|    |-	if (value < lbound || value > ubound)
+| 108|    |-		OutOfBounds::raise(value, lbound, ubound);
+|    | 107|+    if (value < lbound || value > ubound)
+|    | 108|+        OutOfBounds::raise (value, lbound, ubound);
+| 109| 109| }
+| 110| 110| 
+| 111| 111| template <typename Type>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/conversion.h
+|    |++++| /app/src/utility/conversion.h
+| 108| 108| 		OutOfBounds::raise(value, lbound, ubound);
+| 109| 109| }
+| 110| 110| 
+| 111|    |-template <typename Type>
+| 112|    |-void lowerBoundCheck(const Type &value, const Type &lbound)
+|    | 111|+template < typename Type > void
+|    | 112|+lowerBoundCheck (const Type & value, const Type & lbound)
+| 113| 113| {
+| 114|    |-	if (value < lbound)
+| 115|    |-		OutOfBounds::raiseLower(value, lbound);
+|    | 114|+    if (value < lbound)
+|    | 115|+        OutOfBounds::raiseLower (value, lbound);
+| 116| 116| }
+| 117| 117| 
+| 118| 118| template <typename Type>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/conversion.h
+|    |++++| /app/src/utility/conversion.h
+| 115| 115| 		OutOfBounds::raiseLower(value, lbound);
+| 116| 116| }
+| 117| 117| 
+| 118|    |-template <typename Type>
+| 119|    |-void upperBoundCheck(const Type &value, const Type &ubound)
+|    | 118|+template < typename Type > void
+|    | 119|+upperBoundCheck (const Type & value, const Type & ubound)
+| 120| 120| {
+| 121|    |-	if (value > ubound)
+| 122|    |-		OutOfBounds::raiseUpper(value, ubound);
+|    | 121|+    if (value > ubound)
+|    | 122|+        OutOfBounds::raiseUpper (value, ubound);
+| 123| 123| }
+| 124| 124| 
+| 125| 125| #endif // NCMPCPP_UTILITY_CONVERSION_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+|  33|  33| #include "screens/screen.h"
+|  34|  34| #include "song_list.h"
+|  35|  35| 
+|  36|    |-struct TagsWindow: NC::Menu<MPD::MutableSong>, SongList
+|    |  36|+struct TagsWindow:
+|    |  37|+    NC::Menu <
+|    |  38|+    MPD::MutableSong >,
+|    |  39|+    SongList
+|  37|  40| {
+|  38|    |-	TagsWindow() { }
+|  39|    |-	TagsWindow(NC::Menu<MPD::MutableSong> &&base)
+|  40|    |-	: NC::Menu<MPD::MutableSong>(std::move(base)) { }
+|    |  41|+    TagsWindow ()
+|    |  42|+    {
+|    |  43|+    }
+|    |  44|+    TagsWindow (NC::Menu < MPD::MutableSong > &&base):
+|    |  45|+        NC::Menu <
+|    |  46|+    MPD::MutableSong > (std::move (base))
+|    |  47|+    {
+|    |  48|+    }
+|  41|  49| 
+|  42|    |-	virtual SongIterator currentS() override;
+|  43|    |-	virtual ConstSongIterator currentS() const override;
+|  44|    |-	virtual SongIterator beginS() override;
+|  45|    |-	virtual ConstSongIterator beginS() const override;
+|  46|    |-	virtual SongIterator endS() override;
+|  47|    |-	virtual ConstSongIterator endS() const override;
+|    |  50|+    virtual SongIterator
+|    |  51|+    currentS ()
+|    |  52|+        override;
+|    |  53|+    virtual ConstSongIterator
+|    |  54|+    currentS () const
+|    |  55|+        override;
+|    |  56|+    virtual SongIterator
+|    |  57|+    beginS ()
+|    |  58|+        override;
+|    |  59|+    virtual ConstSongIterator
+|    |  60|+    beginS () const
+|    |  61|+        override;
+|    |  62|+    virtual SongIterator
+|    |  63|+    endS ()
+|    |  64|+        override;
+|    |  65|+    virtual ConstSongIterator
+|    |  66|+    endS () const
+|    |  67|+        override;
+|  48|  68| 
+|  49|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|    |  69|+    virtual
+|    |  70|+        std::vector <
+|    |  71|+        MPD::Song >
+|    |  72|+    getSelectedSongs ()
+|    |  73|+        override;
+|  50|  74| };
+|  51|  75| 
+|  52|  76| struct TagEditor: Screen<NC::Window *>, HasActions, HasColumns, HasSongs, Searchable, Tabbable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+|  49|  49| 	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  50|  50| };
+|  51|  51| 
+|  52|    |-struct TagEditor: Screen<NC::Window *>, HasActions, HasColumns, HasSongs, Searchable, Tabbable
+|    |  52|+struct TagEditor:
+|    |  53|+    Screen <
+|    |  54|+NC::Window * >,
+|    |  55|+    HasActions,
+|    |  56|+    HasColumns,
+|    |  57|+    HasSongs,
+|    |  58|+    Searchable,
+|    |  59|+    Tabbable
+|  53|  60| {
+|  54|    |-	TagEditor();
+|  55|    |-	
+|  56|    |-	virtual void resize() override;
+|  57|    |-	virtual void switchTo() override;
+|  58|    |-	
+|  59|    |-	virtual std::wstring title() override;
+|  60|    |-	virtual ScreenType type() override { return ScreenType::TagEditor; }
+|  61|    |-	
+|  62|    |-	virtual void refresh() override;
+|  63|    |-	virtual void update() override;
+|  64|    |-	
+|  65|    |-	virtual void mouseButtonPressed(MEVENT) override;
+|  66|    |-	
+|  67|    |-	virtual bool isLockable() override { return true; }
+|  68|    |-	virtual bool isMergable() override { return true; }
+|  69|    |-	
+|  70|    |-	// Searchable implementation
+|  71|    |-	virtual bool allowsSearching() override;
+|  72|    |-	virtual const std::string &searchConstraint() override;
+|  73|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  74|    |-	virtual void clearSearchConstraint() override;
+|  75|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|  76|    |-
+|  77|    |-	// HasActions implementation
+|  78|    |-	virtual bool actionRunnable() override;
+|  79|    |-	virtual void runAction() override;
+|  80|    |-
+|  81|    |-	// HasSongs implementation
+|  82|    |-	virtual bool itemAvailable() override;
+|  83|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  84|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  85|    |-	
+|  86|    |-	// HasColumns implementation
+|  87|    |-	virtual bool previousColumnAvailable() override;
+|  88|    |-	virtual void previousColumn() override;
+|  89|    |-	
+|  90|    |-	virtual bool nextColumnAvailable() override;
+|  91|    |-	virtual void nextColumn() override;
+|  92|    |-	
+|  93|    |-	// private members
+|  94|    |-	bool enterDirectory();
+|  95|    |-	void LocateSong(const MPD::Song &s);
+|  96|    |-	const std::string &CurrentDir() { return itsBrowsedDir; }
+|  97|    |-	
+|  98|    |-	NC::Menu< std::pair<std::string, std::string> > *Dirs;
+|  99|    |-	NC::Menu<std::string> *TagTypes;
+| 100|    |-	TagsWindow *Tags;
+| 101|    |-	
+| 102|    |-private:
+| 103|    |-	void SetDimensions(size_t, size_t);
+| 104|    |-	
+| 105|    |-	std::vector<MPD::MutableSong *> EditedSongs;
+| 106|    |-	NC::Menu<std::string> *FParserDialog;
+| 107|    |-	NC::Menu<std::string> *FParser;
+| 108|    |-	NC::Scrollpad *FParserHelper;
+| 109|    |-	NC::Scrollpad *FParserLegend;
+| 110|    |-	NC::Scrollpad *FParserPreview;
+| 111|    |-	bool FParserUsePreview;
+| 112|    |-	
+| 113|    |-	std::string itsBrowsedDir;
+| 114|    |-	std::string itsHighlightedDir;
+| 115|    |-
+| 116|    |-	Regex::Filter<std::pair<std::string, std::string>> m_directories_search_predicate;
+| 117|    |-	Regex::Filter<MPD::MutableSong> m_songs_search_predicate;
+|    |  61|+    TagEditor ();
+|    |  62|+
+|    |  63|+    virtual void
+|    |  64|+    resize ()
+|    |  65|+        override;
+|    |  66|+    virtual void
+|    |  67|+    switchTo ()
+|    |  68|+        override;
+|    |  69|+
+|    |  70|+    virtual
+|    |  71|+        std::wstring
+|    |  72|+    title ()
+|    |  73|+        override;
+|    |  74|+    virtual ScreenType
+|    |  75|+    type ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return ScreenType::TagEditor;
+|    |  79|+    }
+|    |  80|+
+|    |  81|+    virtual void
+|    |  82|+    refresh ()
+|    |  83|+        override;
+|    |  84|+    virtual void
+|    |  85|+    update ()
+|    |  86|+        override;
+|    |  87|+
+|    |  88|+    virtual void
+|    |  89|+    mouseButtonPressed (MEVENT)
+|    |  90|+        override;
+|    |  91|+
+|    |  92|+    virtual bool
+|    |  93|+    isLockable ()
+|    |  94|+        override
+|    |  95|+    {
+|    |  96|+        return true;
+|    |  97|+    }
+|    |  98|+    virtual bool
+|    |  99|+    isMergable ()
+|    | 100|+        override
+|    | 101|+    {
+|    | 102|+        return true;
+|    | 103|+    }
+|    | 104|+
+|    | 105|+    // Searchable implementation
+|    | 106|+    virtual bool
+|    | 107|+    allowsSearching ()
+|    | 108|+        override;
+|    | 109|+    virtual const
+|    | 110|+        std::string &
+|    | 111|+    searchConstraint ()
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    setSearchConstraint (const std::string & constraint)
+|    | 115|+        override;
+|    | 116|+    virtual void
+|    | 117|+    clearSearchConstraint ()
+|    | 118|+        override;
+|    | 119|+    virtual bool
+|    | 120|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 121|+        override;
+|    | 122|+
+|    | 123|+    // HasActions implementation
+|    | 124|+    virtual bool
+|    | 125|+    actionRunnable ()
+|    | 126|+        override;
+|    | 127|+    virtual void
+|    | 128|+    runAction ()
+|    | 129|+        override;
+|    | 130|+
+|    | 131|+    // HasSongs implementation
+|    | 132|+    virtual bool
+|    | 133|+    itemAvailable ()
+|    | 134|+        override;
+|    | 135|+    virtual bool
+|    | 136|+    addItemToPlaylist (bool play)
+|    | 137|+        override;
+|    | 138|+    virtual
+|    | 139|+        std::vector <
+|    | 140|+        MPD::Song >
+|    | 141|+    getSelectedSongs ()
+|    | 142|+        override;
+|    | 143|+
+|    | 144|+    // HasColumns implementation
+|    | 145|+    virtual bool
+|    | 146|+    previousColumnAvailable ()
+|    | 147|+        override;
+|    | 148|+    virtual void
+|    | 149|+    previousColumn ()
+|    | 150|+        override;
+|    | 151|+
+|    | 152|+    virtual bool
+|    | 153|+    nextColumnAvailable ()
+|    | 154|+        override;
+|    | 155|+    virtual void
+|    | 156|+    nextColumn ()
+|    | 157|+        override;
+|    | 158|+
+|    | 159|+    // private members
+|    | 160|+    bool
+|    | 161|+    enterDirectory ();
+|    | 162|+    void
+|    | 163|+    LocateSong (const MPD::Song & s);
+|    | 164|+    const
+|    | 165|+        std::string &
+|    | 166|+    CurrentDir ()
+|    | 167|+    {
+|    | 168|+        return itsBrowsedDir;
+|    | 169|+    }
+|    | 170|+
+|    | 171|+    NC::Menu < std::pair < std::string, std::string > >*Dirs;
+|    | 172|+    NC::Menu < std::string > *TagTypes;
+|    | 173|+    TagsWindow *
+|    | 174|+        Tags;
+|    | 175|+
+|    | 176|+  private:
+|    | 177|+    void
+|    | 178|+    SetDimensions (size_t, size_t);
+|    | 179|+
+|    | 180|+    std::vector < MPD::MutableSong * >EditedSongs;
+|    | 181|+    NC::Menu < std::string > *FParserDialog;
+|    | 182|+    NC::Menu < std::string > *FParser;
+|    | 183|+    NC::Scrollpad * FParserHelper;
+|    | 184|+    NC::Scrollpad * FParserLegend;
+|    | 185|+    NC::Scrollpad * FParserPreview;
+|    | 186|+    bool
+|    | 187|+        FParserUsePreview;
+|    | 188|+
+|    | 189|+    std::string itsBrowsedDir;
+|    | 190|+    std::string itsHighlightedDir;
+|    | 191|+
+|    | 192|+    Regex::Filter < std::pair < std::string,
+|    | 193|+        std::string >> m_directories_search_predicate;
+|    | 194|+    Regex::Filter < MPD::MutableSong > m_songs_search_predicate;
+| 118| 195| };
+| 119| 196| 
+| 120| 197| extern TagEditor *myTagEditor;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+| 117| 117| 	Regex::Filter<MPD::MutableSong> m_songs_search_predicate;
+| 118| 118| };
+| 119| 119| 
+| 120|    |-extern TagEditor *myTagEditor;
+|    | 120|+extern TagEditor *
+|    | 121|+    myTagEditor;
+| 121| 122| 
+| 122| 123| #endif // HAVE_TAGLIB_H
+| 123| 124| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+| 122| 122| #endif // HAVE_TAGLIB_H
+| 123| 123| 
+| 124| 124| #endif // NCMPCPP_TAG_EDITOR_H
+| 125|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  27|  27| #include "mpdpp.h"
+|  28|  28| #include "screens/screen.h"
+|  29|  29| 
+|  30|    |-namespace Global {
+|    |  30|+namespace Global
+|    |  31|+{
+|  31|  32| 
+|  32|  33| // currently active screen (displayed in main window)
+|  33|  34| extern BaseScreen *myScreen;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  30|  30| namespace Global {
+|  31|  31| 
+|  32|  32| // currently active screen (displayed in main window)
+|  33|    |-extern BaseScreen *myScreen;
+|    |  33|+    extern BaseScreen *myScreen;
+|  34|  34| 
+|  35|  35| // points at the screen that was locked (or is null if no screen is locked)
+|  36|  36| extern BaseScreen *myLockedScreen;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  33|  33| extern BaseScreen *myScreen;
+|  34|  34| 
+|  35|  35| // points at the screen that was locked (or is null if no screen is locked)
+|  36|    |-extern BaseScreen *myLockedScreen;
+|    |  36|+    extern BaseScreen *myLockedScreen;
+|  37|  37| 
+|  38|  38| // points at inactive screen, if locking was enabled and two screens are displayed
+|  39|  39| extern BaseScreen *myInactiveScreen;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  36|  36| extern BaseScreen *myLockedScreen;
+|  37|  37| 
+|  38|  38| // points at inactive screen, if locking was enabled and two screens are displayed
+|  39|    |-extern BaseScreen *myInactiveScreen;
+|    |  39|+    extern BaseScreen *myInactiveScreen;
+|  40|  40| 
+|  41|  41| // header window (above main window)
+|  42|  42| extern NC::Window *wHeader;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  39|  39| extern BaseScreen *myInactiveScreen;
+|  40|  40| 
+|  41|  41| // header window (above main window)
+|  42|    |-extern NC::Window *wHeader;
+|    |  42|+    extern NC::Window * wHeader;
+|  43|  43| 
+|  44|  44| // footer window (below main window)
+|  45|  45| extern NC::Window *wFooter;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  42|  42| extern NC::Window *wHeader;
+|  43|  43| 
+|  44|  44| // footer window (below main window)
+|  45|    |-extern NC::Window *wFooter;
+|    |  45|+    extern NC::Window * wFooter;
+|  46|  46| 
+|  47|  47| // Y coordinate of top of main window
+|  48|  48| extern size_t MainStartY;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  45|  45| extern NC::Window *wFooter;
+|  46|  46| 
+|  47|  47| // Y coordinate of top of main window
+|  48|    |-extern size_t MainStartY;
+|    |  48|+    extern size_t MainStartY;
+|  49|  49| 
+|  50|  50| // height of main window
+|  51|  51| extern size_t MainHeight;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  48|  48| extern size_t MainStartY;
+|  49|  49| 
+|  50|  50| // height of main window
+|  51|    |-extern size_t MainHeight;
+|    |  51|+    extern size_t MainHeight;
+|  52|  52| 
+|  53|  53| // indicates whether seeking action in currently in progress
+|  54|  54| extern bool SeekingInProgress;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  51|  51| extern size_t MainHeight;
+|  52|  52| 
+|  53|  53| // indicates whether seeking action in currently in progress
+|  54|    |-extern bool SeekingInProgress;
+|    |  54|+    extern bool SeekingInProgress;
+|  55|  55| 
+|  56|  56| // string that represents volume in right top corner. being global
+|  57|  57| // to be used for calculating width offsets in various files.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  55|  55| 
+|  56|  56| // string that represents volume in right top corner. being global
+|  57|  57| // to be used for calculating width offsets in various files.
+|  58|    |-extern std::string VolumeState;
+|    |  58|+    extern std::string VolumeState;
+|  59|  59| 
+|  60|  60| // global timer
+|  61|  61| extern boost::posix_time::ptime Timer;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  58|  58| extern std::string VolumeState;
+|  59|  59| 
+|  60|  60| // global timer
+|  61|    |-extern boost::posix_time::ptime Timer;
+|    |  61|+    extern boost::posix_time::ptime Timer;
+|  62|  62| 
+|  63|  63| // global RNG
+|  64|  64| extern std::mt19937 RNG;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  61|  61| extern boost::posix_time::ptime Timer;
+|  62|  62| 
+|  63|  63| // global RNG
+|  64|    |-extern std::mt19937 RNG;
+|    |  64|+    extern std::mt19937 RNG;
+|  65|  65| 
+|  66|  66| }
+|  67|  67| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/global.h
+|    |++++| /app/src/global.h
+|  65|  65| 
+|  66|  66| }
+|  67|  67| 
+|  68|    |-#endif // NCMPCPP_GLOBAL_H
+|    |  68|+#endif                          // NCMPCPP_GLOBAL_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  25|  25| #include <utility>
+|  26|  26| 
+|  27|  27| /// Map over the first element in range satisfying the predicate.
+|  28|    |-template <typename InputIterator, typename PredicateT, typename MapT>
+|  29|    |-InputIterator find_map_first(InputIterator first, InputIterator last, PredicateT &&p, MapT &&f)
+|    |  28|+template < typename InputIterator, typename PredicateT, typename MapT >
+|    |  29|+    InputIterator find_map_first (InputIterator first, InputIterator last,
+|    |  30|+                                  PredicateT && p, MapT && f)
+|  30|  31| {
+|  31|    |-	auto it = std::find(first, last, std::forward<PredicateT>(p));
+|  32|    |-	if (it != last)
+|  33|    |-		f(*it);
+|  34|    |-	return it;
+|    |  32|+    auto it = std::find (first, last, std::forward < PredicateT > (p));
+|    |  33|+    if (it != last)
+|    |  34|+        f (*it);
+|    |  35|+    return it;
+|  35|  36| }
+|  36|  37| 
+|  37|  38| /// Map over all elements in range satisfying the predicate.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  35|  35| }
+|  36|  36| 
+|  37|  37| /// Map over all elements in range satisfying the predicate.
+|  38|    |-template <typename InputIterator, typename PredicateT, typename MapT>
+|  39|    |-void find_map_all(InputIterator first, InputIterator last, PredicateT &&p, MapT &&f)
+|    |  38|+template < typename InputIterator, typename PredicateT, typename MapT > void
+|    |  39|+find_map_all (InputIterator first, InputIterator last, PredicateT && p, MapT
+|    |  40|+              && f)
+|  40|  41| {
+|  41|    |-	InputIterator it = first;
+|  42|    |-	do
+|  43|    |-		it = find_map_first(it, last, p, f);
+|  44|    |-	while (it != last);
+|    |  42|+    InputIterator it = first;
+|    |  43|+    do
+|    |  44|+        it = find_map_first (it, last, p, f);
+|    |  45|+    while (it != last);
+|  45|  46| }
+|  46|  47| 
+|  47|  48| // convert string to appropriate type
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  45|  45| }
+|  46|  46| 
+|  47|  47| // convert string to appropriate type
+|  48|    |-template <typename TargetT, typename SourceT>
+|  49|    |-struct convertString
+|    |  48|+template < typename TargetT, typename SourceT > struct convertString
+|  50|  49| {
+|  51|    |-	static std::basic_string<TargetT> apply(const std::basic_string<SourceT> &s)
+|  52|    |-	{
+|  53|    |-		return boost::locale::conv::utf_to_utf<TargetT>(s);
+|  54|    |-	}
+|    |  50|+    static std::basic_string < TargetT > apply (const std::basic_string <
+|    |  51|+                                                SourceT > &s)
+|    |  52|+    {
+|    |  53|+        return boost::locale::conv::utf_to_utf < TargetT > (s);
+|    |  54|+    }
+|  55|  55| };
+|  56|    |-template <typename TargetT>
+|  57|    |-struct convertString<TargetT, TargetT>
+|    |  56|+template < typename TargetT > struct convertString <TargetT, TargetT >
+|  58|  57| {
+|  59|    |-	static const std::basic_string<TargetT> &apply(const std::basic_string<TargetT> &s)
+|  60|    |-	{
+|  61|    |-		return s;
+|  62|    |-	}
+|    |  58|+    static const std::basic_string < TargetT >
+|    |  59|+        &apply (const std::basic_string < TargetT > &s)
+|    |  60|+    {
+|    |  61|+        return s;
+|    |  62|+    }
+|  63|  63| };
+|  64|  64| 
+|  65|  65| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  62|  62| 	}
+|  63|  63| };
+|  64|  64| 
+|  65|    |-
+|  66|  65| #endif // NCMPCPP_UTILITY_FUNCTIONAL_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.h
+|    |++++| /app/src/helpers.h
+|  32|  32| #include "utility/type_conversions.h"
+|  33|  33| #include "utility/wide_string.h"
+|  34|  34| 
+|  35|    |-enum ReapplyFilter { Yes, No };
+|  36|    |-
+|  37|    |-template <typename ItemT>
+|  38|    |-struct ScopedUnfilteredMenu
+|  39|    |-{
+|  40|    |-	ScopedUnfilteredMenu(ReapplyFilter reapply_filter, NC::Menu<ItemT> &menu)
+|  41|    |-		: m_refresh(false), m_reapply_filter(reapply_filter), m_menu(menu)
+|  42|    |-	{
+|  43|    |-		m_is_filtered = m_menu.isFiltered();
+|  44|    |-		if (m_is_filtered)
+|  45|    |-			m_menu.showAllItems();
+|  46|    |-	}
+|  47|    |-
+|  48|    |-	~ScopedUnfilteredMenu()
+|  49|    |-	{
+|  50|    |-		if (m_is_filtered)
+|  51|    |-		{
+|  52|    |-			switch (m_reapply_filter)
+|  53|    |-			{
+|  54|    |-			case ReapplyFilter::Yes:
+|  55|    |-				m_menu.reapplyFilter();
+|  56|    |-				break;
+|  57|    |-			case ReapplyFilter::No:
+|  58|    |-				m_menu.showFilteredItems();
+|  59|    |-				break;
+|  60|    |-			}
+|  61|    |-		}
+|  62|    |-		if (m_refresh)
+|  63|    |-			m_menu.refresh();
+|  64|    |-	}
+|  65|    |-
+|  66|    |-	void set(ReapplyFilter reapply_filter, bool refresh)
+|  67|    |-	{
+|  68|    |-		m_reapply_filter = reapply_filter;
+|  69|    |-		m_refresh = refresh;
+|  70|    |-	}
+|  71|    |-
+|  72|    |-private:
+|  73|    |-	bool m_is_filtered;
+|  74|    |-	bool m_refresh;
+|  75|    |-	ReapplyFilter m_reapply_filter;
+|  76|    |-	NC::Menu<ItemT> &m_menu;
+|    |  35|+enum ReapplyFilter
+|    |  36|+{ Yes, No };
+|    |  37|+
+|    |  38|+template < typename ItemT > struct ScopedUnfilteredMenu
+|    |  39|+{
+|    |  40|+    ScopedUnfilteredMenu (ReapplyFilter reapply_filter,
+|    |  41|+                          NC::Menu < ItemT > &menu):m_refresh (false),
+|    |  42|+        m_reapply_filter (reapply_filter), m_menu (menu)
+|    |  43|+    {
+|    |  44|+        m_is_filtered = m_menu.isFiltered ();
+|    |  45|+        if (m_is_filtered)
+|    |  46|+            m_menu.showAllItems ();
+|    |  47|+    }
+|    |  48|+
+|    |  49|+     ~ScopedUnfilteredMenu ()
+|    |  50|+    {
+|    |  51|+        if (m_is_filtered)
+|    |  52|+          {
+|    |  53|+              switch (m_reapply_filter)
+|    |  54|+                {
+|    |  55|+                case ReapplyFilter::Yes:
+|    |  56|+                    m_menu.reapplyFilter ();
+|    |  57|+                    break;
+|    |  58|+                case ReapplyFilter::No:
+|    |  59|+                    m_menu.showFilteredItems ();
+|    |  60|+                    break;
+|    |  61|+                }
+|    |  62|+          }
+|    |  63|+        if (m_refresh)
+|    |  64|+            m_menu.refresh ();
+|    |  65|+    }
+|    |  66|+
+|    |  67|+    void set (ReapplyFilter reapply_filter, bool refresh)
+|    |  68|+    {
+|    |  69|+        m_reapply_filter = reapply_filter;
+|    |  70|+        m_refresh = refresh;
+|    |  71|+    }
+|    |  72|+
+|    |  73|+  private:
+|    |  74|+    bool m_is_filtered;
+|    |  75|+    bool m_refresh;
+|    |  76|+    ReapplyFilter m_reapply_filter;
+|    |  77|+    NC::Menu < ItemT > &m_menu;
+|  77|  78| };
+|  78|  79| 
+|  79|  80| template <typename Iterator, typename PredicateT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.h
+|    |++++| /app/src/helpers.h
+|  76|  76| 	NC::Menu<ItemT> &m_menu;
+|  77|  77| };
+|  78|  78| 
+|  79|    |-template <typename Iterator, typename PredicateT>
+|  80|    |-Iterator wrappedSearch(Iterator begin, Iterator current, Iterator end,
+|  81|    |-                       const PredicateT &pred, bool wrap, bool skip_current)
+|  82|    |-{
+|  83|    |-	if (begin == end)
+|  84|    |-	{
+|  85|    |-		assert(current == end);
+|  86|    |-		return begin;
+|  87|    |-	}
+|  88|    |-	if (skip_current)
+|  89|    |-		++current;
+|  90|    |-	auto it = std::find_if(current, end, pred);
+|  91|    |-	if (it == end && wrap)
+|  92|    |-	{
+|  93|    |-		it = std::find_if(begin, current, pred);
+|  94|    |-		if (it == current)
+|  95|    |-			it = end;
+|  96|    |-	}
+|  97|    |-	return it;
+|  98|    |-}
+|  99|    |-
+| 100|    |-template <typename ItemT, typename PredicateT>
+| 101|    |-bool search(NC::Menu<ItemT> &m, const PredicateT &pred,
+| 102|    |-                  SearchDirection direction, bool wrap, bool skip_current)
+| 103|    |-{
+| 104|    |-	bool result = false;
+| 105|    |-	if (pred.defined())
+| 106|    |-	{
+| 107|    |-		switch (direction)
+| 108|    |-		{
+| 109|    |-			case SearchDirection::Backward:
+| 110|    |-			{
+| 111|    |-				auto it = wrappedSearch(m.rbegin(), m.rcurrent(), m.rend(),
+| 112|    |-					pred, wrap, skip_current
+| 113|    |-				);
+| 114|    |-				if (it != m.rend())
+| 115|    |-				{
+| 116|    |-					m.highlight(it.base()-m.begin()-1);
+| 117|    |-					result = true;
+| 118|    |-				}
+| 119|    |-				break;
+| 120|    |-			}
+| 121|    |-			case SearchDirection::Forward:
+| 122|    |-			{
+| 123|    |-				auto it = wrappedSearch(m.begin(), m.current(), m.end(),
+| 124|    |-					pred, wrap, skip_current
+| 125|    |-				);
+| 126|    |-				if (it != m.end())
+| 127|    |-				{
+| 128|    |-					m.highlight(it-m.begin());
+| 129|    |-					result = true;
+| 130|    |-				}
+| 131|    |-			}
+| 132|    |-		}
+| 133|    |-	}
+| 134|    |-	return result;
+| 135|    |-}
+| 136|    |-
+| 137|    |-template <typename Iterator>
+| 138|    |-bool hasSelected(Iterator first, Iterator last)
+| 139|    |-{
+| 140|    |-	for (; first != last; ++first)
+| 141|    |-		if (first->isSelected())
+| 142|    |-			return true;
+| 143|    |-	return false;
+| 144|    |-}
+| 145|    |-
+| 146|    |-template <typename Iterator>
+| 147|    |-std::vector<Iterator> getSelected(Iterator first, Iterator last)
+| 148|    |-{
+| 149|    |-	std::vector<Iterator> result;
+| 150|    |-	for (; first != last; ++first)
+| 151|    |-		if (first->isSelected())
+| 152|    |-			result.push_back(first);
+| 153|    |-	return result;
+|    |  79|+template < typename Iterator, typename PredicateT >
+|    |  80|+    Iterator wrappedSearch (Iterator begin, Iterator current, Iterator end,
+|    |  81|+                            const PredicateT & pred, bool wrap,
+|    |  82|+                            bool skip_current)
+|    |  83|+{
+|    |  84|+    if (begin == end)
+|    |  85|+      {
+|    |  86|+          assert (current == end);
+|    |  87|+          return begin;
+|    |  88|+      }
+|    |  89|+    if (skip_current)
+|    |  90|+        ++current;
+|    |  91|+    auto it = std::find_if (current, end, pred);
+|    |  92|+    if (it == end && wrap)
+|    |  93|+      {
+|    |  94|+          it = std::find_if (begin, current, pred);
+|    |  95|+          if (it == current)
+|    |  96|+              it = end;
+|    |  97|+      }
+|    |  98|+    return it;
+|    |  99|+}
+|    | 100|+
+|    | 101|+template < typename ItemT, typename PredicateT >
+|    | 102|+    bool search (NC::Menu < ItemT > &m, const PredicateT & pred,
+|    | 103|+                 SearchDirection direction, bool wrap, bool skip_current)
+|    | 104|+{
+|    | 105|+    bool result = false;
+|    | 106|+    if (pred.defined ())
+|    | 107|+      {
+|    | 108|+          switch (direction)
+|    | 109|+            {
+|    | 110|+            case SearchDirection::Backward:
+|    | 111|+                {
+|    | 112|+                    auto it =
+|    | 113|+                        wrappedSearch (m.rbegin (), m.rcurrent (), m.rend (),
+|    | 114|+                                       pred, wrap, skip_current);
+|    | 115|+                    if (it != m.rend ())
+|    | 116|+                      {
+|    | 117|+                          m.highlight (it.base () - m.begin () - 1);
+|    | 118|+                          result = true;
+|    | 119|+                      }
+|    | 120|+                    break;
+|    | 121|+                }
+|    | 122|+            case SearchDirection::Forward:
+|    | 123|+                {
+|    | 124|+                    auto it =
+|    | 125|+                        wrappedSearch (m.begin (), m.current (), m.end (),
+|    | 126|+                                       pred, wrap, skip_current);
+|    | 127|+                    if (it != m.end ())
+|    | 128|+                      {
+|    | 129|+                          m.highlight (it - m.begin ());
+|    | 130|+                          result = true;
+|    | 131|+                      }
+|    | 132|+                }
+|    | 133|+            }
+|    | 134|+      }
+|    | 135|+    return result;
+|    | 136|+}
+|    | 137|+
+|    | 138|+template < typename Iterator > bool hasSelected (Iterator first, Iterator last)
+|    | 139|+{
+|    | 140|+    for (; first != last; ++first)
+|    | 141|+        if (first->isSelected ())
+|    | 142|+            return true;
+|    | 143|+    return false;
+|    | 144|+}
+|    | 145|+
+|    | 146|+template < typename Iterator >
+|    | 147|+    std::vector < Iterator > getSelected (Iterator first, Iterator last)
+|    | 148|+{
+|    | 149|+    std::vector < Iterator > result;
+|    | 150|+    for (; first != last; ++first)
+|    | 151|+        if (first->isSelected ())
+|    | 152|+            result.push_back (first);
+|    | 153|+    return result;
+| 154| 154| }
+| 155| 155| 
+| 156| 156| /// @return true if range that begins and ends with selected items was
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.h
+|    |++++| /app/src/helpers.h
+| 156| 156| /// @return true if range that begins and ends with selected items was
+| 157| 157| /// found, false when there is no selected items (in which case first
+| 158| 158| /// == last).
+| 159|    |-template <typename Iterator>
+| 160|    |-bool findRange(Iterator &first, Iterator &last)
+| 161|    |-{
+| 162|    |-	for (; first != last; ++first)
+| 163|    |-	{
+| 164|    |-		if (first->isSelected())
+| 165|    |-			break;
+| 166|    |-	}
+| 167|    |-	if (first == last)
+| 168|    |-		return false;
+| 169|    |-	--last;
+| 170|    |-	for (; first != last; --last)
+| 171|    |-	{
+| 172|    |-		if (last->isSelected())
+| 173|    |-			break;
+| 174|    |-	}
+| 175|    |-	++last;
+| 176|    |-	return true;
+|    | 159|+template < typename Iterator >
+|    | 160|+    bool findRange (Iterator & first, Iterator & last)
+|    | 161|+{
+|    | 162|+    for (; first != last; ++first)
+|    | 163|+      {
+|    | 164|+          if (first->isSelected ())
+|    | 165|+              break;
+|    | 166|+      }
+|    | 167|+    if (first == last)
+|    | 168|+        return false;
+|    | 169|+    --last;
+|    | 170|+    for (; first != last; --last)
+|    | 171|+      {
+|    | 172|+          if (last->isSelected ())
+|    | 173|+              break;
+|    | 174|+      }
+|    | 175|+    ++last;
+|    | 176|+    return true;
+| 177| 177| }
+| 178| 178| 
+| 179| 179| /// @return true if fully selected range was found or no selected
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  24|  24| #include "curses/window.h"
+|  25|  25| #include "curses/strbuffer.h"
+|  26|  26| 
+|  27|    |-namespace NC {
+|    |  27|+namespace NC
+|    |  28|+{
+|  28|  29| 
+|  29|  30| /// Scrollpad is specialized window that holds large portions of text and
+|  30|  31| /// supports scrolling if the amount of it is bigger than the window area.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  28|  28| 
+|  29|  29| /// Scrollpad is specialized window that holds large portions of text and
+|  30|  30| /// supports scrolling if the amount of it is bigger than the window area.
+|  31|    |-struct Scrollpad: public Window
+|  32|    |-{
+|  33|    |-	Scrollpad() { }
+|  34|    |-	
+|  35|    |-	Scrollpad(size_t startx, size_t starty, size_t width, size_t height,
+|  36|    |-	          const std::string &title, Color color, Border border);
+|  37|    |-	
+|  38|    |-	// override a few Window functions
+|  39|    |-	virtual void refresh() override;
+|  40|    |-	virtual void scroll(Scroll where) override;
+|  41|    |-	virtual void resize(size_t new_width, size_t new_height) override;
+|  42|    |-	virtual void clear() override;
+|  43|    |-	
+|  44|    |-	const std::string &buffer();
+|  45|    |-	
+|  46|    |-	void flush();
+|  47|    |-	void reset();
+|  48|    |-	
+|  49|    |-	bool setProperties(const Color &begin, const std::string &s, const Color &end,
+|  50|    |-	                   size_t flags, size_t id = -2);
+|  51|    |-	bool setProperties(const Format &begin, const std::string &s, const Format &end,
+|  52|    |-	                   size_t flags, size_t id = -2);
+|  53|    |-	bool setProperties(const FormattedColor &fc, const std::string &s,
+|  54|    |-	                   size_t flags, size_t id = -2);
+|  55|    |-	void removeProperties(size_t id = -2);
+|  56|    |-	
+|  57|    |-	Scrollpad &operator<<(int n) { return write(n); }
+|  58|    |-	Scrollpad &operator<<(long int n) { return write(n); }
+|  59|    |-	Scrollpad &operator<<(unsigned int n) { return write(n); }
+|  60|    |-	Scrollpad &operator<<(unsigned long int n) { return write(n); }
+|  61|    |-	Scrollpad &operator<<(char c) { return write(c); }
+|  62|    |-	Scrollpad &operator<<(const char *s) { return write(s); }
+|  63|    |-	Scrollpad &operator<<(const std::string &s) { return write(s); }
+|  64|    |-	Scrollpad &operator<<(Color color) { return write(color); }
+|  65|    |-	Scrollpad &operator<<(Format format) { return write(format); }
+|    |  31|+    struct Scrollpad:public Window
+|    |  32|+    {
+|    |  33|+        Scrollpad ()
+|    |  34|+        {
+|    |  35|+        }
+|  66|  36| 
+|  67|    |-private:
+|  68|    |-	template <typename ItemT>
+|  69|    |-	Scrollpad &write(ItemT &&item)
+|  70|    |-	{
+|  71|    |-		m_buffer << std::forward<ItemT>(item);
+|  72|    |-		return *this;
+|  73|    |-	}
+|    |  37|+        Scrollpad (size_t startx, size_t starty, size_t width, size_t height,
+|    |  38|+                   const std::string & title, Color color, Border border);
+|  74|  39| 
+|  75|    |-	Buffer m_buffer;
+|  76|    |-	
+|  77|    |-	size_t m_beginning;
+|  78|    |-	size_t m_real_height;
+|  79|    |-};
+|    |  40|+        // override a few Window functions
+|    |  41|+        virtual void refresh () override;
+|    |  42|+        virtual void scroll (Scroll where) override;
+|    |  43|+        virtual void resize (size_t new_width, size_t new_height) override;
+|    |  44|+        virtual void clear () override;
+|    |  45|+
+|    |  46|+        const std::string & buffer ();
+|    |  47|+
+|    |  48|+        void flush ();
+|    |  49|+        void reset ();
+|    |  50|+
+|    |  51|+        bool setProperties (const Color & begin, const std::string & s,
+|    |  52|+                            const Color & end, size_t flags, size_t id = -2);
+|    |  53|+        bool setProperties (const Format & begin, const std::string & s,
+|    |  54|+                            const Format & end, size_t flags, size_t id = -2);
+|    |  55|+        bool setProperties (const FormattedColor & fc, const std::string & s,
+|    |  56|+                            size_t flags, size_t id = -2);
+|    |  57|+        void removeProperties (size_t id = -2);
+|    |  58|+
+|    |  59|+          Scrollpad & operator<< (int n)
+|    |  60|+        {
+|    |  61|+            return write (n);
+|    |  62|+        }
+|    |  63|+        Scrollpad & operator<< (long int n)
+|    |  64|+        {
+|    |  65|+            return write (n);
+|    |  66|+        }
+|    |  67|+        Scrollpad & operator<< (unsigned int n)
+|    |  68|+        {
+|    |  69|+            return write (n);
+|    |  70|+        }
+|    |  71|+        Scrollpad & operator<< (unsigned long int n)
+|    |  72|+        {
+|    |  73|+            return write (n);
+|    |  74|+        }
+|    |  75|+        Scrollpad & operator<< (char c)
+|    |  76|+        {
+|    |  77|+            return write (c);
+|    |  78|+        }
+|    |  79|+        Scrollpad & operator<< (const char *s)
+|    |  80|+        {
+|    |  81|+            return write (s);
+|    |  82|+        }
+|    |  83|+        Scrollpad & operator<< (const std::string & s)
+|    |  84|+        {
+|    |  85|+            return write (s);
+|    |  86|+        }
+|    |  87|+        Scrollpad & operator<< (Color color)
+|    |  88|+        {
+|    |  89|+            return write (color);
+|    |  90|+        }
+|    |  91|+        Scrollpad & operator<< (Format format)
+|    |  92|+        {
+|    |  93|+            return write (format);
+|    |  94|+        }
+|    |  95|+
+|    |  96|+      private:
+|    |  97|+        template < typename ItemT > Scrollpad & write (ItemT && item)
+|    |  98|+        {
+|    |  99|+            m_buffer << std::forward < ItemT > (item);
+|    | 100|+            return *this;
+|    | 101|+        }
+|    | 102|+
+|    | 103|+        Buffer m_buffer;
+|    | 104|+
+|    | 105|+        size_t m_beginning;
+|    | 106|+        size_t m_real_height;
+|    | 107|+    };
+|  80| 108| 
+|  81| 109| }
+|  82| 110| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  81|  81| }
+|  82|  82| 
+|  83|  83| #endif // NCMPCPP_SCROLLPAD_H
+|  84|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curl_handle.h
+|    |++++| /app/src/curl_handle.h
+|  28|  28| 
+|  29|  29| namespace Curl
+|  30|  30| {
+|  31|    |-	CURLcode perform(std::string &data, const std::string &URL, const std::string &referer = "", bool follow_redirect = false, unsigned timeout = 10);
+|  32|    |-	
+|  33|    |-	std::string escape(const std::string &s);
+|    |  31|+    CURLcode perform (std::string & data, const std::string & URL,
+|    |  32|+                      const std::string & referer = "", bool follow_redirect =
+|    |  33|+                      false, unsigned timeout = 10);
+|    |  34|+
+|    |  35|+      std::string escape (const std::string & s);
+|  34|  36| }
+|  35|  37| 
+|  36|  38| #endif // NCMPCPP_CURL_HANDLE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curl_handle.h
+|    |++++| /app/src/curl_handle.h
+|  33|  33| 	std::string escape(const std::string &s);
+|  34|  34| }
+|  35|  35| 
+|  36|    |-#endif // NCMPCPP_CURL_HANDLE_H
+|    |  36|+#endif                          // NCMPCPP_CURL_HANDLE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/clock.h
+|    |++++| /app/src/screens/clock.h
+|  29|  29| #include "interfaces.h"
+|  30|  30| #include "screens/screen.h"
+|  31|  31| 
+|  32|    |-struct Clock: Screen<NC::Window>, Tabbable
+|    |  32|+struct Clock:Screen <
+|    |  33|+    NC::Window >,
+|    |  34|+    Tabbable
+|  33|  35| {
+|  34|    |-	Clock();
+|  35|    |-	
+|  36|    |-	virtual void resize() override;
+|  37|    |-	virtual void switchTo() override;
+|  38|    |-	
+|  39|    |-	virtual std::wstring title() override;
+|  40|    |-	virtual ScreenType type() override { return ScreenType::Clock; }
+|  41|    |-	
+|  42|    |-	virtual void update() override;
+|  43|    |-	virtual void scroll(NC::Scroll) override { }
+|  44|    |-	
+|  45|    |-	virtual void mouseButtonPressed(MEVENT) override { }
+|  46|    |-	
+|  47|    |-	virtual bool isLockable() override { return false; }
+|  48|    |-	virtual bool isMergable() override { return true; }
+|  49|    |-	
+|  50|    |-private:
+|  51|    |-	NC::Window m_pane;
+|  52|    |-	
+|  53|    |-	static void Prepare();
+|  54|    |-	static void Set(int, int);
+|  55|    |-	
+|  56|    |-	static short disp[11];
+|  57|    |-	static long older[6], next[6], newer[6], mask;
+|  58|    |-	
+|  59|    |-	static size_t Width;
+|  60|    |-	static const size_t Height;
+|    |  36|+    Clock ();
+|    |  37|+
+|    |  38|+    virtual void
+|    |  39|+    resize ()
+|    |  40|+        override;
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+
+|    |  45|+    virtual
+|    |  46|+        std::wstring
+|    |  47|+    title ()
+|    |  48|+        override;
+|    |  49|+    virtual ScreenType
+|    |  50|+    type ()
+|    |  51|+        override
+|    |  52|+    {
+|    |  53|+        return ScreenType::Clock;
+|    |  54|+    }
+|    |  55|+
+|    |  56|+    virtual void
+|    |  57|+    update ()
+|    |  58|+        override;
+|    |  59|+    virtual void
+|    |  60|+    scroll (NC::Scroll)
+|    |  61|+        override
+|    |  62|+    {
+|    |  63|+    }
+|    |  64|+
+|    |  65|+    virtual void
+|    |  66|+    mouseButtonPressed (MEVENT)
+|    |  67|+        override
+|    |  68|+    {
+|    |  69|+    }
+|    |  70|+
+|    |  71|+    virtual bool
+|    |  72|+    isLockable ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+        return false;
+|    |  76|+    }
+|    |  77|+    virtual bool
+|    |  78|+    isMergable ()
+|    |  79|+        override
+|    |  80|+    {
+|    |  81|+        return true;
+|    |  82|+    }
+|    |  83|+
+|    |  84|+  private:
+|    |  85|+    NC::Window m_pane;
+|    |  86|+
+|    |  87|+    static void
+|    |  88|+    Prepare ();
+|    |  89|+    static void
+|    |  90|+    Set (int, int);
+|    |  91|+
+|    |  92|+    static short
+|    |  93|+        disp[11];
+|    |  94|+    static long
+|    |  95|+        older[6],
+|    |  96|+        next[6],
+|    |  97|+        newer[6],
+|    |  98|+        mask;
+|    |  99|+
+|    | 100|+    static size_t
+|    | 101|+        Width;
+|    | 102|+    static const size_t
+|    | 103|+        Height;
+|  61| 104| };
+|  62| 105| 
+|  63| 106| extern Clock *myClock;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/clock.h
+|    |++++| /app/src/screens/clock.h
+|  60|  60| 	static const size_t Height;
+|  61|  61| };
+|  62|  62| 
+|  63|    |-extern Clock *myClock;
+|    |  63|+extern Clock *
+|    |  64|+    myClock;
+|  64|  65| 
+|  65|  66| #endif // ENABLE_CLOCK
+|  66|  67| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/string.h
+|    |++++| /app/src/utility/string.h
+|  27|  27| #include <vector>
+|  28|  28| #include "gcc.h"
+|  29|  29| 
+|  30|    |-template <size_t N> size_t const_strlen(const char (&)[N]) {
+|  31|    |-	return N-1;
+|    |  30|+template < size_t N > size_t const_strlen (const char (&)[N])
+|    |  31|+{
+|    |  32|+    return N - 1;
+|  32|  33| }
+|  33|  34| 
+|  34|  35| // it's present in boost for std::string, but we want more general version.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/string.h
+|    |++++| /app/src/utility/string.h
+|  32|  32| }
+|  33|  33| 
+|  34|  34| // it's present in boost for std::string, but we want more general version.
+|  35|    |-template <typename StringT, typename CollectionT>
+|  36|    |-StringT join(const CollectionT &collection, const StringT &separator)
+|    |  35|+template < typename StringT, typename CollectionT >
+|    |  36|+    StringT join (const CollectionT & collection, const StringT & separator)
+|  37|  37| {
+|  38|    |-	StringT result;
+|  39|    |-	auto first = std::begin(collection), last = std::end(collection);
+|  40|    |-	if (first != last)
+|  41|    |-	{
+|  42|    |-		while (true)
+|  43|    |-		{
+|  44|    |-			result += *first;
+|  45|    |-			++first;
+|  46|    |-			if (first != last)
+|  47|    |-				result += separator;
+|  48|    |-			else
+|  49|    |-				break;
+|  50|    |-		}
+|  51|    |-	}
+|  52|    |-	return result;
+|    |  38|+    StringT result;
+|    |  39|+    auto first = std::begin (collection), last = std::end (collection);
+|    |  40|+    if (first != last)
+|    |  41|+      {
+|    |  42|+          while (true)
+|    |  43|+            {
+|    |  44|+                result += *first;
+|    |  45|+                ++first;
+|    |  46|+                if (first != last)
+|    |  47|+                    result += separator;
+|    |  48|+                else
+|    |  49|+                    break;
+|    |  50|+            }
+|    |  51|+      }
+|    |  52|+    return result;
+|  53|  53| }
+|  54|  54| 
+|  55|  55| std::string getBasename(const std::string &path);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/string.h
+|    |++++| /app/src/utility/string.h
+|  52|  52| 	return result;
+|  53|  53| }
+|  54|  54| 
+|  55|    |-std::string getBasename(const std::string &path);
+|  56|    |-std::string getParentDirectory(std::string path);
+|  57|    |-std::string getSharedDirectory(const std::string &dir1, const std::string &dir2);
+|    |  55|+std::string getBasename (const std::string & path);
+|    |  56|+std::string getParentDirectory (std::string path);
+|    |  57|+std::string getSharedDirectory (const std::string & dir1,
+|    |  58|+                                const std::string & dir2);
+|  58|  59| 
+|  59|    |-std::string getEnclosedString(const std::string &s, char a, char b, size_t *pos);
+|    |  60|+std::string getEnclosedString (const std::string & s, char a, char b,
+|    |  61|+                               size_t * pos);
+|  60|  62| 
+|  61|    |-void removeInvalidCharsFromFilename(std::string &filename, bool win32_compatible);
+|    |  63|+void removeInvalidCharsFromFilename (std::string & filename,
+|    |  64|+                                     bool win32_compatible);
+|  62|  65| 
+|  63|  66| #endif // NCMPCPP_UTILITY_STRING_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  24|  24| #include "interfaces.h"
+|  25|  25| #include "mpdpp.h"
+|  26|  26| 
+|  27|    |-namespace Status {
+|    |  27|+namespace Status
+|    |  28|+{
+|  28|  29| 
+|  29|    |-void handleClientError(MPD::ClientError &e);
+|  30|    |-void handleServerError(MPD::ServerError &e);
+|    |  30|+    void handleClientError (MPD::ClientError & e);
+|    |  31|+    void handleServerError (MPD::ServerError & e);
+|  31|  32| 
+|  32|    |-void trace(bool update_timer, bool update_window_timeout);
+|  33|    |-inline void trace() { trace(true, false); }
+|  34|    |-void update(int event);
+|  35|    |-void clear();
+|    |  33|+    void trace (bool update_timer, bool update_window_timeout);
+|    |  34|+    inline void trace ()
+|    |  35|+    {
+|    |  36|+        trace (true, false);
+|    |  37|+    }
+|    |  38|+    void update (int event);
+|    |  39|+    void clear ();
+|  36|  40| 
+|  37|    |-namespace State {
+|    |  41|+    namespace State
+|    |  42|+    {
+|  38|  43| 
+|  39|  44| // flags
+|  40|  45| bool consume();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  37|  37| namespace State {
+|  38|  38| 
+|  39|  39| // flags
+|  40|    |-bool consume();
+|  41|    |-bool crossfade();
+|  42|    |-bool repeat();
+|  43|    |-bool random();
+|  44|    |-bool single();
+|    |  40|+        bool consume ();
+|    |  41|+        bool crossfade ();
+|    |  42|+        bool repeat ();
+|    |  43|+        bool random ();
+|    |  44|+        bool single ();
+|  45|  45| 
+|  46|  46| // misc
+|  47|  47| int currentSongID();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  44|  44| bool single();
+|  45|  45| 
+|  46|  46| // misc
+|  47|    |-int currentSongID();
+|  48|    |-int currentSongPosition();
+|  49|    |-unsigned playlistLength();
+|  50|    |-unsigned elapsedTime();
+|  51|    |-MPD::PlayerState player();
+|  52|    |-unsigned totalTime();
+|  53|    |-int volume();
+|    |  47|+        int currentSongID ();
+|    |  48|+        int currentSongPosition ();
+|    |  49|+        unsigned playlistLength ();
+|    |  50|+        unsigned elapsedTime ();
+|    |  51|+          MPD::PlayerState player ();
+|    |  52|+        unsigned totalTime ();
+|    |  53|+        int volume ();
+|    |  54|+
+|    |  55|+    }
+|    |  56|+
+|    |  57|+    namespace Changes
+|    |  58|+    {
+|    |  59|+
+|    |  60|+        void playlist (unsigned previous_version);
+|    |  61|+        void storedPlaylists ();
+|    |  62|+        void database ();
+|    |  63|+        void playerState ();
+|    |  64|+        void songID (int song_id);
+|    |  65|+        void elapsedTime (bool update_elapsed);
+|    |  66|+        void flags ();
+|    |  67|+        void mixer ();
+|    |  68|+        void outputs ();
+|    |  69|+
+|    |  70|+    }
+|  54|  71| 
+|  55|  72| }
+|  56|  73| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  54|  54| 
+|  55|  55| }
+|  56|  56| 
+|  57|    |-namespace Changes {
+|  58|    |-
+|  59|    |-void playlist(unsigned previous_version);
+|  60|    |-void storedPlaylists();
+|  61|    |-void database();
+|  62|    |-void playerState();
+|  63|    |-void songID(int song_id);
+|  64|    |-void elapsedTime(bool update_elapsed);
+|  65|    |-void flags();
+|  66|    |-void mixer();
+|  67|    |-void outputs();
+|  68|    |-
+|  69|    |-}
+|  70|    |-
+|  71|    |-}
+|  72|    |-
+|  73|    |-#endif // NCMPCPP_STATUS_CHECKER_H
+|    |  57|+#endif                          // NCMPCPP_STATUS_CHECKER_H
+
+src/status.h
+|  43| bool•random();
+|    | [NORMAL] CSecurityBear (random):
+|    | random: This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).  use a more secure technique for acquiring random values.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+|  43|  43| 
+|  44|  44| /// NC namespace provides set of easy-to-use
+|  45|  45| /// wrappers over original curses library.
+|  46|    |-namespace NC {
+|  47|    |-
+|  48|    |-namespace Key {
+|  49|    |-
+|  50|    |-typedef uint64_t Type;
+|  51|    |-
+|  52|    |-const Type None = -1;
+|    |  46|+namespace NC
+|    |  47|+{
+|    |  48|+
+|    |  49|+    namespace Key
+|    |  50|+    {
+|    |  51|+
+|    |  52|+        typedef uint64_t Type;
+|    |  53|+
+|    |  54|+        const Type None = -1;
+|  53|  55| 
+|  54|  56| // modifier masks
+|  55|  57| const Type Special = Type{1} << 63;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+|  52|  52| const Type None = -1;
+|  53|  53| 
+|  54|  54| // modifier masks
+|  55|    |-const Type Special = Type{1} << 63;
+|  56|    |-const Type Alt     = Type{1} << 62;
+|  57|    |-const Type Ctrl    = Type{1} << 61;
+|  58|    |-const Type Shift   = Type{1} << 60;
+|    |  55|+        const Type Special = Type { 1 } <<63;
+|    |  56|+        const Type Alt = Type { 1 } <<62;
+|    |  57|+        const Type Ctrl = Type { 1 } <<61;
+|    |  58|+        const Type Shift = Type { 1 } <<60;
+|  59|  59| 
+|  60|  60| // useful names
+|  61|  61| const Type Null      = 0;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+|  58|  58| const Type Shift   = Type{1} << 60;
+|  59|  59| 
+|  60|  60| // useful names
+|  61|    |-const Type Null      = 0;
+|  62|    |-const Type Space     = 32;
+|  63|    |-const Type Backspace = 127;
+|    |  61|+        const Type Null = 0;
+|    |  62|+        const Type Space = 32;
+|    |  63|+        const Type Backspace = 127;
+|  64|  64| 
+|  65|  65| // ctrl-?
+|  66|  66| const Type Ctrl_A            = 1;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+|  63|  63| const Type Backspace = 127;
+|  64|  64| 
+|  65|  65| // ctrl-?
+|  66|    |-const Type Ctrl_A            = 1;
+|  67|    |-const Type Ctrl_B            = 2;
+|  68|    |-const Type Ctrl_C            = 3;
+|  69|    |-const Type Ctrl_D            = 4;
+|  70|    |-const Type Ctrl_E            = 5;
+|  71|    |-const Type Ctrl_F            = 6;
+|  72|    |-const Type Ctrl_G            = 7;
+|  73|    |-const Type Ctrl_H            = 8;
+|  74|    |-const Type Ctrl_I            = 9;
+|  75|    |-const Type Ctrl_J            = 10;
+|  76|    |-const Type Ctrl_K            = 11;
+|  77|    |-const Type Ctrl_L            = 12;
+|  78|    |-const Type Ctrl_M            = 13;
+|  79|    |-const Type Ctrl_N            = 14;
+|  80|    |-const Type Ctrl_O            = 15;
+|  81|    |-const Type Ctrl_P            = 16;
+|  82|    |-const Type Ctrl_Q            = 17;
+|  83|    |-const Type Ctrl_R            = 18;
+|  84|    |-const Type Ctrl_S            = 19;
+|  85|    |-const Type Ctrl_T            = 20;
+|  86|    |-const Type Ctrl_U            = 21;
+|  87|    |-const Type Ctrl_V            = 22;
+|  88|    |-const Type Ctrl_W            = 23;
+|  89|    |-const Type Ctrl_X            = 24;
+|  90|    |-const Type Ctrl_Y            = 25;
+|  91|    |-const Type Ctrl_Z            = 26;
+|  92|    |-const Type Ctrl_LeftBracket  = 27;
+|  93|    |-const Type Ctrl_Backslash    = 28;
+|  94|    |-const Type Ctrl_RightBracket = 29;
+|  95|    |-const Type Ctrl_Caret        = 30;
+|  96|    |-const Type Ctrl_Underscore   = 31;
+|    |  66|+        const Type Ctrl_A = 1;
+|    |  67|+        const Type Ctrl_B = 2;
+|    |  68|+        const Type Ctrl_C = 3;
+|    |  69|+        const Type Ctrl_D = 4;
+|    |  70|+        const Type Ctrl_E = 5;
+|    |  71|+        const Type Ctrl_F = 6;
+|    |  72|+        const Type Ctrl_G = 7;
+|    |  73|+        const Type Ctrl_H = 8;
+|    |  74|+        const Type Ctrl_I = 9;
+|    |  75|+        const Type Ctrl_J = 10;
+|    |  76|+        const Type Ctrl_K = 11;
+|    |  77|+        const Type Ctrl_L = 12;
+|    |  78|+        const Type Ctrl_M = 13;
+|    |  79|+        const Type Ctrl_N = 14;
+|    |  80|+        const Type Ctrl_O = 15;
+|    |  81|+        const Type Ctrl_P = 16;
+|    |  82|+        const Type Ctrl_Q = 17;
+|    |  83|+        const Type Ctrl_R = 18;
+|    |  84|+        const Type Ctrl_S = 19;
+|    |  85|+        const Type Ctrl_T = 20;
+|    |  86|+        const Type Ctrl_U = 21;
+|    |  87|+        const Type Ctrl_V = 22;
+|    |  88|+        const Type Ctrl_W = 23;
+|    |  89|+        const Type Ctrl_X = 24;
+|    |  90|+        const Type Ctrl_Y = 25;
+|    |  91|+        const Type Ctrl_Z = 26;
+|    |  92|+        const Type Ctrl_LeftBracket = 27;
+|    |  93|+        const Type Ctrl_Backslash = 28;
+|    |  94|+        const Type Ctrl_RightBracket = 29;
+|    |  95|+        const Type Ctrl_Caret = 30;
+|    |  96|+        const Type Ctrl_Underscore = 31;
+|  97|  97| 
+|  98|  98| // useful duplicates
+|  99|  99| const Type Tab    = 9;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+|  96|  96| const Type Ctrl_Underscore   = 31;
+|  97|  97| 
+|  98|  98| // useful duplicates
+|  99|    |-const Type Tab    = 9;
+| 100|    |-const Type Enter  = 13;
+| 101|    |-const Type Escape = 27;
+|    |  99|+        const Type Tab = 9;
+|    | 100|+        const Type Enter = 13;
+|    | 101|+        const Type Escape = 27;
+| 102| 102| 
+| 103| 103| // special values, beyond one byte
+| 104| 104| const Type Insert   = Special | 256;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 101| 101| const Type Escape = 27;
+| 102| 102| 
+| 103| 103| // special values, beyond one byte
+| 104|    |-const Type Insert   = Special | 256;
+| 105|    |-const Type Delete   = Special | 257;
+| 106|    |-const Type Home     = Special | 258;
+| 107|    |-const Type End      = Special | 259;
+| 108|    |-const Type PageUp   = Special | 260;
+| 109|    |-const Type PageDown = Special | 261;
+| 110|    |-const Type Up       = Special | 262;
+| 111|    |-const Type Down     = Special | 263;
+| 112|    |-const Type Left     = Special | 264;
+| 113|    |-const Type Right    = Special | 265;
+| 114|    |-const Type F1       = Special | 266;
+| 115|    |-const Type F2       = Special | 267;
+| 116|    |-const Type F3       = Special | 268;
+| 117|    |-const Type F4       = Special | 269;
+| 118|    |-const Type F5       = Special | 270;
+| 119|    |-const Type F6       = Special | 271;
+| 120|    |-const Type F7       = Special | 272;
+| 121|    |-const Type F8       = Special | 273;
+| 122|    |-const Type F9       = Special | 274;
+| 123|    |-const Type F10      = Special | 275;
+| 124|    |-const Type F11      = Special | 276;
+| 125|    |-const Type F12      = Special | 277;
+| 126|    |-const Type Mouse    = Special | 278;
+| 127|    |-const Type EoF      = Special | 279;
+| 128|    |-
+| 129|    |-}
+|    | 104|+        const Type Insert = Special | 256;
+|    | 105|+        const Type Delete = Special | 257;
+|    | 106|+        const Type Home = Special | 258;
+|    | 107|+        const Type End = Special | 259;
+|    | 108|+        const Type PageUp = Special | 260;
+|    | 109|+        const Type PageDown = Special | 261;
+|    | 110|+        const Type Up = Special | 262;
+|    | 111|+        const Type Down = Special | 263;
+|    | 112|+        const Type Left = Special | 264;
+|    | 113|+        const Type Right = Special | 265;
+|    | 114|+        const Type F1 = Special | 266;
+|    | 115|+        const Type F2 = Special | 267;
+|    | 116|+        const Type F3 = Special | 268;
+|    | 117|+        const Type F4 = Special | 269;
+|    | 118|+        const Type F5 = Special | 270;
+|    | 119|+        const Type F6 = Special | 271;
+|    | 120|+        const Type F7 = Special | 272;
+|    | 121|+        const Type F8 = Special | 273;
+|    | 122|+        const Type F9 = Special | 274;
+|    | 123|+        const Type F10 = Special | 275;
+|    | 124|+        const Type F11 = Special | 276;
+|    | 125|+        const Type F12 = Special | 277;
+|    | 126|+        const Type Mouse = Special | 278;
+|    | 127|+        const Type EoF = Special | 279;
+|    | 128|+
+|    | 129|+    }
+| 130| 130| 
+| 131| 131| /// Thrown if Ctrl-C or Ctrl-G is pressed during the call to Window::getString()
+| 132| 132| /// @see Window::getString()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 130| 130| 
+| 131| 131| /// Thrown if Ctrl-C or Ctrl-G is pressed during the call to Window::getString()
+| 132| 132| /// @see Window::getString()
+| 133|    |-struct PromptAborted : std::exception
+| 134|    |-{
+| 135|    |-	PromptAborted() { }
+| 136|    |-
+| 137|    |-	template <typename ArgT>
+| 138|    |-	PromptAborted(ArgT &&prompt)
+| 139|    |-		: m_prompt(std::forward<ArgT>(prompt)) { }
+| 140|    |-
+| 141|    |-	virtual const char *what() const noexcept override { return m_prompt.c_str(); }
+| 142|    |-
+| 143|    |-private:
+| 144|    |-	std::string m_prompt;
+| 145|    |-};
+| 146|    |-
+| 147|    |-struct Color
+| 148|    |-{
+| 149|    |-	friend struct Window;
+| 150|    |-
+| 151|    |-	static const short transparent;
+| 152|    |-	static const short current;
+| 153|    |-
+| 154|    |-	Color() : m_impl(0, 0, true, false) { }
+| 155|    |-	Color(short foreground_value, short background_value,
+| 156|    |-			 bool is_default = false, bool is_end = false)
+| 157|    |-	: m_impl(foreground_value, background_value, is_default, is_end)
+| 158|    |-	{
+| 159|    |-		if (isDefault() && isEnd())
+| 160|    |-			throw std::logic_error("Color flag can't be marked as both 'default' and 'end'");
+| 161|    |-	}
+| 162|    |-
+| 163|    |-	bool operator==(const Color &rhs) const { return m_impl == rhs.m_impl; }
+| 164|    |-	bool operator!=(const Color &rhs) const { return m_impl != rhs.m_impl; }
+| 165|    |-	bool operator<(const Color &rhs) const { return m_impl < rhs.m_impl; }
+| 166|    |-
+| 167|    |-	bool isDefault() const { return std::get<2>(m_impl); }
+| 168|    |-	bool isEnd() const { return std::get<3>(m_impl); }
+| 169|    |-
+| 170|    |-	int pairNumber() const;
+| 171|    |-
+| 172|    |-	static Color Default;
+| 173|    |-	static Color Black;
+| 174|    |-	static Color Red;
+| 175|    |-	static Color Green;
+| 176|    |-	static Color Yellow;
+| 177|    |-	static Color Blue;
+| 178|    |-	static Color Magenta;
+| 179|    |-	static Color Cyan;
+| 180|    |-	static Color White;
+| 181|    |-	static Color End;
+| 182|    |-
+| 183|    |-private:
+| 184|    |-	short foreground() const { return std::get<0>(m_impl); }
+| 185|    |-	short background() const { return std::get<1>(m_impl); }
+| 186|    |-	bool currentBackground() const { return background() == current; }
+| 187|    |-
+| 188|    |-	std::tuple<short, short, bool, bool> m_impl;
+| 189|    |-};
+| 190|    |-
+| 191|    |-std::istream &operator>>(std::istream &is, Color &f);
+| 192|    |-
+| 193|    |-typedef boost::optional<Color> Border;
+|    | 133|+    struct PromptAborted:std::exception
+|    | 134|+    {
+|    | 135|+        PromptAborted ()
+|    | 136|+        {
+|    | 137|+        }
+|    | 138|+
+|    | 139|+        template < typename ArgT >
+|    | 140|+            PromptAborted (ArgT
+|    | 141|+                           && prompt):m_prompt (std::forward < ArgT > (prompt))
+|    | 142|+        {
+|    | 143|+        }
+|    | 144|+
+|    | 145|+        virtual const char *what () const noexcept override
+|    | 146|+        {
+|    | 147|+            return m_prompt.c_str ();
+|    | 148|+        }
+|    | 149|+
+|    | 150|+      private:
+|    | 151|+          std::string m_prompt;
+|    | 152|+    };
+|    | 153|+
+|    | 154|+    struct Color
+|    | 155|+    {
+|    | 156|+        friend struct Window;
+|    | 157|+
+|    | 158|+        static const short transparent;
+|    | 159|+        static const short current;
+|    | 160|+
+|    | 161|+          Color ():m_impl (0, 0, true, false)
+|    | 162|+        {
+|    | 163|+        }
+|    | 164|+      Color (short foreground_value, short background_value, bool is_default = false, bool is_end = false):m_impl (foreground_value, background_value, is_default,
+|    | 165|+                is_end)
+|    | 166|+        {
+|    | 167|+            if (isDefault () && isEnd ())
+|    | 168|+                throw std::
+|    | 169|+                    logic_error
+|    | 170|+                    ("Color flag can't be marked as both 'default' and 'end'");
+|    | 171|+        }
+|    | 172|+
+|    | 173|+        bool operator== (const Color & rhs) const
+|    | 174|+        {
+|    | 175|+            return m_impl == rhs.m_impl;
+|    | 176|+        }
+|    | 177|+        bool operator!= (const Color & rhs) const
+|    | 178|+        {
+|    | 179|+            return m_impl != rhs.m_impl;
+|    | 180|+        }
+|    | 181|+        bool operator< (const Color & rhs) const
+|    | 182|+        {
+|    | 183|+            return m_impl < rhs.m_impl;
+|    | 184|+        }
+|    | 185|+
+|    | 186|+        bool isDefault () const
+|    | 187|+        {
+|    | 188|+            return std::get < 2 > (m_impl);
+|    | 189|+        }
+|    | 190|+        bool isEnd () const
+|    | 191|+        {
+|    | 192|+            return std::get < 3 > (m_impl);
+|    | 193|+        }
+|    | 194|+
+|    | 195|+        int pairNumber () const;
+|    | 196|+
+|    | 197|+        static Color Default;
+|    | 198|+        static Color Black;
+|    | 199|+        static Color Red;
+|    | 200|+        static Color Green;
+|    | 201|+        static Color Yellow;
+|    | 202|+        static Color Blue;
+|    | 203|+        static Color Magenta;
+|    | 204|+        static Color Cyan;
+|    | 205|+        static Color White;
+|    | 206|+        static Color End;
+|    | 207|+
+|    | 208|+      private:
+|    | 209|+        short foreground () const
+|    | 210|+        {
+|    | 211|+            return std::get < 0 > (m_impl);
+|    | 212|+        }
+|    | 213|+        short background () const
+|    | 214|+        {
+|    | 215|+            return std::get < 1 > (m_impl);
+|    | 216|+        }
+|    | 217|+        bool currentBackground () const
+|    | 218|+        {
+|    | 219|+            return background () == current;
+|    | 220|+        }
+|    | 221|+
+|    | 222|+        std::tuple < short, short, bool, bool > m_impl;
+|    | 223|+    };
+|    | 224|+
+|    | 225|+    std::istream & operator>> (std::istream & is, Color & f);
+|    | 226|+
+|    | 227|+    typedef boost::optional < Color > Border;
+| 194| 228| 
+| 195| 229| /// Terminal manipulation functions
+| 196| 230| enum class TermManip { ClearToEOL };
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 193| 193| typedef boost::optional<Color> Border;
+| 194| 194| 
+| 195| 195| /// Terminal manipulation functions
+| 196|    |-enum class TermManip { ClearToEOL };
+|    | 196|+    enum class TermManip
+|    | 197|+    { ClearToEOL };
+| 197| 198| 
+| 198| 199| /// Format flags used by NCurses
+| 199| 200| enum class Format {
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 196| 196| enum class TermManip { ClearToEOL };
+| 197| 197| 
+| 198| 198| /// Format flags used by NCurses
+| 199|    |-enum class Format {
+| 200|    |-	Bold, NoBold,
+| 201|    |-	Underline, NoUnderline,
+| 202|    |-	Reverse, NoReverse,
+| 203|    |-	AltCharset, NoAltCharset
+| 204|    |-};
+| 205|    |-
+| 206|    |-NC::Format reverseFormat(NC::Format fmt);
+|    | 199|+    enum class Format
+|    | 200|+    {
+|    | 201|+        Bold, NoBold,
+|    | 202|+        Underline, NoUnderline,
+|    | 203|+        Reverse, NoReverse,
+|    | 204|+        AltCharset, NoAltCharset
+|    | 205|+    };
+|    | 206|+
+|    | 207|+    NC::Format reverseFormat (NC::Format fmt);
+| 207| 208| 
+| 208| 209| /// This indicates how much the window has to be scrolled
+| 209| 210| enum class Scroll { Up, Down, PageUp, PageDown, Home, End };
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 206| 206| NC::Format reverseFormat(NC::Format fmt);
+| 207| 207| 
+| 208| 208| /// This indicates how much the window has to be scrolled
+| 209|    |-enum class Scroll { Up, Down, PageUp, PageDown, Home, End };
+| 210|    |-
+| 211|    |-namespace Mouse {
+| 212|    |-
+| 213|    |-void enable();
+| 214|    |-void disable();
+| 215|    |-
+| 216|    |-}
+|    | 209|+    enum class Scroll
+|    | 210|+    { Up, Down, PageUp, PageDown, Home, End };
+|    | 211|+
+|    | 212|+    namespace Mouse
+|    | 213|+    {
+|    | 214|+
+|    | 215|+        void enable ();
+|    | 216|+        void disable ();
+|    | 217|+
+|    | 218|+    }
+| 217| 219| 
+| 218| 220| /// Initializes curses screen and sets some additional attributes
+| 219| 221| /// @param enable_colors enables colors
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 217| 217| 
+| 218| 218| /// Initializes curses screen and sets some additional attributes
+| 219| 219| /// @param enable_colors enables colors
+| 220|    |-void initScreen(bool enable_colors, bool enable_mouse);
+|    | 220|+    void initScreen (bool enable_colors, bool enable_mouse);
+| 221| 221| 
+| 222| 222| /// Destroys the screen
+| 223| 223| void destroyScreen();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 220| 220| void initScreen(bool enable_colors, bool enable_mouse);
+| 221| 221| 
+| 222| 222| /// Destroys the screen
+| 223|    |-void destroyScreen();
+|    | 223|+    void destroyScreen ();
+| 224| 224| 
+| 225| 225| /// Struct used for going to given coordinates
+| 226| 226| /// @see Window::operator<<()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 224| 224| 
+| 225| 225| /// Struct used for going to given coordinates
+| 226| 226| /// @see Window::operator<<()
+| 227|    |-struct XY
+| 228|    |-{
+| 229|    |-	XY(int xx, int yy) : x(xx), y(yy) { }
+| 230|    |-	int x;
+| 231|    |-	int y;
+| 232|    |-};
+|    | 227|+    struct XY
+|    | 228|+    {
+|    | 229|+        XY (int xx, int yy):x (xx), y (yy)
+|    | 230|+        {
+|    | 231|+        }
+|    | 232|+        int x;
+|    | 233|+        int y;
+|    | 234|+    };
+| 233| 235| 
+| 234| 236| /// Main class of NCurses namespace, used as base for other specialized windows
+| 235| 237| struct Window
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.h
+|    |++++| /app/src/curses/window.h
+| 232| 232| };
+| 233| 233| 
+| 234| 234| /// Main class of NCurses namespace, used as base for other specialized windows
+| 235|    |-struct Window
+| 236|    |-{
+| 237|    |-	/// Helper function that is periodically invoked
+| 238|    |-	// inside Window::getString() function
+| 239|    |-	/// @see Window::getString()
+| 240|    |-	typedef std::function<bool(const char *)> PromptHook;
+| 241|    |-
+| 242|    |-	/// Sets helper to a specific value for the current scope
+| 243|    |-	struct ScopedPromptHook
+| 244|    |-	{
+| 245|    |-		template <typename HelperT>
+| 246|    |-		ScopedPromptHook(Window &w, HelperT &&helper) noexcept
+| 247|    |-		: m_w(w), m_hook(std::move(w.m_prompt_hook)) {
+| 248|    |-			m_w.m_prompt_hook = std::forward<HelperT>(helper);
+| 249|    |-		}
+| 250|    |-		~ScopedPromptHook() noexcept {
+| 251|    |-			m_w.m_prompt_hook = std::move(m_hook);
+| 252|    |-		}
+| 253|    |-
+| 254|    |-	private:
+| 255|    |-		Window &m_w;
+| 256|    |-		PromptHook m_hook;
+| 257|    |-	};
+| 258|    |-
+| 259|    |-	struct ScopedTimeout
+| 260|    |-	{
+| 261|    |-		ScopedTimeout(Window &w, int new_timeout)
+| 262|    |-			: m_w(w)
+| 263|    |-		{
+| 264|    |-			m_timeout = w.getTimeout();
+| 265|    |-			w.setTimeout(new_timeout);
+| 266|    |-		}
+| 267|    |-
+| 268|    |-		~ScopedTimeout()
+| 269|    |-		{
+| 270|    |-			m_w.setTimeout(m_timeout);
+| 271|    |-		}
+| 272|    |-
+| 273|    |-	private:
+| 274|    |-		Window &m_w;
+| 275|    |-		int m_timeout;
+| 276|    |-	};
+| 277|    |-
+| 278|    |-	Window() : m_window(nullptr) { }
+| 279|    |-	
+| 280|    |-	/// Constructs an empty window with given parameters
+| 281|    |-	/// @param startx X position of left upper corner of constructed window
+| 282|    |-	/// @param starty Y position of left upper corner of constructed window
+| 283|    |-	/// @param width width of constructed window
+| 284|    |-	/// @param height height of constructed window
+| 285|    |-	/// @param title title of constructed window
+| 286|    |-	/// @param color base color of constructed window
+| 287|    |-	/// @param border border of constructed window
+| 288|    |-	Window(size_t startx, size_t starty, size_t width, size_t height,
+| 289|    |-			std::string title, Color color, Border border);
+| 290|    |-	
+| 291|    |-	Window(const Window &rhs);
+| 292|    |-	Window(Window &&rhs);
+| 293|    |-	Window &operator=(Window w);
+| 294|    |-	
+| 295|    |-	virtual ~Window();
+| 296|    |-	
+| 297|    |-	/// Allows for direct access to internal WINDOW pointer in case there
+| 298|    |-	/// is no wrapper for a function from curses library one may want to use
+| 299|    |-	/// @return internal WINDOW pointer
+| 300|    |-	WINDOW *raw() const { return m_window; }
+| 301|    |-	
+| 302|    |-	/// @return window's width
+| 303|    |-	size_t getWidth() const;
+| 304|    |-	
+| 305|    |-	/// @return window's height
+| 306|    |-	size_t getHeight() const;
+| 307|    |-	
+| 308|    |-	/// @return X position of left upper window's corner
+| 309|    |-	size_t getStartX() const;
+| 310|    |-	
+| 311|    |-	/// @return Y position of left upper window's corner
+| 312|    |-	size_t getStarty() const;
+| 313|    |-	
+| 314|    |-	/// @return window's title
+| 315|    |-	const std::string &getTitle() const;
+| 316|    |-	
+| 317|    |-	/// @return current window's color
+| 318|    |-	const Color &getColor() const;
+| 319|    |-	
+| 320|    |-	/// @return current window's border
+| 321|    |-	const Border &getBorder() const;
+| 322|    |-	
+| 323|    |-	/// @return current window's timeout
+| 324|    |-	int getTimeout() const;
+| 325|    |-	
+| 326|    |-	/// @return current mouse event if readKey() returned KEY_MOUSE
+| 327|    |-	const MEVENT &getMouseEvent();
+| 328|    |-
+| 329|    |-	/// Reads the string from standard input using readline library.
+| 330|    |-	/// @param base base string that has to be edited
+| 331|    |-	/// @param length max length of the string, unlimited by default
+| 332|    |-	/// @param width width of area that entry field can take. if it's reached, string
+| 333|    |-	/// will be scrolled. if value is 0, field will be from cursor position to the end
+| 334|    |-	/// of current line wide.
+| 335|    |-	/// @param encrypted if set to true, '*' characters will be displayed instead of
+| 336|    |-	/// actual text.
+| 337|    |-	/// @return edited string
+| 338|    |-	///
+| 339|    |-	/// @see setPromptHook()
+| 340|    |-	/// @see SetTimeout()
+| 341|    |-	std::string prompt(const std::string &base = "", size_t width = -1, bool encrypted = false);
+| 342|    |-	
+| 343|    |-	/// Moves cursor to given coordinates
+| 344|    |-	/// @param x given X position
+| 345|    |-	/// @param y given Y position
+| 346|    |-	void goToXY(int x, int y);
+| 347|    |-	
+| 348|    |-	/// @return x window coordinate
+| 349|    |-	int getX();
+| 350|    |-	
+| 351|    |-	/// @return y windows coordinate
+| 352|    |-	int getY();
+| 353|    |-	
+| 354|    |-	/// Used to indicate whether given coordinates of main screen lies within
+| 355|    |-	/// window area or not and if they do, transform them into in-window coords.
+| 356|    |-	/// Otherwise function doesn't modify its arguments.
+| 357|    |-	/// @param x X position of main screen to be checked
+| 358|    |-	/// @param y Y position of main screen to be checked
+| 359|    |-	/// @return true if it transformed variables, false otherwise
+| 360|    |-	bool hasCoords(int &x, int &y);
+| 361|    |-	
+| 362|    |-	/// Sets hook used in getString()
+| 363|    |-	/// @param hook pointer to function that matches getStringHelper prototype
+| 364|    |-	/// @see getString()
+| 365|    |-	template <typename HookT>
+| 366|    |-	void setPromptHook(HookT &&hook) {
+| 367|    |-		m_prompt_hook = std::forward<HookT>(hook);
+| 368|    |-	}
+| 369|    |-
+| 370|    |-	/// Run current GetString helper function (if defined).
+| 371|    |-	/// @see getString()
+| 372|    |-	/// @return true if helper was run, false otherwise
+| 373|    |-	bool runPromptHook(const char *arg, bool *done) const;
+| 374|    |-
+| 375|    |-	/// Sets window's base color
+| 376|    |-	/// @param fg foregound base color
+| 377|    |-	/// @param bg background base color
+| 378|    |-	void setBaseColor(const Color &color);
+| 379|    |-	
+| 380|    |-	/// Sets window's border
+| 381|    |-	/// @param border new window's border
+| 382|    |-	void setBorder(Border border);
+| 383|    |-	
+| 384|    |-	/// Sets window's timeout
+| 385|    |-	/// @param timeout window's timeout
+| 386|    |-	void setTimeout(int timeout);
+| 387|    |-	
+| 388|    |-	/// Sets window's title
+| 389|    |-	/// @param new_title new title for window
+| 390|    |-	void setTitle(const std::string &new_title);
+| 391|    |-	
+| 392|    |-	/// Refreshed whole window and its border
+| 393|    |-	/// @see refresh()
+| 394|    |-	void display();
+| 395|    |-
+| 396|    |-	/// Refreshes window's border
+| 397|    |-	void refreshBorder() const;
+| 398|    |-
+| 399|    |-	/// Refreshes whole window, but not the border
+| 400|    |-	/// @see display()
+| 401|    |-	virtual void refresh();
+| 402|    |-
+| 403|    |-	/// Moves the window to new coordinates
+| 404|    |-	/// @param new_x new X position of left upper corner of window
+| 405|    |-	/// @param new_y new Y position of left upper corner of window
+| 406|    |-	virtual void moveTo(size_t new_x, size_t new_y);
+| 407|    |-	
+| 408|    |-	/// Resizes the window
+| 409|    |-	/// @param new_width new window's width
+| 410|    |-	/// @param new_height new window's height
+| 411|    |-	virtual void resize(size_t new_width, size_t new_height);
+| 412|    |-	
+| 413|    |-	/// Cleares the window
+| 414|    |-	virtual void clear();
+| 415|    |-	
+| 416|    |-	/// Adds given file descriptor to the list that will be polled in
+| 417|    |-	/// readKey() along with stdin and callback that will be invoked
+| 418|    |-	/// when there is data waiting for reading in it
+| 419|    |-	/// @param fd file descriptor
+| 420|    |-	/// @param callback callback
+| 421|    |-	void addFDCallback(int fd, void (*callback)());
+| 422|    |-	
+| 423|    |-	/// Clears list of file descriptors and their callbacks
+| 424|    |-	void clearFDCallbacksList();
+| 425|    |-	
+| 426|    |-	/// Checks if list of file descriptors is empty
+| 427|    |-	/// @return true if list is empty, false otherwise
+| 428|    |-	bool FDCallbacksListEmpty() const;
+| 429|    |-	
+| 430|    |-	/// Reads key from standard input (or takes it from input queue)
+| 431|    |-	/// and writes it into read_key variable
+| 432|    |-	Key::Type readKey();
+| 433|    |-	
+| 434|    |-	/// Push single character into input queue, so it can get consumed by ReadKey
+| 435|    |-	void pushChar(const NC::Key::Type ch);
+| 436|    |-	
+| 437|    |-	/// @return const reference to internal input queue
+| 438|    |-	const std::queue<NC::Key::Type> &inputQueue() { return m_input_queue; }
+| 439|    |-	
+| 440|    |-	/// Scrolls the window by amount of lines given in its parameter
+| 441|    |-	/// @param where indicates how many lines it has to scroll
+| 442|    |-	virtual void scroll(Scroll where);
+| 443|    |-	
+| 444|    |-	Window &operator<<(TermManip tm);
+| 445|    |-	Window &operator<<(const Color &color);
+| 446|    |-	Window &operator<<(Format format);
+| 447|    |-	Window &operator<<(const XY &coords);
+| 448|    |-	Window &operator<<(const char *s);
+| 449|    |-	Window &operator<<(char c);
+| 450|    |-	Window &operator<<(const wchar_t *ws);
+| 451|    |-	Window &operator<<(wchar_t wc);
+| 452|    |-	Window &operator<<(int i);
+| 453|    |-	Window &operator<<(double d);
+| 454|    |-	Window &operator<<(size_t s);
+| 455|    |-	Window &operator<<(const std::string &s);
+| 456|    |-	Window &operator<<(const std::wstring &ws);
+| 457|    |-protected:
+| 458|    |-	/// Sets colors of window (interal use only)
+| 459|    |-	/// @param fg foregound color
+| 460|    |-	/// @param bg background color
+| 461|    |-	///
+| 462|    |-	void setColor(Color c);
+| 463|    |-	
+| 464|    |-	/// Changes dimensions of window, called from resize()
+| 465|    |-	/// @param width new window's width
+| 466|    |-	/// @param height new window's height
+| 467|    |-	/// @see resize()
+| 468|    |-	///
+| 469|    |-	void adjustDimensions(size_t width, size_t height);
+| 470|    |-	
+| 471|    |-	/// Deletes old window and creates new. It's called by resize(),
+| 472|    |-	/// SetBorder() or setTitle() since internally windows are
+| 473|    |-	/// handled as curses pads and change in size requires to delete
+| 474|    |-	/// them and create again, there is no way to change size of pad.
+| 475|    |-	/// @see SetBorder()
+| 476|    |-	/// @see setTitle()
+| 477|    |-	/// @see resize()
+| 478|    |-	///
+| 479|    |-	virtual void recreate(size_t width, size_t height);
+| 480|    |-	
+| 481|    |-	/// internal WINDOW pointers
+| 482|    |-	WINDOW *m_window;
+| 483|    |-	
+| 484|    |-	/// start points and dimensions
+| 485|    |-	size_t m_start_x;
+| 486|    |-	size_t m_start_y;
+| 487|    |-	size_t m_width;
+| 488|    |-	size_t m_height;
+| 489|    |-	
+| 490|    |-	/// window timeout
+| 491|    |-	int m_window_timeout;
+| 492|    |-	
+| 493|    |-	/// current colors
+| 494|    |-	Color m_color;
+| 495|    |-	
+| 496|    |-	/// base colors
+| 497|    |-	Color m_base_color;
+| 498|    |-	
+| 499|    |-	/// current border
+| 500|    |-	Border m_border;
+| 501|    |-	
+| 502|    |-private:
+| 503|    |-	Key::Type getInputChar(int key);
+| 504|    |-
+| 505|    |-	/// Sets state of bold attribute (internal use only)
+| 506|    |-	/// @param bold_state state of bold attribute
+| 507|    |-	///
+| 508|    |-	void bold(bool bold_state) const;
+| 509|    |-	
+| 510|    |-	/// Sets state of underline attribute (internal use only)
+| 511|    |-	/// @param underline_state state of underline attribute
+| 512|    |-	///
+| 513|    |-	void underline(bool underline_state) const;
+| 514|    |-	
+| 515|    |-	/// Sets state of reverse attribute (internal use only)
+| 516|    |-	/// @param reverse_state state of reverse attribute
+| 517|    |-	///
+| 518|    |-	void reverse(bool reverse_state) const;
+| 519|    |-	
+| 520|    |-	/// Sets state of altcharset attribute (internal use only)
+| 521|    |-	/// @param altcharset_state state of altcharset attribute
+| 522|    |-	///
+| 523|    |-	void altCharset(bool altcharset_state) const;
+| 524|    |-	
+| 525|    |-	/// pointer to helper function used by getString()
+| 526|    |-	/// @see getString()
+| 527|    |-	///
+| 528|    |-	PromptHook m_prompt_hook;
+| 529|    |-	
+| 530|    |-	/// window title
+| 531|    |-	std::string m_title;
+| 532|    |-	
+| 533|    |-	/// stack of colors
+| 534|    |-	std::stack<Color> m_color_stack;
+| 535|    |-	
+| 536|    |-	/// input queue of a window. you can put characters there using
+| 537|    |-	/// PushChar and they will be immediately consumed and
+| 538|    |-	/// returned by ReadKey
+| 539|    |-	std::queue<Key::Type> m_input_queue;
+| 540|    |-	
+| 541|    |-	/// containter used for additional file descriptors that have
+| 542|    |-	/// to be polled in ReadKey() and correspondent callbacks that
+| 543|    |-	/// are invoked if there is data available in them
+| 544|    |-	typedef std::vector< std::pair<int, void (*)()> > FDCallbacks;
+| 545|    |-	FDCallbacks m_fds;
+| 546|    |-	
+| 547|    |-	MEVENT m_mouse_event;
+| 548|    |-	bool m_escape_terminal_sequences;
+| 549|    |-
+| 550|    |-	/// counters for format flags
+| 551|    |-	int m_bold_counter;
+| 552|    |-	int m_underline_counter;
+| 553|    |-	int m_reverse_counter;
+| 554|    |-	int m_alt_charset_counter;
+| 555|    |-};
+|    | 235|+    struct Window
+|    | 236|+    {
+|    | 237|+        /// Helper function that is periodically invoked
+|    | 238|+        // inside Window::getString() function
+|    | 239|+        /// @see Window::getString()
+|    | 240|+        typedef std::function < bool (const char *) > PromptHook;
+|    | 241|+
+|    | 242|+        /// Sets helper to a specific value for the current scope
+|    | 243|+        struct ScopedPromptHook
+|    | 244|+        {
+|    | 245|+            template < typename HelperT >
+|    | 246|+                ScopedPromptHook (Window & w, HelperT
+|    | 247|+                                  && helper) noexcept:m_w (w),
+|    | 248|+                m_hook (std::move (w.m_prompt_hook))
+|    | 249|+            {
+|    | 250|+                m_w.m_prompt_hook = std::forward < HelperT > (helper);
+|    | 251|+            }
+|    | 252|+             ~ScopedPromptHook () noexcept
+|    | 253|+            {
+|    | 254|+                m_w.m_prompt_hook = std::move (m_hook);
+|    | 255|+            }
+|    | 256|+
+|    | 257|+          private:
+|    | 258|+              Window & m_w;
+|    | 259|+            PromptHook m_hook;
+|    | 260|+        };
+|    | 261|+
+|    | 262|+        struct ScopedTimeout
+|    | 263|+        {
+|    | 264|+            ScopedTimeout (Window & w, int new_timeout):m_w (w)
+|    | 265|+            {
+|    | 266|+                m_timeout = w.getTimeout ();
+|    | 267|+                w.setTimeout (new_timeout);
+|    | 268|+            }
+|    | 269|+
+|    | 270|+             ~ScopedTimeout ()
+|    | 271|+            {
+|    | 272|+                m_w.setTimeout (m_timeout);
+|    | 273|+            }
+|    | 274|+
+|    | 275|+          private:
+|    | 276|+            Window & m_w;
+|    | 277|+            int m_timeout;
+|    | 278|+        };
+|    | 279|+
+|    | 280|+      Window ():m_window (nullptr)
+|    | 281|+        {
+|    | 282|+        }
+|    | 283|+
+|    | 284|+        /// Constructs an empty window with given parameters
+|    | 285|+        /// @param startx X position of left upper corner of constructed window
+|    | 286|+        /// @param starty Y position of left upper corner of constructed window
+|    | 287|+        /// @param width width of constructed window
+|    | 288|+        /// @param height height of constructed window
+|    | 289|+        /// @param title title of constructed window
+|    | 290|+        /// @param color base color of constructed window
+|    | 291|+        /// @param border border of constructed window
+|    | 292|+        Window (size_t startx, size_t starty, size_t width, size_t height,
+|    | 293|+                std::string title, Color color, Border border);
+|    | 294|+
+|    | 295|+        Window (const Window & rhs);
+|    | 296|+        Window (Window && rhs);
+|    | 297|+        Window & operator= (Window w);
+|    | 298|+
+|    | 299|+        virtual ~ Window ();
+|    | 300|+
+|    | 301|+        /// Allows for direct access to internal WINDOW pointer in case there
+|    | 302|+        /// is no wrapper for a function from curses library one may want to use
+|    | 303|+        /// @return internal WINDOW pointer
+|    | 304|+        WINDOW *raw () const
+|    | 305|+        {
+|    | 306|+            return m_window;
+|    | 307|+        }
+|    | 308|+
+|    | 309|+        /// @return window's width
+|    | 310|+        size_t getWidth () const;
+|    | 311|+
+|    | 312|+        /// @return window's height
+|    | 313|+        size_t getHeight () const;
+|    | 314|+
+|    | 315|+        /// @return X position of left upper window's corner
+|    | 316|+        size_t getStartX () const;
+|    | 317|+
+|    | 318|+        /// @return Y position of left upper window's corner
+|    | 319|+        size_t getStarty () const;
+|    | 320|+
+|    | 321|+        /// @return window's title
+|    | 322|+        const std::string & getTitle () const;
+|    | 323|+
+|    | 324|+        /// @return current window's color
+|    | 325|+        const Color & getColor () const;
+|    | 326|+
+|    | 327|+        /// @return current window's border
+|    | 328|+        const Border & getBorder () const;
+|    | 329|+
+|    | 330|+        /// @return current window's timeout
+|    | 331|+        int getTimeout () const;
+|    | 332|+
+|    | 333|+        /// @return current mouse event if readKey() returned KEY_MOUSE
+|    | 334|+        const MEVENT & getMouseEvent ();
+|    | 335|+
+|    | 336|+        /// Reads the string from standard input using readline library.
+|    | 337|+        /// @param base base string that has to be edited
+|    | 338|+        /// @param length max length of the string, unlimited by default
+|    | 339|+        /// @param width width of area that entry field can take. if it's reached, string
+|    | 340|+        /// will be scrolled. if value is 0, field will be from cursor position to the end
+|    | 341|+        /// of current line wide.
+|    | 342|+        /// @param encrypted if set to true, '*' characters will be displayed instead of
+|    | 343|+        /// actual text.
+|    | 344|+        /// @return edited string
+|    | 345|+        ///
+|    | 346|+        /// @see setPromptHook()
+|    | 347|+        /// @see SetTimeout()
+|    | 348|+        std::string prompt (const std::string & base = "", size_t width =
+|    | 349|+                            -1, bool encrypted = false);
+|    | 350|+
+|    | 351|+        /// Moves cursor to given coordinates
+|    | 352|+        /// @param x given X position
+|    | 353|+        /// @param y given Y position
+|    | 354|+        void goToXY (int x, int y);
+|    | 355|+
+|    | 356|+        /// @return x window coordinate
+|    | 357|+        int getX ();
+|    | 358|+
+|    | 359|+        /// @return y windows coordinate
+|    | 360|+        int getY ();
+|    | 361|+
+|    | 362|+        /// Used to indicate whether given coordinates of main screen lies within
+|    | 363|+        /// window area or not and if they do, transform them into in-window coords.
+|    | 364|+        /// Otherwise function doesn't modify its arguments.
+|    | 365|+        /// @param x X position of main screen to be checked
+|    | 366|+        /// @param y Y position of main screen to be checked
+|    | 367|+        /// @return true if it transformed variables, false otherwise
+|    | 368|+        bool hasCoords (int &x, int &y);
+|    | 369|+
+|    | 370|+        /// Sets hook used in getString()
+|    | 371|+        /// @param hook pointer to function that matches getStringHelper prototype
+|    | 372|+        /// @see getString()
+|    | 373|+        template < typename HookT > void setPromptHook (HookT && hook)
+|    | 374|+        {
+|    | 375|+            m_prompt_hook = std::forward < HookT > (hook);
+|    | 376|+        }
+|    | 377|+
+|    | 378|+        /// Run current GetString helper function (if defined).
+|    | 379|+        /// @see getString()
+|    | 380|+        /// @return true if helper was run, false otherwise
+|    | 381|+        bool runPromptHook (const char *arg, bool * done) const;
+|    | 382|+
+|    | 383|+        /// Sets window's base color
+|    | 384|+        /// @param fg foregound base color
+|    | 385|+        /// @param bg background base color
+|    | 386|+        void setBaseColor (const Color & color);
+|    | 387|+
+|    | 388|+        /// Sets window's border
+|    | 389|+        /// @param border new window's border
+|    | 390|+        void setBorder (Border border);
+|    | 391|+
+|    | 392|+        /// Sets window's timeout
+|    | 393|+        /// @param timeout window's timeout
+|    | 394|+        void setTimeout (int timeout);
+|    | 395|+
+|    | 396|+        /// Sets window's title
+|    | 397|+        /// @param new_title new title for window
+|    | 398|+        void setTitle (const std::string & new_title);
+|    | 399|+
+|    | 400|+        /// Refreshed whole window and its border
+|    | 401|+        /// @see refresh()
+|    | 402|+        void display ();
+|    | 403|+
+|    | 404|+        /// Refreshes window's border
+|    | 405|+        void refreshBorder () const;
+|    | 406|+
+|    | 407|+        /// Refreshes whole window, but not the border
+|    | 408|+        /// @see display()
+|    | 409|+        virtual void refresh ();
+|    | 410|+
+|    | 411|+        /// Moves the window to new coordinates
+|    | 412|+        /// @param new_x new X position of left upper corner of window
+|    | 413|+        /// @param new_y new Y position of left upper corner of window
+|    | 414|+        virtual void moveTo (size_t new_x, size_t new_y);
+|    | 415|+
+|    | 416|+        /// Resizes the window
+|    | 417|+        /// @param new_width new window's width
+|    | 418|+        /// @param new_height new window's height
+|    | 419|+        virtual void resize (size_t new_width, size_t new_height);
+|    | 420|+
+|    | 421|+        /// Cleares the window
+|    | 422|+        virtual void clear ();
+|    | 423|+
+|    | 424|+        /// Adds given file descriptor to the list that will be polled in
+|    | 425|+        /// readKey() along with stdin and callback that will be invoked
+|    | 426|+        /// when there is data waiting for reading in it
+|    | 427|+        /// @param fd file descriptor
+|    | 428|+        /// @param callback callback
+|    | 429|+        void addFDCallback (int fd, void (*callback) ());
+|    | 430|+
+|    | 431|+        /// Clears list of file descriptors and their callbacks
+|    | 432|+        void clearFDCallbacksList ();
+|    | 433|+
+|    | 434|+        /// Checks if list of file descriptors is empty
+|    | 435|+        /// @return true if list is empty, false otherwise
+|    | 436|+        bool FDCallbacksListEmpty () const;
+|    | 437|+
+|    | 438|+        /// Reads key from standard input (or takes it from input queue)
+|    | 439|+        /// and writes it into read_key variable
+|    | 440|+        Key::Type readKey ();
+|    | 441|+
+|    | 442|+        /// Push single character into input queue, so it can get consumed by ReadKey
+|    | 443|+        void pushChar (const NC::Key::Type ch);
+|    | 444|+
+|    | 445|+        /// @return const reference to internal input queue
+|    | 446|+        const std::queue < NC::Key::Type > &inputQueue ()
+|    | 447|+        {
+|    | 448|+            return m_input_queue;
+|    | 449|+        }
+|    | 450|+
+|    | 451|+        /// Scrolls the window by amount of lines given in its parameter
+|    | 452|+        /// @param where indicates how many lines it has to scroll
+|    | 453|+        virtual void scroll (Scroll where);
+|    | 454|+
+|    | 455|+        Window & operator<< (TermManip tm);
+|    | 456|+        Window & operator<< (const Color & color);
+|    | 457|+        Window & operator<< (Format format);
+|    | 458|+        Window & operator<< (const XY & coords);
+|    | 459|+        Window & operator<< (const char *s);
+|    | 460|+        Window & operator<< (char c);
+|    | 461|+        Window & operator<< (const wchar_t * ws);
+|    | 462|+        Window & operator<< (wchar_t wc);
+|    | 463|+        Window & operator<< (int i);
+|    | 464|+        Window & operator<< (double d);
+|    | 465|+        Window & operator<< (size_t s);
+|    | 466|+        Window & operator<< (const std::string & s);
+|    | 467|+        Window & operator<< (const std::wstring & ws);
+|    | 468|+      protected:
+|    | 469|+        /// Sets colors of window (interal use only)
+|    | 470|+        /// @param fg foregound color
+|    | 471|+        /// @param bg background color
+|    | 472|+        ///
+|    | 473|+        void setColor (Color c);
+|    | 474|+
+|    | 475|+        /// Changes dimensions of window, called from resize()
+|    | 476|+        /// @param width new window's width
+|    | 477|+        /// @param height new window's height
+|    | 478|+        /// @see resize()
+|    | 479|+        ///
+|    | 480|+        void adjustDimensions (size_t width, size_t height);
+|    | 481|+
+|    | 482|+        /// Deletes old window and creates new. It's called by resize(),
+|    | 483|+        /// SetBorder() or setTitle() since internally windows are
+|    | 484|+        /// handled as curses pads and change in size requires to delete
+|    | 485|+        /// them and create again, there is no way to change size of pad.
+|    | 486|+        /// @see SetBorder()
+|    | 487|+        /// @see setTitle()
+|    | 488|+        /// @see resize()
+|    | 489|+        ///
+|    | 490|+        virtual void recreate (size_t width, size_t height);
+|    | 491|+
+|    | 492|+        /// internal WINDOW pointers
+|    | 493|+        WINDOW *m_window;
+|    | 494|+
+|    | 495|+        /// start points and dimensions
+|    | 496|+        size_t m_start_x;
+|    | 497|+        size_t m_start_y;
+|    | 498|+        size_t m_width;
+|    | 499|+        size_t m_height;
+|    | 500|+
+|    | 501|+        /// window timeout
+|    | 502|+        int m_window_timeout;
+|    | 503|+
+|    | 504|+        /// current colors
+|    | 505|+        Color m_color;
+|    | 506|+
+|    | 507|+        /// base colors
+|    | 508|+        Color m_base_color;
+|    | 509|+
+|    | 510|+        /// current border
+|    | 511|+        Border m_border;
+|    | 512|+
+|    | 513|+      private:
+|    | 514|+        Key::Type getInputChar (int key);
+|    | 515|+
+|    | 516|+        /// Sets state of bold attribute (internal use only)
+|    | 517|+        /// @param bold_state state of bold attribute
+|    | 518|+        ///
+|    | 519|+        void bold (bool bold_state) const;
+|    | 520|+
+|    | 521|+        /// Sets state of underline attribute (internal use only)
+|    | 522|+        /// @param underline_state state of underline attribute
+|    | 523|+        ///
+|    | 524|+        void underline (bool underline_state) const;
+|    | 525|+
+|    | 526|+        /// Sets state of reverse attribute (internal use only)
+|    | 527|+        /// @param reverse_state state of reverse attribute
+|    | 528|+        ///
+|    | 529|+        void reverse (bool reverse_state) const;
+|    | 530|+
+|    | 531|+        /// Sets state of altcharset attribute (internal use only)
+|    | 532|+        /// @param altcharset_state state of altcharset attribute
+|    | 533|+        ///
+|    | 534|+        void altCharset (bool altcharset_state) const;
+|    | 535|+
+|    | 536|+        /// pointer to helper function used by getString()
+|    | 537|+        /// @see getString()
+|    | 538|+        ///
+|    | 539|+        PromptHook m_prompt_hook;
+|    | 540|+
+|    | 541|+        /// window title
+|    | 542|+        std::string m_title;
+|    | 543|+
+|    | 544|+        /// stack of colors
+|    | 545|+        std::stack < Color > m_color_stack;
+|    | 546|+
+|    | 547|+        /// input queue of a window. you can put characters there using
+|    | 548|+        /// PushChar and they will be immediately consumed and
+|    | 549|+        /// returned by ReadKey
+|    | 550|+        std::queue < Key::Type > m_input_queue;
+|    | 551|+
+|    | 552|+        /// containter used for additional file descriptors that have
+|    | 553|+        /// to be polled in ReadKey() and correspondent callbacks that
+|    | 554|+        /// are invoked if there is data available in them
+|    | 555|+        typedef std::vector < std::pair < int, void (*) () > >FDCallbacks;
+|    | 556|+        FDCallbacks m_fds;
+|    | 557|+
+|    | 558|+        MEVENT m_mouse_event;
+|    | 559|+        bool m_escape_terminal_sequences;
+|    | 560|+
+|    | 561|+        /// counters for format flags
+|    | 562|+        int m_bold_counter;
+|    | 563|+        int m_underline_counter;
+|    | 564|+        int m_reverse_counter;
+|    | 565|+        int m_alt_charset_counter;
+|    | 566|+    };
+| 556| 567| 
+| 557| 568| }
+| 558| 569| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/configuration.h
+|    |++++| /app/src/configuration.h
+|  21|  21| #ifndef NCMPCPP_CONFIGURATION_H
+|  22|  22| #define NCMPCPP_CONFIGURATION_H
+|  23|  23| 
+|  24|    |-void expand_home(std::string &path);
+|    |  24|+void expand_home (std::string & path);
+|  25|  25| 
+|  26|    |-bool configure(int argc, char **argv);
+|    |  26|+bool configure (int argc, char **argv);
+|  27|  27| 
+|  28|  28| #endif // NCMPCPP_CONFIGURATION_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/enums.h
+|    |++++| /app/src/enums.h
+|  24|  24| #include "config.h"
+|  25|  25| #include <iostream>
+|  26|  26| 
+|  27|    |-enum class SearchDirection { Backward, Forward };
+|  28|    |-std::ostream &operator<<(std::ostream &os, SearchDirection sd);
+|  29|    |-std::istream &operator>>(std::istream &is, SearchDirection &sd);
+|    |  27|+enum class SearchDirection
+|    |  28|+{ Backward, Forward };
+|    |  29|+std::ostream & operator<< (std::ostream & os, SearchDirection sd);
+|    |  30|+std::istream & operator>> (std::istream & is, SearchDirection & sd);
+|  30|  31| 
+|  31|    |-enum class SpaceAddMode { AddRemove, AlwaysAdd };
+|  32|    |-std::ostream &operator<<(std::ostream &os, SpaceAddMode sam);
+|  33|    |-std::istream &operator>>(std::istream &is, SpaceAddMode &sam);
+|    |  32|+enum class SpaceAddMode
+|    |  33|+{ AddRemove, AlwaysAdd };
+|    |  34|+std::ostream & operator<< (std::ostream & os, SpaceAddMode sam);
+|    |  35|+std::istream & operator>> (std::istream & is, SpaceAddMode & sam);
+|  34|  36| 
+|  35|    |-enum class SortMode { Name, ModificationTime, CustomFormat, NoOp };
+|  36|    |-std::ostream &operator<<(std::ostream &os, SortMode sm);
+|  37|    |-std::istream &operator>>(std::istream &is, SortMode &sm);
+|    |  37|+enum class SortMode
+|    |  38|+{ Name, ModificationTime, CustomFormat, NoOp };
+|    |  39|+std::ostream & operator<< (std::ostream & os, SortMode sm);
+|    |  40|+std::istream & operator>> (std::istream & is, SortMode & sm);
+|  38|  41| 
+|  39|    |-enum class DisplayMode { Classic, Columns };
+|  40|    |-std::ostream &operator<<(std::ostream &os, DisplayMode dm);
+|  41|    |-std::istream &operator>>(std::istream &is, DisplayMode &dm);
+|    |  42|+enum class DisplayMode
+|    |  43|+{ Classic, Columns };
+|    |  44|+std::ostream & operator<< (std::ostream & os, DisplayMode dm);
+|    |  45|+std::istream & operator>> (std::istream & is, DisplayMode & dm);
+|  42|  46| 
+|  43|    |-enum class Design { Classic, Alternative };
+|  44|    |-std::ostream &operator<<(std::ostream &os, Design ui);
+|  45|    |-std::istream &operator>>(std::istream &is, Design &ui);
+|    |  47|+enum class Design
+|    |  48|+{ Classic, Alternative };
+|    |  49|+std::ostream & operator<< (std::ostream & os, Design ui);
+|    |  50|+std::istream & operator>> (std::istream & is, Design & ui);
+|  46|  51| 
+|  47|    |-enum class VisualizerType {
+|  48|    |-	Wave,
+|  49|    |-	WaveFilled,
+|    |  52|+enum class VisualizerType
+|    |  53|+{
+|    |  54|+    Wave,
+|    |  55|+    WaveFilled,
+|  50|  56| #	ifdef HAVE_FFTW3_H
+|  51|    |-	Spectrum,
+|  52|    |-#	endif // HAVE_FFTW3_H
+|  53|    |-	Ellipse
+|    |  57|+    Spectrum,
+|    |  58|+#	endif                       // HAVE_FFTW3_H
+|    |  59|+    Ellipse
+|  54|  60| };
+|  55|    |-std::ostream &operator<<(std::ostream &os, VisualizerType vt);
+|  56|    |-std::istream &operator>>(std::istream &is, VisualizerType &vt);
+|    |  61|+std::ostream & operator<< (std::ostream & os, VisualizerType vt);
+|    |  62|+std::istream & operator>> (std::istream & is, VisualizerType & vt);
+|  57|  63| 
+|  58|  64| #endif // NCMPCPP_ENUMS_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/shared_resource.h
+|    |++++| /app/src/utility/shared_resource.h
+|  23|  23| 
+|  24|  24| #include <mutex>
+|  25|  25| 
+|  26|    |-template <typename ResourceT>
+|  27|    |-struct Shared
+|    |  26|+template < typename ResourceT > struct Shared
+|  28|  27| {
+|  29|    |-	struct Resource
+|  30|    |-	{
+|  31|    |-		Resource(std::mutex &mutex, ResourceT &resource)
+|  32|    |-			: m_lock(std::unique_lock<std::mutex>(mutex)), m_resource(resource)
+|  33|    |-		{ }
+|    |  28|+    struct Resource
+|    |  29|+    {
+|    |  30|+        Resource (std::mutex & mutex,
+|    |  31|+                  ResourceT & resource):m_lock (std::unique_lock < std::mutex >
+|    |  32|+                                                (mutex)), m_resource (resource)
+|    |  33|+        {
+|    |  34|+        }
+|  34|  35| 
+|  35|    |-		ResourceT &operator*() { return m_resource; }
+|  36|    |-		const ResourceT &operator*() const { return m_resource; }
+|    |  36|+        ResourceT & operator* ()
+|    |  37|+        {
+|    |  38|+            return m_resource;
+|    |  39|+        }
+|    |  40|+        const ResourceT & operator* () const
+|    |  41|+        {
+|    |  42|+            return m_resource;
+|    |  43|+        }
+|  37|  44| 
+|  38|    |-		ResourceT *operator->() { return &m_resource; }
+|  39|    |-		const ResourceT *operator->() const { return &m_resource; }
+|    |  45|+        ResourceT *operator-> ()
+|    |  46|+        {
+|    |  47|+            return &m_resource;
+|    |  48|+        }
+|    |  49|+        const ResourceT *operator-> () const
+|    |  50|+        {
+|    |  51|+            return &m_resource;
+|    |  52|+        }
+|  40|  53| 
+|  41|    |-	private:
+|  42|    |-		std::unique_lock<std::mutex> m_lock;
+|  43|    |-		ResourceT &m_resource;
+|  44|    |-	};
+|    |  54|+      private:
+|    |  55|+          std::unique_lock < std::mutex > m_lock;
+|    |  56|+        ResourceT & m_resource;
+|    |  57|+    };
+|  45|  58| 
+|  46|    |-	Shared(){ }
+|    |  59|+    Shared ()
+|    |  60|+    {
+|    |  61|+    }
+|  47|  62| 
+|  48|    |-	template <typename ValueT>
+|  49|    |-	Shared(ValueT &&value)
+|  50|    |-		: m_resource(std::forward<ValueT>(value))
+|  51|    |-	{ }
+|    |  63|+  template < typename ValueT > Shared (ValueT && value):m_resource (std::forward < ValueT >
+|    |  64|+                (value))
+|    |  65|+    {
+|    |  66|+    }
+|  52|  67| 
+|  53|    |-	Resource acquire() { return Resource(m_mutex, m_resource); }
+|    |  68|+    Resource acquire ()
+|    |  69|+    {
+|    |  70|+        return Resource (m_mutex, m_resource);
+|    |  71|+    }
+|  54|  72| 
+|  55|    |-private:
+|  56|    |-	std::mutex m_mutex;
+|  57|    |-	ResourceT m_resource;
+|    |  73|+  private:
+|    |  74|+    std::mutex m_mutex;
+|    |  75|+    ResourceT m_resource;
+|  58|  76| };
+|  59|  77| 
+|  60|  78| #endif // NCMPCPP_UTILITY_SHARED_RESOURCE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/scoped_value.h
+|    |++++| /app/src/utility/scoped_value.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_SCOPED_VALUE_H
+|  22|  22| #define NCMPCPP_UTILITY_SCOPED_VALUE_H
+|  23|  23| 
+|  24|    |-template <typename ValueT>
+|  25|    |-struct ScopedValue
+|    |  24|+template < typename ValueT > struct ScopedValue
+|  26|  25| {
+|  27|    |-	ScopedValue(ValueT &ref, ValueT &&new_value)
+|  28|    |-		: m_ref(ref)
+|  29|    |-	{
+|  30|    |-		m_value = ref;
+|  31|    |-		m_ref = std::forward<ValueT>(new_value);
+|  32|    |-	}
+|    |  26|+    ScopedValue (ValueT & ref, ValueT && new_value):m_ref (ref)
+|    |  27|+    {
+|    |  28|+        m_value = ref;
+|    |  29|+        m_ref = std::forward < ValueT > (new_value);
+|    |  30|+    }
+|  33|  31| 
+|  34|    |-	~ScopedValue()
+|  35|    |-	{
+|  36|    |-		m_ref = std::move(m_value);
+|  37|    |-	}
+|    |  32|+     ~ScopedValue ()
+|    |  33|+    {
+|    |  34|+        m_ref = std::move (m_value);
+|    |  35|+    }
+|  38|  36| 
+|  39|    |-private:
+|  40|    |-	ValueT &m_ref;
+|  41|    |-	ValueT m_value;
+|    |  37|+  private:
+|    |  38|+    ValueT & m_ref;
+|    |  39|+    ValueT m_value;
+|  42|  40| };
+|  43|  41| 
+|  44|  42| #endif // NCMPCPP_UTILITY_SCOPED_VALUE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  34|  34| # include <fftw3.h>
+|  35|  35| #endif
+|  36|  36| 
+|  37|    |-struct Visualizer: Screen<NC::Window>, Tabbable
+|    |  37|+struct Visualizer:Screen <
+|    |  38|+    NC::Window >,
+|    |  39|+    Tabbable
+|  38|  40| {
+|  39|    |-	Visualizer();
+|    |  41|+    Visualizer ();
+|  40|  42| 
+|  41|    |-	virtual void switchTo() override;
+|  42|    |-	virtual void resize() override;
+|    |  43|+    virtual void
+|    |  44|+    switchTo ()
+|    |  45|+        override;
+|    |  46|+    virtual void
+|    |  47|+    resize ()
+|    |  48|+        override;
+|  43|  49| 
+|  44|    |-	virtual std::wstring title() override;
+|  45|    |-	virtual ScreenType type() override { return ScreenType::Visualizer; }
+|    |  50|+    virtual
+|    |  51|+        std::wstring
+|    |  52|+    title ()
+|    |  53|+        override;
+|    |  54|+    virtual ScreenType
+|    |  55|+    type ()
+|    |  56|+        override
+|    |  57|+    {
+|    |  58|+        return ScreenType::Visualizer;
+|    |  59|+    }
+|  46|  60| 
+|  47|    |-	virtual void update() override;
+|  48|    |-	virtual void scroll(NC::Scroll) override { }
+|    |  61|+    virtual void
+|    |  62|+    update ()
+|    |  63|+        override;
+|    |  64|+    virtual void
+|    |  65|+    scroll (NC::Scroll)
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+    }
+|  49|  69| 
+|  50|    |-	virtual int windowTimeout() override;
+|    |  70|+    virtual int
+|    |  71|+    windowTimeout ()
+|    |  72|+        override;
+|  51|  73| 
+|  52|    |-	virtual void mouseButtonPressed(MEVENT) override { }
+|    |  74|+    virtual void
+|    |  75|+    mouseButtonPressed (MEVENT)
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+    }
+|  53|  79| 
+|  54|    |-	virtual bool isLockable() override { return true; }
+|  55|    |-	virtual bool isMergable() override { return true; }
+|    |  80|+    virtual bool
+|    |  81|+    isLockable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|    |  86|+    virtual bool
+|    |  87|+    isMergable ()
+|    |  88|+        override
+|    |  89|+    {
+|    |  90|+        return true;
+|    |  91|+    }
+|  56|  92| 
+|  57|    |-	// private members
+|  58|    |-	void ToggleVisualizationType();
+|  59|    |-	void SetFD();
+|  60|    |-	void ResetFD();
+|  61|    |-	void FindOutputID();
+|  62|    |-	void ResetAutoScaleMultiplier();
+|    |  93|+    // private members
+|    |  94|+    void
+|    |  95|+    ToggleVisualizationType ();
+|    |  96|+    void
+|    |  97|+    SetFD ();
+|    |  98|+    void
+|    |  99|+    ResetFD ();
+|    | 100|+    void
+|    | 101|+    FindOutputID ();
+|    | 102|+    void
+|    | 103|+    ResetAutoScaleMultiplier ();
+|  63| 104| 
+|  64|    |-private:
+|  65|    |-	void DrawSoundWave(int16_t *, ssize_t, size_t, size_t);
+|  66|    |-	void DrawSoundWaveStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  67|    |-	void DrawSoundWaveFill(int16_t *, ssize_t, size_t, size_t);
+|  68|    |-	void DrawSoundWaveFillStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  69|    |-	void DrawSoundEllipse(int16_t *, ssize_t, size_t, size_t);
+|  70|    |-	void DrawSoundEllipseStereo(int16_t *, int16_t *, ssize_t, size_t);
+|    | 105|+  private:
+|    | 106|+    void
+|    | 107|+    DrawSoundWave (int16_t *, ssize_t, size_t, size_t);
+|    | 108|+    void
+|    | 109|+    DrawSoundWaveStereo (int16_t *, int16_t *, ssize_t, size_t);
+|    | 110|+    void
+|    | 111|+    DrawSoundWaveFill (int16_t *, ssize_t, size_t, size_t);
+|    | 112|+    void
+|    | 113|+    DrawSoundWaveFillStereo (int16_t *, int16_t *, ssize_t, size_t);
+|    | 114|+    void
+|    | 115|+    DrawSoundEllipse (int16_t *, ssize_t, size_t, size_t);
+|    | 116|+    void
+|    | 117|+    DrawSoundEllipseStereo (int16_t *, int16_t *, ssize_t, size_t);
+|  71| 118| #	ifdef HAVE_FFTW3_H
+|  72|    |-	void DrawFrequencySpectrum(int16_t *, ssize_t, size_t, size_t);
+|  73|    |-	void DrawFrequencySpectrumStereo(int16_t *, int16_t *, ssize_t, size_t);
+|    | 119|+    void
+|    | 120|+    DrawFrequencySpectrum (int16_t *, ssize_t, size_t, size_t);
+|    | 121|+    void
+|    | 122|+    DrawFrequencySpectrumStereo (int16_t *, int16_t *, ssize_t, size_t);
+|  74| 123| #	endif // HAVE_FFTW3_H
+|  75| 124| 
+|  76| 125| 	int m_output_id;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  73|  73| 	void DrawFrequencySpectrumStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  74|  74| #	endif // HAVE_FFTW3_H
+|  75|  75| 
+|  76|    |-	int m_output_id;
+|  77|    |-	boost::posix_time::ptime m_timer;
+|    |  76|+    int
+|    |  77|+        m_output_id;
+|    |  78|+    boost::posix_time::ptime m_timer;
+|  78|  79| 
+|  79|    |-	int m_fifo;
+|  80|    |-	size_t m_samples;
+|  81|    |-	double m_auto_scale_multiplier;
+|    |  80|+    int
+|    |  81|+        m_fifo;
+|    |  82|+    size_t
+|    |  83|+        m_samples;
+|    |  84|+    double
+|    |  85|+        m_auto_scale_multiplier;
+|  82|  86| #	ifdef HAVE_FFTW3_H
+|  83|    |-	size_t m_fftw_results;
+|  84|    |-	double *m_fftw_input;
+|  85|    |-	fftw_complex *m_fftw_output;
+|  86|    |-	fftw_plan m_fftw_plan;
+|    |  87|+    size_t
+|    |  88|+        m_fftw_results;
+|    |  89|+    double *
+|    |  90|+        m_fftw_input;
+|    |  91|+    fftw_complex *
+|    |  92|+        m_fftw_output;
+|    |  93|+    fftw_plan
+|    |  94|+        m_fftw_plan;
+|  87|  95| 
+|  88|    |-	std::vector<double> m_freq_magnitudes;
+|    |  96|+    std::vector < double >
+|    |  97|+        m_freq_magnitudes;
+|  89|  98| #	endif // HAVE_FFTW3_H
+|  90|  99| };
+|  91| 100| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  89|  89| #	endif // HAVE_FFTW3_H
+|  90|  90| };
+|  91|  91| 
+|  92|    |-extern Visualizer *myVisualizer;
+|    |  92|+extern Visualizer *
+|    |  93|+    myVisualizer;
+|  93|  94| 
+|  94|  95| #endif // ENABLE_VISUALIZER
+|  95|  96| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/browser.h
+|    |++++| /app/src/screens/browser.h
+|  27|  27| #include "screens/screen.h"
+|  28|  28| #include "song_list.h"
+|  29|  29| 
+|  30|    |-struct BrowserWindow: NC::Menu<MPD::Item>, SongList
+|    |  30|+struct BrowserWindow:
+|    |  31|+    NC::Menu <
+|    |  32|+    MPD::Item >,
+|    |  33|+    SongList
+|  31|  34| {
+|  32|    |-	BrowserWindow() { }
+|  33|    |-	BrowserWindow(NC::Menu<MPD::Item> &&base)
+|  34|    |-	: NC::Menu<MPD::Item>(std::move(base)) { }
+|    |  35|+    BrowserWindow ()
+|    |  36|+    {
+|    |  37|+    }
+|    |  38|+    BrowserWindow (NC::Menu < MPD::Item > &&base):
+|    |  39|+        NC::Menu <
+|    |  40|+    MPD::Item > (std::move (base))
+|    |  41|+    {
+|    |  42|+    }
+|  35|  43| 
+|  36|    |-	virtual SongIterator currentS() override;
+|  37|    |-	virtual ConstSongIterator currentS() const override;
+|  38|    |-	virtual SongIterator beginS() override;
+|  39|    |-	virtual ConstSongIterator beginS() const override;
+|  40|    |-	virtual SongIterator endS() override;
+|  41|    |-	virtual ConstSongIterator endS() const override;
+|    |  44|+    virtual SongIterator
+|    |  45|+    currentS ()
+|    |  46|+        override;
+|    |  47|+    virtual ConstSongIterator
+|    |  48|+    currentS () const
+|    |  49|+        override;
+|    |  50|+    virtual SongIterator
+|    |  51|+    beginS ()
+|    |  52|+        override;
+|    |  53|+    virtual ConstSongIterator
+|    |  54|+    beginS () const
+|    |  55|+        override;
+|    |  56|+    virtual SongIterator
+|    |  57|+    endS ()
+|    |  58|+        override;
+|    |  59|+    virtual ConstSongIterator
+|    |  60|+    endS () const
+|    |  61|+        override;
+|  42|  62| 
+|  43|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|    |  63|+    virtual
+|    |  64|+        std::vector <
+|    |  65|+        MPD::Song >
+|    |  66|+    getSelectedSongs ()
+|    |  67|+        override;
+|  44|  68| };
+|  45|  69| 
+|  46|  70| struct Browser: Screen<BrowserWindow>, Filterable, HasSongs, Searchable, Tabbable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/browser.h
+|    |++++| /app/src/screens/browser.h
+|  43|  43| 	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  44|  44| };
+|  45|  45| 
+|  46|    |-struct Browser: Screen<BrowserWindow>, Filterable, HasSongs, Searchable, Tabbable
+|    |  46|+struct Browser:
+|    |  47|+    Screen <
+|    |  48|+    BrowserWindow >,
+|    |  49|+    Filterable,
+|    |  50|+    HasSongs,
+|    |  51|+    Searchable,
+|    |  52|+    Tabbable
+|  47|  53| {
+|  48|    |-	Browser();
+|  49|    |-	
+|  50|    |-	// Screen<BrowserWindow> implementation
+|  51|    |-	virtual void resize() override;
+|  52|    |-	virtual void switchTo() override;
+|  53|    |-	
+|  54|    |-	virtual std::wstring title() override;
+|  55|    |-	virtual ScreenType type() override { return ScreenType::Browser; }
+|  56|    |-	
+|  57|    |-	virtual void update() override;
+|  58|    |-	
+|  59|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  60|    |-	
+|  61|    |-	virtual bool isLockable() override { return true; }
+|  62|    |-	virtual bool isMergable() override { return true; }
+|  63|    |-	
+|  64|    |-	// Searchable implementation
+|  65|    |-	virtual bool allowsSearching() override;
+|  66|    |-	virtual const std::string &searchConstraint() override;
+|  67|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  68|    |-	virtual void clearSearchConstraint() override;
+|  69|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|    |  54|+    Browser ();
+|  70|  55| 
+|  71|    |-	// Filterable implemenetation
+|  72|    |-	virtual bool allowsFiltering() override;
+|  73|    |-	virtual std::string currentFilter() override;
+|  74|    |-	virtual void applyFilter(const std::string &filter) override;
+|    |  56|+    // Screen<BrowserWindow> implementation
+|    |  57|+    virtual void
+|    |  58|+    resize ()
+|    |  59|+        override;
+|    |  60|+    virtual void
+|    |  61|+    switchTo ()
+|    |  62|+        override;
+|  75|  63| 
+|  76|    |-	// HasSongs implementation
+|  77|    |-	virtual bool itemAvailable() override;
+|  78|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  79|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  80|    |-	
+|  81|    |-	// private members
+|  82|    |-	void requestUpdate() { m_update_request = true; }
+|    |  64|+    virtual
+|    |  65|+        std::wstring
+|    |  66|+    title ()
+|    |  67|+        override;
+|    |  68|+    virtual ScreenType
+|    |  69|+    type ()
+|    |  70|+        override
+|    |  71|+    {
+|    |  72|+        return ScreenType::Browser;
+|    |  73|+    }
+|  83|  74| 
+|  84|    |-	bool inRootDirectory();
+|  85|    |-	bool isParentDirectory(const MPD::Item &item);
+|  86|    |-	const std::string &currentDirectory();
+|  87|    |-	
+|  88|    |-	bool isLocal() { return m_local_browser; }
+|  89|    |-	void locateSong(const MPD::Song &s);
+|  90|    |-	bool enterDirectory();
+|  91|    |-	void getDirectory(std::string directory);
+|  92|    |-	void changeBrowseMode();
+|  93|    |-	void remove(const MPD::Item &item);
+|    |  75|+    virtual void
+|    |  76|+    update ()
+|    |  77|+        override;
+|  94|  78| 
+|  95|    |-	static void fetchSupportedExtensions();
+|    |  79|+    virtual void
+|    |  80|+    mouseButtonPressed (MEVENT me)
+|    |  81|+        override;
+|  96|  82| 
+|  97|    |-private:
+|  98|    |-	bool m_update_request;
+|  99|    |-	bool m_local_browser;
+| 100|    |-	size_t m_scroll_beginning;
+| 101|    |-	std::string m_current_directory;
+| 102|    |-	Regex::Filter<MPD::Item> m_search_predicate;
+|    |  83|+    virtual bool
+|    |  84|+    isLockable ()
+|    |  85|+        override
+|    |  86|+    {
+|    |  87|+        return true;
+|    |  88|+    }
+|    |  89|+    virtual bool
+|    |  90|+    isMergable ()
+|    |  91|+        override
+|    |  92|+    {
+|    |  93|+        return true;
+|    |  94|+    }
+|    |  95|+
+|    |  96|+    // Searchable implementation
+|    |  97|+    virtual bool
+|    |  98|+    allowsSearching ()
+|    |  99|+        override;
+|    | 100|+    virtual const
+|    | 101|+        std::string &
+|    | 102|+    searchConstraint ()
+|    | 103|+        override;
+|    | 104|+    virtual void
+|    | 105|+    setSearchConstraint (const std::string & constraint)
+|    | 106|+        override;
+|    | 107|+    virtual void
+|    | 108|+    clearSearchConstraint ()
+|    | 109|+        override;
+|    | 110|+    virtual bool
+|    | 111|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 112|+        override;
+|    | 113|+
+|    | 114|+    // Filterable implemenetation
+|    | 115|+    virtual bool
+|    | 116|+    allowsFiltering ()
+|    | 117|+        override;
+|    | 118|+    virtual
+|    | 119|+        std::string
+|    | 120|+    currentFilter ()
+|    | 121|+        override;
+|    | 122|+    virtual void
+|    | 123|+    applyFilter (const std::string & filter)
+|    | 124|+        override;
+|    | 125|+
+|    | 126|+    // HasSongs implementation
+|    | 127|+    virtual bool
+|    | 128|+    itemAvailable ()
+|    | 129|+        override;
+|    | 130|+    virtual bool
+|    | 131|+    addItemToPlaylist (bool play)
+|    | 132|+        override;
+|    | 133|+    virtual
+|    | 134|+        std::vector <
+|    | 135|+        MPD::Song >
+|    | 136|+    getSelectedSongs ()
+|    | 137|+        override;
+|    | 138|+
+|    | 139|+    // private members
+|    | 140|+    void
+|    | 141|+    requestUpdate ()
+|    | 142|+    {
+|    | 143|+        m_update_request = true;
+|    | 144|+    }
+|    | 145|+
+|    | 146|+    bool
+|    | 147|+    inRootDirectory ();
+|    | 148|+    bool
+|    | 149|+    isParentDirectory (const MPD::Item & item);
+|    | 150|+    const
+|    | 151|+        std::string &
+|    | 152|+    currentDirectory ();
+|    | 153|+
+|    | 154|+    bool
+|    | 155|+    isLocal ()
+|    | 156|+    {
+|    | 157|+        return m_local_browser;
+|    | 158|+    }
+|    | 159|+    void
+|    | 160|+    locateSong (const MPD::Song & s);
+|    | 161|+    bool
+|    | 162|+    enterDirectory ();
+|    | 163|+    void
+|    | 164|+    getDirectory (std::string directory);
+|    | 165|+    void
+|    | 166|+    changeBrowseMode ();
+|    | 167|+    void
+|    | 168|+    remove (const MPD::Item & item);
+|    | 169|+
+|    | 170|+    static void
+|    | 171|+    fetchSupportedExtensions ();
+|    | 172|+
+|    | 173|+  private:
+|    | 174|+    bool m_update_request;
+|    | 175|+    bool
+|    | 176|+        m_local_browser;
+|    | 177|+    size_t
+|    | 178|+        m_scroll_beginning;
+|    | 179|+    std::string m_current_directory;
+|    | 180|+    Regex::Filter < MPD::Item > m_search_predicate;
+| 103| 181| };
+| 104| 182| 
+| 105| 183| extern Browser *myBrowser;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/browser.h
+|    |++++| /app/src/screens/browser.h
+| 102| 102| 	Regex::Filter<MPD::Item> m_search_predicate;
+| 103| 103| };
+| 104| 104| 
+| 105|    |-extern Browser *myBrowser;
+|    | 105|+extern Browser *
+|    | 106|+    myBrowser;
+| 106| 107| 
+| 107| 108| #endif // NCMPCPP_BROWSER_H
+| 108| 109| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/browser.h
+|    |++++| /app/src/screens/browser.h
+| 105| 105| extern Browser *myBrowser;
+| 106| 106| 
+| 107| 107| #endif // NCMPCPP_BROWSER_H
+| 108|    |-
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/display.h
+|    |++++| /app/src/display.h
+|  28|  28| #include "screens/search_engine.h"
+|  29|  29| #include "song_list.h"
+|  30|  30| 
+|  31|    |-namespace Display {
+|    |  31|+namespace Display
+|    |  32|+{
+|  32|  33| 
+|  33|    |-std::string Columns(size_t);
+|    |  34|+    std::string Columns (size_t);
+|  34|  35| 
+|  35|    |-void SongsInColumns(NC::Menu<MPD::Song> &menu, const SongList &list);
+|    |  36|+    void SongsInColumns (NC::Menu < MPD::Song > &menu, const SongList & list);
+|  36|  37| 
+|  37|    |-void Songs(NC::Menu<MPD::Song> &menu, const SongList &list, const Format::AST<char> &ast);
+|    |  38|+    void Songs (NC::Menu < MPD::Song > &menu, const SongList & list,
+|    |  39|+                const Format::AST < char >&ast);
+|  38|  40| 
+|  39|    |-void Tags(NC::Menu<MPD::MutableSong> &menu);
+|    |  41|+    void Tags (NC::Menu < MPD::MutableSong > &menu);
+|  40|  42| 
+|  41|    |-void SEItems(NC::Menu<SEItem> &menu, const SongList &list);
+|    |  43|+    void SEItems (NC::Menu < SEItem > &menu, const SongList & list);
+|  42|  44| 
+|  43|    |-void Items(NC::Menu<MPD::Item> &menu, const SongList &list);
+|    |  45|+    void Items (NC::Menu < MPD::Item > &menu, const SongList & list);
+|  44|  46| 
+|  45|  47| }
+|  46|  48| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/display.h
+|    |++++| /app/src/display.h
+|  44|  44| 
+|  45|  45| }
+|  46|  46| 
+|  47|    |-#endif // NCMPCPP_DISPLAY_H
+|  48|    |-
+|    |  47|+#endif                          // NCMPCPP_DISPLAY_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/actions.h
+|    |++++| /app/src/actions.h
+|  31|  31| // forward declarations
+|  32|  32| struct SongList;
+|  33|  33| 
+|  34|    |-namespace Actions {
+|  35|    |-
+|  36|    |-enum class Type
+|  37|    |-{
+|  38|    |-	MacroUtility = -1,
+|  39|    |-	Dummy,
+|  40|    |-	UpdateEnvironment,
+|  41|    |-	MouseEvent,
+|  42|    |-	ScrollUp,
+|  43|    |-	ScrollDown,
+|  44|    |-	ScrollUpArtist,
+|  45|    |-	ScrollUpAlbum,
+|  46|    |-	ScrollDownArtist,
+|  47|    |-	ScrollDownAlbum,
+|  48|    |-	PageUp,
+|  49|    |-	PageDown,
+|  50|    |-	MoveHome,
+|  51|    |-	MoveEnd,
+|  52|    |-	ToggleInterface,
+|  53|    |-	JumpToParentDirectory,
+|  54|    |-	RunAction,
+|  55|    |-	PreviousColumn,
+|  56|    |-	NextColumn,
+|  57|    |-	MasterScreen,
+|  58|    |-	SlaveScreen,
+|  59|    |-	VolumeUp,
+|  60|    |-	VolumeDown,
+|  61|    |-	AddItemToPlaylist,
+|  62|    |-	PlayItem,
+|  63|    |-	DeletePlaylistItems,
+|  64|    |-	DeleteStoredPlaylist,
+|  65|    |-	DeleteBrowserItems,
+|  66|    |-	ReplaySong,
+|  67|    |-	Previous,
+|  68|    |-	Next,
+|  69|    |-	Pause,
+|  70|    |-	Stop,
+|  71|    |-	ExecuteCommand,
+|  72|    |-	SavePlaylist,
+|  73|    |-	MoveSortOrderUp,
+|  74|    |-	MoveSortOrderDown,
+|  75|    |-	MoveSelectedItemsUp,
+|  76|    |-	MoveSelectedItemsDown,
+|  77|    |-	MoveSelectedItemsTo,
+|  78|    |-	Add,
+|  79|    |-	SeekForward,
+|  80|    |-	SeekBackward,
+|  81|    |-	ToggleDisplayMode,
+|  82|    |-	ToggleSeparatorsBetweenAlbums,
+|  83|    |-	ToggleLyricsUpdateOnSongChange,
+|  84|    |-	ToggleLyricsFetcher,
+|  85|    |-	ToggleFetchingLyricsInBackground,
+|  86|    |-	TogglePlayingSongCentering,
+|  87|    |-	UpdateDatabase,
+|  88|    |-	JumpToPlayingSong,
+|  89|    |-	ToggleRepeat,
+|  90|    |-	Shuffle,
+|  91|    |-	ToggleRandom,
+|  92|    |-	StartSearching,
+|  93|    |-	SaveTagChanges,
+|  94|    |-	ToggleSingle,
+|  95|    |-	ToggleConsume,
+|  96|    |-	ToggleCrossfade,
+|  97|    |-	SetCrossfade,
+|  98|    |-	SetVolume,
+|  99|    |-	EnterDirectory,
+| 100|    |-	EditSong,
+| 101|    |-	EditLibraryTag,
+| 102|    |-	EditLibraryAlbum,
+| 103|    |-	EditDirectoryName,
+| 104|    |-	EditPlaylistName,
+| 105|    |-	EditLyrics,
+| 106|    |-	JumpToBrowser,
+| 107|    |-	JumpToMediaLibrary,
+| 108|    |-	JumpToPlaylistEditor,
+| 109|    |-	ToggleScreenLock,
+| 110|    |-	JumpToTagEditor,
+| 111|    |-	JumpToPositionInSong,
+| 112|    |-	SelectItem,
+| 113|    |-	SelectRange,
+| 114|    |-	ReverseSelection,
+| 115|    |-	RemoveSelection,
+| 116|    |-	SelectAlbum,
+| 117|    |-	SelectFoundItems,
+| 118|    |-	AddSelectedItems,
+| 119|    |-	CropMainPlaylist,
+| 120|    |-	CropPlaylist,
+| 121|    |-	ClearMainPlaylist,
+| 122|    |-	ClearPlaylist,
+| 123|    |-	SortPlaylist,
+| 124|    |-	ReversePlaylist,
+| 125|    |-	ApplyFilter,
+| 126|    |-	Find,
+| 127|    |-	FindItemForward,
+| 128|    |-	FindItemBackward,
+| 129|    |-	NextFoundItem,
+| 130|    |-	PreviousFoundItem,
+| 131|    |-	ToggleFindMode,
+| 132|    |-	ToggleReplayGainMode,
+| 133|    |-	ToggleAddMode,
+| 134|    |-	ToggleMouse,
+| 135|    |-	ToggleBitrateVisibility,
+| 136|    |-	AddRandomItems,
+| 137|    |-	ToggleBrowserSortMode,
+| 138|    |-	ToggleLibraryTagType,
+| 139|    |-	ToggleMediaLibrarySortMode,
+| 140|    |-	FetchLyricsInBackground,
+| 141|    |-	RefetchLyrics,
+| 142|    |-	SetSelectedItemsPriority,
+| 143|    |-	ToggleOutput,
+| 144|    |-	ToggleVisualizationType,
+| 145|    |-	ShowSongInfo,
+| 146|    |-	ShowArtistInfo,
+| 147|    |-	ShowLyrics,
+| 148|    |-	Quit,
+| 149|    |-	NextScreen,
+| 150|    |-	PreviousScreen,
+| 151|    |-	ShowHelp,
+| 152|    |-	ShowPlaylist,
+| 153|    |-	ShowBrowser,
+| 154|    |-	ChangeBrowseMode,
+| 155|    |-	ShowSearchEngine,
+| 156|    |-	ResetSearchEngine,
+| 157|    |-	ShowMediaLibrary,
+| 158|    |-	ToggleMediaLibraryColumnsMode,
+| 159|    |-	ShowPlaylistEditor,
+| 160|    |-	ShowTagEditor,
+| 161|    |-	ShowOutputs,
+| 162|    |-	ShowVisualizer,
+| 163|    |-	ShowClock,
+| 164|    |-	ShowServerInfo,
+| 165|    |-	_numberOfActions // needed to dynamically calculate size of action array
+| 166|    |-};
+| 167|    |-
+| 168|    |-void validateScreenSize();
+| 169|    |-void initializeScreens();
+| 170|    |-void setResizeFlags();
+| 171|    |-void resizeScreen(bool reload_main_window);
+| 172|    |-void setWindowsDimensions();
+| 173|    |-
+| 174|    |-void confirmAction(const boost::format &description);
+| 175|    |-inline void confirmAction(const std::string &description)
+| 176|    |-{
+| 177|    |-	confirmAction(boost::format(description));
+|    |  34|+namespace Actions
+|    |  35|+{
+|    |  36|+
+|    |  37|+    enum class Type
+|    |  38|+    {
+|    |  39|+        MacroUtility = -1,
+|    |  40|+        Dummy,
+|    |  41|+        UpdateEnvironment,
+|    |  42|+        MouseEvent,
+|    |  43|+        ScrollUp,
+|    |  44|+        ScrollDown,
+|    |  45|+        ScrollUpArtist,
+|    |  46|+        ScrollUpAlbum,
+|    |  47|+        ScrollDownArtist,
+|    |  48|+        ScrollDownAlbum,
+|    |  49|+        PageUp,
+|    |  50|+        PageDown,
+|    |  51|+        MoveHome,
+|    |  52|+        MoveEnd,
+|    |  53|+        ToggleInterface,
+|    |  54|+        JumpToParentDirectory,
+|    |  55|+        RunAction,
+|    |  56|+        PreviousColumn,
+|    |  57|+        NextColumn,
+|    |  58|+        MasterScreen,
+|    |  59|+        SlaveScreen,
+|    |  60|+        VolumeUp,
+|    |  61|+        VolumeDown,
+|    |  62|+        AddItemToPlaylist,
+|    |  63|+        PlayItem,
+|    |  64|+        DeletePlaylistItems,
+|    |  65|+        DeleteStoredPlaylist,
+|    |  66|+        DeleteBrowserItems,
+|    |  67|+        ReplaySong,
+|    |  68|+        Previous,
+|    |  69|+        Next,
+|    |  70|+        Pause,
+|    |  71|+        Stop,
+|    |  72|+        ExecuteCommand,
+|    |  73|+        SavePlaylist,
+|    |  74|+        MoveSortOrderUp,
+|    |  75|+        MoveSortOrderDown,
+|    |  76|+        MoveSelectedItemsUp,
+|    |  77|+        MoveSelectedItemsDown,
+|    |  78|+        MoveSelectedItemsTo,
+|    |  79|+        Add,
+|    |  80|+        SeekForward,
+|    |  81|+        SeekBackward,
+|    |  82|+        ToggleDisplayMode,
+|    |  83|+        ToggleSeparatorsBetweenAlbums,
+|    |  84|+        ToggleLyricsUpdateOnSongChange,
+|    |  85|+        ToggleLyricsFetcher,
+|    |  86|+        ToggleFetchingLyricsInBackground,
+|    |  87|+        TogglePlayingSongCentering,
+|    |  88|+        UpdateDatabase,
+|    |  89|+        JumpToPlayingSong,
+|    |  90|+        ToggleRepeat,
+|    |  91|+        Shuffle,
+|    |  92|+        ToggleRandom,
+|    |  93|+        StartSearching,
+|    |  94|+        SaveTagChanges,
+|    |  95|+        ToggleSingle,
+|    |  96|+        ToggleConsume,
+|    |  97|+        ToggleCrossfade,
+|    |  98|+        SetCrossfade,
+|    |  99|+        SetVolume,
+|    | 100|+        EnterDirectory,
+|    | 101|+        EditSong,
+|    | 102|+        EditLibraryTag,
+|    | 103|+        EditLibraryAlbum,
+|    | 104|+        EditDirectoryName,
+|    | 105|+        EditPlaylistName,
+|    | 106|+        EditLyrics,
+|    | 107|+        JumpToBrowser,
+|    | 108|+        JumpToMediaLibrary,
+|    | 109|+        JumpToPlaylistEditor,
+|    | 110|+        ToggleScreenLock,
+|    | 111|+        JumpToTagEditor,
+|    | 112|+        JumpToPositionInSong,
+|    | 113|+        SelectItem,
+|    | 114|+        SelectRange,
+|    | 115|+        ReverseSelection,
+|    | 116|+        RemoveSelection,
+|    | 117|+        SelectAlbum,
+|    | 118|+        SelectFoundItems,
+|    | 119|+        AddSelectedItems,
+|    | 120|+        CropMainPlaylist,
+|    | 121|+        CropPlaylist,
+|    | 122|+        ClearMainPlaylist,
+|    | 123|+        ClearPlaylist,
+|    | 124|+        SortPlaylist,
+|    | 125|+        ReversePlaylist,
+|    | 126|+        ApplyFilter,
+|    | 127|+        Find,
+|    | 128|+        FindItemForward,
+|    | 129|+        FindItemBackward,
+|    | 130|+        NextFoundItem,
+|    | 131|+        PreviousFoundItem,
+|    | 132|+        ToggleFindMode,
+|    | 133|+        ToggleReplayGainMode,
+|    | 134|+        ToggleAddMode,
+|    | 135|+        ToggleMouse,
+|    | 136|+        ToggleBitrateVisibility,
+|    | 137|+        AddRandomItems,
+|    | 138|+        ToggleBrowserSortMode,
+|    | 139|+        ToggleLibraryTagType,
+|    | 140|+        ToggleMediaLibrarySortMode,
+|    | 141|+        FetchLyricsInBackground,
+|    | 142|+        RefetchLyrics,
+|    | 143|+        SetSelectedItemsPriority,
+|    | 144|+        ToggleOutput,
+|    | 145|+        ToggleVisualizationType,
+|    | 146|+        ShowSongInfo,
+|    | 147|+        ShowArtistInfo,
+|    | 148|+        ShowLyrics,
+|    | 149|+        Quit,
+|    | 150|+        NextScreen,
+|    | 151|+        PreviousScreen,
+|    | 152|+        ShowHelp,
+|    | 153|+        ShowPlaylist,
+|    | 154|+        ShowBrowser,
+|    | 155|+        ChangeBrowseMode,
+|    | 156|+        ShowSearchEngine,
+|    | 157|+        ResetSearchEngine,
+|    | 158|+        ShowMediaLibrary,
+|    | 159|+        ToggleMediaLibraryColumnsMode,
+|    | 160|+        ShowPlaylistEditor,
+|    | 161|+        ShowTagEditor,
+|    | 162|+        ShowOutputs,
+|    | 163|+        ShowVisualizer,
+|    | 164|+        ShowClock,
+|    | 165|+        ShowServerInfo,
+|    | 166|+        _numberOfActions        // needed to dynamically calculate size of action array
+|    | 167|+    };
+|    | 168|+
+|    | 169|+    void validateScreenSize ();
+|    | 170|+    void initializeScreens ();
+|    | 171|+    void setResizeFlags ();
+|    | 172|+    void resizeScreen (bool reload_main_window);
+|    | 173|+    void setWindowsDimensions ();
+|    | 174|+
+|    | 175|+    void confirmAction (const boost::format & description);
+|    | 176|+    inline void confirmAction (const std::string & description)
+|    | 177|+    {
+|    | 178|+        confirmAction (boost::format (description));
+|    | 179|+    }
+|    | 180|+
+|    | 181|+    bool isMPDMusicDirSet ();
+|    | 182|+
+|    | 183|+    extern bool OriginalStatusbarVisibility;
+|    | 184|+    extern bool ExitMainLoop;
+|    | 185|+
+|    | 186|+    extern size_t HeaderHeight;
+|    | 187|+    extern size_t FooterHeight;
+|    | 188|+    extern size_t FooterStartY;
+|    | 189|+
+|    | 190|+    struct BaseAction
+|    | 191|+    {
+|    | 192|+        BaseAction (Type type_, const char *name_):m_name (name_),
+|    | 193|+            m_type (type_)
+|    | 194|+        {
+|    | 195|+        }
+|    | 196|+
+|    | 197|+        virtual ~ BaseAction ()
+|    | 198|+        {
+|    | 199|+        }
+|    | 200|+
+|    | 201|+        const std::string & name () const
+|    | 202|+        {
+|    | 203|+            return m_name;
+|    | 204|+        }
+|    | 205|+        Type type () const
+|    | 206|+        {
+|    | 207|+            return m_type;
+|    | 208|+        }
+|    | 209|+
+|    | 210|+        virtual bool canBeRun ()
+|    | 211|+        {
+|    | 212|+            return true;
+|    | 213|+        }
+|    | 214|+
+|    | 215|+        bool execute ()
+|    | 216|+        {
+|    | 217|+            if (canBeRun ())
+|    | 218|+              {
+|    | 219|+                  run ();
+|    | 220|+                  return true;
+|    | 221|+              }
+|    | 222|+            return false;
+|    | 223|+        }
+|    | 224|+
+|    | 225|+      protected:
+|    | 226|+        std::string m_name;
+|    | 227|+
+|    | 228|+      private:
+|    | 229|+        virtual void run () = 0;
+|    | 230|+
+|    | 231|+        Type m_type;
+|    | 232|+    };
+|    | 233|+
+|    | 234|+    BaseAction & get (Type at);
+|    | 235|+
+|    | 236|+    std::shared_ptr < BaseAction > get_ (Type at);
+|    | 237|+    std::shared_ptr < BaseAction > get_ (const std::string & name);
+|    | 238|+
+|    | 239|+    struct Dummy:BaseAction
+|    | 240|+    {
+|    | 241|+        Dummy ():BaseAction (Type::Dummy, "dummy")
+|    | 242|+        {
+|    | 243|+        }
+|    | 244|+
+|    | 245|+      private:
+|    | 246|+          virtual void run () override
+|    | 247|+        {
+|    | 248|+        }
+|    | 249|+    };
+|    | 250|+
+|    | 251|+    struct UpdateEnvironment:BaseAction
+|    | 252|+    {
+|    | 253|+        UpdateEnvironment ();
+|    | 254|+
+|    | 255|+        void run (bool update_status, bool refresh_window, bool mpd_sync);
+|    | 256|+
+|    | 257|+      private:
+|    | 258|+          boost::posix_time::ptime m_past;
+|    | 259|+
+|    | 260|+        virtual void run () override;
+|    | 261|+    };
+|    | 262|+
+|    | 263|+    struct MouseEvent:BaseAction
+|    | 264|+    {
+|    | 265|+        MouseEvent ():BaseAction (Type::MouseEvent, "mouse_event")
+|    | 266|+        {
+|    | 267|+            m_old_mouse_event.bstate = 0;
+|    | 268|+            m_mouse_event.bstate = 0;
+|    | 269|+        }
+|    | 270|+
+|    | 271|+      private:
+|    | 272|+          virtual bool canBeRun () override;
+|    | 273|+        virtual void run () override;
+|    | 274|+
+|    | 275|+        MEVENT m_mouse_event;
+|    | 276|+        MEVENT m_old_mouse_event;
+|    | 277|+    };
+|    | 278|+
+|    | 279|+    struct ScrollUp:BaseAction
+|    | 280|+    {
+|    | 281|+        ScrollUp ():BaseAction (Type::ScrollUp, "scroll_up")
+|    | 282|+        {
+|    | 283|+        }
+|    | 284|+
+|    | 285|+      private:
+|    | 286|+          virtual void run () override;
+|    | 287|+    };
+|    | 288|+
+|    | 289|+    struct ScrollDown:BaseAction
+|    | 290|+    {
+|    | 291|+        ScrollDown ():BaseAction (Type::ScrollDown, "scroll_down")
+|    | 292|+        {
+|    | 293|+        }
+|    | 294|+
+|    | 295|+      private:
+|    | 296|+          virtual void run () override;
+|    | 297|+    };
+|    | 298|+
+|    | 299|+    struct ScrollUpArtist:BaseAction
+|    | 300|+    {
+|    | 301|+        ScrollUpArtist ():BaseAction (Type::ScrollUpArtist, "scroll_up_artist")
+|    | 302|+        {
+|    | 303|+        }
+|    | 304|+
+|    | 305|+      private:
+|    | 306|+          virtual bool canBeRun () override;
+|    | 307|+        virtual void run () override;
+|    | 308|+
+|    | 309|+        NC::List * m_list;
+|    | 310|+        const SongList *m_songs;
+|    | 311|+    };
+|    | 312|+
+|    | 313|+    struct ScrollUpAlbum:BaseAction
+|    | 314|+    {
+|    | 315|+        ScrollUpAlbum ():BaseAction (Type::ScrollUpAlbum, "scroll_up_album")
+|    | 316|+        {
+|    | 317|+        }
+|    | 318|+
+|    | 319|+      private:
+|    | 320|+          virtual bool canBeRun () override;
+|    | 321|+        virtual void run () override;
+|    | 322|+
+|    | 323|+        NC::List * m_list;
+|    | 324|+        const SongList *m_songs;
+|    | 325|+    };
+|    | 326|+
+|    | 327|+    struct ScrollDownArtist:BaseAction
+|    | 328|+    {
+|    | 329|+        ScrollDownArtist ():BaseAction (Type::ScrollDownArtist,
+|    | 330|+                                        "scroll_down_artist")
+|    | 331|+        {
+|    | 332|+        }
+|    | 333|+
+|    | 334|+      private:
+|    | 335|+          virtual bool canBeRun () override;
+|    | 336|+        virtual void run () override;
+|    | 337|+
+|    | 338|+        NC::List * m_list;
+|    | 339|+        const SongList *m_songs;
+|    | 340|+    };
+|    | 341|+
+|    | 342|+    struct ScrollDownAlbum:BaseAction
+|    | 343|+    {
+|    | 344|+        ScrollDownAlbum ():BaseAction (Type::ScrollDownAlbum,
+|    | 345|+                                       "scroll_down_album")
+|    | 346|+        {
+|    | 347|+        }
+|    | 348|+
+|    | 349|+      private:
+|    | 350|+          virtual bool canBeRun () override;
+|    | 351|+        virtual void run () override;
+|    | 352|+
+|    | 353|+        NC::List * m_list;
+|    | 354|+        const SongList *m_songs;
+|    | 355|+    };
+|    | 356|+
+|    | 357|+    struct PageUp:BaseAction
+|    | 358|+    {
+|    | 359|+        PageUp ():BaseAction (Type::PageUp, "page_up")
+|    | 360|+        {
+|    | 361|+        }
+|    | 362|+
+|    | 363|+      private:
+|    | 364|+          virtual void run () override;
+|    | 365|+    };
+|    | 366|+
+|    | 367|+    struct PageDown:BaseAction
+|    | 368|+    {
+|    | 369|+        PageDown ():BaseAction (Type::PageDown, "page_down")
+|    | 370|+        {
+|    | 371|+        }
+|    | 372|+
+|    | 373|+      private:
+|    | 374|+          virtual void run () override;
+|    | 375|+    };
+|    | 376|+
+|    | 377|+    struct MoveHome:BaseAction
+|    | 378|+    {
+|    | 379|+        MoveHome ():BaseAction (Type::MoveHome, "move_home")
+|    | 380|+        {
+|    | 381|+        }
+|    | 382|+
+|    | 383|+      private:
+|    | 384|+          virtual void run () override;
+|    | 385|+    };
+|    | 386|+
+|    | 387|+    struct MoveEnd:BaseAction
+|    | 388|+    {
+|    | 389|+        MoveEnd ():BaseAction (Type::MoveEnd, "move_end")
+|    | 390|+        {
+|    | 391|+        }
+|    | 392|+
+|    | 393|+      private:
+|    | 394|+          virtual void run () override;
+|    | 395|+    };
+|    | 396|+
+|    | 397|+    struct ToggleInterface:BaseAction
+|    | 398|+    {
+|    | 399|+        ToggleInterface ():BaseAction (Type::ToggleInterface,
+|    | 400|+                                       "toggle_interface")
+|    | 401|+        {
+|    | 402|+        }
+|    | 403|+
+|    | 404|+      private:
+|    | 405|+          virtual void run () override;
+|    | 406|+    };
+|    | 407|+
+|    | 408|+    struct JumpToParentDirectory:BaseAction
+|    | 409|+    {
+|    | 410|+        JumpToParentDirectory ():BaseAction (Type::JumpToParentDirectory,
+|    | 411|+                                             "jump_to_parent_directory")
+|    | 412|+        {
+|    | 413|+        }
+|    | 414|+
+|    | 415|+      private:
+|    | 416|+          virtual bool canBeRun () override;
+|    | 417|+        virtual void run () override;
+|    | 418|+    };
+|    | 419|+
+|    | 420|+    struct RunAction:BaseAction
+|    | 421|+    {
+|    | 422|+        RunAction ():BaseAction (Type::RunAction, "run_action")
+|    | 423|+        {
+|    | 424|+        }
+|    | 425|+
+|    | 426|+      private:
+|    | 427|+          virtual bool canBeRun () override;
+|    | 428|+        virtual void run () override;
+|    | 429|+
+|    | 430|+        HasActions *m_ha;
+|    | 431|+    };
+|    | 432|+
+|    | 433|+    struct PreviousColumn:BaseAction
+|    | 434|+    {
+|    | 435|+        PreviousColumn ():BaseAction (Type::PreviousColumn, "previous_column")
+|    | 436|+        {
+|    | 437|+        }
+|    | 438|+
+|    | 439|+      private:
+|    | 440|+          virtual bool canBeRun () override;
+|    | 441|+        virtual void run () override;
+|    | 442|+
+|    | 443|+        HasColumns *m_hc;
+|    | 444|+    };
+|    | 445|+
+|    | 446|+    struct NextColumn:BaseAction
+|    | 447|+    {
+|    | 448|+        NextColumn ():BaseAction (Type::NextColumn, "next_column")
+|    | 449|+        {
+|    | 450|+        }
+|    | 451|+
+|    | 452|+      private:
+|    | 453|+          virtual bool canBeRun () override;
+|    | 454|+        virtual void run () override;
+|    | 455|+
+|    | 456|+        HasColumns *m_hc;
+|    | 457|+    };
+|    | 458|+
+|    | 459|+    struct MasterScreen:BaseAction
+|    | 460|+    {
+|    | 461|+        MasterScreen ():BaseAction (Type::MasterScreen, "master_screen")
+|    | 462|+        {
+|    | 463|+        }
+|    | 464|+
+|    | 465|+      private:
+|    | 466|+          virtual bool canBeRun () override;
+|    | 467|+        virtual void run () override;
+|    | 468|+    };
+|    | 469|+
+|    | 470|+    struct SlaveScreen:BaseAction
+|    | 471|+    {
+|    | 472|+        SlaveScreen ():BaseAction (Type::SlaveScreen, "slave_screen")
+|    | 473|+        {
+|    | 474|+        }
+|    | 475|+
+|    | 476|+      private:
+|    | 477|+          virtual bool canBeRun () override;
+|    | 478|+        virtual void run () override;
+|    | 479|+    };
+|    | 480|+
+|    | 481|+    struct VolumeUp:BaseAction
+|    | 482|+    {
+|    | 483|+        VolumeUp ():BaseAction (Type::VolumeUp, "volume_up")
+|    | 484|+        {
+|    | 485|+        }
+|    | 486|+
+|    | 487|+      private:
+|    | 488|+          virtual void run () override;
+|    | 489|+    };
+|    | 490|+
+|    | 491|+    struct VolumeDown:BaseAction
+|    | 492|+    {
+|    | 493|+        VolumeDown ():BaseAction (Type::VolumeDown, "volume_down")
+|    | 494|+        {
+|    | 495|+        }
+|    | 496|+
+|    | 497|+      private:
+|    | 498|+          virtual void run () override;
+|    | 499|+    };
+|    | 500|+
+|    | 501|+    struct AddItemToPlaylist:BaseAction
+|    | 502|+    {
+|    | 503|+        AddItemToPlaylist ():BaseAction (Type::AddItemToPlaylist,
+|    | 504|+                                         "add_item_to_playlist")
+|    | 505|+        {
+|    | 506|+        }
+|    | 507|+
+|    | 508|+      private:
+|    | 509|+          virtual bool canBeRun () override;
+|    | 510|+        virtual void run () override;
+|    | 511|+
+|    | 512|+        HasSongs *m_hs;
+|    | 513|+    };
+|    | 514|+
+|    | 515|+    struct PlayItem:BaseAction
+|    | 516|+    {
+|    | 517|+        PlayItem ():BaseAction (Type::PlayItem, "play_item")
+|    | 518|+        {
+|    | 519|+        }
+|    | 520|+
+|    | 521|+      private:
+|    | 522|+          virtual bool canBeRun () override;
+|    | 523|+        virtual void run () override;
+|    | 524|+
+|    | 525|+        HasSongs *m_hs;
+|    | 526|+    };
+|    | 527|+
+|    | 528|+    struct DeletePlaylistItems:BaseAction
+|    | 529|+    {
+|    | 530|+        DeletePlaylistItems ():BaseAction (Type::DeletePlaylistItems,
+|    | 531|+                                           "delete_playlist_items")
+|    | 532|+        {
+|    | 533|+        }
+|    | 534|+
+|    | 535|+      private:
+|    | 536|+          virtual bool canBeRun () override;
+|    | 537|+        virtual void run () override;
+|    | 538|+    };
+|    | 539|+
+|    | 540|+    struct DeleteStoredPlaylist:BaseAction
+|    | 541|+    {
+|    | 542|+        DeleteStoredPlaylist ():BaseAction (Type::DeleteStoredPlaylist,
+|    | 543|+                                            "delete_stored_playlist")
+|    | 544|+        {
+|    | 545|+        }
+|    | 546|+
+|    | 547|+      private:
+|    | 548|+          virtual bool canBeRun () override;
+|    | 549|+        virtual void run () override;
+|    | 550|+    };
+|    | 551|+
+|    | 552|+    struct DeleteBrowserItems:BaseAction
+|    | 553|+    {
+|    | 554|+        DeleteBrowserItems ():BaseAction (Type::DeleteBrowserItems,
+|    | 555|+                                          "delete_browser_items")
+|    | 556|+        {
+|    | 557|+        }
+|    | 558|+
+|    | 559|+      private:
+|    | 560|+          virtual bool canBeRun () override;
+|    | 561|+        virtual void run () override;
+|    | 562|+    };
+|    | 563|+
+|    | 564|+    struct ReplaySong:BaseAction
+|    | 565|+    {
+|    | 566|+        ReplaySong ():BaseAction (Type::ReplaySong, "replay_song")
+|    | 567|+        {
+|    | 568|+        }
+|    | 569|+
+|    | 570|+      private:
+|    | 571|+          virtual void run () override;
+|    | 572|+    };
+|    | 573|+
+|    | 574|+    struct PreviousSong:BaseAction
+|    | 575|+    {
+|    | 576|+        PreviousSong ():BaseAction (Type::Previous, "previous")
+|    | 577|+        {
+|    | 578|+        }
+|    | 579|+
+|    | 580|+      private:
+|    | 581|+          virtual void run () override;
+|    | 582|+    };
+|    | 583|+
+|    | 584|+    struct NextSong:BaseAction
+|    | 585|+    {
+|    | 586|+        NextSong ():BaseAction (Type::Next, "next")
+|    | 587|+        {
+|    | 588|+        }
+|    | 589|+
+|    | 590|+      private:
+|    | 591|+          virtual void run () override;
+|    | 592|+    };
+|    | 593|+
+|    | 594|+    struct Pause:BaseAction
+|    | 595|+    {
+|    | 596|+        Pause ():BaseAction (Type::Pause, "pause")
+|    | 597|+        {
+|    | 598|+        }
+|    | 599|+
+|    | 600|+      private:
+|    | 601|+          virtual void run () override;
+|    | 602|+    };
+|    | 603|+
+|    | 604|+    struct Stop:BaseAction
+|    | 605|+    {
+|    | 606|+        Stop ():BaseAction (Type::Stop, "stop")
+|    | 607|+        {
+|    | 608|+        }
+|    | 609|+
+|    | 610|+      private:
+|    | 611|+          virtual void run () override;
+|    | 612|+    };
+|    | 613|+
+|    | 614|+    struct ExecuteCommand:BaseAction
+|    | 615|+    {
+|    | 616|+        ExecuteCommand ():BaseAction (Type::ExecuteCommand, "execute_command")
+|    | 617|+        {
+|    | 618|+        }
+|    | 619|+
+|    | 620|+      private:
+|    | 621|+          virtual void run () override;
+|    | 622|+    };
+|    | 623|+
+|    | 624|+    struct SavePlaylist:BaseAction
+|    | 625|+    {
+|    | 626|+        SavePlaylist ():BaseAction (Type::SavePlaylist, "save_playlist")
+|    | 627|+        {
+|    | 628|+        }
+|    | 629|+
+|    | 630|+      private:
+|    | 631|+          virtual void run () override;
+|    | 632|+    };
+|    | 633|+
+|    | 634|+    struct MoveSortOrderUp:BaseAction
+|    | 635|+    {
+|    | 636|+        MoveSortOrderUp ():BaseAction (Type::MoveSortOrderUp,
+|    | 637|+                                       "move_sort_order_up")
+|    | 638|+        {
+|    | 639|+        }
+|    | 640|+
+|    | 641|+      private:
+|    | 642|+          virtual bool canBeRun () override;
+|    | 643|+        virtual void run () override;
+|    | 644|+    };
+|    | 645|+
+|    | 646|+    struct MoveSortOrderDown:BaseAction
+|    | 647|+    {
+|    | 648|+        MoveSortOrderDown ():BaseAction (Type::MoveSortOrderDown,
+|    | 649|+                                         "move_sort_order_down")
+|    | 650|+        {
+|    | 651|+        }
+|    | 652|+
+|    | 653|+      private:
+|    | 654|+          virtual bool canBeRun () override;
+|    | 655|+        virtual void run () override;
+|    | 656|+    };
+|    | 657|+
+|    | 658|+    struct MoveSelectedItemsUp:BaseAction
+|    | 659|+    {
+|    | 660|+        MoveSelectedItemsUp ():BaseAction (Type::MoveSelectedItemsUp,
+|    | 661|+                                           "move_selected_items_up")
+|    | 662|+        {
+|    | 663|+        }
+|    | 664|+
+|    | 665|+      private:
+|    | 666|+          virtual bool canBeRun () override;
+|    | 667|+        virtual void run () override;
+|    | 668|+    };
+|    | 669|+
+|    | 670|+    struct MoveSelectedItemsDown:BaseAction
+|    | 671|+    {
+|    | 672|+        MoveSelectedItemsDown ():BaseAction (Type::MoveSelectedItemsDown,
+|    | 673|+                                             "move_selected_items_down")
+|    | 674|+        {
+|    | 675|+        }
+|    | 676|+
+|    | 677|+      private:
+|    | 678|+          virtual bool canBeRun () override;
+|    | 679|+        virtual void run () override;
+|    | 680|+    };
+|    | 681|+
+|    | 682|+    struct MoveSelectedItemsTo:BaseAction
+|    | 683|+    {
+|    | 684|+        MoveSelectedItemsTo ():BaseAction (Type::MoveSelectedItemsTo,
+|    | 685|+                                           "move_selected_items_to")
+|    | 686|+        {
+|    | 687|+        }
+|    | 688|+
+|    | 689|+      private:
+|    | 690|+          virtual bool canBeRun () override;
+|    | 691|+        virtual void run () override;
+|    | 692|+    };
+|    | 693|+
+|    | 694|+    struct Add:BaseAction
+|    | 695|+    {
+|    | 696|+        Add ():BaseAction (Type::Add, "add")
+|    | 697|+        {
+|    | 698|+        }
+|    | 699|+
+|    | 700|+      private:
+|    | 701|+          virtual bool canBeRun () override;
+|    | 702|+        virtual void run () override;
+|    | 703|+    };
+|    | 704|+
+|    | 705|+    struct SeekForward:BaseAction
+|    | 706|+    {
+|    | 707|+        SeekForward ():BaseAction (Type::SeekForward, "seek_forward")
+|    | 708|+        {
+|    | 709|+        }
+|    | 710|+
+|    | 711|+      private:
+|    | 712|+          virtual bool canBeRun () override;
+|    | 713|+        virtual void run () override;
+|    | 714|+    };
+|    | 715|+
+|    | 716|+    struct SeekBackward:BaseAction
+|    | 717|+    {
+|    | 718|+        SeekBackward ():BaseAction (Type::SeekBackward, "seek_backward")
+|    | 719|+        {
+|    | 720|+        }
+|    | 721|+
+|    | 722|+      private:
+|    | 723|+          virtual bool canBeRun () override;
+|    | 724|+        virtual void run () override;
+|    | 725|+    };
+|    | 726|+
+|    | 727|+    struct ToggleDisplayMode:BaseAction
+|    | 728|+    {
+|    | 729|+        ToggleDisplayMode ():BaseAction (Type::ToggleDisplayMode,
+|    | 730|+                                         "toggle_display_mode")
+|    | 731|+        {
+|    | 732|+        }
+|    | 733|+
+|    | 734|+      private:
+|    | 735|+          virtual bool canBeRun () override;
+|    | 736|+        virtual void run () override;
+|    | 737|+    };
+|    | 738|+
+|    | 739|+    struct ToggleSeparatorsBetweenAlbums:BaseAction
+|    | 740|+    {
+|    | 741|+        ToggleSeparatorsBetweenAlbums ():BaseAction (Type::
+|    | 742|+                                                     ToggleSeparatorsBetweenAlbums,
+|    | 743|+                                                     "toggle_separators_between_albums")
+|    | 744|+        {
+|    | 745|+        }
+|    | 746|+
+|    | 747|+      private:
+|    | 748|+          virtual bool canBeRun () override;
+|    | 749|+        virtual void run () override;
+|    | 750|+    };
+|    | 751|+
+|    | 752|+    struct ToggleLyricsUpdateOnSongChange:BaseAction
+|    | 753|+    {
+|    | 754|+        ToggleLyricsUpdateOnSongChange ():BaseAction (Type::
+|    | 755|+                                                      ToggleLyricsUpdateOnSongChange,
+|    | 756|+                                                      "toggle_lyrics_update_on_song_change")
+|    | 757|+        {
+|    | 758|+        }
+|    | 759|+
+|    | 760|+      private:
+|    | 761|+          virtual bool canBeRun () override;
+|    | 762|+        virtual void run () override;
+|    | 763|+    };
+|    | 764|+
+|    | 765|+    struct ToggleLyricsFetcher:BaseAction
+|    | 766|+    {
+|    | 767|+        ToggleLyricsFetcher ():BaseAction (Type::ToggleLyricsFetcher,
+|    | 768|+                                           "toggle_lyrics_fetcher")
+|    | 769|+        {
+|    | 770|+        }
+|    | 771|+
+|    | 772|+      private:
+|    | 773|+          virtual void run () override;
+|    | 774|+    };
+|    | 775|+
+|    | 776|+    struct ToggleFetchingLyricsInBackground:BaseAction
+|    | 777|+    {
+|    | 778|+        ToggleFetchingLyricsInBackground ():BaseAction (Type::
+|    | 779|+                                                        ToggleFetchingLyricsInBackground,
+|    | 780|+                                                        "toggle_fetching_lyrics_in_background")
+|    | 781|+        {
+|    | 782|+        }
+|    | 783|+
+|    | 784|+      private:
+|    | 785|+          virtual void run () override;
+|    | 786|+    };
+|    | 787|+
+|    | 788|+    struct TogglePlayingSongCentering:BaseAction
+|    | 789|+    {
+|    | 790|+        TogglePlayingSongCentering ():BaseAction (Type::
+|    | 791|+                                                  TogglePlayingSongCentering,
+|    | 792|+                                                  "toggle_playing_song_centering")
+|    | 793|+        {
+|    | 794|+        }
+|    | 795|+
+|    | 796|+      private:
+|    | 797|+          virtual void run () override;
+|    | 798|+    };
+|    | 799|+
+|    | 800|+    struct UpdateDatabase:BaseAction
+|    | 801|+    {
+|    | 802|+        UpdateDatabase ():BaseAction (Type::UpdateDatabase, "update_database")
+|    | 803|+        {
+|    | 804|+        }
+|    | 805|+
+|    | 806|+      private:
+|    | 807|+          virtual void run () override;
+|    | 808|+    };
+|    | 809|+
+|    | 810|+    struct JumpToPlayingSong:BaseAction
+|    | 811|+    {
+|    | 812|+        JumpToPlayingSong ():BaseAction (Type::JumpToPlayingSong,
+|    | 813|+                                         "jump_to_playing_song")
+|    | 814|+        {
+|    | 815|+        }
+|    | 816|+
+|    | 817|+      private:
+|    | 818|+          virtual bool canBeRun () override;
+|    | 819|+        virtual void run () override;
+|    | 820|+
+|    | 821|+        MPD::Song m_song;
+|    | 822|+    };
+|    | 823|+
+|    | 824|+    struct ToggleRepeat:BaseAction
+|    | 825|+    {
+|    | 826|+        ToggleRepeat ():BaseAction (Type::ToggleRepeat, "toggle_repeat")
+|    | 827|+        {
+|    | 828|+        }
+|    | 829|+
+|    | 830|+      private:
+|    | 831|+          virtual void run () override;
+|    | 832|+    };
+|    | 833|+
+|    | 834|+    struct Shuffle:BaseAction
+|    | 835|+    {
+|    | 836|+        Shuffle ():BaseAction (Type::Shuffle, "shuffle")
+|    | 837|+        {
+|    | 838|+        }
+|    | 839|+
+|    | 840|+      private:
+|    | 841|+          virtual bool canBeRun () override;
+|    | 842|+        virtual void run () override;
+|    | 843|+
+|    | 844|+        NC::Menu < MPD::Song >::ConstIterator m_begin;
+|    | 845|+        NC::Menu < MPD::Song >::ConstIterator m_end;
+|    | 846|+    };
+|    | 847|+
+|    | 848|+    struct ToggleRandom:BaseAction
+|    | 849|+    {
+|    | 850|+        ToggleRandom ():BaseAction (Type::ToggleRandom, "toggle_random")
+|    | 851|+        {
+|    | 852|+        }
+|    | 853|+
+|    | 854|+      private:
+|    | 855|+          virtual void run () override;
+|    | 856|+    };
+|    | 857|+
+|    | 858|+    struct StartSearching:BaseAction
+|    | 859|+    {
+|    | 860|+        StartSearching ():BaseAction (Type::StartSearching, "start_searching")
+|    | 861|+        {
+|    | 862|+        }
+|    | 863|+
+|    | 864|+      private:
+|    | 865|+          virtual bool canBeRun () override;
+|    | 866|+        virtual void run () override;
+|    | 867|+    };
+|    | 868|+
+|    | 869|+    struct SaveTagChanges:BaseAction
+|    | 870|+    {
+|    | 871|+        SaveTagChanges ():BaseAction (Type::SaveTagChanges, "save_tag_changes")
+|    | 872|+        {
+|    | 873|+        }
+|    | 874|+
+|    | 875|+      private:
+|    | 876|+          virtual bool canBeRun () override;
+|    | 877|+        virtual void run () override;
+|    | 878|+    };
+|    | 879|+
+|    | 880|+    struct ToggleSingle:BaseAction
+|    | 881|+    {
+|    | 882|+        ToggleSingle ():BaseAction (Type::ToggleSingle, "toggle_single")
+|    | 883|+        {
+|    | 884|+        }
+|    | 885|+
+|    | 886|+      private:
+|    | 887|+          virtual void run () override;
+|    | 888|+    };
+|    | 889|+
+|    | 890|+    struct ToggleConsume:BaseAction
+|    | 891|+    {
+|    | 892|+        ToggleConsume ():BaseAction (Type::ToggleConsume, "toggle_consume")
+|    | 893|+        {
+|    | 894|+        }
+|    | 895|+
+|    | 896|+      private:
+|    | 897|+          virtual void run () override;
+|    | 898|+    };
+|    | 899|+
+|    | 900|+    struct ToggleCrossfade:BaseAction
+|    | 901|+    {
+|    | 902|+        ToggleCrossfade ():BaseAction (Type::ToggleCrossfade,
+|    | 903|+                                       "toggle_crossfade")
+|    | 904|+        {
+|    | 905|+        }
+|    | 906|+
+|    | 907|+      private:
+|    | 908|+          virtual void run () override;
+|    | 909|+    };
+|    | 910|+
+|    | 911|+    struct SetCrossfade:BaseAction
+|    | 912|+    {
+|    | 913|+        SetCrossfade ():BaseAction (Type::SetCrossfade, "set_crossfade")
+|    | 914|+        {
+|    | 915|+        }
+|    | 916|+
+|    | 917|+      private:
+|    | 918|+          virtual void run () override;
+|    | 919|+    };
+|    | 920|+
+|    | 921|+    struct SetVolume:BaseAction
+|    | 922|+    {
+|    | 923|+        SetVolume ():BaseAction (Type::SetVolume, "set_volume")
+|    | 924|+        {
+|    | 925|+        }
+|    | 926|+
+|    | 927|+      private:
+|    | 928|+          virtual void run () override;
+|    | 929|+    };
+|    | 930|+
+|    | 931|+    struct EnterDirectory:BaseAction
+|    | 932|+    {
+|    | 933|+        EnterDirectory ():BaseAction (Type::EnterDirectory, "enter_directory")
+|    | 934|+        {
+|    | 935|+        }
+|    | 936|+
+|    | 937|+      private:
+|    | 938|+          virtual bool canBeRun () override;
+|    | 939|+        virtual void run () override;
+|    | 940|+    };
+|    | 941|+
+|    | 942|+    struct EditSong:BaseAction
+|    | 943|+    {
+|    | 944|+        EditSong ():BaseAction (Type::EditSong, "edit_song")
+|    | 945|+        {
+|    | 946|+        }
+|    | 947|+
+|    | 948|+      private:
+|    | 949|+          virtual bool canBeRun () override;
+|    | 950|+        virtual void run () override;
+|    | 951|+
+|    | 952|+#ifdef HAVE_TAGLIB_H
+|    | 953|+        const MPD::Song * m_song;
+|    | 954|+#endif // HAVE_TAGLIB_H
+|    | 955|+    };
+|    | 956|+
+|    | 957|+    struct EditLibraryTag:BaseAction
+|    | 958|+    {
+|    | 959|+        EditLibraryTag ():BaseAction (Type::EditLibraryTag, "edit_library_tag")
+|    | 960|+        {
+|    | 961|+        }
+|    | 962|+
+|    | 963|+      private:
+|    | 964|+          virtual bool canBeRun () override;
+|    | 965|+        virtual void run () override;
+|    | 966|+    };
+|    | 967|+
+|    | 968|+    struct EditLibraryAlbum:BaseAction
+|    | 969|+    {
+|    | 970|+        EditLibraryAlbum ():BaseAction (Type::EditLibraryAlbum,
+|    | 971|+                                        "edit_library_album")
+|    | 972|+        {
+|    | 973|+        }
+|    | 974|+
+|    | 975|+      private:
+|    | 976|+          virtual bool canBeRun () override;
+|    | 977|+        virtual void run () override;
+|    | 978|+    };
+|    | 979|+
+|    | 980|+    struct EditDirectoryName:BaseAction
+|    | 981|+    {
+|    | 982|+        EditDirectoryName ():BaseAction (Type::EditDirectoryName,
+|    | 983|+                                         "edit_directory_name")
+|    | 984|+        {
+|    | 985|+        }
+|    | 986|+
+|    | 987|+      private:
+|    | 988|+          virtual bool canBeRun () override;
+|    | 989|+        virtual void run () override;
+|    | 990|+    };
+|    | 991|+
+|    | 992|+    struct EditPlaylistName:BaseAction
+|    | 993|+    {
+|    | 994|+        EditPlaylistName ():BaseAction (Type::EditPlaylistName,
+|    | 995|+                                        "edit_playlist_name")
+|    | 996|+        {
+|    | 997|+        }
+|    | 998|+
+|    | 999|+      private:
+|    |1000|+          virtual bool canBeRun () override;
+|    |1001|+        virtual void run () override;
+|    |1002|+    };
+|    |1003|+
+|    |1004|+    struct EditLyrics:BaseAction
+|    |1005|+    {
+|    |1006|+        EditLyrics ():BaseAction (Type::EditLyrics, "edit_lyrics")
+|    |1007|+        {
+|    |1008|+        }
+|    |1009|+
+|    |1010|+      private:
+|    |1011|+          virtual bool canBeRun () override;
+|    |1012|+        virtual void run () override;
+|    |1013|+    };
+|    |1014|+
+|    |1015|+    struct JumpToBrowser:BaseAction
+|    |1016|+    {
+|    |1017|+        JumpToBrowser ():BaseAction (Type::JumpToBrowser, "jump_to_browser")
+|    |1018|+        {
+|    |1019|+        }
+|    |1020|+
+|    |1021|+      private:
+|    |1022|+          virtual bool canBeRun () override;
+|    |1023|+        virtual void run () override;
+|    |1024|+
+|    |1025|+        const MPD::Song * m_song;
+|    |1026|+    };
+|    |1027|+
+|    |1028|+    struct JumpToMediaLibrary:BaseAction
+|    |1029|+    {
+|    |1030|+        JumpToMediaLibrary ():BaseAction (Type::JumpToMediaLibrary,
+|    |1031|+                                          "jump_to_media_library")
+|    |1032|+        {
+|    |1033|+        }
+|    |1034|+
+|    |1035|+      private:
+|    |1036|+          virtual bool canBeRun () override;
+|    |1037|+        virtual void run () override;
+|    |1038|+
+|    |1039|+        const MPD::Song * m_song;
+|    |1040|+    };
+|    |1041|+
+|    |1042|+    struct JumpToPlaylistEditor:BaseAction
+|    |1043|+    {
+|    |1044|+        JumpToPlaylistEditor ():BaseAction (Type::JumpToPlaylistEditor,
+|    |1045|+                                            "jump_to_playlist_editor")
+|    |1046|+        {
+|    |1047|+        }
+|    |1048|+
+|    |1049|+      private:
+|    |1050|+          virtual bool canBeRun () override;
+|    |1051|+        virtual void run () override;
+|    |1052|+    };
+|    |1053|+
+|    |1054|+    struct ToggleScreenLock:BaseAction
+|    |1055|+    {
+|    |1056|+        ToggleScreenLock ():BaseAction (Type::ToggleScreenLock,
+|    |1057|+                                        "toggle_screen_lock")
+|    |1058|+        {
+|    |1059|+        }
+|    |1060|+
+|    |1061|+      private:
+|    |1062|+          virtual void run () override;
+|    |1063|+    };
+|    |1064|+
+|    |1065|+    struct JumpToTagEditor:BaseAction
+|    |1066|+    {
+|    |1067|+        JumpToTagEditor ():BaseAction (Type::JumpToTagEditor,
+|    |1068|+                                       "jump_to_tag_editor")
+|    |1069|+        {
+|    |1070|+        }
+|    |1071|+
+|    |1072|+      private:
+|    |1073|+          virtual bool canBeRun () override;
+|    |1074|+        virtual void run () override;
+|    |1075|+
+|    |1076|+#ifdef HAVE_TAGLIB_H
+|    |1077|+        const MPD::Song * m_song;
+|    |1078|+#endif // HAVE_TAGLIB_H
+|    |1079|+    };
+|    |1080|+
+|    |1081|+    struct JumpToPositionInSong:BaseAction
+|    |1082|+    {
+|    |1083|+        JumpToPositionInSong ():BaseAction (Type::JumpToPositionInSong,
+|    |1084|+                                            "jump_to_position_in_song")
+|    |1085|+        {
+|    |1086|+        }
+|    |1087|+
+|    |1088|+      private:
+|    |1089|+          virtual bool canBeRun () override;
+|    |1090|+        virtual void run () override;
+|    |1091|+    };
+|    |1092|+
+|    |1093|+    struct SelectItem:BaseAction
+|    |1094|+    {
+|    |1095|+        SelectItem ():BaseAction (Type::SelectItem, "select_item")
+|    |1096|+        {
+|    |1097|+        }
+|    |1098|+
+|    |1099|+      private:
+|    |1100|+          virtual bool canBeRun () override;
+|    |1101|+        virtual void run () override;
+|    |1102|+
+|    |1103|+        NC::List * m_list;
+|    |1104|+    };
+|    |1105|+
+|    |1106|+    struct SelectRange:BaseAction
+|    |1107|+    {
+|    |1108|+        SelectRange ():BaseAction (Type::SelectRange, "select_range")
+|    |1109|+        {
+|    |1110|+        }
+|    |1111|+
+|    |1112|+      private:
+|    |1113|+          virtual bool canBeRun () override;
+|    |1114|+        virtual void run () override;
+|    |1115|+
+|    |1116|+        NC::List * m_list;
+|    |1117|+        NC::List::Iterator m_begin;
+|    |1118|+        NC::List::Iterator m_end;
+|    |1119|+    };
+|    |1120|+
+|    |1121|+    struct ReverseSelection:BaseAction
+|    |1122|+    {
+|    |1123|+        ReverseSelection ():BaseAction (Type::ReverseSelection,
+|    |1124|+                                        "reverse_selection")
+|    |1125|+        {
+|    |1126|+        }
+|    |1127|+
+|    |1128|+      private:
+|    |1129|+          virtual bool canBeRun () override;
+|    |1130|+        virtual void run () override;
+|    |1131|+
+|    |1132|+        NC::List * m_list;
+|    |1133|+    };
+|    |1134|+
+|    |1135|+    struct RemoveSelection:BaseAction
+|    |1136|+    {
+|    |1137|+        RemoveSelection ():BaseAction (Type::RemoveSelection,
+|    |1138|+                                       "remove_selection")
+|    |1139|+        {
+|    |1140|+        }
+|    |1141|+
+|    |1142|+      private:
+|    |1143|+          virtual bool canBeRun () override;
+|    |1144|+        virtual void run () override;
+|    |1145|+
+|    |1146|+        NC::List * m_list;
+|    |1147|+    };
+|    |1148|+
+|    |1149|+    struct SelectAlbum:BaseAction
+|    |1150|+    {
+|    |1151|+        SelectAlbum ():BaseAction (Type::SelectAlbum, "select_album")
+|    |1152|+        {
+|    |1153|+        }
+|    |1154|+
+|    |1155|+      private:
+|    |1156|+          virtual bool canBeRun () override;
+|    |1157|+        virtual void run () override;
+|    |1158|+
+|    |1159|+        NC::List * m_list;
+|    |1160|+        SongList *m_songs;
+|    |1161|+    };
+|    |1162|+
+|    |1163|+    struct SelectFoundItems:BaseAction
+|    |1164|+    {
+|    |1165|+        SelectFoundItems ():BaseAction (Type::SelectFoundItems,
+|    |1166|+                                        "select_found_items")
+|    |1167|+        {
+|    |1168|+        }
+|    |1169|+
+|    |1170|+      private:
+|    |1171|+          virtual bool canBeRun () override;
+|    |1172|+        virtual void run () override;
+|    |1173|+
+|    |1174|+        NC::List * m_list;
+|    |1175|+        Searchable *m_searchable;
+|    |1176|+    };
+|    |1177|+
+|    |1178|+    struct AddSelectedItems:BaseAction
+|    |1179|+    {
+|    |1180|+        AddSelectedItems ():BaseAction (Type::AddSelectedItems,
+|    |1181|+                                        "add_selected_items")
+|    |1182|+        {
+|    |1183|+        }
+|    |1184|+
+|    |1185|+      private:
+|    |1186|+          virtual bool canBeRun () override;
+|    |1187|+        virtual void run () override;
+|    |1188|+    };
+|    |1189|+
+|    |1190|+    struct CropMainPlaylist:BaseAction
+|    |1191|+    {
+|    |1192|+        CropMainPlaylist ():BaseAction (Type::CropMainPlaylist,
+|    |1193|+                                        "crop_main_playlist")
+|    |1194|+        {
+|    |1195|+        }
+|    |1196|+
+|    |1197|+      private:
+|    |1198|+          virtual void run () override;
+|    |1199|+    };
+|    |1200|+
+|    |1201|+    struct CropPlaylist:BaseAction
+|    |1202|+    {
+|    |1203|+        CropPlaylist ():BaseAction (Type::CropPlaylist, "crop_playlist")
+|    |1204|+        {
+|    |1205|+        }
+|    |1206|+
+|    |1207|+      private:
+|    |1208|+          virtual bool canBeRun () override;
+|    |1209|+        virtual void run () override;
+|    |1210|+    };
+|    |1211|+
+|    |1212|+    struct ClearMainPlaylist:BaseAction
+|    |1213|+    {
+|    |1214|+        ClearMainPlaylist ():BaseAction (Type::ClearMainPlaylist,
+|    |1215|+                                         "clear_main_playlist")
+|    |1216|+        {
+|    |1217|+        }
+|    |1218|+
+|    |1219|+      private:
+|    |1220|+          virtual void run () override;
+|    |1221|+    };
+|    |1222|+
+|    |1223|+    struct ClearPlaylist:BaseAction
+|    |1224|+    {
+|    |1225|+        ClearPlaylist ():BaseAction (Type::ClearPlaylist, "clear_playlist")
+|    |1226|+        {
+|    |1227|+        }
+|    |1228|+
+|    |1229|+      private:
+|    |1230|+          virtual bool canBeRun () override;
+|    |1231|+        virtual void run () override;
+|    |1232|+    };
+|    |1233|+
+|    |1234|+    struct SortPlaylist:BaseAction
+|    |1235|+    {
+|    |1236|+        SortPlaylist ():BaseAction (Type::SortPlaylist, "sort_playlist")
+|    |1237|+        {
+|    |1238|+        }
+|    |1239|+
+|    |1240|+      private:
+|    |1241|+          virtual bool canBeRun () override;
+|    |1242|+        virtual void run () override;
+|    |1243|+    };
+|    |1244|+
+|    |1245|+    struct ReversePlaylist:BaseAction
+|    |1246|+    {
+|    |1247|+        ReversePlaylist ():BaseAction (Type::ReversePlaylist,
+|    |1248|+                                       "reverse_playlist")
+|    |1249|+        {
+|    |1250|+        }
+|    |1251|+
+|    |1252|+      private:
+|    |1253|+          virtual bool canBeRun () override;
+|    |1254|+        virtual void run () override;
+|    |1255|+
+|    |1256|+        NC::Menu < MPD::Song >::ConstIterator m_begin;
+|    |1257|+        NC::Menu < MPD::Song >::ConstIterator m_end;
+|    |1258|+    };
+|    |1259|+
+|    |1260|+    struct ApplyFilter:public BaseAction
+|    |1261|+    {
+|    |1262|+        ApplyFilter ():BaseAction (Type::ApplyFilter, "apply_filter")
+|    |1263|+        {
+|    |1264|+        }
+|    |1265|+
+|    |1266|+      private:
+|    |1267|+          virtual bool canBeRun () override;
+|    |1268|+        virtual void run () override;
+|    |1269|+
+|    |1270|+        Filterable *m_filterable;
+|    |1271|+    };
+|    |1272|+
+|    |1273|+    struct Find:BaseAction
+|    |1274|+    {
+|    |1275|+        Find ():BaseAction (Type::Find, "find")
+|    |1276|+        {
+|    |1277|+        }
+|    |1278|+
+|    |1279|+      private:
+|    |1280|+          virtual bool canBeRun () override;
+|    |1281|+        virtual void run () override;
+|    |1282|+    };
+|    |1283|+
+|    |1284|+    struct FindItemForward:BaseAction
+|    |1285|+    {
+|    |1286|+        FindItemForward ():BaseAction (Type::FindItemForward,
+|    |1287|+                                       "find_item_forward")
+|    |1288|+        {
+|    |1289|+        }
+|    |1290|+
+|    |1291|+      private:
+|    |1292|+          virtual bool canBeRun () override;
+|    |1293|+        virtual void run () override;
+|    |1294|+    };
+|    |1295|+
+|    |1296|+    struct FindItemBackward:BaseAction
+|    |1297|+    {
+|    |1298|+        FindItemBackward ():BaseAction (Type::FindItemBackward,
+|    |1299|+                                        "find_item_backward")
+|    |1300|+        {
+|    |1301|+        }
+|    |1302|+
+|    |1303|+      private:
+|    |1304|+          virtual bool canBeRun () override;
+|    |1305|+        virtual void run () override;
+|    |1306|+    };
+|    |1307|+
+|    |1308|+    struct NextFoundItem:BaseAction
+|    |1309|+    {
+|    |1310|+        NextFoundItem ():BaseAction (Type::NextFoundItem, "next_found_item")
+|    |1311|+        {
+|    |1312|+        }
+|    |1313|+
+|    |1314|+      private:
+|    |1315|+          virtual bool canBeRun () override;
+|    |1316|+        virtual void run () override;
+|    |1317|+    };
+|    |1318|+
+|    |1319|+    struct PreviousFoundItem:BaseAction
+|    |1320|+    {
+|    |1321|+        PreviousFoundItem ():BaseAction (Type::PreviousFoundItem,
+|    |1322|+                                         "previous_found_item")
+|    |1323|+        {
+|    |1324|+        }
+|    |1325|+
+|    |1326|+      private:
+|    |1327|+          virtual bool canBeRun () override;
+|    |1328|+        virtual void run () override;
+|    |1329|+    };
+|    |1330|+
+|    |1331|+    struct ToggleFindMode:BaseAction
+|    |1332|+    {
+|    |1333|+        ToggleFindMode ():BaseAction (Type::ToggleFindMode, "toggle_find_mode")
+|    |1334|+        {
+|    |1335|+        }
+|    |1336|+
+|    |1337|+      private:
+|    |1338|+          virtual void run () override;
+|    |1339|+    };
+|    |1340|+
+|    |1341|+    struct ToggleReplayGainMode:BaseAction
+|    |1342|+    {
+|    |1343|+        ToggleReplayGainMode ():BaseAction (Type::ToggleReplayGainMode,
+|    |1344|+                                            "toggle_replay_gain_mode")
+|    |1345|+        {
+|    |1346|+        }
+|    |1347|+
+|    |1348|+      private:
+|    |1349|+          virtual void run () override;
+|    |1350|+    };
+|    |1351|+
+|    |1352|+    struct ToggleAddMode:BaseAction
+|    |1353|+    {
+|    |1354|+        ToggleAddMode ():BaseAction (Type::ToggleAddMode, "toggle_add_mode")
+|    |1355|+        {
+|    |1356|+        }
+|    |1357|+
+|    |1358|+      private:
+|    |1359|+          virtual void run () override;
+|    |1360|+    };
+|    |1361|+
+|    |1362|+    struct ToggleMouse:BaseAction
+|    |1363|+    {
+|    |1364|+        ToggleMouse ():BaseAction (Type::ToggleMouse, "toggle_mouse")
+|    |1365|+        {
+|    |1366|+        }
+|    |1367|+
+|    |1368|+      private:
+|    |1369|+          virtual void run () override;
+|    |1370|+    };
+|    |1371|+
+|    |1372|+    struct ToggleBitrateVisibility:BaseAction
+|    |1373|+    {
+|    |1374|+        ToggleBitrateVisibility ():BaseAction (Type::ToggleBitrateVisibility,
+|    |1375|+                                               "toggle_bitrate_visibility")
+|    |1376|+        {
+|    |1377|+        }
+|    |1378|+
+|    |1379|+      private:
+|    |1380|+          virtual void run () override;
+|    |1381|+    };
+|    |1382|+
+|    |1383|+    struct AddRandomItems:BaseAction
+|    |1384|+    {
+|    |1385|+        AddRandomItems ():BaseAction (Type::AddRandomItems, "add_random_items")
+|    |1386|+        {
+|    |1387|+        }
+|    |1388|+
+|    |1389|+      private:
+|    |1390|+          virtual void run () override;
+|    |1391|+    };
+|    |1392|+
+|    |1393|+    struct ToggleBrowserSortMode:BaseAction
+|    |1394|+    {
+|    |1395|+        ToggleBrowserSortMode ():BaseAction (Type::ToggleBrowserSortMode,
+|    |1396|+                                             "toggle_browser_sort_mode")
+|    |1397|+        {
+|    |1398|+        }
+|    |1399|+
+|    |1400|+      private:
+|    |1401|+          virtual bool canBeRun () override;
+|    |1402|+        virtual void run () override;
+|    |1403|+    };
+|    |1404|+
+|    |1405|+    struct ToggleLibraryTagType:BaseAction
+|    |1406|+    {
+|    |1407|+        ToggleLibraryTagType ():BaseAction (Type::ToggleLibraryTagType,
+|    |1408|+                                            "toggle_library_tag_type")
+|    |1409|+        {
+|    |1410|+        }
+|    |1411|+
+|    |1412|+      private:
+|    |1413|+          virtual bool canBeRun () override;
+|    |1414|+        virtual void run () override;
+|    |1415|+    };
+|    |1416|+
+|    |1417|+    struct ToggleMediaLibrarySortMode:BaseAction
+|    |1418|+    {
+|    |1419|+        ToggleMediaLibrarySortMode ():BaseAction (Type::
+|    |1420|+                                                  ToggleMediaLibrarySortMode,
+|    |1421|+                                                  "toggle_media_library_sort_mode")
+|    |1422|+        {
+|    |1423|+        }
+|    |1424|+
+|    |1425|+      private:
+|    |1426|+          virtual bool canBeRun () override;
+|    |1427|+        virtual void run () override;
+|    |1428|+    };
+|    |1429|+
+|    |1430|+    struct FetchLyricsInBackground:BaseAction
+|    |1431|+    {
+|    |1432|+        FetchLyricsInBackground ():BaseAction (Type::FetchLyricsInBackground,
+|    |1433|+                                               "fetch_lyrics_in_background")
+|    |1434|+        {
+|    |1435|+        }
+|    |1436|+
+|    |1437|+      private:
+|    |1438|+          virtual bool canBeRun () override;
+|    |1439|+        virtual void run () override;
+|    |1440|+
+|    |1441|+        HasSongs *m_hs;
+|    |1442|+    };
+|    |1443|+
+|    |1444|+    struct RefetchLyrics:BaseAction
+|    |1445|+    {
+|    |1446|+        RefetchLyrics ():BaseAction (Type::RefetchLyrics, "refetch_lyrics")
+|    |1447|+        {
+|    |1448|+        }
+|    |1449|+
+|    |1450|+      private:
+|    |1451|+          virtual bool canBeRun () override;
+|    |1452|+        virtual void run () override;
+|    |1453|+    };
+|    |1454|+
+|    |1455|+    struct SetSelectedItemsPriority:BaseAction
+|    |1456|+    {
+|    |1457|+        SetSelectedItemsPriority ():BaseAction (Type::SetSelectedItemsPriority,
+|    |1458|+                                                "set_selected_items_priority")
+|    |1459|+        {
+|    |1460|+        }
+|    |1461|+
+|    |1462|+      private:
+|    |1463|+          virtual bool canBeRun () override;
+|    |1464|+        virtual void run () override;
+|    |1465|+    };
+|    |1466|+
+|    |1467|+    struct ToggleOutput:BaseAction
+|    |1468|+    {
+|    |1469|+        ToggleOutput ():BaseAction (Type::ToggleOutput, "toggle_output")
+|    |1470|+        {
+|    |1471|+        }
+|    |1472|+
+|    |1473|+      private:
+|    |1474|+          virtual bool canBeRun () override;
+|    |1475|+        virtual void run () override;
+|    |1476|+    };
+|    |1477|+
+|    |1478|+    struct ToggleVisualizationType:BaseAction
+|    |1479|+    {
+|    |1480|+        ToggleVisualizationType ():BaseAction (Type::ToggleVisualizationType,
+|    |1481|+                                               "toggle_visualization_type")
+|    |1482|+        {
+|    |1483|+        }
+|    |1484|+
+|    |1485|+      private:
+|    |1486|+
+|    |1487|+          virtual bool canBeRun () override;
+|    |1488|+        virtual void run () override;
+|    |1489|+    };
+|    |1490|+
+|    |1491|+    struct ShowSongInfo:BaseAction
+|    |1492|+    {
+|    |1493|+        ShowSongInfo ():BaseAction (Type::ShowSongInfo, "show_song_info")
+|    |1494|+        {
+|    |1495|+        }
+|    |1496|+
+|    |1497|+      private:
+|    |1498|+          virtual void run () override;
+|    |1499|+    };
+|    |1500|+
+|    |1501|+    struct ShowArtistInfo:BaseAction
+|    |1502|+    {
+|    |1503|+        ShowArtistInfo ():BaseAction (Type::ShowArtistInfo, "show_artist_info")
+|    |1504|+        {
+|    |1505|+        }
+|    |1506|+
+|    |1507|+      private:
+|    |1508|+          virtual bool canBeRun () override;
+|    |1509|+        virtual void run () override;
+|    |1510|+    };
+|    |1511|+
+|    |1512|+    struct ShowLyrics:BaseAction
+|    |1513|+    {
+|    |1514|+        ShowLyrics ():BaseAction (Type::ShowLyrics, "show_lyrics")
+|    |1515|+        {
+|    |1516|+        }
+|    |1517|+
+|    |1518|+      private:
+|    |1519|+          virtual bool canBeRun () override;
+|    |1520|+        virtual void run () override;
+|    |1521|+
+|    |1522|+        const MPD::Song * m_song;
+|    |1523|+    };
+|    |1524|+
+|    |1525|+    struct Quit:BaseAction
+|    |1526|+    {
+|    |1527|+        Quit ():BaseAction (Type::Quit, "quit")
+|    |1528|+        {
+|    |1529|+        }
+|    |1530|+
+|    |1531|+      private:
+|    |1532|+          virtual void run () override;
+|    |1533|+    };
+|    |1534|+
+|    |1535|+    struct NextScreen:BaseAction
+|    |1536|+    {
+|    |1537|+        NextScreen ():BaseAction (Type::NextScreen, "next_screen")
+|    |1538|+        {
+|    |1539|+        }
+|    |1540|+
+|    |1541|+      private:
+|    |1542|+          virtual void run () override;
+|    |1543|+    };
+|    |1544|+
+|    |1545|+    struct PreviousScreen:BaseAction
+|    |1546|+    {
+|    |1547|+        PreviousScreen ():BaseAction (Type::PreviousScreen, "previous_screen")
+|    |1548|+        {
+|    |1549|+        }
+|    |1550|+
+|    |1551|+      private:
+|    |1552|+          virtual void run () override;
+|    |1553|+    };
+|    |1554|+
+|    |1555|+    struct ShowHelp:BaseAction
+|    |1556|+    {
+|    |1557|+        ShowHelp ():BaseAction (Type::ShowHelp, "show_help")
+|    |1558|+        {
+|    |1559|+        }
+|    |1560|+
+|    |1561|+      private:
+|    |1562|+          virtual bool canBeRun () override;
+|    |1563|+        virtual void run () override;
+|    |1564|+    };
+|    |1565|+
+|    |1566|+    struct ShowPlaylist:BaseAction
+|    |1567|+    {
+|    |1568|+        ShowPlaylist ():BaseAction (Type::ShowPlaylist, "show_playlist")
+|    |1569|+        {
+|    |1570|+        }
+|    |1571|+
+|    |1572|+      private:
+|    |1573|+          virtual bool canBeRun () override;
+|    |1574|+        virtual void run () override;
+|    |1575|+    };
+|    |1576|+
+|    |1577|+    struct ShowBrowser:BaseAction
+|    |1578|+    {
+|    |1579|+        ShowBrowser ():BaseAction (Type::ShowBrowser, "show_browser")
+|    |1580|+        {
+|    |1581|+        }
+|    |1582|+
+|    |1583|+      private:
+|    |1584|+          virtual bool canBeRun () override;
+|    |1585|+        virtual void run () override;
+|    |1586|+    };
+|    |1587|+
+|    |1588|+    struct ChangeBrowseMode:BaseAction
+|    |1589|+    {
+|    |1590|+        ChangeBrowseMode ():BaseAction (Type::ChangeBrowseMode,
+|    |1591|+                                        "change_browse_mode")
+|    |1592|+        {
+|    |1593|+        }
+|    |1594|+
+|    |1595|+      private:
+|    |1596|+          virtual bool canBeRun () override;
+|    |1597|+        virtual void run () override;
+|    |1598|+    };
+|    |1599|+
+|    |1600|+    struct ShowSearchEngine:BaseAction
+|    |1601|+    {
+|    |1602|+        ShowSearchEngine ():BaseAction (Type::ShowSearchEngine,
+|    |1603|+                                        "show_search_engine")
+|    |1604|+        {
+|    |1605|+        }
+|    |1606|+
+|    |1607|+      private:
+|    |1608|+          virtual bool canBeRun () override;
+|    |1609|+        virtual void run () override;
+|    |1610|+    };
+|    |1611|+
+|    |1612|+    struct ResetSearchEngine:BaseAction
+|    |1613|+    {
+|    |1614|+        ResetSearchEngine ():BaseAction (Type::ResetSearchEngine,
+|    |1615|+                                         "reset_search_engine")
+|    |1616|+        {
+|    |1617|+        }
+|    |1618|+
+|    |1619|+      private:
+|    |1620|+          virtual bool canBeRun () override;
+|    |1621|+        virtual void run () override;
+|    |1622|+    };
+|    |1623|+
+|    |1624|+    struct ShowMediaLibrary:BaseAction
+|    |1625|+    {
+|    |1626|+        ShowMediaLibrary ():BaseAction (Type::ShowMediaLibrary,
+|    |1627|+                                        "show_media_library")
+|    |1628|+        {
+|    |1629|+        }
+|    |1630|+
+|    |1631|+      private:
+|    |1632|+          virtual bool canBeRun () override;
+|    |1633|+        virtual void run () override;
+|    |1634|+    };
+|    |1635|+
+|    |1636|+    struct ToggleMediaLibraryColumnsMode:BaseAction
+|    |1637|+    {
+|    |1638|+        ToggleMediaLibraryColumnsMode ():BaseAction (Type::
+|    |1639|+                                                     ToggleMediaLibraryColumnsMode,
+|    |1640|+                                                     "toggle_media_library_columns_mode")
+|    |1641|+        {
+|    |1642|+        }
+|    |1643|+
+|    |1644|+      private:
+|    |1645|+          virtual bool canBeRun () override;
+|    |1646|+        virtual void run () override;
+|    |1647|+    };
+|    |1648|+
+|    |1649|+    struct ShowPlaylistEditor:BaseAction
+|    |1650|+    {
+|    |1651|+        ShowPlaylistEditor ():BaseAction (Type::ShowPlaylistEditor,
+|    |1652|+                                          "show_playlist_editor")
+|    |1653|+        {
+|    |1654|+        }
+|    |1655|+
+|    |1656|+      private:
+|    |1657|+          virtual bool canBeRun () override;
+|    |1658|+        virtual void run () override;
+|    |1659|+    };
+|    |1660|+
+|    |1661|+    struct ShowTagEditor:BaseAction
+|    |1662|+    {
+|    |1663|+        ShowTagEditor ():BaseAction (Type::ShowTagEditor, "show_tag_editor")
+|    |1664|+        {
+|    |1665|+        }
+|    |1666|+
+|    |1667|+      private:
+|    |1668|+          virtual bool canBeRun () override;
+|    |1669|+        virtual void run () override;
+|    |1670|+    };
+|    |1671|+
+|    |1672|+    struct ShowOutputs:BaseAction
+|    |1673|+    {
+|    |1674|+        ShowOutputs ():BaseAction (Type::ShowOutputs, "show_outputs")
+|    |1675|+        {
+|    |1676|+        }
+|    |1677|+
+|    |1678|+      private:
+|    |1679|+          virtual bool canBeRun () override;
+|    |1680|+        virtual void run () override;
+|    |1681|+    };
+|    |1682|+
+|    |1683|+    struct ShowVisualizer:BaseAction
+|    |1684|+    {
+|    |1685|+        ShowVisualizer ():BaseAction (Type::ShowVisualizer, "show_visualizer")
+|    |1686|+        {
+|    |1687|+        }
+|    |1688|+
+|    |1689|+      private:
+|    |1690|+          virtual bool canBeRun () override;
+|    |1691|+        virtual void run () override;
+|    |1692|+    };
+|    |1693|+
+|    |1694|+    struct ShowClock:BaseAction
+|    |1695|+    {
+|    |1696|+        ShowClock ():BaseAction (Type::ShowClock, "show_clock")
+|    |1697|+        {
+|    |1698|+        }
+|    |1699|+
+|    |1700|+      private:
+|    |1701|+          virtual bool canBeRun () override;
+|    |1702|+        virtual void run () override;
+|    |1703|+    };
+|    |1704|+
+|    |1705|+    struct ShowServerInfo:BaseAction
+|    |1706|+    {
+|    |1707|+        ShowServerInfo ():BaseAction (Type::ShowServerInfo, "show_server_info")
+|    |1708|+        {
+|    |1709|+        }
+|    |1710|+
+|    |1711|+      private:
+|    |1712|+#	ifdef HAVE_TAGLIB_H
+|    |1713|+          virtual bool canBeRun () override;
+|    |1714|+#	endif // HAVE_TAGLIB_H
+|    |1715|+        virtual void run () override;
+|    |1716|+    };
+|    |1717|+
+| 178|1718| }
+| 179|1719| 
+| 180|1720| bool isMPDMusicDirSet();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/actions.h
+|    |++++| /app/src/actions.h
+| 177| 177| 	confirmAction(boost::format(description));
+| 178| 178| }
+| 179| 179| 
+| 180|    |-bool isMPDMusicDirSet();
+| 181|    |-
+| 182|    |-extern bool OriginalStatusbarVisibility;
+| 183|    |-extern bool ExitMainLoop;
+| 184|    |-
+| 185|    |-extern size_t HeaderHeight;
+| 186|    |-extern size_t FooterHeight;
+| 187|    |-extern size_t FooterStartY;
+| 188|    |-
+| 189|    |-struct BaseAction
+| 190|    |-{
+| 191|    |-	BaseAction(Type type_, const char *name_): m_name(name_), m_type(type_) { }
+| 192|    |-
+| 193|    |-	virtual ~BaseAction() { }
+| 194|    |-
+| 195|    |-	const std::string &name() const { return m_name; }
+| 196|    |-	Type type() const { return m_type; }
+| 197|    |-	
+| 198|    |-	virtual bool canBeRun() { return true; }
+| 199|    |-	
+| 200|    |-	bool execute()
+| 201|    |-	{
+| 202|    |-		if (canBeRun())
+| 203|    |-		{
+| 204|    |-			run();
+| 205|    |-			return true;
+| 206|    |-		}
+| 207|    |-		return false;
+| 208|    |-	}
+| 209|    |-
+| 210|    |-protected:
+| 211|    |-	std::string m_name;
+| 212|    |-
+| 213|    |-private:
+| 214|    |-	virtual void run() = 0;
+| 215|    |-
+| 216|    |-	Type m_type;
+| 217|    |-};
+| 218|    |-
+| 219|    |-BaseAction &get(Type at);
+| 220|    |-
+| 221|    |-std::shared_ptr<BaseAction> get_(Type at);
+| 222|    |-std::shared_ptr<BaseAction> get_(const std::string &name);
+| 223|    |-
+| 224|    |-struct Dummy: BaseAction
+| 225|    |-{
+| 226|    |-	Dummy(): BaseAction(Type::Dummy, "dummy") { }
+| 227|    |-	
+| 228|    |-private:
+| 229|    |-	virtual void run() override { }
+| 230|    |-};
+| 231|    |-
+| 232|    |-struct UpdateEnvironment: BaseAction
+| 233|    |-{
+| 234|    |-	UpdateEnvironment();
+| 235|    |-
+| 236|    |-	void run(bool update_status, bool refresh_window, bool mpd_sync);
+| 237|    |-
+| 238|    |-private:
+| 239|    |-	boost::posix_time::ptime m_past;
+| 240|    |-
+| 241|    |-	virtual void run() override;
+| 242|    |-};
+| 243|    |-
+| 244|    |-struct MouseEvent: BaseAction
+| 245|    |-{
+| 246|    |-	MouseEvent(): BaseAction(Type::MouseEvent, "mouse_event")
+| 247|    |-	{
+| 248|    |-		m_old_mouse_event.bstate = 0;
+| 249|    |-		m_mouse_event.bstate = 0;
+| 250|    |-	}
+| 251|    |-	
+| 252|    |-private:
+| 253|    |-	virtual bool canBeRun() override;
+| 254|    |-	virtual void run() override;
+| 255|    |-	
+| 256|    |-	MEVENT m_mouse_event;
+| 257|    |-	MEVENT m_old_mouse_event;
+| 258|    |-};
+| 259|    |-
+| 260|    |-struct ScrollUp: BaseAction
+| 261|    |-{
+| 262|    |-	ScrollUp(): BaseAction(Type::ScrollUp, "scroll_up") { }
+| 263|    |-	
+| 264|    |-private:
+| 265|    |-	virtual void run() override;
+| 266|    |-};
+| 267|    |-
+| 268|    |-struct ScrollDown: BaseAction
+| 269|    |-{
+| 270|    |-	ScrollDown(): BaseAction(Type::ScrollDown, "scroll_down") { }
+| 271|    |-	
+| 272|    |-private:
+| 273|    |-	virtual void run() override;
+| 274|    |-};
+| 275|    |-
+| 276|    |-struct ScrollUpArtist: BaseAction
+| 277|    |-{
+| 278|    |-	ScrollUpArtist(): BaseAction(Type::ScrollUpArtist, "scroll_up_artist") { }
+| 279|    |-	
+| 280|    |-private:
+| 281|    |-	virtual bool canBeRun() override;
+| 282|    |-	virtual void run() override;
+| 283|    |-
+| 284|    |-	NC::List *m_list;
+| 285|    |-	const SongList *m_songs;
+| 286|    |-};
+| 287|    |-
+| 288|    |-struct ScrollUpAlbum: BaseAction
+| 289|    |-{
+| 290|    |-	ScrollUpAlbum(): BaseAction(Type::ScrollUpAlbum, "scroll_up_album") { }
+| 291|    |-	
+| 292|    |-private:
+| 293|    |-	virtual bool canBeRun() override;
+| 294|    |-	virtual void run() override;
+| 295|    |-
+| 296|    |-	NC::List *m_list;
+| 297|    |-	const SongList *m_songs;
+| 298|    |-};
+| 299|    |-
+| 300|    |-struct ScrollDownArtist: BaseAction
+| 301|    |-{
+| 302|    |-	ScrollDownArtist(): BaseAction(Type::ScrollDownArtist, "scroll_down_artist") { }
+| 303|    |-	
+| 304|    |-private:
+| 305|    |-	virtual bool canBeRun() override;
+| 306|    |-	virtual void run() override;
+| 307|    |-
+| 308|    |-	NC::List *m_list;
+| 309|    |-	const SongList *m_songs;
+| 310|    |-};
+| 311|    |-
+| 312|    |-struct ScrollDownAlbum: BaseAction
+| 313|    |-{
+| 314|    |-	ScrollDownAlbum(): BaseAction(Type::ScrollDownAlbum, "scroll_down_album") { }
+| 315|    |-	
+| 316|    |-private:
+| 317|    |-	virtual bool canBeRun() override;
+| 318|    |-	virtual void run() override;
+| 319|    |-
+| 320|    |-	NC::List *m_list;
+| 321|    |-	const SongList *m_songs;
+| 322|    |-};
+| 323|    |-
+| 324|    |-struct PageUp: BaseAction
+| 325|    |-{
+| 326|    |-	PageUp(): BaseAction(Type::PageUp, "page_up") { }
+| 327|    |-	
+| 328|    |-private:
+| 329|    |-	virtual void run() override;
+| 330|    |-};
+| 331|    |-
+| 332|    |-struct PageDown: BaseAction
+| 333|    |-{
+| 334|    |-	PageDown(): BaseAction(Type::PageDown, "page_down") { }
+| 335|    |-	
+| 336|    |-private:
+| 337|    |-	virtual void run() override;
+| 338|    |-};
+| 339|    |-
+| 340|    |-struct MoveHome: BaseAction
+| 341|    |-{
+| 342|    |-	MoveHome(): BaseAction(Type::MoveHome, "move_home") { }
+| 343|    |-	
+| 344|    |-private:
+| 345|    |-	virtual void run() override;
+| 346|    |-};
+| 347|    |-
+| 348|    |-struct MoveEnd: BaseAction
+| 349|    |-{
+| 350|    |-	MoveEnd(): BaseAction(Type::MoveEnd, "move_end") { }
+| 351|    |-	
+| 352|    |-private:
+| 353|    |-	virtual void run() override;
+| 354|    |-};
+| 355|    |-
+| 356|    |-struct ToggleInterface: BaseAction
+| 357|    |-{
+| 358|    |-	ToggleInterface(): BaseAction(Type::ToggleInterface, "toggle_interface") { }
+| 359|    |-	
+| 360|    |-private:
+| 361|    |-	virtual void run() override;
+| 362|    |-};
+| 363|    |-
+| 364|    |-struct JumpToParentDirectory: BaseAction
+| 365|    |-{
+| 366|    |-	JumpToParentDirectory(): BaseAction(Type::JumpToParentDirectory, "jump_to_parent_directory") { }
+| 367|    |-	
+| 368|    |-private:
+| 369|    |-	virtual bool canBeRun() override;
+| 370|    |-	virtual void run() override;
+| 371|    |-};
+| 372|    |-
+| 373|    |-struct RunAction: BaseAction
+| 374|    |-{
+| 375|    |-	RunAction(): BaseAction(Type::RunAction, "run_action") { }
+| 376|    |-
+| 377|    |-private:
+| 378|    |-	virtual bool canBeRun() override;
+| 379|    |-	virtual void run() override;
+| 380|    |-
+| 381|    |-	HasActions *m_ha;
+| 382|    |-};
+| 383|    |-
+| 384|    |-struct PreviousColumn: BaseAction
+| 385|    |-{
+| 386|    |-	PreviousColumn(): BaseAction(Type::PreviousColumn, "previous_column") { }
+| 387|    |-	
+| 388|    |-private:
+| 389|    |-	virtual bool canBeRun() override;
+| 390|    |-	virtual void run() override;
+| 391|    |-
+| 392|    |-	HasColumns *m_hc;
+| 393|    |-};
+| 394|    |-
+| 395|    |-struct NextColumn: BaseAction
+| 396|    |-{
+| 397|    |-	NextColumn(): BaseAction(Type::NextColumn, "next_column") { }
+| 398|    |-	
+| 399|    |-private:
+| 400|    |-	virtual bool canBeRun() override;
+| 401|    |-	virtual void run() override;
+| 402|    |-
+| 403|    |-	HasColumns *m_hc;
+| 404|    |-};
+| 405|    |-
+| 406|    |-struct MasterScreen: BaseAction
+| 407|    |-{
+| 408|    |-	MasterScreen(): BaseAction(Type::MasterScreen, "master_screen") { }
+| 409|    |-	
+| 410|    |-private:
+| 411|    |-	virtual bool canBeRun() override;
+| 412|    |-	virtual void run() override;
+| 413|    |-};
+| 414|    |-
+| 415|    |-struct SlaveScreen: BaseAction
+| 416|    |-{
+| 417|    |-	SlaveScreen(): BaseAction(Type::SlaveScreen, "slave_screen") { }
+| 418|    |-	
+| 419|    |-private:
+| 420|    |-	virtual bool canBeRun() override;
+| 421|    |-	virtual void run() override;
+| 422|    |-};
+| 423|    |-
+| 424|    |-struct VolumeUp: BaseAction
+| 425|    |-{
+| 426|    |-	VolumeUp(): BaseAction(Type::VolumeUp, "volume_up") { }
+| 427|    |-	
+| 428|    |-private:
+| 429|    |-	virtual void run() override;
+| 430|    |-};
+| 431|    |-
+| 432|    |-struct VolumeDown: BaseAction
+| 433|    |-{
+| 434|    |-	VolumeDown(): BaseAction(Type::VolumeDown, "volume_down") { }
+| 435|    |-	
+| 436|    |-private:
+| 437|    |-	virtual void run() override;
+| 438|    |-};
+| 439|    |-
+| 440|    |-struct AddItemToPlaylist: BaseAction
+| 441|    |-{
+| 442|    |-	AddItemToPlaylist(): BaseAction(Type::AddItemToPlaylist, "add_item_to_playlist") { }
+| 443|    |-
+| 444|    |-private:
+| 445|    |-	virtual bool canBeRun() override;
+| 446|    |-	virtual void run() override;
+| 447|    |-
+| 448|    |-	HasSongs *m_hs;
+| 449|    |-};
+| 450|    |-
+| 451|    |-struct PlayItem: BaseAction
+| 452|    |-{
+| 453|    |-	PlayItem(): BaseAction(Type::PlayItem, "play_item") { }
+| 454|    |-
+| 455|    |-private:
+| 456|    |-	virtual bool canBeRun() override;
+| 457|    |-	virtual void run() override;
+| 458|    |-
+| 459|    |-	HasSongs *m_hs;
+| 460|    |-};
+| 461|    |-
+| 462|    |-struct DeletePlaylistItems: BaseAction
+| 463|    |-{
+| 464|    |-	DeletePlaylistItems(): BaseAction(Type::DeletePlaylistItems, "delete_playlist_items") { }
+| 465|    |-	
+| 466|    |-private:
+| 467|    |-	virtual bool canBeRun() override;
+| 468|    |-	virtual void run() override;
+| 469|    |-};
+| 470|    |-
+| 471|    |-struct DeleteStoredPlaylist: BaseAction
+| 472|    |-{
+| 473|    |-	DeleteStoredPlaylist(): BaseAction(Type::DeleteStoredPlaylist, "delete_stored_playlist") { }
+| 474|    |-	
+| 475|    |-private:
+| 476|    |-	virtual bool canBeRun() override;
+| 477|    |-	virtual void run() override;
+| 478|    |-};
+| 479|    |-
+| 480|    |-struct DeleteBrowserItems: BaseAction
+| 481|    |-{
+| 482|    |-	DeleteBrowserItems(): BaseAction(Type::DeleteBrowserItems, "delete_browser_items") { }
+| 483|    |-	
+| 484|    |-private:
+| 485|    |-	virtual bool canBeRun() override;
+| 486|    |-	virtual void run() override;
+| 487|    |-};
+| 488|    |-
+| 489|    |-struct ReplaySong: BaseAction
+| 490|    |-{
+| 491|    |-	ReplaySong(): BaseAction(Type::ReplaySong, "replay_song") { }
+| 492|    |-	
+| 493|    |-private:
+| 494|    |-	virtual void run() override;
+| 495|    |-};
+| 496|    |-
+| 497|    |-struct PreviousSong: BaseAction
+| 498|    |-{
+| 499|    |-	PreviousSong(): BaseAction(Type::Previous, "previous") { }
+| 500|    |-	
+| 501|    |-private:
+| 502|    |-	virtual void run() override;
+| 503|    |-};
+| 504|    |-
+| 505|    |-struct NextSong: BaseAction
+| 506|    |-{
+| 507|    |-	NextSong(): BaseAction(Type::Next, "next") { }
+| 508|    |-	
+| 509|    |-private:
+| 510|    |-	virtual void run() override;
+| 511|    |-};
+| 512|    |-
+| 513|    |-struct Pause: BaseAction
+| 514|    |-{
+| 515|    |-	Pause(): BaseAction(Type::Pause, "pause") { }
+| 516|    |-	
+| 517|    |-private:
+| 518|    |-	virtual void run() override;
+| 519|    |-};
+| 520|    |-
+| 521|    |-struct Stop: BaseAction
+| 522|    |-{
+| 523|    |-	Stop(): BaseAction(Type::Stop, "stop") { }
+| 524|    |-	
+| 525|    |-private:
+| 526|    |-	virtual void run() override;
+| 527|    |-};
+| 528|    |-
+| 529|    |-struct ExecuteCommand: BaseAction
+| 530|    |-{
+| 531|    |-	ExecuteCommand(): BaseAction(Type::ExecuteCommand, "execute_command") { }
+| 532|    |-	
+| 533|    |-private:
+| 534|    |-	virtual void run() override;
+| 535|    |-};
+| 536|    |-
+| 537|    |-struct SavePlaylist: BaseAction
+| 538|    |-{
+| 539|    |-	SavePlaylist(): BaseAction(Type::SavePlaylist, "save_playlist") { }
+| 540|    |-	
+| 541|    |-private:
+| 542|    |-	virtual void run() override;
+| 543|    |-};
+| 544|    |-
+| 545|    |-struct MoveSortOrderUp: BaseAction
+| 546|    |-{
+| 547|    |-	MoveSortOrderUp(): BaseAction(Type::MoveSortOrderUp, "move_sort_order_up") { }
+| 548|    |-	
+| 549|    |-private:
+| 550|    |-	virtual bool canBeRun() override;
+| 551|    |-	virtual void run() override;
+| 552|    |-};
+| 553|    |-
+| 554|    |-struct MoveSortOrderDown: BaseAction
+| 555|    |-{
+| 556|    |-	MoveSortOrderDown(): BaseAction(Type::MoveSortOrderDown, "move_sort_order_down") { }
+| 557|    |-	
+| 558|    |-private:
+| 559|    |-	virtual bool canBeRun() override;
+| 560|    |-	virtual void run() override;
+| 561|    |-};
+| 562|    |-
+| 563|    |-struct MoveSelectedItemsUp: BaseAction
+| 564|    |-{
+| 565|    |-	MoveSelectedItemsUp(): BaseAction(Type::MoveSelectedItemsUp, "move_selected_items_up") { }
+| 566|    |-	
+| 567|    |-private:
+| 568|    |-	virtual bool canBeRun() override;
+| 569|    |-	virtual void run() override;
+| 570|    |-};
+| 571|    |-
+| 572|    |-struct MoveSelectedItemsDown: BaseAction
+| 573|    |-{
+| 574|    |-	MoveSelectedItemsDown(): BaseAction(Type::MoveSelectedItemsDown, "move_selected_items_down") { }
+| 575|    |-	
+| 576|    |-private:
+| 577|    |-	virtual bool canBeRun() override;
+| 578|    |-	virtual void run() override;
+| 579|    |-};
+| 580|    |-
+| 581|    |-struct MoveSelectedItemsTo: BaseAction
+| 582|    |-{
+| 583|    |-	MoveSelectedItemsTo(): BaseAction(Type::MoveSelectedItemsTo, "move_selected_items_to") { }
+| 584|    |-	
+| 585|    |-private:
+| 586|    |-	virtual bool canBeRun() override;
+| 587|    |-	virtual void run() override;
+| 588|    |-};
+| 589|    |-
+| 590|    |-struct Add: BaseAction
+| 591|    |-{
+| 592|    |-	Add(): BaseAction(Type::Add, "add") { }
+| 593|    |-	
+| 594|    |-private:
+| 595|    |-	virtual bool canBeRun() override;
+| 596|    |-	virtual void run() override;
+| 597|    |-};
+| 598|    |-
+| 599|    |-struct SeekForward: BaseAction
+| 600|    |-{
+| 601|    |-	SeekForward(): BaseAction(Type::SeekForward, "seek_forward") { }
+| 602|    |-	
+| 603|    |-private:
+| 604|    |-	virtual bool canBeRun() override;
+| 605|    |-	virtual void run() override;
+| 606|    |-};
+| 607|    |-
+| 608|    |-struct SeekBackward: BaseAction
+| 609|    |-{
+| 610|    |-	SeekBackward(): BaseAction(Type::SeekBackward, "seek_backward") { }
+| 611|    |-	
+| 612|    |-private:
+| 613|    |-	virtual bool canBeRun() override;
+| 614|    |-	virtual void run() override;
+| 615|    |-};
+| 616|    |-
+| 617|    |-struct ToggleDisplayMode: BaseAction
+| 618|    |-{
+| 619|    |-	ToggleDisplayMode(): BaseAction(Type::ToggleDisplayMode, "toggle_display_mode") { }
+| 620|    |-	
+| 621|    |-private:
+| 622|    |-	virtual bool canBeRun() override;
+| 623|    |-	virtual void run() override;
+| 624|    |-};
+| 625|    |-
+| 626|    |-struct ToggleSeparatorsBetweenAlbums: BaseAction
+| 627|    |-{
+| 628|    |-	ToggleSeparatorsBetweenAlbums()
+| 629|    |-	: BaseAction(Type::ToggleSeparatorsBetweenAlbums, "toggle_separators_between_albums") { }
+| 630|    |-	
+| 631|    |-private:
+| 632|    |-	virtual bool canBeRun() override;
+| 633|    |-	virtual void run() override;
+| 634|    |-};
+| 635|    |-
+| 636|    |-struct ToggleLyricsUpdateOnSongChange: BaseAction
+| 637|    |-{
+| 638|    |-	ToggleLyricsUpdateOnSongChange()
+| 639|    |-	: BaseAction(Type::ToggleLyricsUpdateOnSongChange, "toggle_lyrics_update_on_song_change") { }
+| 640|    |-
+| 641|    |-private:
+| 642|    |-	virtual bool canBeRun() override;
+| 643|    |-	virtual void run() override;
+| 644|    |-};
+| 645|    |-
+| 646|    |-struct ToggleLyricsFetcher: BaseAction
+| 647|    |-{
+| 648|    |-	ToggleLyricsFetcher(): BaseAction(Type::ToggleLyricsFetcher, "toggle_lyrics_fetcher") { }
+| 649|    |-	
+| 650|    |-private:
+| 651|    |-	virtual void run() override;
+| 652|    |-};
+| 653|    |-
+| 654|    |-struct ToggleFetchingLyricsInBackground: BaseAction
+| 655|    |-{
+| 656|    |-	ToggleFetchingLyricsInBackground()
+| 657|    |-	: BaseAction(Type::ToggleFetchingLyricsInBackground, "toggle_fetching_lyrics_in_background") { }
+| 658|    |-	
+| 659|    |-private:
+| 660|    |-	virtual void run() override;
+| 661|    |-};
+| 662|    |-
+| 663|    |-struct TogglePlayingSongCentering: BaseAction
+| 664|    |-{
+| 665|    |-	TogglePlayingSongCentering()
+| 666|    |-	: BaseAction(Type::TogglePlayingSongCentering, "toggle_playing_song_centering") { }
+| 667|    |-	
+| 668|    |-private:
+| 669|    |-	virtual void run() override;
+| 670|    |-};
+| 671|    |-
+| 672|    |-struct UpdateDatabase: BaseAction
+| 673|    |-{
+| 674|    |-	UpdateDatabase(): BaseAction(Type::UpdateDatabase, "update_database") { }
+| 675|    |-	
+| 676|    |-private:
+| 677|    |-	virtual void run() override;
+| 678|    |-};
+| 679|    |-
+| 680|    |-struct JumpToPlayingSong: BaseAction
+| 681|    |-{
+| 682|    |-	JumpToPlayingSong(): BaseAction(Type::JumpToPlayingSong, "jump_to_playing_song") { }
+| 683|    |-	
+| 684|    |-private:
+| 685|    |-	virtual bool canBeRun() override;
+| 686|    |-	virtual void run() override;
+| 687|    |-
+| 688|    |-	MPD::Song m_song;
+| 689|    |-};
+| 690|    |-
+| 691|    |-struct ToggleRepeat: BaseAction
+| 692|    |-{
+| 693|    |-	ToggleRepeat(): BaseAction(Type::ToggleRepeat, "toggle_repeat") { }
+| 694|    |-	
+| 695|    |-private:
+| 696|    |-	virtual void run() override;
+| 697|    |-};
+| 698|    |-
+| 699|    |-struct Shuffle: BaseAction
+| 700|    |-{
+| 701|    |-	Shuffle(): BaseAction(Type::Shuffle, "shuffle") { }
+| 702|    |-	
+| 703|    |-private:
+| 704|    |-	virtual bool canBeRun() override;
+| 705|    |-	virtual void run() override;
+| 706|    |-
+| 707|    |-	NC::Menu<MPD::Song>::ConstIterator m_begin;
+| 708|    |-	NC::Menu<MPD::Song>::ConstIterator m_end;
+| 709|    |-};
+| 710|    |-
+| 711|    |-struct ToggleRandom: BaseAction
+| 712|    |-{
+| 713|    |-	ToggleRandom(): BaseAction(Type::ToggleRandom, "toggle_random") { }
+| 714|    |-	
+| 715|    |-private:
+| 716|    |-	virtual void run() override;
+| 717|    |-};
+| 718|    |-
+| 719|    |-struct StartSearching: BaseAction
+| 720|    |-{
+| 721|    |-	StartSearching(): BaseAction(Type::StartSearching, "start_searching") { }
+| 722|    |-	
+| 723|    |-private:
+| 724|    |-	virtual bool canBeRun() override;
+| 725|    |-	virtual void run() override;
+| 726|    |-};
+| 727|    |-
+| 728|    |-struct SaveTagChanges: BaseAction
+| 729|    |-{
+| 730|    |-	SaveTagChanges(): BaseAction(Type::SaveTagChanges, "save_tag_changes") { }
+| 731|    |-	
+| 732|    |-private:
+| 733|    |-	virtual bool canBeRun() override;
+| 734|    |-	virtual void run() override;
+| 735|    |-};
+| 736|    |-
+| 737|    |-struct ToggleSingle: BaseAction
+| 738|    |-{
+| 739|    |-	ToggleSingle(): BaseAction(Type::ToggleSingle, "toggle_single") { }
+| 740|    |-	
+| 741|    |-private:
+| 742|    |-	virtual void run() override;
+| 743|    |-};
+| 744|    |-
+| 745|    |-struct ToggleConsume: BaseAction
+| 746|    |-{
+| 747|    |-	ToggleConsume(): BaseAction(Type::ToggleConsume, "toggle_consume") { }
+| 748|    |-	
+| 749|    |-private:
+| 750|    |-	virtual void run() override;
+| 751|    |-};
+| 752|    |-
+| 753|    |-struct ToggleCrossfade: BaseAction
+| 754|    |-{
+| 755|    |-	ToggleCrossfade(): BaseAction(Type::ToggleCrossfade, "toggle_crossfade") { }
+| 756|    |-	
+| 757|    |-private:
+| 758|    |-	virtual void run() override;
+| 759|    |-};
+| 760|    |-
+| 761|    |-struct SetCrossfade: BaseAction
+| 762|    |-{
+| 763|    |-	SetCrossfade(): BaseAction(Type::SetCrossfade, "set_crossfade") { }
+| 764|    |-	
+| 765|    |-private:
+| 766|    |-	virtual void run() override;
+| 767|    |-};
+| 768|    |-
+| 769|    |-struct SetVolume: BaseAction
+| 770|    |-{
+| 771|    |-	SetVolume(): BaseAction(Type::SetVolume, "set_volume") { }
+| 772|    |-	
+| 773|    |-private:
+| 774|    |-	virtual void run() override;
+| 775|    |-};
+| 776|    |-
+| 777|    |-struct EnterDirectory: BaseAction
+| 778|    |-{
+| 779|    |-	EnterDirectory(): BaseAction(Type::EnterDirectory, "enter_directory") { }
+| 780|    |-
+| 781|    |-private:
+| 782|    |-	virtual bool canBeRun() override;
+| 783|    |-	virtual void run() override;
+| 784|    |-};
+| 785|    |-
+| 786|    |-
+| 787|    |-struct EditSong: BaseAction
+| 788|    |-{
+| 789|    |-	EditSong(): BaseAction(Type::EditSong, "edit_song") { }
+| 790|    |-	
+| 791|    |-private:
+| 792|    |-	virtual bool canBeRun() override;
+| 793|    |-	virtual void run() override;
+| 794|    |-
+| 795|    |-#ifdef HAVE_TAGLIB_H
+| 796|    |-	const MPD::Song *m_song;
+| 797|    |-#endif // HAVE_TAGLIB_H
+| 798|    |-};
+| 799|    |-
+| 800|    |-struct EditLibraryTag: BaseAction
+| 801|    |-{
+| 802|    |-	EditLibraryTag(): BaseAction(Type::EditLibraryTag, "edit_library_tag") { }
+| 803|    |-	
+| 804|    |-private:
+| 805|    |-	virtual bool canBeRun() override;
+| 806|    |-	virtual void run() override;
+| 807|    |-};
+| 808|    |-
+| 809|    |-struct EditLibraryAlbum: BaseAction
+| 810|    |-{
+| 811|    |-	EditLibraryAlbum(): BaseAction(Type::EditLibraryAlbum, "edit_library_album") { }
+| 812|    |-	
+| 813|    |-private:
+| 814|    |-	virtual bool canBeRun() override;
+| 815|    |-	virtual void run() override;
+| 816|    |-};
+| 817|    |-
+| 818|    |-struct EditDirectoryName: BaseAction
+| 819|    |-{
+| 820|    |-	EditDirectoryName(): BaseAction(Type::EditDirectoryName, "edit_directory_name") { }
+| 821|    |-	
+| 822|    |-private:
+| 823|    |-	virtual bool canBeRun() override;
+| 824|    |-	virtual void run() override;
+| 825|    |-};
+| 826|    |-
+| 827|    |-struct EditPlaylistName: BaseAction
+| 828|    |-{
+| 829|    |-	EditPlaylistName(): BaseAction(Type::EditPlaylistName, "edit_playlist_name") { }
+| 830|    |-	
+| 831|    |-private:
+| 832|    |-	virtual bool canBeRun() override;
+| 833|    |-	virtual void run() override;
+| 834|    |-};
+| 835|    |-
+| 836|    |-struct EditLyrics: BaseAction
+| 837|    |-{
+| 838|    |-	EditLyrics(): BaseAction(Type::EditLyrics, "edit_lyrics") { }
+| 839|    |-	
+| 840|    |-private:
+| 841|    |-	virtual bool canBeRun() override;
+| 842|    |-	virtual void run() override;
+| 843|    |-};
+| 844|    |-
+| 845|    |-struct JumpToBrowser: BaseAction
+| 846|    |-{
+| 847|    |-	JumpToBrowser(): BaseAction(Type::JumpToBrowser, "jump_to_browser") { }
+| 848|    |-	
+| 849|    |-private:
+| 850|    |-	virtual bool canBeRun() override;
+| 851|    |-	virtual void run() override;
+| 852|    |-
+| 853|    |-	const MPD::Song *m_song;
+| 854|    |-};
+| 855|    |-
+| 856|    |-struct JumpToMediaLibrary: BaseAction
+| 857|    |-{
+| 858|    |-	JumpToMediaLibrary(): BaseAction(Type::JumpToMediaLibrary, "jump_to_media_library") { }
+| 859|    |-	
+| 860|    |-private:
+| 861|    |-	virtual bool canBeRun() override;
+| 862|    |-	virtual void run() override;
+| 863|    |-
+| 864|    |-	const MPD::Song *m_song;
+| 865|    |-};
+| 866|    |-
+| 867|    |-struct JumpToPlaylistEditor: BaseAction
+| 868|    |-{
+| 869|    |-	JumpToPlaylistEditor(): BaseAction(Type::JumpToPlaylistEditor, "jump_to_playlist_editor") { }
+| 870|    |-	
+| 871|    |-private:
+| 872|    |-	virtual bool canBeRun() override;
+| 873|    |-	virtual void run() override;
+| 874|    |-};
+| 875|    |-
+| 876|    |-struct ToggleScreenLock: BaseAction
+| 877|    |-{
+| 878|    |-	ToggleScreenLock(): BaseAction(Type::ToggleScreenLock, "toggle_screen_lock") { }
+| 879|    |-	
+| 880|    |-private:
+| 881|    |-	virtual void run() override;
+| 882|    |-};
+| 883|    |-
+| 884|    |-struct JumpToTagEditor: BaseAction
+| 885|    |-{
+| 886|    |-	JumpToTagEditor(): BaseAction(Type::JumpToTagEditor, "jump_to_tag_editor") { }
+| 887|    |-	
+| 888|    |-private:
+| 889|    |-	virtual bool canBeRun() override;
+| 890|    |-	virtual void run() override;
+| 891|    |-
+| 892|    |-#ifdef HAVE_TAGLIB_H
+| 893|    |-	const MPD::Song *m_song;
+| 894|    |-#endif // HAVE_TAGLIB_H
+| 895|    |-};
+| 896|    |-
+| 897|    |-struct JumpToPositionInSong: BaseAction
+| 898|    |-{
+| 899|    |-	JumpToPositionInSong(): BaseAction(Type::JumpToPositionInSong, "jump_to_position_in_song") { }
+| 900|    |-	
+| 901|    |-private:
+| 902|    |-	virtual bool canBeRun() override;
+| 903|    |-	virtual void run() override;
+| 904|    |-};
+| 905|    |-
+| 906|    |-struct SelectItem: BaseAction
+| 907|    |-{
+| 908|    |-	SelectItem(): BaseAction(Type::SelectItem, "select_item") { }
+| 909|    |-
+| 910|    |-private:
+| 911|    |-	virtual bool canBeRun() override;
+| 912|    |-	virtual void run() override;
+| 913|    |-
+| 914|    |-	NC::List *m_list;
+| 915|    |-};
+| 916|    |-
+| 917|    |-struct SelectRange: BaseAction
+| 918|    |-{
+| 919|    |-	SelectRange(): BaseAction(Type::SelectRange, "select_range") { }
+| 920|    |-
+| 921|    |-private:
+| 922|    |-	virtual bool canBeRun() override;
+| 923|    |-	virtual void run() override;
+| 924|    |-
+| 925|    |-	NC::List *m_list;
+| 926|    |-	NC::List::Iterator m_begin;
+| 927|    |-	NC::List::Iterator m_end;
+| 928|    |-};
+| 929|    |-
+| 930|    |-struct ReverseSelection: BaseAction
+| 931|    |-{
+| 932|    |-	ReverseSelection(): BaseAction(Type::ReverseSelection, "reverse_selection") { }
+| 933|    |-	
+| 934|    |-private:
+| 935|    |-	virtual bool canBeRun() override;
+| 936|    |-	virtual void run() override;
+| 937|    |-
+| 938|    |-	NC::List *m_list;
+| 939|    |-};
+| 940|    |-
+| 941|    |-struct RemoveSelection: BaseAction
+| 942|    |-{
+| 943|    |-	RemoveSelection(): BaseAction(Type::RemoveSelection, "remove_selection") { }
+| 944|    |-	
+| 945|    |-private:
+| 946|    |-	virtual bool canBeRun() override;
+| 947|    |-	virtual void run() override;
+| 948|    |-
+| 949|    |-	NC::List *m_list;
+| 950|    |-};
+| 951|    |-
+| 952|    |-struct SelectAlbum: BaseAction
+| 953|    |-{
+| 954|    |-	SelectAlbum(): BaseAction(Type::SelectAlbum, "select_album") { }
+| 955|    |-	
+| 956|    |-private:
+| 957|    |-	virtual bool canBeRun() override;
+| 958|    |-	virtual void run() override;
+| 959|    |-
+| 960|    |-	NC::List *m_list;
+| 961|    |-	SongList *m_songs;
+| 962|    |-};
+| 963|    |-
+| 964|    |-struct SelectFoundItems: BaseAction
+| 965|    |-{
+| 966|    |-	SelectFoundItems(): BaseAction(Type::SelectFoundItems, "select_found_items") { }
+| 967|    |-
+| 968|    |-private:
+| 969|    |-	virtual bool canBeRun() override;
+| 970|    |-	virtual void run() override;
+| 971|    |-
+| 972|    |-	NC::List *m_list;
+| 973|    |-	Searchable *m_searchable;
+| 974|    |-};
+| 975|    |-
+| 976|    |-struct AddSelectedItems: BaseAction
+| 977|    |-{
+| 978|    |-	AddSelectedItems(): BaseAction(Type::AddSelectedItems, "add_selected_items") { }
+| 979|    |-	
+| 980|    |-private:
+| 981|    |-	virtual bool canBeRun() override;
+| 982|    |-	virtual void run() override;
+| 983|    |-};
+| 984|    |-
+| 985|    |-struct CropMainPlaylist: BaseAction
+| 986|    |-{
+| 987|    |-	CropMainPlaylist(): BaseAction(Type::CropMainPlaylist, "crop_main_playlist") { }
+| 988|    |-	
+| 989|    |-private:
+| 990|    |-	virtual void run() override;
+| 991|    |-};
+| 992|    |-
+| 993|    |-struct CropPlaylist: BaseAction
+| 994|    |-{
+| 995|    |-	CropPlaylist(): BaseAction(Type::CropPlaylist, "crop_playlist") { }
+| 996|    |-	
+| 997|    |-private:
+| 998|    |-	virtual bool canBeRun() override;
+| 999|    |-	virtual void run() override;
+|1000|    |-};
+|1001|    |-
+|1002|    |-struct ClearMainPlaylist: BaseAction
+|1003|    |-{
+|1004|    |-	ClearMainPlaylist(): BaseAction(Type::ClearMainPlaylist, "clear_main_playlist") { }
+|1005|    |-	
+|1006|    |-private:
+|1007|    |-	virtual void run() override;
+|1008|    |-};
+|1009|    |-
+|1010|    |-struct ClearPlaylist: BaseAction
+|1011|    |-{
+|1012|    |-	ClearPlaylist(): BaseAction(Type::ClearPlaylist, "clear_playlist") { }
+|1013|    |-	
+|1014|    |-private:
+|1015|    |-	virtual bool canBeRun() override;
+|1016|    |-	virtual void run() override;
+|1017|    |-};
+|1018|    |-
+|1019|    |-struct SortPlaylist: BaseAction
+|1020|    |-{
+|1021|    |-	SortPlaylist(): BaseAction(Type::SortPlaylist, "sort_playlist") { }
+|1022|    |-	
+|1023|    |-private:
+|1024|    |-	virtual bool canBeRun() override;
+|1025|    |-	virtual void run() override;
+|1026|    |-};
+|1027|    |-
+|1028|    |-struct ReversePlaylist: BaseAction
+|1029|    |-{
+|1030|    |-	ReversePlaylist(): BaseAction(Type::ReversePlaylist, "reverse_playlist") { }
+|1031|    |-	
+|1032|    |-private:
+|1033|    |-	virtual bool canBeRun() override;
+|1034|    |-	virtual void run() override;
+|1035|    |-
+|1036|    |-	NC::Menu<MPD::Song>::ConstIterator m_begin;
+|1037|    |-	NC::Menu<MPD::Song>::ConstIterator m_end;
+|1038|    |-};
+|1039|    |-
+|1040|    |-struct ApplyFilter: public BaseAction
+|1041|    |-{
+|1042|    |-	ApplyFilter(): BaseAction(Type::ApplyFilter, "apply_filter") { }
+|1043|    |-
+|1044|    |-private:
+|1045|    |-	virtual bool canBeRun() override;
+|1046|    |-	virtual void run() override;
+|1047|    |-
+|1048|    |-	Filterable *m_filterable;
+|1049|    |-};
+|1050|    |-
+|1051|    |-struct Find: BaseAction
+|1052|    |-{
+|1053|    |-	Find(): BaseAction(Type::Find, "find") { }
+|1054|    |-	
+|1055|    |-private:
+|1056|    |-	virtual bool canBeRun() override;
+|1057|    |-	virtual void run() override;
+|1058|    |-};
+|1059|    |-
+|1060|    |-struct FindItemForward: BaseAction
+|1061|    |-{
+|1062|    |-	FindItemForward(): BaseAction(Type::FindItemForward, "find_item_forward") { }
+|1063|    |-	
+|1064|    |-private:
+|1065|    |-	virtual bool canBeRun() override;
+|1066|    |-	virtual void run() override;
+|1067|    |-};
+|1068|    |-
+|1069|    |-struct FindItemBackward: BaseAction
+|1070|    |-{
+|1071|    |-	FindItemBackward(): BaseAction(Type::FindItemBackward, "find_item_backward") { }
+|1072|    |-	
+|1073|    |-private:
+|1074|    |-	virtual bool canBeRun() override;
+|1075|    |-	virtual void run() override;
+|1076|    |-};
+|1077|    |-
+|1078|    |-struct NextFoundItem: BaseAction
+|1079|    |-{
+|1080|    |-	NextFoundItem(): BaseAction(Type::NextFoundItem, "next_found_item") { }
+|1081|    |-	
+|1082|    |-private:
+|1083|    |-	virtual bool canBeRun() override;
+|1084|    |-	virtual void run() override;
+|1085|    |-};
+|1086|    |-
+|1087|    |-struct PreviousFoundItem: BaseAction
+|1088|    |-{
+|1089|    |-	PreviousFoundItem(): BaseAction(Type::PreviousFoundItem, "previous_found_item") { }
+|1090|    |-	
+|1091|    |-private:
+|1092|    |-	virtual bool canBeRun() override;
+|1093|    |-	virtual void run() override;
+|1094|    |-};
+|1095|    |-
+|1096|    |-struct ToggleFindMode: BaseAction
+|1097|    |-{
+|1098|    |-	ToggleFindMode(): BaseAction(Type::ToggleFindMode, "toggle_find_mode") { }
+|1099|    |-	
+|1100|    |-private:
+|1101|    |-	virtual void run() override;
+|1102|    |-};
+|1103|    |-
+|1104|    |-struct ToggleReplayGainMode: BaseAction
+|1105|    |-{
+|1106|    |-	ToggleReplayGainMode(): BaseAction(Type::ToggleReplayGainMode, "toggle_replay_gain_mode") { }
+|1107|    |-	
+|1108|    |-private:
+|1109|    |-	virtual void run() override;
+|1110|    |-};
+|1111|    |-
+|1112|    |-struct ToggleAddMode: BaseAction
+|1113|    |-{
+|1114|    |-	ToggleAddMode(): BaseAction(Type::ToggleAddMode, "toggle_add_mode") { }
+|1115|    |-	
+|1116|    |-private:
+|1117|    |-	virtual void run() override;
+|1118|    |-};
+|1119|    |-
+|1120|    |-struct ToggleMouse: BaseAction
+|1121|    |-{
+|1122|    |-	ToggleMouse(): BaseAction(Type::ToggleMouse, "toggle_mouse") { }
+|1123|    |-	
+|1124|    |-private:
+|1125|    |-	virtual void run() override;
+|1126|    |-};
+|1127|    |-
+|1128|    |-struct ToggleBitrateVisibility: BaseAction
+|1129|    |-{
+|1130|    |-	ToggleBitrateVisibility(): BaseAction(Type::ToggleBitrateVisibility, "toggle_bitrate_visibility") { }
+|1131|    |-	
+|1132|    |-private:
+|1133|    |-	virtual void run() override;
+|1134|    |-};
+|1135|    |-
+|1136|    |-struct AddRandomItems: BaseAction
+|1137|    |-{
+|1138|    |-	AddRandomItems(): BaseAction(Type::AddRandomItems, "add_random_items") { }
+|1139|    |-	
+|1140|    |-private:
+|1141|    |-	virtual void run() override;
+|1142|    |-};
+|1143|    |-
+|1144|    |-struct ToggleBrowserSortMode: BaseAction
+|1145|    |-{
+|1146|    |-	ToggleBrowserSortMode(): BaseAction(Type::ToggleBrowserSortMode, "toggle_browser_sort_mode") { }
+|1147|    |-	
+|1148|    |-private:
+|1149|    |-	virtual bool canBeRun() override;
+|1150|    |-	virtual void run() override;
+|1151|    |-};
+|1152|    |-
+|1153|    |-struct ToggleLibraryTagType: BaseAction
+|1154|    |-{
+|1155|    |-	ToggleLibraryTagType(): BaseAction(Type::ToggleLibraryTagType, "toggle_library_tag_type") { }
+|1156|    |-	
+|1157|    |-private:
+|1158|    |-	virtual bool canBeRun() override;
+|1159|    |-	virtual void run() override;
+|1160|    |-};
+|1161|    |-
+|1162|    |-struct ToggleMediaLibrarySortMode: BaseAction
+|1163|    |-{
+|1164|    |-	ToggleMediaLibrarySortMode()
+|1165|    |-	: BaseAction(Type::ToggleMediaLibrarySortMode, "toggle_media_library_sort_mode") { }
+|1166|    |-	
+|1167|    |-private:
+|1168|    |-	virtual bool canBeRun() override;
+|1169|    |-	virtual void run() override;
+|1170|    |-};
+|1171|    |-
+|1172|    |-struct FetchLyricsInBackground: BaseAction
+|1173|    |-{
+|1174|    |-	FetchLyricsInBackground()
+|1175|    |-		: BaseAction(Type::FetchLyricsInBackground, "fetch_lyrics_in_background") { }
+|1176|    |-
+|1177|    |-private:
+|1178|    |-	virtual bool canBeRun() override;
+|1179|    |-	virtual void run() override;
+|1180|    |-
+|1181|    |-	HasSongs *m_hs;
+|1182|    |-};
+|1183|    |-
+|1184|    |-struct RefetchLyrics: BaseAction
+|1185|    |-{
+|1186|    |-	RefetchLyrics(): BaseAction(Type::RefetchLyrics, "refetch_lyrics") { }
+|1187|    |-	
+|1188|    |-private:
+|1189|    |-	virtual bool canBeRun() override;
+|1190|    |-	virtual void run() override;
+|1191|    |-};
+|1192|    |-
+|1193|    |-struct SetSelectedItemsPriority: BaseAction
+|1194|    |-{
+|1195|    |-	SetSelectedItemsPriority()
+|1196|    |-	: BaseAction(Type::SetSelectedItemsPriority, "set_selected_items_priority") { }
+|1197|    |-	
+|1198|    |-private:
+|1199|    |-	virtual bool canBeRun() override;
+|1200|    |-	virtual void run() override;
+|1201|    |-};
+|1202|    |-
+|1203|    |-struct ToggleOutput: BaseAction
+|1204|    |-{
+|1205|    |-	ToggleOutput(): BaseAction(Type::ToggleOutput, "toggle_output") { }
+|1206|    |-
+|1207|    |-private:
+|1208|    |-	virtual bool canBeRun() override;
+|1209|    |-	virtual void run() override;
+|1210|    |-};
+|1211|    |-
+|1212|    |-struct ToggleVisualizationType: BaseAction
+|1213|    |-{
+|1214|    |-	ToggleVisualizationType()
+|1215|    |-	: BaseAction(Type::ToggleVisualizationType, "toggle_visualization_type") { }
+|1216|    |-
+|1217|    |-private:
+|1218|    |-	
+|1219|    |-	virtual bool canBeRun() override;
+|1220|    |-	virtual void run() override;
+|1221|    |-};
+|1222|    |-
+|1223|    |-struct ShowSongInfo: BaseAction
+|1224|    |-{
+|1225|    |-	ShowSongInfo(): BaseAction(Type::ShowSongInfo, "show_song_info") { }
+|1226|    |-	
+|1227|    |-private:
+|1228|    |-	virtual void run() override;
+|1229|    |-};
+|1230|    |-
+|1231|    |-struct ShowArtistInfo: BaseAction
+|1232|    |-{
+|1233|    |-	ShowArtistInfo(): BaseAction(Type::ShowArtistInfo, "show_artist_info") { }
+|1234|    |-	
+|1235|    |-private:
+|1236|    |-	virtual bool canBeRun() override;
+|1237|    |-	virtual void run() override;
+|1238|    |-};
+|1239|    |-
+|1240|    |-struct ShowLyrics: BaseAction
+|1241|    |-{
+|1242|    |-	ShowLyrics(): BaseAction(Type::ShowLyrics, "show_lyrics") { }
+|1243|    |-	
+|1244|    |-private:
+|1245|    |-	virtual bool canBeRun() override;
+|1246|    |-	virtual void run() override;
+|1247|    |-
+|1248|    |-	const MPD::Song *m_song;
+|1249|    |-};
+|1250|    |-
+|1251|    |-struct Quit: BaseAction
+|1252|    |-{
+|1253|    |-	Quit(): BaseAction(Type::Quit, "quit") { }
+|1254|    |-	
+|1255|    |-private:
+|1256|    |-	virtual void run() override;
+|1257|    |-};
+|1258|    |-
+|1259|    |-struct NextScreen: BaseAction
+|1260|    |-{
+|1261|    |-	NextScreen(): BaseAction(Type::NextScreen, "next_screen") { }
+|1262|    |-	
+|1263|    |-private:
+|1264|    |-	virtual void run() override;
+|1265|    |-};
+|1266|    |-
+|1267|    |-struct PreviousScreen: BaseAction
+|1268|    |-{
+|1269|    |-	PreviousScreen(): BaseAction(Type::PreviousScreen, "previous_screen") { }
+|1270|    |-	
+|1271|    |-private:
+|1272|    |-	virtual void run() override;
+|1273|    |-};
+|1274|    |-
+|1275|    |-struct ShowHelp: BaseAction
+|1276|    |-{
+|1277|    |-	ShowHelp(): BaseAction(Type::ShowHelp, "show_help") { }
+|1278|    |-	
+|1279|    |-private:
+|1280|    |-	virtual bool canBeRun() override;
+|1281|    |-	virtual void run() override;
+|1282|    |-};
+|1283|    |-
+|1284|    |-struct ShowPlaylist: BaseAction
+|1285|    |-{
+|1286|    |-	ShowPlaylist(): BaseAction(Type::ShowPlaylist, "show_playlist") { }
+|1287|    |-	
+|1288|    |-private:
+|1289|    |-	virtual bool canBeRun() override;
+|1290|    |-	virtual void run() override;
+|1291|    |-};
+|1292|    |-
+|1293|    |-struct ShowBrowser: BaseAction
+|1294|    |-{
+|1295|    |-	ShowBrowser(): BaseAction(Type::ShowBrowser, "show_browser") { }
+|1296|    |-	
+|1297|    |-private:
+|1298|    |-	virtual bool canBeRun() override;
+|1299|    |-	virtual void run() override;
+|1300|    |-};
+|1301|    |-
+|1302|    |-struct ChangeBrowseMode: BaseAction
+|1303|    |-{
+|1304|    |-	ChangeBrowseMode(): BaseAction(Type::ChangeBrowseMode, "change_browse_mode") { }
+|1305|    |-	
+|1306|    |-private:
+|1307|    |-	virtual bool canBeRun() override;
+|1308|    |-	virtual void run() override;
+|1309|    |-};
+|1310|    |-
+|1311|    |-struct ShowSearchEngine: BaseAction
+|1312|    |-{
+|1313|    |-	ShowSearchEngine(): BaseAction(Type::ShowSearchEngine, "show_search_engine") { }
+|1314|    |-	
+|1315|    |-private:
+|1316|    |-	virtual bool canBeRun() override;
+|1317|    |-	virtual void run() override;
+|1318|    |-};
+|1319|    |-
+|1320|    |-struct ResetSearchEngine: BaseAction
+|1321|    |-{
+|1322|    |-	ResetSearchEngine(): BaseAction(Type::ResetSearchEngine, "reset_search_engine") { }
+|1323|    |-	
+|1324|    |-private:
+|1325|    |-	virtual bool canBeRun() override;
+|1326|    |-	virtual void run() override;
+|1327|    |-};
+|1328|    |-
+|1329|    |-struct ShowMediaLibrary: BaseAction
+|1330|    |-{
+|1331|    |-	ShowMediaLibrary(): BaseAction(Type::ShowMediaLibrary, "show_media_library") { }
+|1332|    |-	
+|1333|    |-private:
+|1334|    |-	virtual bool canBeRun() override;
+|1335|    |-	virtual void run() override;
+|1336|    |-};
+|1337|    |-
+|1338|    |-struct ToggleMediaLibraryColumnsMode: BaseAction
+|1339|    |-{
+|1340|    |-	ToggleMediaLibraryColumnsMode()
+|1341|    |-	: BaseAction(Type::ToggleMediaLibraryColumnsMode, "toggle_media_library_columns_mode") { }
+|1342|    |-	
+|1343|    |-private:
+|1344|    |-	virtual bool canBeRun() override;
+|1345|    |-	virtual void run() override;
+|1346|    |-};
+|1347|    |-
+|1348|    |-struct ShowPlaylistEditor: BaseAction
+|1349|    |-{
+|1350|    |-	ShowPlaylistEditor(): BaseAction(Type::ShowPlaylistEditor, "show_playlist_editor") { }
+|1351|    |-	
+|1352|    |-private:
+|1353|    |-	virtual bool canBeRun() override;
+|1354|    |-	virtual void run() override;
+|1355|    |-};
+|1356|    |-
+|1357|    |-struct ShowTagEditor: BaseAction
+|1358|    |-{
+|1359|    |-	ShowTagEditor(): BaseAction(Type::ShowTagEditor, "show_tag_editor") { }
+|1360|    |-	
+|1361|    |-private:
+|1362|    |-	virtual bool canBeRun() override;
+|1363|    |-	virtual void run() override;
+|1364|    |-};
+|1365|    |-
+|1366|    |-struct ShowOutputs: BaseAction
+|1367|    |-{
+|1368|    |-	ShowOutputs(): BaseAction(Type::ShowOutputs, "show_outputs") { }
+|1369|    |-	
+|1370|    |-private:
+|1371|    |-	virtual bool canBeRun() override;
+|1372|    |-	virtual void run() override;
+|1373|    |-};
+|1374|    |-
+|1375|    |-struct ShowVisualizer: BaseAction
+|1376|    |-{
+|1377|    |-	ShowVisualizer(): BaseAction(Type::ShowVisualizer, "show_visualizer") { }
+|1378|    |-	
+|1379|    |-private:
+|1380|    |-	virtual bool canBeRun() override;
+|1381|    |-	virtual void run() override;
+|1382|    |-};
+|1383|    |-
+|1384|    |-struct ShowClock: BaseAction
+|1385|    |-{
+|1386|    |-	ShowClock(): BaseAction(Type::ShowClock, "show_clock") { }
+|1387|    |-	
+|1388|    |-private:
+|1389|    |-	virtual bool canBeRun() override;
+|1390|    |-	virtual void run() override;
+|1391|    |-};
+|1392|    |-
+|1393|    |-struct ShowServerInfo: BaseAction
+|1394|    |-{
+|1395|    |-	ShowServerInfo(): BaseAction(Type::ShowServerInfo, "show_server_info") { }
+|1396|    |-	
+|1397|    |-private:
+|1398|    |-#	ifdef HAVE_TAGLIB_H
+|1399|    |-	virtual bool canBeRun() override;
+|1400|    |-#	endif // HAVE_TAGLIB_H
+|1401|    |-	virtual void run() override;
+|1402|    |-};
+|1403|    |-
+|1404|    |-}
+|1405|    |-
+|1406| 180| #endif // NCMPCPP_ACTIONS_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.h
+|    |++++| /app/src/screens/help.h
+|  25|  25| #include "interfaces.h"
+|  26|  26| #include "screens/screen.h"
+|  27|  27| 
+|  28|    |-struct Help: Screen<NC::Scrollpad>, Tabbable
+|    |  28|+struct Help:Screen <
+|    |  29|+    NC::Scrollpad >,
+|    |  30|+    Tabbable
+|  29|  31| {
+|  30|    |-	Help();
+|  31|    |-	
+|  32|    |-	virtual void resize() override;
+|  33|    |-	virtual void switchTo() override;
+|  34|    |-	
+|  35|    |-	virtual std::wstring title() override;
+|  36|    |-	virtual ScreenType type() override { return ScreenType::Help; }
+|  37|    |-	
+|  38|    |-	virtual void update() override { }
+|  39|    |-	
+|  40|    |-	virtual bool isLockable() override { return true; }
+|  41|    |-	virtual bool isMergable() override { return true; }
+|    |  32|+    Help ();
+|    |  33|+
+|    |  34|+    virtual void
+|    |  35|+    resize ()
+|    |  36|+        override;
+|    |  37|+    virtual void
+|    |  38|+    switchTo ()
+|    |  39|+        override;
+|    |  40|+
+|    |  41|+    virtual
+|    |  42|+        std::wstring
+|    |  43|+    title ()
+|    |  44|+        override;
+|    |  45|+    virtual ScreenType
+|    |  46|+    type ()
+|    |  47|+        override
+|    |  48|+    {
+|    |  49|+        return ScreenType::Help;
+|    |  50|+    }
+|    |  51|+
+|    |  52|+    virtual void
+|    |  53|+    update ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+    }
+|    |  57|+
+|    |  58|+    virtual bool
+|    |  59|+    isLockable ()
+|    |  60|+        override
+|    |  61|+    {
+|    |  62|+        return true;
+|    |  63|+    }
+|    |  64|+    virtual bool
+|    |  65|+    isMergable ()
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+        return true;
+|    |  69|+    }
+|  42|  70| };
+|  43|  71| 
+|  44|  72| extern Help *myHelp;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.h
+|    |++++| /app/src/screens/help.h
+|  41|  41| 	virtual bool isMergable() override { return true; }
+|  42|  42| };
+|  43|  43| 
+|  44|    |-extern Help *myHelp;
+|    |  44|+extern Help *
+|    |  45|+    myHelp;
+|  45|  46| 
+|  46|  47| #endif // NCMPCPP_HELP_H
+|  47|  48| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.h
+|    |++++| /app/src/screens/help.h
+|  44|  44| extern Help *myHelp;
+|  45|  45| 
+|  46|  46| #endif // NCMPCPP_HELP_H
+|  47|    |-
+Executing section yaml...
+Executing section c++...
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  30|  30| #include "mpdpp.h"
+|  31|  31| #include "screens/screen.h"
+|  32|  32| 
+|  33|    |-struct Outputs: Screen<NC::Menu<MPD::Output>>, Tabbable
+|    |  33|+struct Outputs:Screen <
+|    |  34|+    NC::Menu <
+|    |  35|+    MPD::Output >>,
+|    |  36|+    Tabbable
+|  34|  37| {
+|  35|    |-	Outputs();
+|  36|    |-	
+|  37|    |-	// Screen< NC::Menu<MPD::Output> > implementation
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	
+|  41|    |-	virtual std::wstring title() override;
+|  42|    |-	virtual ScreenType type() override { return ScreenType::Outputs; }
+|  43|    |-	
+|  44|    |-	virtual void update() override { }
+|  45|    |-	
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// private members
+|  52|    |-	void fetchList();
+|  53|    |-	void toggleOutput();
+|    |  38|+    Outputs ();
+|    |  39|+
+|    |  40|+    // Screen< NC::Menu<MPD::Output> > implementation
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|    |  47|+
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::Outputs;
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    virtual void
+|    |  60|+    update ()
+|    |  61|+        override
+|    |  62|+    {
+|    |  63|+    }
+|    |  64|+
+|    |  65|+    virtual void
+|    |  66|+    mouseButtonPressed (MEVENT me)
+|    |  67|+        override;
+|    |  68|+
+|    |  69|+    virtual bool
+|    |  70|+    isLockable ()
+|    |  71|+        override
+|    |  72|+    {
+|    |  73|+        return true;
+|    |  74|+    }
+|    |  75|+    virtual bool
+|    |  76|+    isMergable ()
+|    |  77|+        override
+|    |  78|+    {
+|    |  79|+        return true;
+|    |  80|+    }
+|    |  81|+
+|    |  82|+    // private members
+|    |  83|+    void
+|    |  84|+    fetchList ();
+|    |  85|+    void
+|    |  86|+    toggleOutput ();
+|  54|  87| };
+|  55|  88| 
+|  56|  89| extern Outputs *myOutputs;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  53|  53| 	void toggleOutput();
+|  54|  54| };
+|  55|  55| 
+|  56|    |-extern Outputs *myOutputs;
+|    |  56|+extern Outputs *
+|    |  57|+    myOutputs;
+|  57|  58| 
+|  58|  59| #endif // ENABLE_OUTPUTS
+|  59|  60| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  58|  58| #endif // ENABLE_OUTPUTS
+|  59|  59| 
+|  60|  60| #endif // NCMPCPP_OUTPUTS_H
+|  61|    |-
+
+src/screens/outputs.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/outputs.h
+|  28| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/outputs.h
+|  29| #include•"menu.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'menu.h'
+
+src/screens/outputs.h
+|  30| #include•"mpdpp.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'mpdpp.h'
+
+src/screens/outputs.h
+|  31| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/outputs.h
+|  56| extern•Outputs•*myOutputs;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myOutputs'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+|  27|  27| #include "curses/formatted_color.h"
+|  28|  28| #include "curses/window.h"
+|  29|  29| 
+|  30|    |-namespace NC {
+|    |  30|+namespace NC
+|    |  31|+{
+|  31|  32| 
+|  32|  33| /// Buffer template class that stores text
+|  33|  34| /// along with its properties (colors/formatting).
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+|  31|  31| 
+|  32|  32| /// Buffer template class that stores text
+|  33|  33| /// along with its properties (colors/formatting).
+|  34|    |-template <typename CharT> class BasicBuffer
+|  35|    |-{
+|  36|    |-	struct Property
+|  37|    |-	{
+|  38|    |-		template <typename ArgT>
+|  39|    |-		Property(ArgT &&arg, size_t id_)
+|  40|    |-		: m_impl(std::forward<ArgT>(arg)), m_id(id_) { }
+|  41|    |-		
+|  42|    |-		size_t id() const { return m_id; }
+|  43|    |-
+|  44|    |-		bool operator==(const Property &rhs) const
+|  45|    |-		{
+|  46|    |-			return m_id == rhs.m_id && m_impl == rhs.m_impl;
+|  47|    |-		}
+|  48|    |-
+|  49|    |-		template <typename OutputStreamT>
+|  50|    |-		friend OutputStreamT &operator<<(OutputStreamT &os, const Property &p)
+|  51|    |-		{
+|  52|    |-			boost::apply_visitor([&os](const auto &v) { os << v; }, p.m_impl);
+|  53|    |-			return os;
+|  54|    |-		}
+|  55|    |-		
+|  56|    |-	private:
+|  57|    |-		boost::variant<Color,
+|  58|    |-		               Format,
+|  59|    |-		               FormattedColor,
+|  60|    |-		               FormattedColor::End<StorageKind::Value>
+|  61|    |-		               > m_impl;
+|  62|    |-		size_t m_id;
+|  63|    |-	};
+|  64|    |-	
+|  65|    |-public:
+|  66|    |-	typedef std::basic_string<CharT> StringType;
+|  67|    |-	typedef std::multimap<size_t, Property> Properties;
+|  68|    |-	
+|  69|    |-	const StringType &str() const { return m_string; }
+|  70|    |-	const Properties &properties() const { return m_properties; }
+|  71|    |-	
+|  72|    |-	template <typename PropertyT>
+|  73|    |-	void addProperty(size_t position, PropertyT &&property, size_t id = -1)
+|  74|    |-	{
+|  75|    |-		assert(position <= m_string.size());
+|  76|    |-		m_properties.emplace(position, Property(std::forward<PropertyT>(property), id));
+|  77|    |-	}
+|  78|    |-
+|  79|    |-	void removeProperties(size_t id = -1)
+|  80|    |-	{
+|  81|    |-		auto it = m_properties.begin();
+|  82|    |-		while (it != m_properties.end())
+|  83|    |-		{
+|  84|    |-			if (it->second.id() == id)
+|  85|    |-				m_properties.erase(it++);
+|  86|    |-			else
+|  87|    |-				++it;
+|  88|    |-		}
+|  89|    |-	}
+|  90|    |-
+|  91|    |-	bool empty() const
+|  92|    |-	{
+|  93|    |-		return m_string.empty() && m_properties.empty();
+|  94|    |-	}
+|  95|    |-
+|  96|    |-	void clear()
+|  97|    |-	{
+|  98|    |-		m_string.clear();
+|  99|    |-		m_properties.clear();
+| 100|    |-	}
+| 101|    |-	
+| 102|    |-	BasicBuffer<CharT> &operator<<(int n)
+| 103|    |-	{
+| 104|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 105|    |-		return *this;
+| 106|    |-	}
+| 107|    |-	
+| 108|    |-	BasicBuffer<CharT> &operator<<(long int n)
+| 109|    |-	{
+| 110|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 111|    |-		return *this;
+| 112|    |-	}
+| 113|    |-	
+| 114|    |-	BasicBuffer<CharT> &operator<<(unsigned int n)
+| 115|    |-	{
+| 116|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 117|    |-		return *this;
+| 118|    |-	}
+| 119|    |-	
+| 120|    |-	BasicBuffer<CharT> &operator<<(unsigned long int n)
+| 121|    |-	{
+| 122|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 123|    |-		return *this;
+| 124|    |-	}
+| 125|    |-	
+| 126|    |-	BasicBuffer<CharT> &operator<<(CharT c)
+| 127|    |-	{
+| 128|    |-		m_string += c;
+| 129|    |-		return *this;
+| 130|    |-	}
+| 131|    |-
+| 132|    |-	BasicBuffer<CharT> &operator<<(const CharT *s)
+| 133|    |-	{
+| 134|    |-		m_string += s;
+| 135|    |-		return *this;
+| 136|    |-	}
+| 137|    |-	
+| 138|    |-	BasicBuffer<CharT> &operator<<(const StringType &s)
+| 139|    |-	{
+| 140|    |-		m_string += s;
+| 141|    |-		return *this;
+| 142|    |-	}
+| 143|    |-	
+| 144|    |-	BasicBuffer<CharT> &operator<<(const Color &color)
+| 145|    |-	{
+| 146|    |-		addProperty(m_string.size(), color);
+| 147|    |-		return *this;
+| 148|    |-	}
+| 149|    |-	
+| 150|    |-	BasicBuffer<CharT> &operator<<(const Format &format)
+| 151|    |-	{
+| 152|    |-		addProperty(m_string.size(), format);
+| 153|    |-		return *this;
+| 154|    |-	}
+| 155|    |-
+| 156|    |-	// static variadic initializer. used instead of a proper constructor because
+| 157|    |-	// it's too polymorphic and would end up invoked as a copy/move constructor.
+| 158|    |-	template <typename... Args>
+| 159|    |-	static BasicBuffer init(Args&&... args)
+| 160|    |-	{
+| 161|    |-		BasicBuffer result;
+| 162|    |-		result.construct(std::forward<Args>(args)...);
+| 163|    |-		return result;
+| 164|    |-	}
+| 165|    |-
+| 166|    |-private:
+| 167|    |-	void construct() { }
+| 168|    |-	template <typename ArgT, typename... Args>
+| 169|    |-	void construct(ArgT &&arg, Args&&... args)
+| 170|    |-	{
+| 171|    |-		*this << std::forward<ArgT>(arg);
+| 172|    |-		construct(std::forward<Args>(args)...);
+| 173|    |-	}
+| 174|    |-
+| 175|    |-	StringType m_string;
+| 176|    |-	Properties m_properties;
+| 177|    |-};
+| 178|    |-
+| 179|    |-typedef BasicBuffer<char> Buffer;
+| 180|    |-typedef BasicBuffer<wchar_t> WBuffer;
+| 181|    |-
+| 182|    |-template <typename CharT>
+| 183|    |-bool operator==(const BasicBuffer<CharT> &lhs, const BasicBuffer<CharT> &rhs)
+| 184|    |-{
+| 185|    |-	return lhs.str() == rhs.str()
+| 186|    |-		&& lhs.properties() == rhs.properties();
+|    |  34|+    template < typename CharT > class BasicBuffer
+|    |  35|+    {
+|    |  36|+        struct Property
+|    |  37|+        {
+|    |  38|+            template < typename ArgT >
+|    |  39|+                Property (ArgT
+|    |  40|+                          && arg,
+|    |  41|+                          size_t id_):m_impl (std::forward < ArgT > (arg)),
+|    |  42|+                m_id (id_)
+|    |  43|+            {
+|    |  44|+            }
+|    |  45|+
+|    |  46|+            size_t id () const
+|    |  47|+            {
+|    |  48|+                return m_id;
+|    |  49|+            }
+|    |  50|+
+|    |  51|+            bool operator== (const Property & rhs) const
+|    |  52|+            {
+|    |  53|+                return m_id == rhs.m_id && m_impl == rhs.m_impl;
+|    |  54|+            }
+|    |  55|+
+|    |  56|+            template < typename OutputStreamT >
+|    |  57|+                friend OutputStreamT & operator<< (OutputStreamT & os,
+|    |  58|+                                                   const Property & p)
+|    |  59|+            {
+|    |  60|+                boost::apply_visitor ([&os] (const auto & v)
+|    |  61|+                                      {
+|    |  62|+                                      os << v;
+|    |  63|+                                      }, p.m_impl);
+|    |  64|+                return os;
+|    |  65|+            }
+|    |  66|+
+|    |  67|+          private:
+|    |  68|+            boost::variant < Color,
+|    |  69|+                Format,
+|    |  70|+                FormattedColor,
+|    |  71|+                FormattedColor::End < StorageKind::Value > >m_impl;
+|    |  72|+            size_t m_id;
+|    |  73|+        };
+|    |  74|+
+|    |  75|+      public:
+|    |  76|+        typedef std::basic_string < CharT > StringType;
+|    |  77|+        typedef std::multimap < size_t, Property > Properties;
+|    |  78|+
+|    |  79|+        const StringType & str () const
+|    |  80|+        {
+|    |  81|+            return m_string;
+|    |  82|+        }
+|    |  83|+        const Properties & properties () const
+|    |  84|+        {
+|    |  85|+            return m_properties;
+|    |  86|+        }
+|    |  87|+
+|    |  88|+        template < typename PropertyT >
+|    |  89|+            void addProperty (size_t position, PropertyT
+|    |  90|+                              && property, size_t id = -1)
+|    |  91|+        {
+|    |  92|+            assert (position <= m_string.size ());
+|    |  93|+            m_properties.emplace (position,
+|    |  94|+                                  Property (std::forward < PropertyT >
+|    |  95|+                                            (property), id));
+|    |  96|+        }
+|    |  97|+
+|    |  98|+        void removeProperties (size_t id = -1)
+|    |  99|+        {
+|    | 100|+            auto it = m_properties.begin ();
+|    | 101|+            while (it != m_properties.end ())
+|    | 102|+              {
+|    | 103|+                  if (it->second.id () == id)
+|    | 104|+                      m_properties.erase (it++);
+|    | 105|+                  else
+|    | 106|+                      ++it;
+|    | 107|+              }
+|    | 108|+        }
+|    | 109|+
+|    | 110|+        bool empty () const
+|    | 111|+        {
+|    | 112|+            return m_string.empty () && m_properties.empty ();
+|    | 113|+        }
+|    | 114|+
+|    | 115|+        void clear ()
+|    | 116|+        {
+|    | 117|+            m_string.clear ();
+|    | 118|+            m_properties.clear ();
+|    | 119|+        }
+|    | 120|+
+|    | 121|+        BasicBuffer < CharT > &operator<< (int n)
+|    | 122|+        {
+|    | 123|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 124|+            return *this;
+|    | 125|+        }
+|    | 126|+
+|    | 127|+        BasicBuffer < CharT > &operator<< (long int n)
+|    | 128|+        {
+|    | 129|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 130|+            return *this;
+|    | 131|+        }
+|    | 132|+
+|    | 133|+        BasicBuffer < CharT > &operator<< (unsigned int n)
+|    | 134|+        {
+|    | 135|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 136|+            return *this;
+|    | 137|+        }
+|    | 138|+
+|    | 139|+        BasicBuffer < CharT > &operator<< (unsigned long int n)
+|    | 140|+        {
+|    | 141|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 142|+            return *this;
+|    | 143|+        }
+|    | 144|+
+|    | 145|+        BasicBuffer < CharT > &operator<< (CharT c)
+|    | 146|+        {
+|    | 147|+            m_string += c;
+|    | 148|+            return *this;
+|    | 149|+        }
+|    | 150|+
+|    | 151|+        BasicBuffer < CharT > &operator<< (const CharT * s)
+|    | 152|+        {
+|    | 153|+            m_string += s;
+|    | 154|+            return *this;
+|    | 155|+        }
+|    | 156|+
+|    | 157|+        BasicBuffer < CharT > &operator<< (const StringType & s)
+|    | 158|+        {
+|    | 159|+            m_string += s;
+|    | 160|+            return *this;
+|    | 161|+        }
+|    | 162|+
+|    | 163|+        BasicBuffer < CharT > &operator<< (const Color & color)
+|    | 164|+        {
+|    | 165|+            addProperty (m_string.size (), color);
+|    | 166|+            return *this;
+|    | 167|+        }
+|    | 168|+
+|    | 169|+        BasicBuffer < CharT > &operator<< (const Format & format)
+|    | 170|+        {
+|    | 171|+            addProperty (m_string.size (), format);
+|    | 172|+            return *this;
+|    | 173|+        }
+|    | 174|+
+|    | 175|+        // static variadic initializer. used instead of a proper constructor because
+|    | 176|+        // it's too polymorphic and would end up invoked as a copy/move constructor.
+|    | 177|+        template < typename...Args > static BasicBuffer init (Args && ... args)
+|    | 178|+        {
+|    | 179|+            BasicBuffer result;
+|    | 180|+            result.construct (std::forward < Args > (args)...);
+|    | 181|+            return result;
+|    | 182|+        }
+|    | 183|+
+|    | 184|+      private:
+|    | 185|+        void construct ()
+|    | 186|+        {
+|    | 187|+        }
+|    | 188|+        template < typename ArgT, typename...Args >
+|    | 189|+            void construct (ArgT && arg, Args && ... args)
+|    | 190|+        {
+|    | 191|+            *this << std::forward < ArgT > (arg);
+|    | 192|+            construct (std::forward < Args > (args)...);
+|    | 193|+        }
+|    | 194|+
+|    | 195|+        StringType m_string;
+|    | 196|+        Properties m_properties;
+|    | 197|+    };
+|    | 198|+
+|    | 199|+    typedef BasicBuffer < char >Buffer;
+|    | 200|+    typedef BasicBuffer < wchar_t > WBuffer;
+|    | 201|+
+|    | 202|+    template < typename CharT >
+|    | 203|+        bool operator== (const BasicBuffer < CharT > &lhs,
+|    | 204|+                         const BasicBuffer < CharT > &rhs)
+|    | 205|+    {
+|    | 206|+        return lhs.str () == rhs.str ()
+|    | 207|+            && lhs.properties () == rhs.properties ();
+|    | 208|+    }
+|    | 209|+
+|    | 210|+    template < typename OutputStreamT, typename CharT >
+|    | 211|+        OutputStreamT & operator<< (OutputStreamT & os,
+|    | 212|+                                    const BasicBuffer < CharT > &buffer)
+|    | 213|+    {
+|    | 214|+        if (buffer.properties ().empty ())
+|    | 215|+            os << buffer.str ();
+|    | 216|+        else
+|    | 217|+          {
+|    | 218|+              auto & s = buffer.str ();
+|    | 219|+              auto & ps = buffer.properties ();
+|    | 220|+              auto p = ps.begin ();
+|    | 221|+              for (size_t i = 0;; ++i)
+|    | 222|+                {
+|    | 223|+                    for (; p != ps.end () && p->first == i; ++p)
+|    | 224|+                        os << p->second;
+|    | 225|+                    if (i < s.size ())
+|    | 226|+                        os << s[i];
+|    | 227|+                    else
+|    | 228|+                        break;
+|    | 229|+                }
+|    | 230|+          }
+|    | 231|+        return os;
+|    | 232|+    }
+|    | 233|+
+| 187| 234| }
+| 188| 235| 
+| 189| 236| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+| 186| 186| 		&& lhs.properties() == rhs.properties();
+| 187| 187| }
+| 188| 188| 
+| 189|    |-
+| 190|    |-template <typename OutputStreamT, typename CharT>
+| 191|    |-OutputStreamT &operator<<(OutputStreamT &os, const BasicBuffer<CharT> &buffer)
+| 192|    |-{
+| 193|    |-	if (buffer.properties().empty())
+| 194|    |-		os << buffer.str();
+| 195|    |-	else
+| 196|    |-	{
+| 197|    |-		auto &s = buffer.str();
+| 198|    |-		auto &ps = buffer.properties();
+| 199|    |-		auto p = ps.begin();
+| 200|    |-		for (size_t i = 0;; ++i)
+| 201|    |-		{
+| 202|    |-			for (; p != ps.end() && p->first == i; ++p)
+| 203|    |-				os << p->second;
+| 204|    |-			if (i < s.size())
+| 205|    |-				os << s[i];
+| 206|    |-			else
+| 207|    |-				break;
+| 208|    |-		}
+| 209|    |-	}
+| 210|    |-	return os;
+| 211|    |-}
+| 212|    |-
+| 213|    |-}
+| 214|    |-
+| 215| 189| #endif // NCMPCPP_STRBUFFER_H
+
+src/curses/strbuffer.h
+|  27| #include•"curses/formatted_color.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/formatted_color.h'
+
+src/curses/strbuffer.h
+|  28| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  34|  34| # include <fftw3.h>
+|  35|  35| #endif
+|  36|  36| 
+|  37|    |-struct Visualizer: Screen<NC::Window>, Tabbable
+|    |  37|+struct Visualizer:Screen <
+|    |  38|+    NC::Window >,
+|    |  39|+    Tabbable
+|  38|  40| {
+|  39|    |-	Visualizer();
+|    |  41|+    Visualizer ();
+|  40|  42| 
+|  41|    |-	virtual void switchTo() override;
+|  42|    |-	virtual void resize() override;
+|    |  43|+    virtual void
+|    |  44|+    switchTo ()
+|    |  45|+        override;
+|    |  46|+    virtual void
+|    |  47|+    resize ()
+|    |  48|+        override;
+|  43|  49| 
+|  44|    |-	virtual std::wstring title() override;
+|  45|    |-	virtual ScreenType type() override { return ScreenType::Visualizer; }
+|    |  50|+    virtual
+|    |  51|+        std::wstring
+|    |  52|+    title ()
+|    |  53|+        override;
+|    |  54|+    virtual ScreenType
+|    |  55|+    type ()
+|    |  56|+        override
+|    |  57|+    {
+|    |  58|+        return ScreenType::Visualizer;
+|    |  59|+    }
+|  46|  60| 
+|  47|    |-	virtual void update() override;
+|  48|    |-	virtual void scroll(NC::Scroll) override { }
+|    |  61|+    virtual void
+|    |  62|+    update ()
+|    |  63|+        override;
+|    |  64|+    virtual void
+|    |  65|+    scroll (NC::Scroll)
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+    }
+|  49|  69| 
+|  50|    |-	virtual int windowTimeout() override;
+|    |  70|+    virtual int
+|    |  71|+    windowTimeout ()
+|    |  72|+        override;
+|  51|  73| 
+|  52|    |-	virtual void mouseButtonPressed(MEVENT) override { }
+|    |  74|+    virtual void
+|    |  75|+    mouseButtonPressed (MEVENT)
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+    }
+|  53|  79| 
+|  54|    |-	virtual bool isLockable() override { return true; }
+|  55|    |-	virtual bool isMergable() override { return true; }
+|    |  80|+    virtual bool
+|    |  81|+    isLockable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|    |  86|+    virtual bool
+|    |  87|+    isMergable ()
+|    |  88|+        override
+|    |  89|+    {
+|    |  90|+        return true;
+|    |  91|+    }
+|  56|  92| 
+|  57|    |-	// private members
+|  58|    |-	void ToggleVisualizationType();
+|  59|    |-	void SetFD();
+|  60|    |-	void ResetFD();
+|  61|    |-	void FindOutputID();
+|  62|    |-	void ResetAutoScaleMultiplier();
+|    |  93|+    // private members
+|    |  94|+    void
+|    |  95|+    ToggleVisualizationType ();
+|    |  96|+    void
+|    |  97|+    SetFD ();
+|    |  98|+    void
+|    |  99|+    ResetFD ();
+|    | 100|+    void
+|    | 101|+    FindOutputID ();
+|    | 102|+    void
+|    | 103|+    ResetAutoScaleMultiplier ();
+|  63| 104| 
+|  64|    |-private:
+|  65|    |-	void DrawSoundWave(int16_t *, ssize_t, size_t, size_t);
+|  66|    |-	void DrawSoundWaveStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  67|    |-	void DrawSoundWaveFill(int16_t *, ssize_t, size_t, size_t);
+|  68|    |-	void DrawSoundWaveFillStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  69|    |-	void DrawSoundEllipse(int16_t *, ssize_t, size_t, size_t);
+|  70|    |-	void DrawSoundEllipseStereo(int16_t *, int16_t *, ssize_t, size_t);
+|    | 105|+  private:
+|    | 106|+    void
+|    | 107|+    DrawSoundWave (int16_t *, ssize_t, size_t, size_t);
+|    | 108|+    void
+|    | 109|+    DrawSoundWaveStereo (int16_t *, int16_t *, ssize_t, size_t);
+|    | 110|+    void
+|    | 111|+    DrawSoundWaveFill (int16_t *, ssize_t, size_t, size_t);
+|    | 112|+    void
+|    | 113|+    DrawSoundWaveFillStereo (int16_t *, int16_t *, ssize_t, size_t);
+|    | 114|+    void
+|    | 115|+    DrawSoundEllipse (int16_t *, ssize_t, size_t, size_t);
+|    | 116|+    void
+|    | 117|+    DrawSoundEllipseStereo (int16_t *, int16_t *, ssize_t, size_t);
+|  71| 118| #	ifdef HAVE_FFTW3_H
+|  72|    |-	void DrawFrequencySpectrum(int16_t *, ssize_t, size_t, size_t);
+|  73|    |-	void DrawFrequencySpectrumStereo(int16_t *, int16_t *, ssize_t, size_t);
+|    | 119|+    void
+|    | 120|+    DrawFrequencySpectrum (int16_t *, ssize_t, size_t, size_t);
+|    | 121|+    void
+|    | 122|+    DrawFrequencySpectrumStereo (int16_t *, int16_t *, ssize_t, size_t);
+|  74| 123| #	endif // HAVE_FFTW3_H
+|  75| 124| 
+|  76| 125| 	int m_output_id;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  73|  73| 	void DrawFrequencySpectrumStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  74|  74| #	endif // HAVE_FFTW3_H
+|  75|  75| 
+|  76|    |-	int m_output_id;
+|  77|    |-	boost::posix_time::ptime m_timer;
+|    |  76|+    int
+|    |  77|+        m_output_id;
+|    |  78|+    boost::posix_time::ptime m_timer;
+|  78|  79| 
+|  79|    |-	int m_fifo;
+|  80|    |-	size_t m_samples;
+|  81|    |-	double m_auto_scale_multiplier;
+|    |  80|+    int
+|    |  81|+        m_fifo;
+|    |  82|+    size_t
+|    |  83|+        m_samples;
+|    |  84|+    double
+|    |  85|+        m_auto_scale_multiplier;
+|  82|  86| #	ifdef HAVE_FFTW3_H
+|  83|    |-	size_t m_fftw_results;
+|  84|    |-	double *m_fftw_input;
+|  85|    |-	fftw_complex *m_fftw_output;
+|  86|    |-	fftw_plan m_fftw_plan;
+|    |  87|+    size_t
+|    |  88|+        m_fftw_results;
+|    |  89|+    double *
+|    |  90|+        m_fftw_input;
+|    |  91|+    fftw_complex *
+|    |  92|+        m_fftw_output;
+|    |  93|+    fftw_plan
+|    |  94|+        m_fftw_plan;
+|  87|  95| 
+|  88|    |-	std::vector<double> m_freq_magnitudes;
+|    |  96|+    std::vector < double >
+|    |  97|+        m_freq_magnitudes;
+|  89|  98| #	endif // HAVE_FFTW3_H
+|  90|  99| };
+|  91| 100| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  89|  89| #	endif // HAVE_FFTW3_H
+|  90|  90| };
+|  91|  91| 
+|  92|    |-extern Visualizer *myVisualizer;
+|    |  92|+extern Visualizer *
+|    |  93|+    myVisualizer;
+|  93|  94| 
+|  94|  95| #endif // ENABLE_VISUALIZER
+|  95|  96| 
+
+src/screens/visualizer.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/visualizer.h
+|  29| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+
+src/screens/visualizer.h
+|  30| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/visualizer.h
+|  31| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/visualizer.h
+|  92| extern•Visualizer•*myVisualizer;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myVisualizer'
+
+src/utility/readline.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  27|  27| #include "actions.h"
+|  28|  28| #include "macro_utilities.h"
+|  29|  29| 
+|  30|    |-NC::Key::Type readKey(NC::Window &w);
+|  31|    |-std::wstring keyToWString(const NC::Key::Type key);
+|    |  30|+NC::Key::Type readKey (NC::Window & w);
+|    |  31|+std::wstring keyToWString (const NC::Key::Type key);
+|  32|  32| 
+|  33|  33| /// Represents either single action or chain of actions bound to a certain key
+|  34|  34| struct Binding
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  33|  33| /// Represents either single action or chain of actions bound to a certain key
+|  34|  34| struct Binding
+|  35|  35| {
+|  36|    |-	typedef std::vector<std::shared_ptr<Actions::BaseAction>> ActionChain;
+|    |  36|+    typedef std::vector < std::shared_ptr < Actions::BaseAction >> ActionChain;
+|  37|  37| 
+|  38|    |-	template <typename ArgT>
+|  39|    |-	Binding(ArgT &&actions_)
+|  40|    |-	: m_actions(std::forward<ArgT>(actions_)) {
+|  41|    |-		assert(!m_actions.empty());
+|  42|    |-	}
+|  43|    |-	Binding(Actions::Type at)
+|  44|    |-	: Binding(ActionChain({Actions::get_(at)})) { }
+|    |  38|+      template < typename ArgT >
+|    |  39|+        Binding (ArgT && actions_):m_actions (std::forward < ArgT > (actions_))
+|    |  40|+    {
+|    |  41|+        assert (!m_actions.empty ());
+|    |  42|+    }
+|    |  43|+    Binding (Actions::Type at):Binding (ActionChain (
+|    |  44|+                                                        {
+|    |  45|+                                                        Actions::get_ (at)}))
+|    |  46|+    {
+|    |  47|+    }
+|  45|  48| 
+|  46|    |-	bool execute() const {
+|  47|    |-		return std::all_of(m_actions.begin(), m_actions.end(),
+|  48|    |-			std::bind(&Actions::BaseAction::execute, std::placeholders::_1)
+|  49|    |-		);
+|  50|    |-	}
+|    |  49|+    bool execute () const
+|    |  50|+    {
+|    |  51|+        return std::all_of (m_actions.begin (), m_actions.end (),
+|    |  52|+                            std::bind (&Actions::BaseAction::execute,
+|    |  53|+                                       std::placeholders::_1));
+|    |  54|+    }
+|  51|  55| 
+|  52|    |-	bool isSingle() const {
+|  53|    |-		return m_actions.size() == 1;
+|  54|    |-	}
+|    |  56|+    bool isSingle () const
+|    |  57|+    {
+|    |  58|+        return m_actions.size () == 1;
+|    |  59|+    }
+|  55|  60| 
+|  56|    |-	Actions::BaseAction &action() const {
+|  57|    |-		assert(isSingle());
+|  58|    |-		assert(m_actions[0] != nullptr);
+|  59|    |-		return *m_actions[0];
+|  60|    |-	}
+|    |  61|+    Actions::BaseAction & action () const
+|    |  62|+    {
+|    |  63|+        assert (isSingle ());
+|    |  64|+        assert (m_actions[0] != nullptr);
+|    |  65|+        return *m_actions[0];
+|    |  66|+    }
+|  61|  67| 
+|  62|    |-	const ActionChain &actions() const {
+|  63|    |-		return m_actions;
+|  64|    |-	}
+|    |  68|+    const ActionChain & actions () const
+|    |  69|+    {
+|    |  70|+        return m_actions;
+|    |  71|+    }
+|  65|  72| 
+|  66|    |-private:
+|  67|    |-	ActionChain m_actions;
+|    |  73|+  private:
+|    |  74|+      ActionChain m_actions;
+|  68|  75| };
+|  69|  76| 
+|  70|  77| /// Represents executable command
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  70|  70| /// Represents executable command
+|  71|  71| struct Command
+|  72|  72| {
+|  73|    |-	template <typename ArgT>
+|  74|    |-	Command(ArgT &&binding_, bool immediate_)
+|  75|    |-	: m_impl(std::forward<ArgT>(binding_), immediate_) { }
+|    |  73|+    template < typename ArgT >
+|    |  74|+        Command (ArgT
+|    |  75|+                 && binding_,
+|    |  76|+                 bool immediate_):m_impl (std::forward < ArgT > (binding_),
+|    |  77|+                                          immediate_)
+|    |  78|+    {
+|    |  79|+    }
+|  76|  80| 
+|  77|    |-	const Binding &binding() const { return std::get<0>(m_impl); }
+|  78|    |-	bool immediate() const { return std::get<1>(m_impl); }
+|    |  81|+    const Binding & binding () const
+|    |  82|+    {
+|    |  83|+        return std::get < 0 > (m_impl);
+|    |  84|+    }
+|    |  85|+    bool immediate () const
+|    |  86|+    {
+|    |  87|+        return std::get < 1 > (m_impl);
+|    |  88|+    }
+|  79|  89| 
+|  80|    |-private:
+|  81|    |-	std::tuple<Binding, bool> m_impl;
+|    |  90|+  private:
+|    |  91|+      std::tuple < Binding, bool > m_impl;
+|  82|  92| };
+|  83|  93| 
+|  84|  94| /// Keybindings configuration
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  84|  84| /// Keybindings configuration
+|  85|  85| class BindingsConfiguration
+|  86|  86| {
+|  87|    |-	typedef std::unordered_map<std::string, Command> CommandsSet;
+|  88|    |-	typedef std::unordered_map<NC::Key::Type, std::vector<Binding>> BindingsMap;
+|    |  87|+    typedef std::unordered_map < std::string, Command > CommandsSet;
+|    |  88|+    typedef std::unordered_map < NC::Key::Type,
+|    |  89|+        std::vector < Binding >> BindingsMap;
+|  89|  90| 
+|  90|    |-public:
+|  91|    |-	typedef BindingsMap::value_type::second_type::iterator BindingIterator;
+|  92|    |-	typedef BindingsMap::value_type::second_type::const_iterator ConstBindingIterator;
+|  93|    |-	typedef std::pair<BindingIterator, BindingIterator> BindingIteratorPair;
+|    |  91|+  public:
+|    |  92|+    typedef BindingsMap::value_type::second_type::iterator BindingIterator;
+|    |  93|+    typedef BindingsMap::value_type::second_type::
+|    |  94|+        const_iterator ConstBindingIterator;
+|    |  95|+    typedef std::pair < BindingIterator, BindingIterator > BindingIteratorPair;
+|  94|  96| 
+|  95|    |-	bool read(const std::vector<std::string> &binding_paths);
+|  96|    |-	void generateDefaults();
+|    |  97|+    bool read (const std::vector < std::string > &binding_paths);
+|    |  98|+    void generateDefaults ();
+|  97|  99| 
+|  98|    |-	const Command *findCommand(const std::string &name);
+|  99|    |-	BindingIteratorPair get(const NC::Key::Type &k);
+|    | 100|+    const Command *findCommand (const std::string & name);
+|    | 101|+    BindingIteratorPair get (const NC::Key::Type & k);
+| 100| 102| 
+| 101|    |-	BindingsMap::const_iterator begin() const { return m_bindings.begin(); }
+| 102|    |-	BindingsMap::const_iterator end() const { return m_bindings.end(); }
+|    | 103|+      BindingsMap::const_iterator begin () const
+|    | 104|+    {
+|    | 105|+        return m_bindings.begin ();
+|    | 106|+    }
+|    | 107|+    BindingsMap::const_iterator end () const
+|    | 108|+    {
+|    | 109|+        return m_bindings.end ();
+|    | 110|+    }
+| 103| 111| 
+| 104|    |-private:
+| 105|    |-	bool notBound(const NC::Key::Type &k) const {
+| 106|    |-		return k != NC::Key::None && m_bindings.find(k) == m_bindings.end();
+| 107|    |-	}
+|    | 112|+  private:
+|    | 113|+      bool notBound (const NC::Key::Type & k) const
+|    | 114|+    {
+|    | 115|+        return k != NC::Key::None && m_bindings.find (k) == m_bindings.end ();
+|    | 116|+    }
+| 108| 117| 
+| 109|    |-	template <typename ArgT>
+| 110|    |-	void bind(NC::Key::Type k, ArgT &&t) {
+| 111|    |-		m_bindings[k].push_back(std::forward<ArgT>(t));
+| 112|    |-	}
+|    | 118|+    template < typename ArgT > void bind (NC::Key::Type k, ArgT && t)
+|    | 119|+    {
+|    | 120|+        m_bindings[k].push_back (std::forward < ArgT > (t));
+|    | 121|+    }
+| 113| 122| 
+| 114|    |-	bool read(const std::string &file);
+|    | 123|+    bool read (const std::string & file);
+| 115| 124| 
+| 116|    |-	BindingsMap m_bindings;
+| 117|    |-	CommandsSet m_commands;
+|    | 125|+    BindingsMap m_bindings;
+|    | 126|+    CommandsSet m_commands;
+| 118| 127| };
+| 119| 128| 
+| 120| 129| extern BindingsConfiguration Bindings;
+
+src/bindings.h
+|  28| #include•"macro_utilities.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'macro_utilities.h' does not need to be #included
+
+src/bindings.h
+| 120| extern•BindingsConfiguration•Bindings;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Bindings'
+
+src/bindings.h
+| 196| The line belonging to the following result cannot be printed because it refers to a line that doesn't seem to exist in the given file.
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/charset.cpp
+|    |++++| /app/src/charset.cpp
+|  22|  22| #include "charset.h"
+|  23|  23| #include "settings.h"
+|  24|  24| 
+|  25|    |-namespace Charset {
+|    |  25|+namespace Charset
+|    |  26|+{
+|  26|  27| 
+|  27|    |-std::locale internalLocale()
+|  28|    |-{
+|  29|    |-	boost::locale::generator gen;
+|  30|    |-	std::locale loc = gen("");
+|  31|    |-	bool is_utf = std::use_facet<boost::locale::info>(loc).utf8();
+|  32|    |-	std::string name = std::use_facet<boost::locale::info>(loc).name();
+|  33|    |-	if (!is_utf && name != "C" && name != "POSIX")
+|  34|    |-	{
+|  35|    |-		// if current locale does not use unicode, use variant of this
+|  36|    |-		// locale with utf8 as ncmpcpp uses utf8 internally and we need
+|  37|    |-		// current locale for sorting, case conversions etc.
+|  38|    |-		std::string new_name = std::use_facet<boost::locale::info>(loc).language()
+|  39|    |-		                     + "_"
+|  40|    |-		                     + std::use_facet<boost::locale::info>(loc).country()
+|  41|    |-		                     + ".UTF-8";
+|  42|    |-		loc = gen(new_name);
+|  43|    |-	}
+|  44|    |-	return loc;
+|  45|    |-}
+|    |  28|+    std::locale internalLocale ()
+|    |  29|+    {
+|    |  30|+        boost::locale::generator gen;
+|    |  31|+        std::locale loc = gen ("");
+|    |  32|+        bool is_utf = std::use_facet < boost::locale::info > (loc).utf8 ();
+|    |  33|+          std::string name =
+|    |  34|+            std::use_facet < boost::locale::info > (loc).name ();
+|    |  35|+        if (!is_utf && name != "C" && name != "POSIX")
+|    |  36|+          {
+|    |  37|+              // if current locale does not use unicode, use variant of this
+|    |  38|+              // locale with utf8 as ncmpcpp uses utf8 internally and we need
+|    |  39|+              // current locale for sorting, case conversions etc.
+|    |  40|+              std::string new_name =
+|    |  41|+                  std::use_facet < boost::locale::info >
+|    |  42|+                  (loc).language () + "_" + std::use_facet <
+|    |  43|+                  boost::locale::info > (loc).country () + ".UTF-8";
+|    |  44|+              loc = gen (new_name);
+|    |  45|+          }
+|    |  46|+        return loc;
+|    |  47|+    }
+|  46|  48| 
+|  47|    |-std::string toUtf8From(const std::string &s, const char *charset)
+|  48|    |-{
+|  49|    |-	return boost::locale::conv::to_utf<char>(s, charset);
+|  50|    |-}
+|    |  49|+    std::string toUtf8From (const std::string & s, const char *charset)
+|    |  50|+    {
+|    |  51|+        return boost::locale::conv::to_utf < char >(s, charset);
+|    |  52|+    }
+|  51|  53| 
+|  52|    |-std::string fromUtf8To(const std::string &s, const char *charset)
+|  53|    |-{
+|  54|    |-	return boost::locale::conv::to_utf<char>(s, charset);
+|  55|    |-}
+|    |  54|+    std::string fromUtf8To (const std::string & s, const char *charset)
+|    |  55|+    {
+|    |  56|+        return boost::locale::conv::to_utf < char >(s, charset);
+|    |  57|+    }
+|  56|  58| 
+|  57|    |-std::string utf8ToLocale(const std::string &s)
+|  58|    |-{
+|  59|    |-	return Config.system_encoding.empty()
+|  60|    |-	     ? s
+|  61|    |-	     : boost::locale::conv::from_utf<char>(s, Config.system_encoding);
+|  62|    |-}
+|    |  59|+    std::string utf8ToLocale (const std::string & s)
+|    |  60|+    {
+|    |  61|+        return Config.system_encoding.empty ()? s
+|    |  62|+            : boost::locale::conv::from_utf < char >(s,
+|    |  63|+                                                     Config.system_encoding);
+|    |  64|+    }
+|  63|  65| 
+|  64|    |-std::string localeToUtf8(const std::string &s)
+|  65|    |-{
+|  66|    |-	return Config.system_encoding.empty()
+|  67|    |-	     ? s
+|  68|    |-	     : boost::locale::conv::to_utf<char>(s, Config.system_encoding);
+|  69|    |-}
+|    |  66|+    std::string localeToUtf8 (const std::string & s)
+|    |  67|+    {
+|    |  68|+        return Config.system_encoding.empty ()? s
+|    |  69|+            : boost::locale::conv::to_utf < char >(s, Config.system_encoding);
+|    |  70|+    }
+|  70|  71| 
+|  71|    |-std::string utf8ToLocale(std::string &&s)
+|  72|    |-{
+|  73|    |-	if (!Config.system_encoding.empty())
+|  74|    |-		s = boost::locale::conv::from_utf<char>(s, Config.system_encoding);
+|  75|    |-	return std::move(s);
+|  76|    |-}
+|    |  72|+    std::string utf8ToLocale (std::string && s)
+|    |  73|+    {
+|    |  74|+        if (!Config.system_encoding.empty ())
+|    |  75|+            s = boost::locale::conv::from_utf < char >(s,
+|    |  76|+                                                       Config.system_encoding);
+|    |  77|+        return std::move (s);
+|    |  78|+    }
+|  77|  79| 
+|  78|    |-std::string localeToUtf8(std::string &&s)
+|  79|    |-{
+|  80|    |-	if (!Config.system_encoding.empty())
+|  81|    |-		s = boost::locale::conv::to_utf<char>(s, Config.system_encoding);
+|  82|    |-	return std::move(s);
+|  83|    |-}
+|    |  80|+    std::string localeToUtf8 (std::string && s)
+|    |  81|+    {
+|    |  82|+        if (!Config.system_encoding.empty ())
+|    |  83|+            s = boost::locale::conv::to_utf < char >(s,
+|    |  84|+                                                     Config.system_encoding);
+|    |  85|+        return std::move (s);
+|    |  86|+    }
+|  84|  87| 
+|  85|  88| }
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sel_items_adder.h
+|    |++++| /app/src/screens/sel_items_adder.h
+|  27|  27| #include "screens/screen.h"
+|  28|  28| #include "song.h"
+|  29|  29| 
+|  30|    |-struct SelectedItemsAdder: Screen<NC::Menu<RunnableItem<std::string, void()>> *>, HasActions, Searchable, Tabbable
+|    |  30|+struct SelectedItemsAdder:Screen <
+|    |  31|+    NC::Menu <
+|    |  32|+    RunnableItem <
+|    |  33|+std::string, void () >> *>,
+|    |  34|+    HasActions,
+|    |  35|+    Searchable,
+|    |  36|+    Tabbable
+|  31|  37| {
+|  32|    |-	typedef SelectedItemsAdder Self;
+|  33|    |-	typedef typename std::remove_pointer<WindowType>::type Component;
+|  34|    |-	typedef Component::Item::Type Entry;
+|  35|    |-	
+|  36|    |-	SelectedItemsAdder();
+|  37|    |-	
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	virtual void refresh() override;
+|  41|    |-	
+|  42|    |-	virtual std::wstring title() override;
+|  43|    |-	virtual ScreenType type() override { return ScreenType::SelectedItemsAdder; }
+|  44|    |-	
+|  45|    |-	virtual void update() override { }
+|  46|    |-	
+|  47|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  48|    |-	
+|  49|    |-	virtual bool isLockable() override { return false; }
+|  50|    |-	virtual bool isMergable() override { return false; }
+|    |  38|+    typedef SelectedItemsAdder
+|    |  39|+        Self;
+|    |  40|+    typedef typename
+|    |  41|+        std::remove_pointer <
+|    |  42|+        WindowType >::type
+|    |  43|+        Component;
+|    |  44|+    typedef
+|    |  45|+        Component::Item::Type
+|    |  46|+        Entry;
+|  51|  47| 
+|  52|    |-	// HasActions implementation
+|  53|    |-	virtual bool actionRunnable() override;
+|  54|    |-	virtual void runAction() override;
+|    |  48|+    SelectedItemsAdder ();
+|  55|  49| 
+|  56|    |-	// Searchable implementation
+|  57|    |-	virtual bool allowsSearching() override;
+|  58|    |-	virtual const std::string &searchConstraint() override;
+|  59|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  60|    |-	virtual void clearSearchConstraint() override;
+|  61|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|    |  50|+    virtual void
+|    |  51|+    switchTo ()
+|    |  52|+        override;
+|    |  53|+    virtual void
+|    |  54|+    resize ()
+|    |  55|+        override;
+|    |  56|+    virtual void
+|    |  57|+    refresh ()
+|    |  58|+        override;
+|  62|  59| 
+|  63|    |-private:
+|  64|    |-	void populatePlaylistSelector(BaseScreen *screen);
+|  65|    |-	
+|  66|    |-	void addToCurrentPlaylist();
+|  67|    |-	void addToNewPlaylist() const;
+|  68|    |-	void addToExistingPlaylist(const std::string &playlist) const;
+|  69|    |-	void addAtTheEndOfPlaylist() const;
+|  70|    |-	void addAtTheBeginningOfPlaylist() const;
+|  71|    |-	void addAfterCurrentSong() const;
+|  72|    |-	void addAfterCurrentAlbum() const;
+|  73|    |-	void addAfterHighlightedSong() const;
+|  74|    |-	void cancel();
+|  75|    |-	void exitSuccessfully(bool success) const;
+|  76|    |-	
+|  77|    |-	void setDimensions();
+|  78|    |-	
+|  79|    |-	size_t m_playlist_selector_width;
+|  80|    |-	size_t m_playlist_selector_height;
+|  81|    |-	
+|  82|    |-	size_t m_position_selector_width;
+|  83|    |-	size_t m_position_selector_height;
+|  84|    |-	
+|  85|    |-	Component m_playlist_selector;
+|  86|    |-	Component m_position_selector;
+|  87|    |-	
+|  88|    |-	std::vector<MPD::Song> m_selected_items;
+|    |  60|+    virtual
+|    |  61|+        std::wstring
+|    |  62|+    title ()
+|    |  63|+        override;
+|    |  64|+    virtual ScreenType
+|    |  65|+    type ()
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+        return ScreenType::SelectedItemsAdder;
+|    |  69|+    }
+|  89|  70| 
+|  90|    |-	Regex::ItemFilter<Entry> m_search_predicate;
+|    |  71|+    virtual void
+|    |  72|+    update ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+    }
+|    |  76|+
+|    |  77|+    virtual void
+|    |  78|+    mouseButtonPressed (MEVENT me)
+|    |  79|+        override;
+|    |  80|+
+|    |  81|+    virtual bool
+|    |  82|+    isLockable ()
+|    |  83|+        override
+|    |  84|+    {
+|    |  85|+        return false;
+|    |  86|+    }
+|    |  87|+    virtual bool
+|    |  88|+    isMergable ()
+|    |  89|+        override
+|    |  90|+    {
+|    |  91|+        return false;
+|    |  92|+    }
+|    |  93|+
+|    |  94|+    // HasActions implementation
+|    |  95|+    virtual bool
+|    |  96|+    actionRunnable ()
+|    |  97|+        override;
+|    |  98|+    virtual void
+|    |  99|+    runAction ()
+|    | 100|+        override;
+|    | 101|+
+|    | 102|+    // Searchable implementation
+|    | 103|+    virtual bool
+|    | 104|+    allowsSearching ()
+|    | 105|+        override;
+|    | 106|+    virtual const
+|    | 107|+        std::string &
+|    | 108|+    searchConstraint ()
+|    | 109|+        override;
+|    | 110|+    virtual void
+|    | 111|+    setSearchConstraint (const std::string & constraint)
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    clearSearchConstraint ()
+|    | 115|+        override;
+|    | 116|+    virtual bool
+|    | 117|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 118|+        override;
+|    | 119|+
+|    | 120|+  private:
+|    | 121|+    void
+|    | 122|+    populatePlaylistSelector (BaseScreen * screen);
+|    | 123|+
+|    | 124|+    void
+|    | 125|+    addToCurrentPlaylist ();
+|    | 126|+    void
+|    | 127|+    addToNewPlaylist () const;
+|    | 128|+    void
+|    | 129|+    addToExistingPlaylist (const std::string & playlist) const;
+|    | 130|+    void
+|    | 131|+    addAtTheEndOfPlaylist () const;
+|    | 132|+    void
+|    | 133|+    addAtTheBeginningOfPlaylist () const;
+|    | 134|+    void
+|    | 135|+    addAfterCurrentSong () const;
+|    | 136|+    void
+|    | 137|+    addAfterCurrentAlbum () const;
+|    | 138|+    void
+|    | 139|+    addAfterHighlightedSong () const;
+|    | 140|+    void
+|    | 141|+    cancel ();
+|    | 142|+    void
+|    | 143|+    exitSuccessfully (bool success) const;
+|    | 144|+
+|    | 145|+    void
+|    | 146|+    setDimensions ();
+|    | 147|+
+|    | 148|+    size_t
+|    | 149|+        m_playlist_selector_width;
+|    | 150|+    size_t
+|    | 151|+        m_playlist_selector_height;
+|    | 152|+
+|    | 153|+    size_t
+|    | 154|+        m_position_selector_width;
+|    | 155|+    size_t
+|    | 156|+        m_position_selector_height;
+|    | 157|+
+|    | 158|+    Component
+|    | 159|+        m_playlist_selector;
+|    | 160|+    Component
+|    | 161|+        m_position_selector;
+|    | 162|+
+|    | 163|+    std::vector < MPD::Song > m_selected_items;
+|    | 164|+
+|    | 165|+    Regex::ItemFilter < Entry > m_search_predicate;
+|  91| 166| };
+|  92| 167| 
+|  93| 168| extern SelectedItemsAdder *mySelectedItemsAdder;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sel_items_adder.h
+|    |++++| /app/src/screens/sel_items_adder.h
+|  90|  90| 	Regex::ItemFilter<Entry> m_search_predicate;
+|  91|  91| };
+|  92|  92| 
+|  93|    |-extern SelectedItemsAdder *mySelectedItemsAdder;
+|    |  93|+extern SelectedItemsAdder *
+|    |  94|+    mySelectedItemsAdder;
+|  94|  95| 
+|  95|  96| #endif // NCMPCPP_SEL_ITEMS_ADDER_H
+|  96|  97| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sel_items_adder.h
+|    |++++| /app/src/screens/sel_items_adder.h
+|  93|  93| extern SelectedItemsAdder *mySelectedItemsAdder;
+|  94|  94| 
+|  95|  95| #endif // NCMPCPP_SEL_ITEMS_ADDER_H
+|  96|    |-
+
+src/screens/sel_items_adder.h
+|  24| #include•"runnable_item.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'runnable_item.h'
+
+src/screens/sel_items_adder.h
+|  25| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/sel_items_adder.h
+|  26| #include•"regex_filter.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'regex_filter.h'
+
+src/screens/sel_items_adder.h
+|  27| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/sel_items_adder.h
+|  28| #include•"song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song.h'
+
+src/screens/sel_items_adder.h
+|  93| extern•SelectedItemsAdder•*mySelectedItemsAdder;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'mySelectedItemsAdder'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  24|  24| #include "screens/screen.h"
+|  25|  25| #include "settings.h"
+|  26|  26| 
+|  27|    |-using Global::myScreen;
+|  28|    |-using Global::myLockedScreen;
+|  29|    |-using Global::myInactiveScreen;
+|    |  27|+using
+|    |  28|+    Global::myScreen;
+|    |  29|+using
+|    |  30|+    Global::myLockedScreen;
+|    |  31|+using
+|    |  32|+    Global::myInactiveScreen;
+|  30|  33| 
+|  31|    |-void drawSeparator(int x)
+|    |  34|+void
+|    |  35|+drawSeparator (int x)
+|  32|  36| {
+|  33|    |-	color_set(Config.main_color.pairNumber(), nullptr);
+|  34|    |-	mvvline(Global::MainStartY, x, 0, Global::MainHeight);
+|  35|    |-	standend();
+|  36|    |-	refresh();
+|    |  37|+    color_set (Config.main_color.pairNumber (), nullptr);
+|    |  38|+    mvvline (Global::MainStartY, x, 0, Global::MainHeight);
+|    |  39|+    standend ();
+|    |  40|+    refresh ();
+|  37|  41| }
+|  38|  42| 
+|  39|  43| void genericMouseButtonPressed(NC::Window &w, MEVENT me)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  36|  36| 	refresh();
+|  37|  37| }
+|  38|  38| 
+|  39|    |-void genericMouseButtonPressed(NC::Window &w, MEVENT me)
+|    |  39|+void
+|    |  40|+genericMouseButtonPressed (NC::Window & w, MEVENT me)
+|  40|  41| {
+|  41|    |-	if (me.bstate & BUTTON5_PRESSED)
+|  42|    |-	{
+|  43|    |-		if (Config.mouse_list_scroll_whole_page)
+|  44|    |-			w.scroll(NC::Scroll::PageDown);
+|  45|    |-		else
+|  46|    |-			for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  47|    |-				w.scroll(NC::Scroll::Down);
+|  48|    |-	}
+|  49|    |-	else if (me.bstate & BUTTON4_PRESSED)
+|  50|    |-	{
+|  51|    |-		if (Config.mouse_list_scroll_whole_page)
+|  52|    |-			w.scroll(NC::Scroll::PageUp);
+|  53|    |-		else
+|  54|    |-			for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  55|    |-				w.scroll(NC::Scroll::Up);
+|  56|    |-	}
+|    |  42|+    if (me.bstate & BUTTON5_PRESSED)
+|    |  43|+      {
+|    |  44|+          if (Config.mouse_list_scroll_whole_page)
+|    |  45|+              w.scroll (NC::Scroll::PageDown);
+|    |  46|+          else
+|    |  47|+              for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  48|+                  w.scroll (NC::Scroll::Down);
+|    |  49|+      }
+|    |  50|+    else if (me.bstate & BUTTON4_PRESSED)
+|    |  51|+      {
+|    |  52|+          if (Config.mouse_list_scroll_whole_page)
+|    |  53|+              w.scroll (NC::Scroll::PageUp);
+|    |  54|+          else
+|    |  55|+              for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  56|+                  w.scroll (NC::Scroll::Up);
+|    |  57|+      }
+|  57|  58| }
+|  58|  59| 
+|  59|  60| void scrollpadMouseButtonPressed(NC::Scrollpad &w, MEVENT me)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  56|  56| 	}
+|  57|  57| }
+|  58|  58| 
+|  59|    |-void scrollpadMouseButtonPressed(NC::Scrollpad &w, MEVENT me)
+|    |  59|+void
+|    |  60|+scrollpadMouseButtonPressed (NC::Scrollpad & w, MEVENT me)
+|  60|  61| {
+|  61|    |-	if (me.bstate & BUTTON5_PRESSED)
+|  62|    |-	{
+|  63|    |-		for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  64|    |-			w.scroll(NC::Scroll::Down);
+|  65|    |-	}
+|  66|    |-	else if (me.bstate & BUTTON4_PRESSED)
+|  67|    |-	{
+|  68|    |-		for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  69|    |-			w.scroll(NC::Scroll::Up);
+|  70|    |-	}
+|    |  62|+    if (me.bstate & BUTTON5_PRESSED)
+|    |  63|+      {
+|    |  64|+          for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  65|+              w.scroll (NC::Scroll::Down);
+|    |  66|+      }
+|    |  67|+    else if (me.bstate & BUTTON4_PRESSED)
+|    |  68|+      {
+|    |  69|+          for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  70|+              w.scroll (NC::Scroll::Up);
+|    |  71|+      }
+|  71|  72| }
+|  72|  73| 
+|  73|  74| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  72|  72| 
+|  73|  73| /***********************************************************************/
+|  74|  74| 
+|  75|    |-void BaseScreen::getWindowResizeParams(size_t &x_offset, size_t &width, bool adjust_locked_screen)
+|    |  75|+void
+|    |  76|+BaseScreen::getWindowResizeParams (size_t & x_offset, size_t & width,
+|    |  77|+                                   bool adjust_locked_screen)
+|  76|  78| {
+|  77|    |-	width = COLS;
+|  78|    |-	x_offset = 0;
+|  79|    |-	if (myLockedScreen && myInactiveScreen)
+|  80|    |-	{
+|  81|    |-		size_t locked_width = COLS*Config.locked_screen_width_part;
+|  82|    |-		if (myLockedScreen == this)
+|  83|    |-			width = locked_width;
+|  84|    |-		else
+|  85|    |-		{
+|  86|    |-			width = COLS-locked_width-1;
+|  87|    |-			x_offset = locked_width+1;
+|  88|    |-			
+|  89|    |-			if (adjust_locked_screen)
+|  90|    |-			{
+|  91|    |-				myLockedScreen->resize();
+|  92|    |-				myLockedScreen->refresh();
+|  93|    |-				drawSeparator(x_offset-1);
+|  94|    |-			}
+|  95|    |-		}
+|  96|    |-	}
+|    |  79|+    width = COLS;
+|    |  80|+    x_offset = 0;
+|    |  81|+    if (myLockedScreen && myInactiveScreen)
+|    |  82|+      {
+|    |  83|+          size_t locked_width = COLS * Config.locked_screen_width_part;
+|    |  84|+          if (myLockedScreen == this)
+|    |  85|+              width = locked_width;
+|    |  86|+          else
+|    |  87|+            {
+|    |  88|+                width = COLS - locked_width - 1;
+|    |  89|+                x_offset = locked_width + 1;
+|    |  90|+
+|    |  91|+                if (adjust_locked_screen)
+|    |  92|+                  {
+|    |  93|+                      myLockedScreen->resize ();
+|    |  94|+                      myLockedScreen->refresh ();
+|    |  95|+                      drawSeparator (x_offset - 1);
+|    |  96|+                  }
+|    |  97|+            }
+|    |  98|+      }
+|  97|  99| }
+|  98| 100| 
+|  99| 101| bool BaseScreen::lock()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  96|  96| 	}
+|  97|  97| }
+|  98|  98| 
+|  99|    |-bool BaseScreen::lock()
+|    |  99|+bool
+|    | 100|+BaseScreen::lock ()
+| 100| 101| {
+| 101|    |-	assert(myLockedScreen == nullptr);
+| 102|    |-	if (isLockable())
+| 103|    |-	{
+| 104|    |-		myLockedScreen = this;
+| 105|    |-		return true;
+| 106|    |-	}
+| 107|    |-	else
+| 108|    |-		return false;
+|    | 102|+    assert (myLockedScreen == nullptr);
+|    | 103|+    if (isLockable ())
+|    | 104|+      {
+|    | 105|+          myLockedScreen = this;
+|    | 106|+          return true;
+|    | 107|+      }
+|    | 108|+    else
+|    | 109|+        return false;
+| 109| 110| }
+| 110| 111| 
+| 111| 112| void BaseScreen::unlock()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 108| 108| 		return false;
+| 109| 109| }
+| 110| 110| 
+| 111|    |-void BaseScreen::unlock()
+|    | 111|+void
+|    | 112|+BaseScreen::unlock ()
+| 112| 113| {
+| 113|    |-	if (myInactiveScreen && myInactiveScreen != myLockedScreen)
+| 114|    |-		myScreen = myInactiveScreen;
+| 115|    |-	if (myScreen != myLockedScreen)
+| 116|    |-		myLockedScreen->switchTo();
+| 117|    |-	myLockedScreen = 0;
+| 118|    |-	myInactiveScreen = 0;
+|    | 114|+    if (myInactiveScreen && myInactiveScreen != myLockedScreen)
+|    | 115|+        myScreen = myInactiveScreen;
+|    | 116|+    if (myScreen != myLockedScreen)
+|    | 117|+        myLockedScreen->switchTo ();
+|    | 118|+    myLockedScreen = 0;
+|    | 119|+    myInactiveScreen = 0;
+| 119| 120| }
+| 120| 121| 
+| 121| 122| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 120| 120| 
+| 121| 121| /***********************************************************************/
+| 122| 122| 
+| 123|    |-void applyToVisibleWindows(std::function<void(BaseScreen *)> f)
+|    | 123|+void
+|    | 124|+applyToVisibleWindows (std::function < void (BaseScreen *) > f)
+| 124| 125| {
+| 125|    |-	if (myLockedScreen && myScreen->isMergable())
+| 126|    |-	{
+| 127|    |-		if (myScreen == myLockedScreen)
+| 128|    |-		{
+| 129|    |-			if (myInactiveScreen)
+| 130|    |-				f(myInactiveScreen);
+| 131|    |-		}
+| 132|    |-		else
+| 133|    |-			f(myLockedScreen);
+| 134|    |-	}
+| 135|    |-	f(myScreen);
+|    | 126|+    if (myLockedScreen && myScreen->isMergable ())
+|    | 127|+      {
+|    | 128|+          if (myScreen == myLockedScreen)
+|    | 129|+            {
+|    | 130|+                if (myInactiveScreen)
+|    | 131|+                    f (myInactiveScreen);
+|    | 132|+            }
+|    | 133|+          else
+|    | 134|+              f (myLockedScreen);
+|    | 135|+      }
+|    | 136|+    f (myScreen);
+| 136| 137| }
+| 137| 138| 
+| 138| 139| void updateInactiveScreen(BaseScreen *screen_to_be_set)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 135| 135| 	f(myScreen);
+| 136| 136| }
+| 137| 137| 
+| 138|    |-void updateInactiveScreen(BaseScreen *screen_to_be_set)
+|    | 138|+void
+|    | 139|+updateInactiveScreen (BaseScreen * screen_to_be_set)
+| 139| 140| {
+| 140|    |-	if (myInactiveScreen && myLockedScreen != myInactiveScreen && myLockedScreen == screen_to_be_set)
+| 141|    |-	{
+| 142|    |-		// if we're here, the following conditions are (or at least should be) met:
+| 143|    |-		// 1. screen is split (myInactiveScreen is not null)
+| 144|    |-		// 2. current screen (myScreen) is not splittable, ie. is stacked on top of split screens
+| 145|    |-		// 3. current screen was activated while master screen was active
+| 146|    |-		// 4. we are returning to master screen
+| 147|    |-		// in such case we want to keep slave screen visible, so we never set it to null
+| 148|    |-		// as in "else" case. we also need to refresh it and redraw separator between
+| 149|    |-		// them as stacked screen probably has overwritten part ot it.
+| 150|    |-		myInactiveScreen->refresh();
+| 151|    |-		drawSeparator(COLS*Config.locked_screen_width_part);
+| 152|    |-	}
+| 153|    |-	else
+| 154|    |-	{
+| 155|    |-		if (myLockedScreen == screen_to_be_set)
+| 156|    |-			myInactiveScreen = 0;
+| 157|    |-		else
+| 158|    |-			myInactiveScreen = myLockedScreen;
+| 159|    |-	}
+|    | 141|+    if (myInactiveScreen && myLockedScreen != myInactiveScreen
+|    | 142|+        && myLockedScreen == screen_to_be_set)
+|    | 143|+      {
+|    | 144|+          // if we're here, the following conditions are (or at least should be) met:
+|    | 145|+          // 1. screen is split (myInactiveScreen is not null)
+|    | 146|+          // 2. current screen (myScreen) is not splittable, ie. is stacked on top of split screens
+|    | 147|+          // 3. current screen was activated while master screen was active
+|    | 148|+          // 4. we are returning to master screen
+|    | 149|+          // in such case we want to keep slave screen visible, so we never set it to null
+|    | 150|+          // as in "else" case. we also need to refresh it and redraw separator between
+|    | 151|+          // them as stacked screen probably has overwritten part ot it.
+|    | 152|+          myInactiveScreen->refresh ();
+|    | 153|+          drawSeparator (COLS * Config.locked_screen_width_part);
+|    | 154|+      }
+|    | 155|+    else
+|    | 156|+      {
+|    | 157|+          if (myLockedScreen == screen_to_be_set)
+|    | 158|+              myInactiveScreen = 0;
+|    | 159|+          else
+|    | 160|+              myInactiveScreen = myLockedScreen;
+|    | 161|+      }
+| 160| 162| }
+| 161| 163| 
+| 162| 164| bool isVisible(BaseScreen *screen)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 159| 159| 	}
+| 160| 160| }
+| 161| 161| 
+| 162|    |-bool isVisible(BaseScreen *screen)
+|    | 162|+bool
+|    | 163|+isVisible (BaseScreen * screen)
+| 163| 164| {
+| 164|    |-	assert(screen != 0);
+| 165|    |-	if (myLockedScreen && myScreen->isMergable())
+| 166|    |-		return screen == myScreen || screen == myInactiveScreen || screen == myLockedScreen;
+| 167|    |-	else
+| 168|    |-		return screen == myScreen;
+|    | 165|+    assert (screen != 0);
+|    | 166|+    if (myLockedScreen && myScreen->isMergable ())
+|    | 167|+        return screen == myScreen || screen == myInactiveScreen
+|    | 168|+            || screen == myLockedScreen;
+|    | 169|+    else
+|    | 170|+        return screen == myScreen;
+| 169| 171| }
+
+src/screens/screen.cpp
+|  23| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/screen.cpp
+|  24| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/screen.cpp
+|  25| #include•"settings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'settings.h'
+
+src/screens/screen.cpp
+|  31| void•drawSeparator(int•x)
+|    | [NORMAL] CPPCleanBear:
+|    | 'drawSeparator' not found in any directly #included header
+
+src/screens/screen.cpp
+|  39| void•genericMouseButtonPressed(NC::Window•&w,•MEVENT•me)
+|    | [NORMAL] CPPCleanBear:
+|    | 'genericMouseButtonPressed' not found in any directly #included header
+
+src/screens/screen.cpp
+|  59| void•scrollpadMouseButtonPressed(NC::Scrollpad•&w,•MEVENT•me)
+|    | [NORMAL] CPPCleanBear:
+|    | 'scrollpadMouseButtonPressed' not found in any directly #included header
+
+src/screens/screen.cpp
+| 123| void•applyToVisibleWindows(std::function<void(BaseScreen•*)>•f)
+|    | [NORMAL] CPPCleanBear:
+|    | 'applyToVisibleWindows' not found in any directly #included header
+
+src/screens/screen.cpp
+| 138| void•updateInactiveScreen(BaseScreen•*screen_to_be_set)
+|    | [NORMAL] CPPCleanBear:
+|    | 'updateInactiveScreen' not found in any directly #included header
+
+src/screens/screen.cpp
+| 162| bool•isVisible(BaseScreen•*screen)
+|    | [NORMAL] CPPCleanBear:
+|    | 'isVisible' not found in any directly #included header
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+|  28|  28| #include "screens/screen.h"
+|  29|  29| #include "song_list.h"
+|  30|  30| 
+|  31|    |-struct MediaLibrary: Screen<NC::Window *>, Filterable, HasColumns, HasSongs, Searchable, Tabbable
+|    |  31|+struct MediaLibrary:Screen <
+|    |  32|+NC::Window * >,
+|    |  33|+    Filterable,
+|    |  34|+    HasColumns,
+|    |  35|+    HasSongs,
+|    |  36|+    Searchable,
+|    |  37|+    Tabbable
+|  32|  38| {
+|  33|    |-	MediaLibrary();
+|  34|    |-	
+|  35|    |-	virtual void switchTo() override;
+|  36|    |-	virtual void resize() override;
+|  37|    |-	
+|  38|    |-	virtual std::wstring title() override;
+|  39|    |-	virtual ScreenType type() override { return ScreenType::MediaLibrary; }
+|  40|    |-	
+|  41|    |-	virtual void refresh() override;
+|  42|    |-	virtual void update() override;
+|  43|    |-	
+|  44|    |-	virtual int windowTimeout() override;
+|  45|    |-
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// Searchable implementation
+|  52|    |-	virtual bool allowsSearching() override;
+|  53|    |-	virtual const std::string &searchConstraint() override;
+|  54|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  55|    |-	virtual void clearSearchConstraint() override;
+|  56|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|  57|    |-
+|  58|    |-	// Filterable implementation
+|  59|    |-	virtual bool allowsFiltering() override;
+|  60|    |-	virtual std::string currentFilter() override;
+|  61|    |-	virtual void applyFilter(const std::string &filter) override;
+|  62|    |-
+|  63|    |-	// HasSongs implementation
+|  64|    |-	virtual bool itemAvailable() override;
+|  65|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  66|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  67|    |-	
+|  68|    |-	// HasColumns implementation
+|  69|    |-	virtual bool previousColumnAvailable() override;
+|  70|    |-	virtual void previousColumn() override;
+|  71|    |-	
+|  72|    |-	virtual bool nextColumnAvailable() override;
+|  73|    |-	virtual void nextColumn() override;
+|  74|    |-	
+|  75|    |-	// other members
+|  76|    |-	void updateTimer();
+|  77|    |-	void toggleColumnsMode();
+|  78|    |-	int columns();
+|  79|    |-	void locateSong(const MPD::Song &s);
+|  80|    |-	void toggleSortMode();
+|  81|    |-	
+|  82|    |-	void requestTagsUpdate() { m_tags_update_request = true; }
+|  83|    |-	void requestAlbumsUpdate() { m_albums_update_request = true; }
+|  84|    |-	void requestSongsUpdate() { m_songs_update_request = true; }
+|  85|    |-	
+|  86|    |-	struct PrimaryTag
+|  87|    |-	{
+|  88|    |-		PrimaryTag() : m_mtime(0) { }
+|  89|    |-		PrimaryTag(std::string tag_, time_t mtime_)
+|  90|    |-		: m_tag(std::move(tag_)), m_mtime(mtime_) { }
+|  91|    |-		
+|  92|    |-		const std::string &tag() const { return m_tag; }
+|  93|    |-		time_t mtime() const { return m_mtime; }
+|  94|    |-		
+|  95|    |-	private:
+|  96|    |-		std::string m_tag;
+|  97|    |-		time_t m_mtime;
+|  98|    |-	};
+|  99|    |-	
+| 100|    |-	struct Album
+| 101|    |-	{
+| 102|    |-		Album(std::string tag_, std::string album_, std::string date_, time_t mtime_)
+| 103|    |-		: m_tag(std::move(tag_)), m_album(std::move(album_))
+| 104|    |-		, m_date(std::move(date_)), m_mtime(mtime_) { }
+| 105|    |-		
+| 106|    |-		const std::string &tag() const { return m_tag; }
+| 107|    |-		const std::string &album() const { return m_album; }
+| 108|    |-		const std::string &date() const { return m_date; }
+| 109|    |-		time_t mtime() const { return m_mtime; }
+| 110|    |-		
+| 111|    |-	private:
+| 112|    |-		std::string m_tag;
+| 113|    |-		std::string m_album;
+| 114|    |-		std::string m_date;
+| 115|    |-		time_t m_mtime;
+| 116|    |-	};
+| 117|    |-	
+| 118|    |-	struct AlbumEntry
+| 119|    |-	{
+| 120|    |-		AlbumEntry() : m_all_tracks_entry(false), m_album("", "", "", 0) { }
+| 121|    |-		explicit AlbumEntry(Album album_) : m_all_tracks_entry(false), m_album(album_) { }
+| 122|    |-		
+| 123|    |-		const Album &entry() const { return m_album; }
+| 124|    |-		bool isAllTracksEntry() const { return m_all_tracks_entry; }
+| 125|    |-		
+| 126|    |-		static AlbumEntry mkAllTracksEntry(std::string tag) {
+| 127|    |-			auto result = AlbumEntry(Album(tag, "", "", 0));
+| 128|    |-			result.m_all_tracks_entry = true;
+| 129|    |-			return result;
+| 130|    |-		}
+| 131|    |-		
+| 132|    |-	private:
+| 133|    |-		bool m_all_tracks_entry;
+| 134|    |-		Album m_album;
+| 135|    |-	};
+| 136|    |-	
+| 137|    |-	NC::Menu<PrimaryTag> Tags;
+| 138|    |-	NC::Menu<AlbumEntry> Albums;
+| 139|    |-	SongMenu Songs;
+| 140|    |-	
+| 141|    |-private:
+| 142|    |-	bool m_tags_update_request;
+| 143|    |-	bool m_albums_update_request;
+| 144|    |-	bool m_songs_update_request;
+| 145|    |-
+| 146|    |-	boost::posix_time::ptime m_timer;
+| 147|    |-
+| 148|    |-	const int m_window_timeout;
+| 149|    |-	const boost::posix_time::time_duration m_fetching_delay;
+| 150|    |-
+| 151|    |-	Regex::Filter<PrimaryTag> m_tags_search_predicate;
+| 152|    |-	Regex::ItemFilter<AlbumEntry> m_albums_search_predicate;
+| 153|    |-	Regex::Filter<MPD::Song> m_songs_search_predicate;
+|    |  39|+    MediaLibrary ();
+|    |  40|+
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|    |  47|+
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::MediaLibrary;
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    virtual void
+|    |  60|+    refresh ()
+|    |  61|+        override;
+|    |  62|+    virtual void
+|    |  63|+    update ()
+|    |  64|+        override;
+|    |  65|+
+|    |  66|+    virtual int
+|    |  67|+    windowTimeout ()
+|    |  68|+        override;
+|    |  69|+
+|    |  70|+    virtual void
+|    |  71|+    mouseButtonPressed (MEVENT me)
+|    |  72|+        override;
+|    |  73|+
+|    |  74|+    virtual bool
+|    |  75|+    isLockable ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return true;
+|    |  79|+    }
+|    |  80|+    virtual bool
+|    |  81|+    isMergable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|    |  86|+
+|    |  87|+    // Searchable implementation
+|    |  88|+    virtual bool
+|    |  89|+    allowsSearching ()
+|    |  90|+        override;
+|    |  91|+    virtual const
+|    |  92|+        std::string &
+|    |  93|+    searchConstraint ()
+|    |  94|+        override;
+|    |  95|+    virtual void
+|    |  96|+    setSearchConstraint (const std::string & constraint)
+|    |  97|+        override;
+|    |  98|+    virtual void
+|    |  99|+    clearSearchConstraint ()
+|    | 100|+        override;
+|    | 101|+    virtual bool
+|    | 102|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 103|+        override;
+|    | 104|+
+|    | 105|+    // Filterable implementation
+|    | 106|+    virtual bool
+|    | 107|+    allowsFiltering ()
+|    | 108|+        override;
+|    | 109|+    virtual
+|    | 110|+        std::string
+|    | 111|+    currentFilter ()
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    applyFilter (const std::string & filter)
+|    | 115|+        override;
+|    | 116|+
+|    | 117|+    // HasSongs implementation
+|    | 118|+    virtual bool
+|    | 119|+    itemAvailable ()
+|    | 120|+        override;
+|    | 121|+    virtual bool
+|    | 122|+    addItemToPlaylist (bool play)
+|    | 123|+        override;
+|    | 124|+    virtual
+|    | 125|+        std::vector <
+|    | 126|+        MPD::Song >
+|    | 127|+    getSelectedSongs ()
+|    | 128|+        override;
+|    | 129|+
+|    | 130|+    // HasColumns implementation
+|    | 131|+    virtual bool
+|    | 132|+    previousColumnAvailable ()
+|    | 133|+        override;
+|    | 134|+    virtual void
+|    | 135|+    previousColumn ()
+|    | 136|+        override;
+|    | 137|+
+|    | 138|+    virtual bool
+|    | 139|+    nextColumnAvailable ()
+|    | 140|+        override;
+|    | 141|+    virtual void
+|    | 142|+    nextColumn ()
+|    | 143|+        override;
+|    | 144|+
+|    | 145|+    // other members
+|    | 146|+    void
+|    | 147|+    updateTimer ();
+|    | 148|+    void
+|    | 149|+    toggleColumnsMode ();
+|    | 150|+    int
+|    | 151|+    columns ();
+|    | 152|+    void
+|    | 153|+    locateSong (const MPD::Song & s);
+|    | 154|+    void
+|    | 155|+    toggleSortMode ();
+|    | 156|+
+|    | 157|+    void
+|    | 158|+    requestTagsUpdate ()
+|    | 159|+    {
+|    | 160|+        m_tags_update_request = true;
+|    | 161|+    }
+|    | 162|+    void
+|    | 163|+    requestAlbumsUpdate ()
+|    | 164|+    {
+|    | 165|+        m_albums_update_request = true;
+|    | 166|+    }
+|    | 167|+    void
+|    | 168|+    requestSongsUpdate ()
+|    | 169|+    {
+|    | 170|+        m_songs_update_request = true;
+|    | 171|+    }
+|    | 172|+
+|    | 173|+    struct PrimaryTag
+|    | 174|+    {
+|    | 175|+        PrimaryTag ():
+|    | 176|+        m_mtime (0)
+|    | 177|+        {
+|    | 178|+        }
+|    | 179|+        PrimaryTag (std::string tag_, time_t mtime_):
+|    | 180|+        m_tag (std::move (tag_)),
+|    | 181|+        m_mtime (mtime_)
+|    | 182|+        {
+|    | 183|+        }
+|    | 184|+
+|    | 185|+        const
+|    | 186|+            std::string &
+|    | 187|+        tag () const
+|    | 188|+        {
+|    | 189|+            return
+|    | 190|+                m_tag;
+|    | 191|+        }
+|    | 192|+        time_t
+|    | 193|+        mtime () const
+|    | 194|+        {
+|    | 195|+            return
+|    | 196|+                m_mtime;
+|    | 197|+        }
+|    | 198|+
+|    | 199|+      private:
+|    | 200|+        std::string
+|    | 201|+            m_tag;
+|    | 202|+        time_t
+|    | 203|+            m_mtime;
+|    | 204|+    };
+|    | 205|+
+|    | 206|+    struct Album
+|    | 207|+    {
+|    | 208|+        Album (std::string tag_, std::string album_, std::string date_,
+|    | 209|+               time_t mtime_):
+|    | 210|+        m_tag (std::move (tag_)),
+|    | 211|+        m_album (std::move (album_)),
+|    | 212|+        m_date (std::move (date_)),
+|    | 213|+        m_mtime (mtime_)
+|    | 214|+        {
+|    | 215|+        }
+|    | 216|+
+|    | 217|+        const
+|    | 218|+            std::string &
+|    | 219|+        tag () const
+|    | 220|+        {
+|    | 221|+            return
+|    | 222|+                m_tag;
+|    | 223|+        }
+|    | 224|+        const
+|    | 225|+            std::string &
+|    | 226|+        album () const
+|    | 227|+        {
+|    | 228|+            return
+|    | 229|+                m_album;
+|    | 230|+        }
+|    | 231|+        const
+|    | 232|+            std::string &
+|    | 233|+        date () const
+|    | 234|+        {
+|    | 235|+            return
+|    | 236|+                m_date;
+|    | 237|+        }
+|    | 238|+        time_t
+|    | 239|+        mtime () const
+|    | 240|+        {
+|    | 241|+            return
+|    | 242|+                m_mtime;
+|    | 243|+        }
+|    | 244|+
+|    | 245|+      private:
+|    | 246|+        std::string
+|    | 247|+            m_tag;
+|    | 248|+        std::string m_album;
+|    | 249|+        std::string m_date;
+|    | 250|+        time_t
+|    | 251|+            m_mtime;
+|    | 252|+    };
+|    | 253|+
+|    | 254|+    struct AlbumEntry
+|    | 255|+    {
+|    | 256|+        AlbumEntry ():
+|    | 257|+        m_all_tracks_entry (false),
+|    | 258|+        m_album ("", "", "", 0)
+|    | 259|+        {
+|    | 260|+        }
+|    | 261|+        explicit
+|    | 262|+        AlbumEntry (Album album_):
+|    | 263|+        m_all_tracks_entry (false),
+|    | 264|+        m_album (album_)
+|    | 265|+        {
+|    | 266|+        }
+|    | 267|+
+|    | 268|+        const
+|    | 269|+            Album &
+|    | 270|+        entry () const
+|    | 271|+        {
+|    | 272|+            return
+|    | 273|+                m_album;
+|    | 274|+        }
+|    | 275|+        bool
+|    | 276|+        isAllTracksEntry () const
+|    | 277|+        {
+|    | 278|+            return
+|    | 279|+                m_all_tracks_entry;
+|    | 280|+        }
+|    | 281|+
+|    | 282|+        static AlbumEntry
+|    | 283|+        mkAllTracksEntry (std::string tag)
+|    | 284|+        {
+|    | 285|+            auto
+|    | 286|+                result = AlbumEntry (Album (tag, "", "", 0));
+|    | 287|+            result.m_all_tracks_entry = true;
+|    | 288|+            return result;
+|    | 289|+        }
+|    | 290|+
+|    | 291|+      private:
+|    | 292|+        bool m_all_tracks_entry;
+|    | 293|+        Album
+|    | 294|+            m_album;
+|    | 295|+    };
+|    | 296|+
+|    | 297|+    NC::Menu < PrimaryTag > Tags;
+|    | 298|+    NC::Menu < AlbumEntry > Albums;
+|    | 299|+    SongMenu
+|    | 300|+        Songs;
+|    | 301|+
+|    | 302|+  private:
+|    | 303|+    bool m_tags_update_request;
+|    | 304|+    bool
+|    | 305|+        m_albums_update_request;
+|    | 306|+    bool
+|    | 307|+        m_songs_update_request;
+|    | 308|+
+|    | 309|+    boost::posix_time::ptime m_timer;
+|    | 310|+
+|    | 311|+    const int
+|    | 312|+        m_window_timeout;
+|    | 313|+    const
+|    | 314|+        boost::posix_time::time_duration
+|    | 315|+        m_fetching_delay;
+|    | 316|+
+|    | 317|+    Regex::Filter < PrimaryTag > m_tags_search_predicate;
+|    | 318|+    Regex::ItemFilter < AlbumEntry > m_albums_search_predicate;
+|    | 319|+    Regex::Filter < MPD::Song > m_songs_search_predicate;
+| 154| 320| 
+| 155| 321| };
+| 156| 322| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+| 154| 154| 
+| 155| 155| };
+| 156| 156| 
+| 157|    |-extern MediaLibrary *myLibrary;
+|    | 157|+extern MediaLibrary *
+|    | 158|+    myLibrary;
+| 158| 159| 
+| 159| 160| #endif // NCMPCPP_MEDIA_LIBRARY_H
+| 160| 161| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+| 157| 157| extern MediaLibrary *myLibrary;
+| 158| 158| 
+| 159| 159| #endif // NCMPCPP_MEDIA_LIBRARY_H
+| 160|    |-
+
+src/screens/media_library.h
+|  26| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/media_library.h
+|  27| #include•"regex_filter.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'regex_filter.h'
+
+src/screens/media_library.h
+|  28| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/media_library.h
+|  29| #include•"song_list.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song_list.h'
+
+src/screens/media_library.h
+| 157| extern•MediaLibrary•*myLibrary;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myLibrary'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/comparators.cpp
+|    |++++| /app/src/utility/comparators.cpp
+|  23|  23| #include "format_impl.h"
+|  24|  24| #include "utility/string.h"
+|  25|  25| 
+|  26|    |-namespace {
+|    |  26|+namespace
+|    |  27|+{
+|  27|  28| 
+|  28|    |-bool hasTheWord(const std::string &s)
+|  29|    |-{
+|  30|    |-	return s.length() >= 4
+|  31|    |-	&&     (s[0] == 't' || s[0] == 'T')
+|  32|    |-	&&     (s[1] == 'h' || s[1] == 'H')
+|  33|    |-	&&     (s[2] == 'e' || s[2] == 'E')
+|  34|    |-	&&     (s[3] == ' ');
+|  35|    |-}
+|    |  29|+    bool hasTheWord (const std::string & s)
+|    |  30|+    {
+|    |  31|+        return s.length () >= 4
+|    |  32|+            && (s[0] == 't' || s[0] == 'T')
+|    |  33|+            && (s[1] == 'h' || s[1] == 'H')
+|    |  34|+            && (s[2] == 'e' || s[2] == 'E') && (s[3] == ' ');
+|    |  35|+    }
+|  36|  36| 
+|  37|  37| }
+|  38|  38| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/comparators.cpp
+|    |++++| /app/src/utility/comparators.cpp
+|  36|  36| 
+|  37|  37| }
+|  38|  38| 
+|  39|    |-int LocaleStringComparison::compare(const char *a, size_t a_len, const char *b, size_t b_len) const
+|    |  39|+int
+|    |  40|+LocaleStringComparison::compare (const char *a, size_t a_len, const char *b,
+|    |  41|+                                 size_t b_len) const const
+|  40|  42| {
+|  41|    |-	size_t ac_off = 0, bc_off = 0;
+|  42|    |-	if (m_ignore_the)
+|  43|    |-	{
+|  44|    |-		if (hasTheWord(a))
+|  45|    |-			ac_off += 4;
+|  46|    |-		if (hasTheWord(b))
+|  47|    |-			bc_off += 4;
+|  48|    |-	}
+|  49|    |-	return std::use_facet<std::collate<char>>(m_locale).compare(
+|  50|    |-		a+ac_off, a+a_len, b+bc_off, b+b_len
+|  51|    |-	);
+|    |  43|+    size_t ac_off = 0, bc_off = 0;
+|    |  44|+    if (m_ignore_the)
+|    |  45|+      {
+|    |  46|+          if (hasTheWord (a))
+|    |  47|+              ac_off += 4;
+|    |  48|+          if (hasTheWord (b))
+|    |  49|+              bc_off += 4;
+|    |  50|+      }
+|    |  51|+    return std::use_facet < std::collate <
+|    |  52|+        char >>(m_locale).compare (a + ac_off, a + a_len, b + bc_off,
+|    |  53|+                                   b + b_len);
+|  52|  54| }
+|  53|  55| 
+|  54|  56| bool LocaleBasedItemSorting::operator()(const MPD::Item &a, const MPD::Item &b) const
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/comparators.cpp
+|    |++++| /app/src/utility/comparators.cpp
+|  51|  51| 	);
+|  52|  52| }
+|  53|  53| 
+|  54|    |-bool LocaleBasedItemSorting::operator()(const MPD::Item &a, const MPD::Item &b) const
+|  55|    |-{
+|  56|    |-	bool result = false;
+|  57|    |-	if (a.type() == b.type())
+|  58|    |-	{
+|  59|    |-		switch (m_sort_mode)
+|  60|    |-		{
+|  61|    |-			case SortMode::Name:
+|  62|    |-				switch (a.type())
+|  63|    |-				{
+|  64|    |-					case MPD::Item::Type::Directory:
+|  65|    |-						result = m_cmp(a.directory().path(), b.directory().path());
+|  66|    |-						break;
+|  67|    |-					case MPD::Item::Type::Playlist:
+|  68|    |-						result = m_cmp(a.playlist().path(), b.playlist().path());
+|  69|    |-						break;
+|  70|    |-					case MPD::Item::Type::Song:
+|  71|    |-						result = m_cmp(a.song(), b.song());
+|  72|    |-						break;
+|  73|    |-				}
+|  74|    |-				break;
+|  75|    |-			case SortMode::CustomFormat:
+|  76|    |-				switch (a.type())
+|  77|    |-				{
+|  78|    |-					case MPD::Item::Type::Directory:
+|  79|    |-						result = m_cmp(a.directory().path(), b.directory().path());
+|  80|    |-						break;
+|  81|    |-					case MPD::Item::Type::Playlist:
+|  82|    |-						result = m_cmp(a.playlist().path(), b.playlist().path());
+|  83|    |-						break;
+|  84|    |-					case MPD::Item::Type::Song:
+|  85|    |-						result = m_cmp(Format::stringify<char>(Config.browser_sort_format, &a.song()),
+|  86|    |-						               Format::stringify<char>(Config.browser_sort_format, &b.song()));
+|  87|    |-						break;
+|  88|    |-				}
+|  89|    |-				break;
+|  90|    |-			case SortMode::ModificationTime:
+|  91|    |-				switch (a.type())
+|  92|    |-				{
+|  93|    |-					case MPD::Item::Type::Directory:
+|  94|    |-						result = a.directory().lastModified() > b.directory().lastModified();
+|  95|    |-						break;
+|  96|    |-					case MPD::Item::Type::Playlist:
+|  97|    |-						result = a.playlist().lastModified() > b.playlist().lastModified();
+|  98|    |-						break;
+|  99|    |-					case MPD::Item::Type::Song:
+| 100|    |-						result = a.song().getMTime() > b.song().getMTime();
+| 101|    |-						break;
+| 102|    |-				}
+| 103|    |-				break;
+| 104|    |-			case SortMode::NoOp:
+| 105|    |-				throw std::logic_error("can't sort with NoOp sorting mode");
+| 106|    |-		}
+| 107|    |-	}
+| 108|    |-	else
+| 109|    |-		result = a.type() < b.type();
+| 110|    |-	return result;
+| 111|    |-}
+|    |  54|+bool
+|    |  55|+LocaleBasedItemSorting::operator () (const MPD::Item & a, const MPD::Item & b)
+|    |  56|+     const
+|    |  57|+     {
+|    |  58|+         bool result = false;
+|    |  59|+         if (a.type () == b.type ())
+|    |  60|+           {
+|    |  61|+               switch (m_sort_mode)
+|    |  62|+                 {
+|    |  63|+                 case SortMode::Name:
+|    |  64|+                     switch (a.type ())
+|    |  65|+                       {
+|    |  66|+                       case MPD::Item::Type::Directory:
+|    |  67|+                           result =
+|    |  68|+                               m_cmp (a.directory ().path (),
+|    |  69|+                                      b.directory ().path ());
+|    |  70|+                           break;
+|    |  71|+                           case MPD::Item::Type::Playlist:result =
+|    |  72|+                               m_cmp (a.playlist ().path (),
+|    |  73|+                                      b.playlist ().path ());
+|    |  74|+                           break;
+|    |  75|+                           case MPD::Item::Type::Song:result =
+|    |  76|+                               m_cmp (a.song (), b.song ());
+|    |  77|+                           break;
+|    |  78|+                       }
+|    |  79|+                     break;
+|    |  80|+                 case SortMode::CustomFormat:
+|    |  81|+                     switch (a.type ())
+|    |  82|+                       {
+|    |  83|+                       case MPD::Item::Type::Directory:
+|    |  84|+                           result =
+|    |  85|+                               m_cmp (a.directory ().path (),
+|    |  86|+                                      b.directory ().path ());
+|    |  87|+                           break;
+|    |  88|+                       case MPD::Item::Type::Playlist:
+|    |  89|+                           result =
+|    |  90|+                               m_cmp (a.playlist ().path (),
+|    |  91|+                                      b.playlist ().path ());
+|    |  92|+                           break;
+|    |  93|+                       case MPD::Item::Type::Song:
+|    |  94|+                           result =
+|    |  95|+                               m_cmp (Format::stringify <
+|    |  96|+                                      char >(Config.browser_sort_format,
+|    |  97|+                                             &a.song ()),
+|    |  98|+                                      Format::stringify <
+|    |  99|+                                      char >(Config.browser_sort_format,
+|    | 100|+                                             &b.song ()));
+|    | 101|+                           break;
+|    | 102|+                       }
+|    | 103|+                     break;
+|    | 104|+                 case SortMode::ModificationTime:
+|    | 105|+                     switch (a.type ())
+|    | 106|+                       {
+|    | 107|+                       case MPD::Item::Type::Directory:
+|    | 108|+                           result =
+|    | 109|+                               a.directory ().lastModified () >
+|    | 110|+                               b.directory ().lastModified ();
+|    | 111|+                           break;
+|    | 112|+                       case MPD::Item::Type::Playlist:
+|    | 113|+                           result =
+|    | 114|+                               a.playlist ().lastModified () >
+|    | 115|+                               b.playlist ().lastModified ();
+|    | 116|+                           break;
+|    | 117|+                       case MPD::Item::Type::Song:
+|    | 118|+                           result =
+|    | 119|+                               a.song ().getMTime () > b.song ().getMTime ();
+|    | 120|+                           break;
+|    | 121|+                       }
+|    | 122|+                     break;
+|    | 123|+                 case SortMode::NoOp:
+|    | 124|+                     throw std::
+|    | 125|+                         logic_error ("can't sort with NoOp sorting mode");
+|    | 126|+                 }
+|    | 127|+           }
+|    | 128|+         else
+|    | 129|+             result = a.type () < b.type ();
+|    | 130|+         return result;
+|    | 131|+     }
+
+src/utility/comparators.cpp
+|  23| #include•"format_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'format_impl.h'
+
+src/utility/comparators.cpp
+|  24| #include•"utility/string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/string.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  22|  22| #include "screens/song_info.h"
+|  23|  23| #include "utility/functional.h"
+|  24|  24| 
+|  25|    |-SongIterator SongMenu::currentS()
+|    |  25|+SongIterator
+|    |  26|+SongMenu::currentS ()
+|  26|  27| {
+|  27|    |-	return makeSongIterator(current());
+|    |  28|+    return makeSongIterator (current ());
+|  28|  29| }
+|  29|  30| 
+|  30|  31| ConstSongIterator SongMenu::currentS() const
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  27|  27| 	return makeSongIterator(current());
+|  28|  28| }
+|  29|  29| 
+|  30|    |-ConstSongIterator SongMenu::currentS() const
+|    |  30|+ConstSongIterator
+|    |  31|+SongMenu::currentS () const const
+|  31|  32| {
+|  32|    |-	return makeConstSongIterator(current());
+|    |  33|+    return makeConstSongIterator (current ());
+|  33|  34| }
+|  34|  35| 
+|  35|  36| SongIterator SongMenu::beginS()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  32|  32| 	return makeConstSongIterator(current());
+|  33|  33| }
+|  34|  34| 
+|  35|    |-SongIterator SongMenu::beginS()
+|    |  35|+SongIterator
+|    |  36|+SongMenu::beginS ()
+|  36|  37| {
+|  37|    |-	return makeSongIterator(begin());
+|    |  38|+    return makeSongIterator (begin ());
+|  38|  39| }
+|  39|  40| 
+|  40|  41| ConstSongIterator SongMenu::beginS() const
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  37|  37| 	return makeSongIterator(begin());
+|  38|  38| }
+|  39|  39| 
+|  40|    |-ConstSongIterator SongMenu::beginS() const
+|    |  40|+ConstSongIterator
+|    |  41|+SongMenu::beginS () const const
+|  41|  42| {
+|  42|    |-	return makeConstSongIterator(begin());
+|    |  43|+    return makeConstSongIterator (begin ());
+|  43|  44| }
+|  44|  45| 
+|  45|  46| SongIterator SongMenu::endS()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  42|  42| 	return makeConstSongIterator(begin());
+|  43|  43| }
+|  44|  44| 
+|  45|    |-SongIterator SongMenu::endS()
+|    |  45|+SongIterator
+|    |  46|+SongMenu::endS ()
+|  46|  47| {
+|  47|    |-	return makeSongIterator(end());
+|    |  48|+    return makeSongIterator (end ());
+|  48|  49| }
+|  49|  50| 
+|  50|  51| ConstSongIterator SongMenu::endS() const
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  47|  47| 	return makeSongIterator(end());
+|  48|  48| }
+|  49|  49| 
+|  50|    |-ConstSongIterator SongMenu::endS() const
+|    |  50|+ConstSongIterator
+|    |  51|+SongMenu::endS () const const
+|  51|  52| {
+|  52|    |-	return makeConstSongIterator(end());
+|    |  53|+    return makeConstSongIterator (end ());
+|  53|  54| }
+|  54|  55| 
+|  55|  56| std::vector<MPD::Song> SongMenu::getSelectedSongs()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  52|  52| 	return makeConstSongIterator(end());
+|  53|  53| }
+|  54|  54| 
+|  55|    |-std::vector<MPD::Song> SongMenu::getSelectedSongs()
+|    |  55|+std::vector < MPD::Song > SongMenu::getSelectedSongs ()
+|  56|  56| {
+|  57|    |-	std::vector<MPD::Song> result;
+|  58|    |-	for (auto it = begin(); it != end(); ++it)
+|  59|    |-		if (it->isSelected())
+|  60|    |-			result.push_back(it->value());
+|  61|    |-	if (result.empty() && !empty())
+|  62|    |-		result.push_back(current()->value());
+|  63|    |-	return result;
+|    |  57|+    std::vector < MPD::Song > result;
+|    |  58|+    for (auto it = begin (); it != end (); ++it)
+|    |  59|+        if (it->isSelected ())
+|    |  60|+            result.push_back (it->value ());
+|    |  61|+    if (result.empty () && !empty ())
+|    |  62|+        result.push_back (current ()->value ());
+|    |  63|+    return result;
+|  64|  64| }
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/const.h
+|    |++++| /app/src/utility/const.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_CONST_H
+|  22|  22| #define NCMPCPP_UTILITY_CONST_H
+|  23|  23| 
+|  24|    |-enum class Const { Yes, No };
+|    |  24|+enum class Const
+|    |  25|+{ Yes, No };
+|  25|  26| 
+|  26|  27| #endif // NCMPCPP_UTILITY_CONST_H
+
+src/utility/const.h
+|  24| enum•class•Const•{•Yes,•No•};
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+|  28|  28| 
+|  29|  29| BindingsConfiguration Bindings;
+|  30|  30| 
+|  31|    |-namespace {
+|  32|    |-
+|  33|    |-void warning(const char *msg)
+|  34|    |-{
+|  35|    |-	std::cerr << "WARNING: " << msg << "\n";
+|    |  31|+namespace
+|    |  32|+{
+|    |  33|+
+|    |  34|+    void warning (const char *msg)
+|    |  35|+    {
+|    |  36|+        std::cerr << "WARNING: " << msg << "\n";
+|    |  37|+    }
+|    |  38|+
+|    |  39|+    NC::Key::Type stringToKey (const std::string & s);
+|    |  40|+
+|    |  41|+    NC::Key::Type stringToSpecialKey (const std::string & s)
+|    |  42|+    {
+|    |  43|+        NC::Key::Type result = NC::Key::None;
+|    |  44|+        if (!s.compare (0, 4, "ctrl") && s.length () == 6 && s[4] == '-')
+|    |  45|+          {
+|    |  46|+              if (s[5] >= 'a' && s[5] <= 'z')
+|    |  47|+                  result = NC::Key::Ctrl_A + (s[5] - 'a');
+|    |  48|+              else if (s[5] == '[')
+|    |  49|+                  result = NC::Key::Ctrl_LeftBracket;
+|    |  50|+              else if (s[5] == '\\')
+|    |  51|+                  result = NC::Key::Ctrl_Backslash;
+|    |  52|+              else if (s[5] == ']')
+|    |  53|+                  result = NC::Key::Ctrl_RightBracket;
+|    |  54|+              else if (s[5] == '^')
+|    |  55|+                  result = NC::Key::Ctrl_Caret;
+|    |  56|+              else if (s[5] == '_')
+|    |  57|+                  result = NC::Key::Ctrl_Underscore;
+|    |  58|+          }
+|    |  59|+        else if (!s.compare (0, 3, "alt") && s.length () > 3 && s[3] == '-')
+|    |  60|+          {
+|    |  61|+              result = NC::Key::Alt | stringToKey (s.substr (4));
+|    |  62|+          }
+|    |  63|+        else if (!s.compare (0, 4, "ctrl") && s.length () > 4 && s[4] == '-')
+|    |  64|+          {
+|    |  65|+              result = NC::Key::Ctrl | stringToKey (s.substr (5));
+|    |  66|+          }
+|    |  67|+        else if (!s.compare (0, 5, "shift") && s.length () > 5 && s[5] == '-')
+|    |  68|+          {
+|    |  69|+              result = NC::Key::Shift | stringToKey (s.substr (6));
+|    |  70|+          }
+|    |  71|+        else if (!s.compare ("escape"))
+|    |  72|+            result = NC::Key::Escape;
+|    |  73|+        else if (!s.compare ("mouse"))
+|    |  74|+            result = NC::Key::Mouse;
+|    |  75|+        else if (!s.compare ("up"))
+|    |  76|+            result = NC::Key::Up;
+|    |  77|+        else if (!s.compare ("down"))
+|    |  78|+            result = NC::Key::Down;
+|    |  79|+        else if (!s.compare ("page_up"))
+|    |  80|+            result = NC::Key::PageUp;
+|    |  81|+        else if (!s.compare ("page_down"))
+|    |  82|+            result = NC::Key::PageDown;
+|    |  83|+        else if (!s.compare ("home"))
+|    |  84|+            result = NC::Key::Home;
+|    |  85|+        else if (!s.compare ("end"))
+|    |  86|+            result = NC::Key::End;
+|    |  87|+        else if (!s.compare ("space"))
+|    |  88|+            result = NC::Key::Space;
+|    |  89|+        else if (!s.compare ("enter"))
+|    |  90|+            result = NC::Key::Enter;
+|    |  91|+        else if (!s.compare ("insert"))
+|    |  92|+            result = NC::Key::Insert;
+|    |  93|+        else if (!s.compare ("delete"))
+|    |  94|+            result = NC::Key::Delete;
+|    |  95|+        else if (!s.compare ("left"))
+|    |  96|+            result = NC::Key::Left;
+|    |  97|+        else if (!s.compare ("right"))
+|    |  98|+            result = NC::Key::Right;
+|    |  99|+        else if (!s.compare ("tab"))
+|    | 100|+            result = NC::Key::Tab;
+|    | 101|+        else if ((s.length () == 2 || s.length () == 3) && s[0] == 'f')
+|    | 102|+          {
+|    | 103|+              int n = atoi (s.c_str () + 1);
+|    | 104|+              if (n >= 1 && n <= 12)
+|    | 105|+                  result = NC::Key::F1 + n - 1;
+|    | 106|+          }
+|    | 107|+        else if (!s.compare ("backspace"))
+|    | 108|+            result = NC::Key::Backspace;
+|    | 109|+        return result;
+|    | 110|+    }
+|    | 111|+
+|    | 112|+    NC::Key::Type stringToKey (const std::string & s)
+|    | 113|+    {
+|    | 114|+        NC::Key::Type result = stringToSpecialKey (s);
+|    | 115|+        if (result == NC::Key::None)
+|    | 116|+          {
+|    | 117|+              std::wstring ws = ToWString (s);
+|    | 118|+              if (ws.length () == 1)
+|    | 119|+                  result = ws[0];
+|    | 120|+          }
+|    | 121|+        return result;
+|    | 122|+    }
+|    | 123|+
+|    | 124|+    template < typename F >
+|    | 125|+        std::shared_ptr < Actions::BaseAction >
+|    | 126|+        parseActionLine (const std::string & line, F error)
+|    | 127|+    {
+|    | 128|+        std::shared_ptr < Actions::BaseAction > result;
+|    | 129|+        size_t i = 0;
+|    | 130|+        for (; i < line.size () && !isspace (line[i]); ++i)
+|    | 131|+          {
+|    | 132|+          }
+|    | 133|+        if (i == line.size ())  // only action name
+|    | 134|+          {
+|    | 135|+              if (line == "set_visualizer_sample_multiplier")
+|    | 136|+                {
+|    | 137|+                    warning
+|    | 138|+                        ("action 'set_visualizer_sample_multiplier' is deprecated"
+|    | 139|+                         " and will be removed in 0.9");
+|    | 140|+                    result = Actions::get_ (Actions::Type::Dummy);
+|    | 141|+                }
+|    | 142|+              else
+|    | 143|+                  result = Actions::get_ (line);
+|    | 144|+          }
+|    | 145|+        else                    // there is something else
+|    | 146|+          {
+|    | 147|+              std::string action_name = line.substr (0, i);
+|    | 148|+              if (action_name == "push_character")
+|    | 149|+                {
+|    | 150|+                    // push single character into input queue
+|    | 151|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 152|+                    NC::Key::Type k = stringToSpecialKey (arg);
+|    | 153|+                    if (k != NC::Key::None)
+|    | 154|+                        result =
+|    | 155|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 156|+                            (std::make_shared < Actions::PushCharacters >
+|    | 157|+                             (&Global::wFooter, std::vector < NC::Key::Type >
+|    | 158|+                              {
+|    | 159|+                              k}
+|    | 160|+                             ));
+|    | 161|+                    else
+|    | 162|+                    error () << "invalid character passed to push_character: '"
+|    | 163|+                        << arg << "'\n";
+|    | 164|+                }
+|    | 165|+              else if (action_name == "push_characters")
+|    | 166|+                {
+|    | 167|+                    // push sequence of characters into input queue
+|    | 168|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 169|+                    if (!arg.empty ())
+|    | 170|+                      {
+|    | 171|+                          // if char is signed, erase 1s from char -> int conversion
+|    | 172|+                          for (auto it = arg.begin (); it != arg.end (); ++it)
+|    | 173|+                              *it &= 0xff;
+|    | 174|+                          result =
+|    | 175|+                              std::static_pointer_cast < Actions::BaseAction >
+|    | 176|+                              (std::make_shared < Actions::PushCharacters >
+|    | 177|+                               (&Global::wFooter, std::vector < NC::Key::Type >
+|    | 178|+                                {
+|    | 179|+                                arg.begin (), arg.end ()}
+|    | 180|+                               ));
+|    | 181|+                      }
+|    | 182|+                    else
+|    | 183|+                        error () <<
+|    | 184|+                            "empty argument passed to push_characters\n";
+|    | 185|+                }
+|    | 186|+              else if (action_name == "require_screen")
+|    | 187|+                {
+|    | 188|+                    // require screen of given type
+|    | 189|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 190|+                    ScreenType screen_type = stringToScreenType (arg);
+|    | 191|+                    if (screen_type != ScreenType::Unknown)
+|    | 192|+                        result =
+|    | 193|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 194|+                            (std::make_shared < Actions::RequireScreen >
+|    | 195|+                             (screen_type));
+|    | 196|+                    else
+|    | 197|+                        error () <<
+|    | 198|+                            "unknown screen passed to require_screen: '" << arg
+|    | 199|+                            << "'\n";
+|    | 200|+                }
+|    | 201|+              else if (action_name == "require_runnable")
+|    | 202|+                {
+|    | 203|+                    // require that given action is runnable
+|    | 204|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 205|+                    auto action = Actions::get_ (arg);
+|    | 206|+                    if (action)
+|    | 207|+                        result =
+|    | 208|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 209|+                            (std::make_shared < Actions::RequireRunnable >
+|    | 210|+                             (action));
+|    | 211|+                    else
+|    | 212|+                        error () <<
+|    | 213|+                            "unknown action passed to require_runnable: '" <<
+|    | 214|+                            arg << "'\n";
+|    | 215|+                }
+|    | 216|+              else if (action_name == "run_external_command")
+|    | 217|+                {
+|    | 218|+                    std::string command =
+|    | 219|+                        getEnclosedString (line, '"', '"', 0);
+|    | 220|+                    if (!command.empty ())
+|    | 221|+                        result =
+|    | 222|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 223|+                            (std::make_shared < Actions::RunExternalCommand >
+|    | 224|+                             (std::move (command)));
+|    | 225|+                    else
+|    | 226|+                        error () <<
+|    | 227|+                            "empty command passed to run_external_command\n";
+|    | 228|+                }
+|    | 229|+          }
+|    | 230|+        return result;
+|    | 231|+    }
+|    | 232|+
+|  36| 233| }
+|  37| 234| 
+|  38| 235| NC::Key::Type stringToKey(const std::string &s);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+|  35|  35| 	std::cerr << "WARNING: " << msg << "\n";
+|  36|  36| }
+|  37|  37| 
+|  38|    |-NC::Key::Type stringToKey(const std::string &s);
+|  39|    |-
+|  40|    |-NC::Key::Type stringToSpecialKey(const std::string &s)
+|  41|    |-{
+|  42|    |-	NC::Key::Type result = NC::Key::None;
+|  43|    |-	if (!s.compare(0, 4, "ctrl") && s.length() == 6 && s[4] == '-')
+|  44|    |-	{
+|  45|    |-		if (s[5] >= 'a' && s[5] <= 'z')
+|  46|    |-			result = NC::Key::Ctrl_A + (s[5] - 'a');
+|  47|    |-		else if (s[5] == '[')
+|  48|    |-			result = NC::Key::Ctrl_LeftBracket;
+|  49|    |-		else if (s[5] == '\\')
+|  50|    |-			result = NC::Key::Ctrl_Backslash;
+|  51|    |-		else if (s[5] == ']')
+|  52|    |-			result = NC::Key::Ctrl_RightBracket;
+|  53|    |-		else if (s[5] == '^')
+|  54|    |-			result = NC::Key::Ctrl_Caret;
+|  55|    |-		else if (s[5] == '_')
+|  56|    |-			result = NC::Key::Ctrl_Underscore;
+|  57|    |-	}
+|  58|    |-	else if (!s.compare(0, 3, "alt") && s.length() > 3 && s[3] == '-')
+|  59|    |-	{
+|  60|    |-		result = NC::Key::Alt | stringToKey(s.substr(4));
+|  61|    |-	}
+|  62|    |-	else if (!s.compare(0, 4, "ctrl") && s.length() > 4 && s[4] == '-')
+|  63|    |-	{
+|  64|    |-		result = NC::Key::Ctrl | stringToKey(s.substr(5));
+|  65|    |-	}
+|  66|    |-	else if (!s.compare(0, 5, "shift") && s.length() > 5 && s[5] == '-')
+|  67|    |-	{
+|  68|    |-		result = NC::Key::Shift | stringToKey(s.substr(6));
+|  69|    |-	}
+|  70|    |-	else if (!s.compare("escape"))
+|  71|    |-		result = NC::Key::Escape;
+|  72|    |-	else if (!s.compare("mouse"))
+|  73|    |-		result = NC::Key::Mouse;
+|  74|    |-	else if (!s.compare("up"))
+|  75|    |-		result = NC::Key::Up;
+|  76|    |-	else if (!s.compare("down"))
+|  77|    |-		result = NC::Key::Down;
+|  78|    |-	else if (!s.compare("page_up"))
+|  79|    |-		result = NC::Key::PageUp;
+|  80|    |-	else if (!s.compare("page_down"))
+|  81|    |-		result = NC::Key::PageDown;
+|  82|    |-	else if (!s.compare("home"))
+|  83|    |-		result = NC::Key::Home;
+|  84|    |-	else if (!s.compare("end"))
+|  85|    |-		result = NC::Key::End;
+|  86|    |-	else if (!s.compare("space"))
+|  87|    |-		result = NC::Key::Space;
+|  88|    |-	else if (!s.compare("enter"))
+|  89|    |-		result = NC::Key::Enter;
+|  90|    |-	else if (!s.compare("insert"))
+|  91|    |-		result = NC::Key::Insert;
+|  92|    |-	else if (!s.compare("delete"))
+|  93|    |-		result = NC::Key::Delete;
+|  94|    |-	else if (!s.compare("left"))
+|  95|    |-		result = NC::Key::Left;
+|  96|    |-	else if (!s.compare("right"))
+|  97|    |-		result = NC::Key::Right;
+|  98|    |-	else if (!s.compare("tab"))
+|  99|    |-		result = NC::Key::Tab;
+| 100|    |-	else if ((s.length() == 2 || s.length() == 3) && s[0] == 'f')
+| 101|    |-	{
+| 102|    |-		int n = atoi(s.c_str() + 1);
+| 103|    |-		if (n >= 1 && n <= 12)
+| 104|    |-			result = NC::Key::F1 + n - 1;
+| 105|    |-	}
+| 106|    |-	else if (!s.compare("backspace"))
+| 107|    |-		result = NC::Key::Backspace;
+| 108|    |-	return result;
+|    |  38|+NC::Key::Type readKey (NC::Window & w)
+|    |  39|+{
+|    |  40|+    NC::Key::Type result = NC::Key::None;
+|    |  41|+    std::string tmp;
+|    |  42|+    NC::Key::Type input;
+|    |  43|+    bool
+|    |  44|+        alt_pressed = false;
+|    |  45|+    while (true)
+|    |  46|+      {
+|    |  47|+          input = w.readKey ();
+|    |  48|+          if (input == NC::Key::None)
+|    |  49|+              break;
+|    |  50|+          if (input & NC::Key::Alt)
+|    |  51|+            {
+|    |  52|+                // Complete the key and reapply the mask at the end.
+|    |  53|+                alt_pressed = true;
+|    |  54|+                input &= ~NC::Key::Alt;
+|    |  55|+            }
+|    |  56|+          if (input > 255)      // NC special character
+|    |  57|+            {
+|    |  58|+                result = input;
+|    |  59|+                break;
+|    |  60|+            }
+|    |  61|+          else
+|    |  62|+            {
+|    |  63|+                wchar_t
+|    |  64|+                    wc;
+|    |  65|+                tmp += input;
+|    |  66|+                size_t
+|    |  67|+                    conv_res = mbrtowc (&wc, tmp.c_str (), MB_CUR_MAX, 0);
+|    |  68|+                if (conv_res == size_t (-1))    // incomplete multibyte character
+|    |  69|+                    continue;
+|    |  70|+                else if (conv_res == size_t (-2))   // garbage character sequence
+|    |  71|+                    break;
+|    |  72|+                else            // character complete
+|    |  73|+                  {
+|    |  74|+                      result = wc;
+|    |  75|+                      break;
+|    |  76|+                  }
+|    |  77|+            }
+|    |  78|+      }
+|    |  79|+    if (alt_pressed)
+|    |  80|+        result |= NC::Key::Alt;
+|    |  81|+    return result;
+| 109|  82| }
+| 110|  83| 
+| 111|  84| NC::Key::Type stringToKey(const std::string &s)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+| 108| 108| 	return result;
+| 109| 109| }
+| 110| 110| 
+| 111|    |-NC::Key::Type stringToKey(const std::string &s)
+| 112|    |-{
+| 113|    |-	NC::Key::Type result = stringToSpecialKey(s);
+| 114|    |-	if (result == NC::Key::None)
+| 115|    |-	{
+| 116|    |-		std::wstring ws = ToWString(s);
+| 117|    |-		if (ws.length() == 1)
+| 118|    |-			result = ws[0];
+| 119|    |-	}
+| 120|    |-	return result;
+|    | 111|+std::wstring keyToWString (const NC::Key::Type key)
+|    | 112|+{
+|    | 113|+    std::wstring result;
+|    | 114|+
+|    | 115|+    if (key == NC::Key::Tab)
+|    | 116|+        result += L"Tab";
+|    | 117|+    else if (key == NC::Key::Enter)
+|    | 118|+        result += L"Enter";
+|    | 119|+    else if (key == NC::Key::Escape)
+|    | 120|+        result += L"Escape";
+|    | 121|+    else if (key >= NC::Key::Ctrl_A && key <= NC::Key::Ctrl_Z)
+|    | 122|+      {
+|    | 123|+          result += L"Ctrl-";
+|    | 124|+          result += 'A' + (key - NC::Key::Ctrl_A);
+|    | 125|+      }
+|    | 126|+    else if (key == NC::Key::Ctrl_LeftBracket)
+|    | 127|+        result += L"Ctrl-[";
+|    | 128|+    else if (key == NC::Key::Ctrl_Backslash)
+|    | 129|+        result += L"Ctrl-\\";
+|    | 130|+    else if (key == NC::Key::Ctrl_RightBracket)
+|    | 131|+        result += L"Ctrl-]";
+|    | 132|+    else if (key == NC::Key::Ctrl_Caret)
+|    | 133|+        result += L"Ctrl-^";
+|    | 134|+    else if (key == NC::Key::Ctrl_Underscore)
+|    | 135|+        result += L"Ctrl-_";
+|    | 136|+    else if (key & NC::Key::Alt)
+|    | 137|+      {
+|    | 138|+          result += L"Alt-";
+|    | 139|+          result += keyToWString (key & ~NC::Key::Alt);
+|    | 140|+      }
+|    | 141|+    else if (key & NC::Key::Ctrl)
+|    | 142|+      {
+|    | 143|+          result += L"Ctrl-";
+|    | 144|+          result += keyToWString (key & ~NC::Key::Ctrl);
+|    | 145|+      }
+|    | 146|+    else if (key & NC::Key::Shift)
+|    | 147|+      {
+|    | 148|+          result += L"Shift-";
+|    | 149|+          result += keyToWString (key & ~NC::Key::Shift);
+|    | 150|+      }
+|    | 151|+    else if (key == NC::Key::Space)
+|    | 152|+        result += L"Space";
+|    | 153|+    else if (key == NC::Key::Backspace)
+|    | 154|+        result += L"Backspace";
+|    | 155|+    else if (key == NC::Key::Insert)
+|    | 156|+        result += L"Insert";
+|    | 157|+    else if (key == NC::Key::Delete)
+|    | 158|+        result += L"Delete";
+|    | 159|+    else if (key == NC::Key::Home)
+|    | 160|+        result += L"Home";
+|    | 161|+    else if (key == NC::Key::End)
+|    | 162|+        result += L"End";
+|    | 163|+    else if (key == NC::Key::PageUp)
+|    | 164|+        result += L"PageUp";
+|    | 165|+    else if (key == NC::Key::PageDown)
+|    | 166|+        result += L"PageDown";
+|    | 167|+    else if (key == NC::Key::Up)
+|    | 168|+        result += L"Up";
+|    | 169|+    else if (key == NC::Key::Down)
+|    | 170|+        result += L"Down";
+|    | 171|+    else if (key == NC::Key::Left)
+|    | 172|+        result += L"Left";
+|    | 173|+    else if (key == NC::Key::Right)
+|    | 174|+        result += L"Right";
+|    | 175|+    else if (key >= NC::Key::F1 && key <= NC::Key::F9)
+|    | 176|+      {
+|    | 177|+          result += L"F";
+|    | 178|+          result += '1' + (key - NC::Key::F1);
+|    | 179|+      }
+|    | 180|+    else if (key >= NC::Key::F10 && key <= NC::Key::F12)
+|    | 181|+      {
+|    | 182|+          result += L"F1";
+|    | 183|+          result += '0' + (key - NC::Key::F10);
+|    | 184|+      }
+|    | 185|+    else
+|    | 186|+        result += std::wstring (1, key);
+|    | 187|+
+|    | 188|+    return result;
+| 121| 189| }
+| 122| 190| 
+| 123| 191| template <typename F>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+| 120| 120| 	return result;
+| 121| 121| }
+| 122| 122| 
+| 123|    |-template <typename F>
+| 124|    |-std::shared_ptr<Actions::BaseAction> parseActionLine(const std::string &line, F error)
+|    | 123|+bool
+|    | 124|+BindingsConfiguration::read (const std::string & file)
+| 125| 125| {
+| 126|    |-	std::shared_ptr<Actions::BaseAction> result;
+| 127|    |-	size_t i = 0;
+| 128|    |-	for (; i < line.size() && !isspace(line[i]); ++i) { }
+| 129|    |-	if (i == line.size()) // only action name
+| 130|    |-	{
+| 131|    |-		if (line == "set_visualizer_sample_multiplier")
+| 132|    |-		{
+| 133|    |-			warning("action 'set_visualizer_sample_multiplier' is deprecated"
+| 134|    |-			        " and will be removed in 0.9");
+| 135|    |-			result = Actions::get_(Actions::Type::Dummy);
+| 136|    |-		}
+| 137|    |-		else
+| 138|    |-			result = Actions::get_(line);
+| 139|    |-	}
+| 140|    |-	else // there is something else
+| 141|    |-	{
+| 142|    |-		std::string action_name = line.substr(0, i);
+| 143|    |-		if (action_name == "push_character")
+| 144|    |-		{
+| 145|    |-			// push single character into input queue
+| 146|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 147|    |-			NC::Key::Type k = stringToSpecialKey(arg);
+| 148|    |-			if (k != NC::Key::None)
+| 149|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 150|    |-					std::make_shared<Actions::PushCharacters>(
+| 151|    |-						&Global::wFooter,
+| 152|    |-						std::vector<NC::Key::Type>{k}));
+| 153|    |-			else
+| 154|    |-				error() << "invalid character passed to push_character: '" << arg << "'\n";
+| 155|    |-		}
+| 156|    |-		else if (action_name == "push_characters")
+| 157|    |-		{
+| 158|    |-			// push sequence of characters into input queue
+| 159|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 160|    |-			if (!arg.empty())
+| 161|    |-			{
+| 162|    |-				// if char is signed, erase 1s from char -> int conversion
+| 163|    |-				for (auto it = arg.begin(); it != arg.end(); ++it)
+| 164|    |-					*it &= 0xff;
+| 165|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 166|    |-					std::make_shared<Actions::PushCharacters>(
+| 167|    |-						&Global::wFooter,
+| 168|    |-						std::vector<NC::Key::Type>{arg.begin(), arg.end()}));
+| 169|    |-			}
+| 170|    |-			else
+| 171|    |-				error() << "empty argument passed to push_characters\n";
+| 172|    |-		}
+| 173|    |-		else if (action_name == "require_screen")
+| 174|    |-		{
+| 175|    |-			// require screen of given type
+| 176|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 177|    |-			ScreenType screen_type = stringToScreenType(arg);
+| 178|    |-			if (screen_type != ScreenType::Unknown)
+| 179|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 180|    |-					std::make_shared<Actions::RequireScreen>(screen_type));
+| 181|    |-			else
+| 182|    |-				error() << "unknown screen passed to require_screen: '" << arg << "'\n";
+| 183|    |-		}
+| 184|    |-		else if (action_name == "require_runnable")
+| 185|    |-		{
+| 186|    |-			// require that given action is runnable
+| 187|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 188|    |-			auto action = Actions::get_(arg);
+| 189|    |-			if (action)
+| 190|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 191|    |-					std::make_shared<Actions::RequireRunnable>(action));
+| 192|    |-			else
+| 193|    |-				error() << "unknown action passed to require_runnable: '" << arg << "'\n";
+| 194|    |-		}
+| 195|    |-		else if (action_name == "run_external_command")
+| 196|    |-		{
+| 197|    |-			std::string command = getEnclosedString(line, '"', '"', 0);
+| 198|    |-			if (!command.empty())
+| 199|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 200|    |-					std::make_shared<Actions::RunExternalCommand>(std::move(command)));
+| 201|    |-			else
+| 202|    |-				error() << "empty command passed to run_external_command\n";
+| 203|    |-		}
+| 204|    |-	}
+| 205|    |-	return result;
+| 206|    |-}
+| 207|    |-
+| 208|    |-}
+| 209|    |-
+| 210|    |-NC::Key::Type readKey(NC::Window &w)
+| 211|    |-{
+| 212|    |-	NC::Key::Type result = NC::Key::None;
+| 213|    |-	std::string tmp;
+| 214|    |-	NC::Key::Type input;
+| 215|    |-	bool alt_pressed = false;
+| 216|    |-	while (true)
+| 217|    |-	{
+| 218|    |-		input = w.readKey();
+| 219|    |-		if (input == NC::Key::None)
+| 220|    |-			break;
+| 221|    |-		if (input & NC::Key::Alt)
+| 222|    |-		{
+| 223|    |-			// Complete the key and reapply the mask at the end.
+| 224|    |-			alt_pressed = true;
+| 225|    |-			input &= ~NC::Key::Alt;
+| 226|    |-		}
+| 227|    |-		if (input > 255) // NC special character
+| 228|    |-		{
+| 229|    |-			result = input;
+| 230|    |-			break;
+| 231|    |-		}
+| 232|    |-		else
+| 233|    |-		{
+| 234|    |-			wchar_t wc;
+| 235|    |-			tmp += input;
+| 236|    |-			size_t conv_res = mbrtowc(&wc, tmp.c_str(), MB_CUR_MAX, 0);
+| 237|    |-			if (conv_res == size_t(-1)) // incomplete multibyte character
+| 238|    |-				continue;
+| 239|    |-			else if (conv_res == size_t(-2)) // garbage character sequence
+| 240|    |-				break;
+| 241|    |-			else // character complete
+| 242|    |-			{
+| 243|    |-				result = wc;
+| 244|    |-				break;
+| 245|    |-			}
+| 246|    |-		}
+| 247|    |-	}
+| 248|    |-	if (alt_pressed)
+| 249|    |-		result |= NC::Key::Alt;
+| 250|    |-	return result;
+| 251|    |-}
+| 252|    |-
+| 253|    |-std::wstring keyToWString(const NC::Key::Type key)
+| 254|    |-{
+| 255|    |-	std::wstring result;
+| 256|    |-
+| 257|    |-	if (key == NC::Key::Tab)
+| 258|    |-		result += L"Tab";
+| 259|    |-	else if (key == NC::Key::Enter)
+| 260|    |-		result += L"Enter";
+| 261|    |-	else if (key == NC::Key::Escape)
+| 262|    |-		result += L"Escape";
+| 263|    |-	else if (key >= NC::Key::Ctrl_A && key <= NC::Key::Ctrl_Z)
+| 264|    |-	{
+| 265|    |-		result += L"Ctrl-";
+| 266|    |-		result += 'A' + (key - NC::Key::Ctrl_A);
+| 267|    |-	}
+| 268|    |-	else if (key == NC::Key::Ctrl_LeftBracket)
+| 269|    |-		result += L"Ctrl-[";
+| 270|    |-	else if (key == NC::Key::Ctrl_Backslash)
+| 271|    |-		result += L"Ctrl-\\";
+| 272|    |-	else if (key == NC::Key::Ctrl_RightBracket)
+| 273|    |-		result += L"Ctrl-]";
+| 274|    |-	else if (key == NC::Key::Ctrl_Caret)
+| 275|    |-		result += L"Ctrl-^";
+| 276|    |-	else if (key == NC::Key::Ctrl_Underscore)
+| 277|    |-		result += L"Ctrl-_";
+| 278|    |-	else if (key & NC::Key::Alt)
+| 279|    |-	{
+| 280|    |-		result += L"Alt-";
+| 281|    |-		result += keyToWString(key & ~NC::Key::Alt);
+| 282|    |-	}
+| 283|    |-	else if (key & NC::Key::Ctrl)
+| 284|    |-	{
+| 285|    |-		result += L"Ctrl-";
+| 286|    |-		result += keyToWString(key & ~NC::Key::Ctrl);
+| 287|    |-	}
+| 288|    |-	else if (key & NC::Key::Shift)
+| 289|    |-	{
+| 290|    |-		result += L"Shift-";
+| 291|    |-		result += keyToWString(key & ~NC::Key::Shift);
+| 292|    |-	}
+| 293|    |-	else if (key == NC::Key::Space)
+| 294|    |-		result += L"Space";
+| 295|    |-	else if (key == NC::Key::Backspace)
+| 296|    |-		result += L"Backspace";
+| 297|    |-	else if (key == NC::Key::Insert)
+| 298|    |-		result += L"Insert";
+| 299|    |-	else if (key == NC::Key::Delete)
+| 300|    |-		result += L"Delete";
+| 301|    |-	else if (key == NC::Key::Home)
+| 302|    |-		result += L"Home";
+| 303|    |-	else if (key == NC::Key::End)
+| 304|    |-		result += L"End";
+| 305|    |-	else if (key == NC::Key::PageUp)
+| 306|    |-		result += L"PageUp";
+| 307|    |-	else if (key == NC::Key::PageDown)
+| 308|    |-		result += L"PageDown";
+| 309|    |-	else if (key == NC::Key::Up)
+| 310|    |-		result += L"Up";
+| 311|    |-	else if (key == NC::Key::Down)
+| 312|    |-		result += L"Down";
+| 313|    |-	else if (key == NC::Key::Left)
+| 314|    |-		result += L"Left";
+| 315|    |-	else if (key == NC::Key::Right)
+| 316|    |-		result += L"Right";
+| 317|    |-	else if (key >= NC::Key::F1 && key <= NC::Key::F9)
+| 318|    |-	{
+| 319|    |-		result += L"F";
+| 320|    |-		result += '1' + (key - NC::Key::F1);
+| 321|    |-	}
+| 322|    |-	else if (key >= NC::Key::F10 && key <= NC::Key::F12)
+| 323|    |-	{
+| 324|    |-		result += L"F1";
+| 325|    |-		result += '0' + (key - NC::Key::F10);
+| 326|    |-	}
+| 327|    |-	else
+| 328|    |-		result += std::wstring(1, key);
+| 329|    |-
+| 330|    |-	return result;
+| 331|    |-}
+| 332|    |-
+| 333|    |-bool BindingsConfiguration::read(const std::string &file)
+| 334|    |-{
+| 335|    |-	enum class InProgress { None, Command, Key };
+| 336|    |-	
+| 337|    |-	bool result = true;
+| 338|    |-	
+| 339|    |-	std::ifstream f(file);
+| 340|    |-	if (!f.is_open())
+| 341|    |-		return result;
+| 342|    |-	
+| 343|    |-	// shared variables
+| 344|    |-	InProgress in_progress = InProgress::None;
+| 345|    |-	size_t line_no = 0;
+| 346|    |-	std::string line;
+| 347|    |-	Binding::ActionChain actions;
+| 348|    |-	
+| 349|    |-	// def_key specific variables
+| 350|    |-	NC::Key::Type key = NC::Key::None;
+| 351|    |-	std::string strkey;
+| 352|    |-	
+| 353|    |-	// def_command specific variables
+| 354|    |-	bool cmd_immediate = false;
+| 355|    |-	std::string cmd_name;
+| 356|    |-	
+| 357|    |-	auto error = [&]() -> std::ostream & {
+| 358|    |-		std::cerr << file << ":" << line_no << ": error: ";
+| 359|    |-		in_progress = InProgress::None;
+| 360|    |-		result = false;
+| 361|    |-		return std::cerr;
+| 362|    |-	};
+| 363|    |-	
+| 364|    |-	auto bind_in_progress = [&]() -> bool {
+| 365|    |-		if (in_progress == InProgress::Command)
+| 366|    |-		{
+| 367|    |-			if (!actions.empty())
+| 368|    |-			{
+| 369|    |-				m_commands.insert(std::make_pair(cmd_name, Command(std::move(actions), cmd_immediate)));
+| 370|    |-				actions.clear();
+| 371|    |-				return true;
+| 372|    |-			}
+| 373|    |-			else
+| 374|    |-			{
+| 375|    |-				error() << "definition of command '" << cmd_name << "' cannot be empty\n";
+| 376|    |-				return false;
+| 377|    |-			}
+| 378|    |-		}
+| 379|    |-		else if (in_progress == InProgress::Key)
+| 380|    |-		{
+| 381|    |-			if (!actions.empty())
+| 382|    |-			{
+| 383|    |-				bind(key, actions);
+| 384|    |-				actions.clear();
+| 385|    |-				return true;
+| 386|    |-			}
+| 387|    |-			else
+| 388|    |-			{
+| 389|    |-				error() << "definition of key '" << strkey << "' cannot be empty\n";
+| 390|    |-				return false;
+| 391|    |-			}
+| 392|    |-		}
+| 393|    |-		return true;
+| 394|    |-	};
+| 395|    |-	
+| 396|    |-	const char def_command[] = "def_command";
+| 397|    |-	const char def_key[] = "def_key";
+| 398|    |-	
+| 399|    |-	while (!f.eof() && ++line_no)
+| 400|    |-	{
+| 401|    |-		getline(f, line);
+| 402|    |-		if (line.empty() || line[0] == '#')
+| 403|    |-			continue;
+| 404|    |-		
+| 405|    |-		// beginning of command definition
+| 406|    |-		if (!line.compare(0, const_strlen(def_command), def_command))
+| 407|    |-		{
+| 408|    |-			if (!bind_in_progress())
+| 409|    |-				break;
+| 410|    |-			in_progress = InProgress::Command;
+| 411|    |-			cmd_name = getEnclosedString(line, '"', '"', 0);
+| 412|    |-			if (cmd_name.empty())
+| 413|    |-			{
+| 414|    |-				error() << "command must have non-empty name\n";
+| 415|    |-				break;
+| 416|    |-			}
+| 417|    |-			if (m_commands.find(cmd_name) != m_commands.end())
+| 418|    |-			{
+| 419|    |-				error() << "redefinition of command '" << cmd_name << "'\n";
+| 420|    |-				break;
+| 421|    |-			}
+| 422|    |-			std::string cmd_type = getEnclosedString(line, '[', ']', 0);
+| 423|    |-			if (cmd_type == "immediate")
+| 424|    |-				cmd_immediate = true;
+| 425|    |-			else if (cmd_type == "deferred")
+| 426|    |-				cmd_immediate = false;
+| 427|    |-			else
+| 428|    |-			{
+| 429|    |-				error() << "invalid type of command: '" << cmd_type << "'\n";
+| 430|    |-				break;
+| 431|    |-			}
+| 432|    |-		}
+| 433|    |-		// beginning of key definition
+| 434|    |-		else if (!line.compare(0, const_strlen(def_key), def_key))
+| 435|    |-		{
+| 436|    |-			if (!bind_in_progress())
+| 437|    |-				break;
+| 438|    |-			in_progress = InProgress::Key;
+| 439|    |-			strkey = getEnclosedString(line, '"', '"', 0);
+| 440|    |-			key = stringToKey(strkey);
+| 441|    |-			if (key == NC::Key::None)
+| 442|    |-			{
+| 443|    |-				error() << "invalid key: '" << strkey << "'\n";
+| 444|    |-				break;
+| 445|    |-			}
+| 446|    |-		}
+| 447|    |-		else if (isspace(line[0])) // name of action to be bound
+| 448|    |-		{
+| 449|    |-			boost::trim(line);
+| 450|    |-			auto action = parseActionLine(line, error);
+| 451|    |-			if (action)
+| 452|    |-				actions.push_back(action);
+| 453|    |-			else
+| 454|    |-			{
+| 455|    |-				error() << "unknown action: '" << line << "'\n";
+| 456|    |-				break;
+| 457|    |-			}
+| 458|    |-		}
+| 459|    |-		else
+| 460|    |-		{
+| 461|    |-			error() << "invalid line: '" << line << "'\n";
+| 462|    |-			break;
+| 463|    |-		}
+| 464|    |-	}
+| 465|    |-	bind_in_progress();
+| 466|    |-	f.close();
+| 467|    |-	return result;
+| 468|    |-}
+| 469|    |-
+| 470|    |-bool BindingsConfiguration::read(const std::vector<std::string> &binding_paths)
+| 471|    |-{
+| 472|    |-	return std::all_of(
+| 473|    |-		binding_paths.begin(),
+| 474|    |-		binding_paths.end(),
+| 475|    |-		[&](const std::string &binding_path) {
+| 476|    |-			return read(binding_path);
+| 477|    |-		}
+| 478|    |-	);
+| 479|    |-}
+| 480|    |-
+| 481|    |-void BindingsConfiguration::generateDefaults()
+| 482|    |-{
+| 483|    |-	NC::Key::Type k = NC::Key::None;
+| 484|    |-	bind(NC::Key::EoF, Actions::Type::Quit);
+| 485|    |-	if (notBound(k = stringToKey("mouse")))
+| 486|    |-		bind(k, Actions::Type::MouseEvent);
+| 487|    |-	if (notBound(k = stringToKey("up")))
+| 488|    |-		bind(k, Actions::Type::ScrollUp);
+| 489|    |-	if (notBound(k = stringToKey("shift-up")))
+| 490|    |-		bind(k, Binding::ActionChain({Actions::get_(Actions::Type::SelectItem), Actions::get_(Actions::Type::ScrollUp)}));
+| 491|    |-	if (notBound(k = stringToKey("down")))
+| 492|    |-		bind(k, Actions::Type::ScrollDown);
+| 493|    |-	if (notBound(k = stringToKey("shift-down")))
+| 494|    |-		bind(k, Binding::ActionChain({Actions::get_(Actions::Type::SelectItem), Actions::get_(Actions::Type::ScrollDown)}));
+| 495|    |-	if (notBound(k = stringToKey("[")))
+| 496|    |-		bind(k, Actions::Type::ScrollUpAlbum);
+| 497|    |-	if (notBound(k = stringToKey("]")))
+| 498|    |-		bind(k, Actions::Type::ScrollDownAlbum);
+| 499|    |-	if (notBound(k = stringToKey("{")))
+| 500|    |-		bind(k, Actions::Type::ScrollUpArtist);
+| 501|    |-	if (notBound(k = stringToKey("}")))
+| 502|    |-		bind(k, Actions::Type::ScrollDownArtist);
+| 503|    |-	if (notBound(k = stringToKey("page_up")))
+| 504|    |-		bind(k, Actions::Type::PageUp);
+| 505|    |-	if (notBound(k = stringToKey("page_down")))
+| 506|    |-		bind(k, Actions::Type::PageDown);
+| 507|    |-	if (notBound(k = stringToKey("home")))
+| 508|    |-		bind(k, Actions::Type::MoveHome);
+| 509|    |-	if (notBound(k = stringToKey("end")))
+| 510|    |-		bind(k, Actions::Type::MoveEnd);
+| 511|    |-	if (notBound(k = stringToKey("insert")))
+| 512|    |-		bind(k, Actions::Type::SelectItem);
+| 513|    |-	if (notBound(k = stringToKey("enter")))
+| 514|    |-	{
+| 515|    |-		bind(k, Actions::Type::EnterDirectory);
+| 516|    |-		bind(k, Actions::Type::ToggleOutput);
+| 517|    |-		bind(k, Actions::Type::RunAction);
+| 518|    |-		bind(k, Actions::Type::PlayItem);
+| 519|    |-	}
+| 520|    |-	if (notBound(k = stringToKey("space")))
+| 521|    |-	{
+| 522|    |-		bind(k, Actions::Type::AddItemToPlaylist);
+| 523|    |-		bind(k, Actions::Type::ToggleLyricsUpdateOnSongChange);
+| 524|    |-		bind(k, Actions::Type::ToggleVisualizationType);
+| 525|    |-	}
+| 526|    |-	if (notBound(k = stringToKey("delete")))
+| 527|    |-	{
+| 528|    |-		bind(k, Actions::Type::DeletePlaylistItems);
+| 529|    |-		bind(k, Actions::Type::DeleteBrowserItems);
+| 530|    |-		bind(k, Actions::Type::DeleteStoredPlaylist);
+| 531|    |-	}
+| 532|    |-	if (notBound(k = stringToKey("right")))
+| 533|    |-	{
+| 534|    |-		bind(k, Actions::Type::NextColumn);
+| 535|    |-		bind(k, Actions::Type::SlaveScreen);
+| 536|    |-		bind(k, Actions::Type::VolumeUp);
+| 537|    |-	}
+| 538|    |-	if (notBound(k = stringToKey("+")))
+| 539|    |-		bind(k, Actions::Type::VolumeUp);
+| 540|    |-	if (notBound(k = stringToKey("left")))
+| 541|    |-	{
+| 542|    |-		bind(k, Actions::Type::PreviousColumn);
+| 543|    |-		bind(k, Actions::Type::MasterScreen);
+| 544|    |-		bind(k, Actions::Type::VolumeDown);
+| 545|    |-	}
+| 546|    |-	if (notBound(k = stringToKey("-")))
+| 547|    |-		bind(k, Actions::Type::VolumeDown);
+| 548|    |-	if (notBound(k = stringToKey(":")))
+| 549|    |-		bind(k, Actions::Type::ExecuteCommand);
+| 550|    |-	if (notBound(k = stringToKey("tab")))
+| 551|    |-		bind(k, Actions::Type::NextScreen);
+| 552|    |-	if (notBound(k = stringToKey("shift-tab")))
+| 553|    |-		bind(k, Actions::Type::PreviousScreen);
+| 554|    |-	if (notBound(k = stringToKey("f1")))
+| 555|    |-		bind(k, Actions::Type::ShowHelp);
+| 556|    |-	if (notBound(k = stringToKey("1")))
+| 557|    |-		bind(k, Actions::Type::ShowPlaylist);
+| 558|    |-	if (notBound(k = stringToKey("2")))
+| 559|    |-	{
+| 560|    |-		bind(k, Actions::Type::ShowBrowser);
+| 561|    |-		bind(k, Actions::Type::ChangeBrowseMode);
+| 562|    |-	}
+| 563|    |-	if (notBound(k = stringToKey("3")))
+| 564|    |-	{
+| 565|    |-		bind(k, Actions::Type::ShowSearchEngine);
+| 566|    |-		bind(k, Actions::Type::ResetSearchEngine);
+| 567|    |-	}
+| 568|    |-	if (notBound(k = stringToKey("4")))
+| 569|    |-	{
+| 570|    |-		bind(k, Actions::Type::ShowMediaLibrary);
+| 571|    |-		bind(k, Actions::Type::ToggleMediaLibraryColumnsMode);
+| 572|    |-	}
+| 573|    |-	if (notBound(k = stringToKey("5")))
+| 574|    |-		bind(k, Actions::Type::ShowPlaylistEditor);
+| 575|    |-	if (notBound(k = stringToKey("6")))
+| 576|    |-		bind(k, Actions::Type::ShowTagEditor);
+| 577|    |-	if (notBound(k = stringToKey("7")))
+| 578|    |-		bind(k, Actions::Type::ShowOutputs);
+| 579|    |-	if (notBound(k = stringToKey("8")))
+| 580|    |-		bind(k, Actions::Type::ShowVisualizer);
+| 581|    |-	if (notBound(k = stringToKey("=")))
+| 582|    |-		bind(k, Actions::Type::ShowClock);
+| 583|    |-	if (notBound(k = stringToKey("@")))
+| 584|    |-		bind(k, Actions::Type::ShowServerInfo);
+| 585|    |-	if (notBound(k = stringToKey("s")))
+| 586|    |-		bind(k, Actions::Type::Stop);
+| 587|    |-	if (notBound(k = stringToKey("p")))
+| 588|    |-		bind(k, Actions::Type::Pause);
+| 589|    |-	if (notBound(k = stringToKey(">")))
+| 590|    |-		bind(k, Actions::Type::Next);
+| 591|    |-	if (notBound(k = stringToKey("<")))
+| 592|    |-		bind(k, Actions::Type::Previous);
+| 593|    |-	if (notBound(k = stringToKey("ctrl-h")))
+| 594|    |-	{
+| 595|    |-		bind(k, Actions::Type::JumpToParentDirectory);
+| 596|    |-		bind(k, Actions::Type::ReplaySong);
+| 597|    |-	}
+| 598|    |-	if (notBound(k = stringToKey("backspace")))
+| 599|    |-	{
+| 600|    |-		bind(k, Actions::Type::JumpToParentDirectory);
+| 601|    |-		bind(k, Actions::Type::ReplaySong);
+| 602|    |-	}
+| 603|    |-	if (notBound(k = stringToKey("f")))
+| 604|    |-		bind(k, Actions::Type::SeekForward);
+| 605|    |-	if (notBound(k = stringToKey("b")))
+| 606|    |-		bind(k, Actions::Type::SeekBackward);
+| 607|    |-	if (notBound(k = stringToKey("r")))
+| 608|    |-		bind(k, Actions::Type::ToggleRepeat);
+| 609|    |-	if (notBound(k = stringToKey("z")))
+| 610|    |-		bind(k, Actions::Type::ToggleRandom);
+| 611|    |-	if (notBound(k = stringToKey("y")))
+| 612|    |-	{
+| 613|    |-		bind(k, Actions::Type::SaveTagChanges);
+| 614|    |-		bind(k, Actions::Type::StartSearching);
+| 615|    |-		bind(k, Actions::Type::ToggleSingle);
+| 616|    |-	}
+| 617|    |-	if (notBound(k = stringToKey("R")))
+| 618|    |-		bind(k, Actions::Type::ToggleConsume);
+| 619|    |-	if (notBound(k = stringToKey("Y")))
+| 620|    |-		bind(k, Actions::Type::ToggleReplayGainMode);
+| 621|    |-	if (notBound(k = stringToKey("T")))
+| 622|    |-		bind(k, Actions::Type::ToggleAddMode);
+| 623|    |-	if (notBound(k = stringToKey("|")))
+| 624|    |-		bind(k, Actions::Type::ToggleMouse);
+| 625|    |-	if (notBound(k = stringToKey("#")))
+| 626|    |-		bind(k, Actions::Type::ToggleBitrateVisibility);
+| 627|    |-	if (notBound(k = stringToKey("Z")))
+| 628|    |-		bind(k, Actions::Type::Shuffle);
+| 629|    |-	if (notBound(k = stringToKey("x")))
+| 630|    |-		bind(k, Actions::Type::ToggleCrossfade);
+| 631|    |-	if (notBound(k = stringToKey("X")))
+| 632|    |-		bind(k, Actions::Type::SetCrossfade);
+| 633|    |-	if (notBound(k = stringToKey("u")))
+| 634|    |-		bind(k, Actions::Type::UpdateDatabase);
+| 635|    |-	if (notBound(k = stringToKey("ctrl-s")))
+| 636|    |-	{
+| 637|    |-		bind(k, Actions::Type::SortPlaylist);
+| 638|    |-		bind(k, Actions::Type::ToggleBrowserSortMode);
+| 639|    |-		bind(k, Actions::Type::ToggleMediaLibrarySortMode);
+| 640|    |-	}
+| 641|    |-	if (notBound(k = stringToKey("ctrl-r")))
+| 642|    |-		bind(k, Actions::Type::ReversePlaylist);
+| 643|    |-	if (notBound(k = stringToKey("ctrl-f")))
+| 644|    |-		bind(k, Actions::Type::ApplyFilter);
+| 645|    |-	if (notBound(k = stringToKey("ctrl-_")))
+| 646|    |-		bind(k, Actions::Type::SelectFoundItems);
+| 647|    |-	if (notBound(k = stringToKey("/")))
+| 648|    |-	{
+| 649|    |-		bind(k, Actions::Type::Find);
+| 650|    |-		bind(k, Actions::Type::FindItemForward);
+| 651|    |-	}
+| 652|    |-	if (notBound(k = stringToKey("?")))
+| 653|    |-	{
+| 654|    |-		bind(k, Actions::Type::Find);
+| 655|    |-		bind(k, Actions::Type::FindItemBackward);
+| 656|    |-	}
+| 657|    |-	if (notBound(k = stringToKey(".")))
+| 658|    |-		bind(k, Actions::Type::NextFoundItem);
+| 659|    |-	if (notBound(k = stringToKey(",")))
+| 660|    |-		bind(k, Actions::Type::PreviousFoundItem);
+| 661|    |-	if (notBound(k = stringToKey("w")))
+| 662|    |-		bind(k, Actions::Type::ToggleFindMode);
+| 663|    |-	if (notBound(k = stringToKey("e")))
+| 664|    |-	{
+| 665|    |-		bind(k, Actions::Type::EditSong);
+| 666|    |-		bind(k, Actions::Type::EditLibraryTag);
+| 667|    |-		bind(k, Actions::Type::EditLibraryAlbum);
+| 668|    |-		bind(k, Actions::Type::EditDirectoryName);
+| 669|    |-		bind(k, Actions::Type::EditPlaylistName);
+| 670|    |-		bind(k, Actions::Type::EditLyrics);
+| 671|    |-	}
+| 672|    |-	if (notBound(k = stringToKey("i")))
+| 673|    |-		bind(k, Actions::Type::ShowSongInfo);
+| 674|    |-	if (notBound(k = stringToKey("I")))
+| 675|    |-		bind(k, Actions::Type::ShowArtistInfo);
+| 676|    |-	if (notBound(k = stringToKey("g")))
+| 677|    |-		bind(k, Actions::Type::JumpToPositionInSong);
+| 678|    |-	if (notBound(k = stringToKey("l")))
+| 679|    |-		bind(k, Actions::Type::ShowLyrics);
+| 680|    |-	if (notBound(k = stringToKey("ctrl-v")))
+| 681|    |-		bind(k, Actions::Type::SelectRange);
+| 682|    |-	if (notBound(k = stringToKey("v")))
+| 683|    |-		bind(k, Actions::Type::ReverseSelection);
+| 684|    |-	if (notBound(k = stringToKey("V")))
+| 685|    |-		bind(k, Actions::Type::RemoveSelection);
+| 686|    |-	if (notBound(k = stringToKey("B")))
+| 687|    |-		bind(k, Actions::Type::SelectAlbum);
+| 688|    |-	if (notBound(k = stringToKey("a")))
+| 689|    |-		bind(k, Actions::Type::AddSelectedItems);
+| 690|    |-	if (notBound(k = stringToKey("c")))
+| 691|    |-	{
+| 692|    |-		bind(k, Actions::Type::ClearPlaylist);
+| 693|    |-		bind(k, Actions::Type::ClearMainPlaylist);
+| 694|    |-	}
+| 695|    |-	if (notBound(k = stringToKey("C")))
+| 696|    |-	{
+| 697|    |-		bind(k, Actions::Type::CropPlaylist);
+| 698|    |-		bind(k, Actions::Type::CropMainPlaylist);
+| 699|    |-	}
+| 700|    |-	if (notBound(k = stringToKey("m")))
+| 701|    |-	{
+| 702|    |-		bind(k, Actions::Type::MoveSortOrderUp);
+| 703|    |-		bind(k, Actions::Type::MoveSelectedItemsUp);
+| 704|    |-	}
+| 705|    |-	if (notBound(k = stringToKey("n")))
+| 706|    |-	{
+| 707|    |-		bind(k, Actions::Type::MoveSortOrderDown);
+| 708|    |-		bind(k, Actions::Type::MoveSelectedItemsDown);
+| 709|    |-	}
+| 710|    |-	if (notBound(k = stringToKey("M")))
+| 711|    |-		bind(k, Actions::Type::MoveSelectedItemsTo);
+| 712|    |-	if (notBound(k = stringToKey("A")))
+| 713|    |-		bind(k, Actions::Type::Add);
+| 714|    |-	if (notBound(k = stringToKey("S")))
+| 715|    |-		bind(k, Actions::Type::SavePlaylist);
+| 716|    |-	if (notBound(k = stringToKey("o")))
+| 717|    |-		bind(k, Actions::Type::JumpToPlayingSong);
+| 718|    |-	if (notBound(k = stringToKey("G")))
+| 719|    |-	{
+| 720|    |-		bind(k, Actions::Type::JumpToBrowser);
+| 721|    |-		bind(k, Actions::Type::JumpToPlaylistEditor);
+| 722|    |-	}
+| 723|    |-	if (notBound(k = stringToKey("~")))
+| 724|    |-		bind(k, Actions::Type::JumpToMediaLibrary);
+| 725|    |-	if (notBound(k = stringToKey("E")))
+| 726|    |-		bind(k, Actions::Type::JumpToTagEditor);
+| 727|    |-	if (notBound(k = stringToKey("U")))
+| 728|    |-		bind(k, Actions::Type::TogglePlayingSongCentering);
+| 729|    |-	if (notBound(k = stringToKey("P")))
+| 730|    |-		bind(k, Actions::Type::ToggleDisplayMode);
+| 731|    |-	if (notBound(k = stringToKey("\\")))
+| 732|    |-		bind(k, Actions::Type::ToggleInterface);
+| 733|    |-	if (notBound(k = stringToKey("!")))
+| 734|    |-		bind(k, Actions::Type::ToggleSeparatorsBetweenAlbums);
+| 735|    |-	if (notBound(k = stringToKey("L")))
+| 736|    |-		bind(k, Actions::Type::ToggleLyricsFetcher);
+| 737|    |-	if (notBound(k = stringToKey("F")))
+| 738|    |-		bind(k, Actions::Type::FetchLyricsInBackground);
+| 739|    |-	if (notBound(k = stringToKey("alt-l")))
+| 740|    |-		bind(k, Actions::Type::ToggleFetchingLyricsInBackground);
+| 741|    |-	if (notBound(k = stringToKey("ctrl-l")))
+| 742|    |-		bind(k, Actions::Type::ToggleScreenLock);
+| 743|    |-	if (notBound(k = stringToKey("`")))
+| 744|    |-	{
+| 745|    |-		bind(k, Actions::Type::ToggleLibraryTagType);
+| 746|    |-		bind(k, Actions::Type::RefetchLyrics);
+| 747|    |-		bind(k, Actions::Type::AddRandomItems);
+| 748|    |-	}
+| 749|    |-	if (notBound(k = stringToKey("ctrl-p")))
+| 750|    |-		bind(k, Actions::Type::SetSelectedItemsPriority);
+| 751|    |-	if (notBound(k = stringToKey("q")))
+| 752|    |-		bind(k, Actions::Type::Quit);
+| 753|    |-}
+| 754|    |-
+| 755|    |-const Command *BindingsConfiguration::findCommand(const std::string &name)
+| 756|    |-{
+| 757|    |-	const Command *ptr = nullptr;
+| 758|    |-	auto it = m_commands.find(name);
+| 759|    |-	if (it != m_commands.end())
+| 760|    |-		ptr = &it->second;
+| 761|    |-	return ptr;
+| 762|    |-}
+| 763|    |-
+| 764|    |-BindingsConfiguration::BindingIteratorPair BindingsConfiguration::get(const NC::Key::Type &k)
+| 765|    |-{
+| 766|    |-	std::pair<BindingIterator, BindingIterator> result;
+| 767|    |-	auto it = m_bindings.find(k);
+| 768|    |-	if (it != m_bindings.end()) {
+| 769|    |-		result.first = it->second.begin();
+| 770|    |-		result.second = it->second.end();
+| 771|    |-	} else {
+| 772|    |-		auto list_end = m_bindings.begin()->second.end();
+| 773|    |-		result.first = list_end;
+| 774|    |-		result.second = list_end;
+| 775|    |-	}
+| 776|    |-	return result;
+| 777|    |-}
+|    | 126|+    enum class InProgress
+|    | 127|+    { None, Command, Key };
+|    | 128|+
+|    | 129|+    bool result = true;
+|    | 130|+
+|    | 131|+    std::ifstream f (file);
+|    | 132|+    if (!f.is_open ())
+|    | 133|+        return result;
+|    | 134|+
+|    | 135|+    // shared variables
+|    | 136|+    InProgress in_progress = InProgress::None;
+|    | 137|+    size_t line_no = 0;
+|    | 138|+    std::string line;
+|    | 139|+    Binding::ActionChain actions;
+|    | 140|+
+|    | 141|+    // def_key specific variables
+|    | 142|+    NC::Key::Type key = NC::Key::None;
+|    | 143|+    std::string strkey;
+|    | 144|+
+|    | 145|+    // def_command specific variables
+|    | 146|+    bool cmd_immediate = false;
+|    | 147|+    std::string cmd_name;
+|    | 148|+
+|    | 149|+    auto error =[&]()->std::ostream & {
+|    | 150|+        std::cerr << file << ":" << line_no << ": error: ";
+|    | 151|+        in_progress = InProgress::None;
+|    | 152|+        result = false;
+|    | 153|+        return std::cerr;
+|    | 154|+    };
+|    | 155|+
+|    | 156|+    auto bind_in_progress =[&]()->bool {
+|    | 157|+        if (in_progress == InProgress::Command)
+|    | 158|+          {
+|    | 159|+           if (!actions.empty ()){
+|    | 160|+                                  m_commands.
+|    | 161|+                                  insert (std::
+|    | 162|+                                          make_pair (cmd_name,
+|    | 163|+                                                     Command (std::
+|    | 164|+                                                              move (actions),
+|    | 165|+                                                              cmd_immediate)));
+|    | 166|+                                  actions.clear (); return true;}
+|    | 167|+                                  else
+|    | 168|+                                  {
+|    | 169|+                                  error () << "definition of command '" <<
+|    | 170|+                                  cmd_name << "' cannot be empty\n";
+|    | 171|+                                  return false;}
+|    | 172|+                                  }
+|    | 173|+                                  else if (in_progress == InProgress::Key)
+|    | 174|+                                  {
+|    | 175|+                                  if (!actions.empty ())
+|    | 176|+                                  {
+|    | 177|+                                  bind (key, actions);
+|    | 178|+                                  actions.clear (); return true;}
+|    | 179|+                                  else
+|    | 180|+                                  {
+|    | 181|+                                  error () << "definition of key '" << strkey
+|    | 182|+                                  << "' cannot be empty\n"; return false;}
+|    | 183|+                                  }
+|    | 184|+                                  return true;};
+|    | 185|+                                  const char def_command[] = "def_command";
+|    | 186|+                                  const char def_key[] = "def_key";
+|    | 187|+                                  while (!f.eof () && ++line_no)
+|    | 188|+                                  {
+|    | 189|+                                  getline (f, line);
+|    | 190|+                                  if (line.empty () || line[0] == '#')
+|    | 191|+                                  continue;
+|    | 192|+                                  // beginning of command definition
+|    | 193|+                                  if (!line.
+|    | 194|+                                      compare (0, const_strlen (def_command),
+|    | 195|+                                               def_command))
+|    | 196|+                                  {
+|    | 197|+                                  if (!bind_in_progress ())break;
+|    | 198|+                                  in_progress = InProgress::Command;
+|    | 199|+                                  cmd_name =
+|    | 200|+                                  getEnclosedString (line, '"', '"', 0);
+|    | 201|+                                  if (cmd_name.empty ())
+|    | 202|+                                  {
+|    | 203|+                                  error () <<
+|    | 204|+                                  "command must have non-empty name\n"; break;}
+|    | 205|+                                  if (m_commands.find (cmd_name) !=
+|    | 206|+                                      m_commands.end ())
+|    | 207|+                                  {
+|    | 208|+                                  error () << "redefinition of command '" <<
+|    | 209|+                                  cmd_name << "'\n"; break;}
+|    | 210|+                                  std::string cmd_type =
+|    | 211|+                                  getEnclosedString (line, '[', ']', 0);
+|    | 212|+                                  if (cmd_type == "immediate") cmd_immediate =
+|    | 213|+                                  true;
+|    | 214|+                                  else
+|    | 215|+                                  if (cmd_type == "deferred")
+|    | 216|+                                  cmd_immediate = false;
+|    | 217|+                                  else
+|    | 218|+                                  {
+|    | 219|+                                  error () << "invalid type of command: '" <<
+|    | 220|+                                  cmd_type << "'\n"; break;}
+|    | 221|+                                  }
+|    | 222|+                                  // beginning of key definition
+|    | 223|+                                  else
+|    | 224|+                                  if (!line.
+|    | 225|+                                      compare (0, const_strlen (def_key),
+|    | 226|+                                               def_key))
+|    | 227|+                                  {
+|    | 228|+                                  if (!bind_in_progress ())break;
+|    | 229|+                                  in_progress = InProgress::Key;
+|    | 230|+                                  strkey =
+|    | 231|+                                  getEnclosedString (line, '"', '"', 0);
+|    | 232|+                                  key = stringToKey (strkey);
+|    | 233|+                                  if (key == NC::Key::None)
+|    | 234|+                                  {
+|    | 235|+                                  error () << "invalid key: '" << strkey <<
+|    | 236|+                                  "'\n"; break;}
+|    | 237|+                                  }
+|    | 238|+                                  else
+|    | 239|+                                  if (isspace (line[0]))    // name of action to be bound
+|    | 240|+                                  {
+|    | 241|+                                  boost::trim (line);
+|    | 242|+                                  auto action = parseActionLine (line, error);
+|    | 243|+                                  if (action) actions.push_back (action);
+|    | 244|+                                  else
+|    | 245|+                                  {
+|    | 246|+                                  error () << "unknown action: '" << line <<
+|    | 247|+                                  "'\n"; break;}
+|    | 248|+                                  }
+|    | 249|+                                  else
+|    | 250|+                                  {
+|    | 251|+                                  error () << "invalid line: '" << line <<
+|    | 252|+                                  "'\n"; break;}
+|    | 253|+                                  }
+|    | 254|+                                  bind_in_progress ();
+|    | 255|+                                  f.close (); return result;}
+|    | 256|+
+|    | 257|+                                  bool BindingsConfiguration::read (const std::
+|    | 258|+                                                                    vector <
+|    | 259|+                                                                    std::
+|    | 260|+                                                                    string >
+|    | 261|+                                                                    &binding_paths)
+|    | 262|+                                  {
+|    | 263|+                                  return std::all_of (binding_paths.begin (),
+|    | 264|+                                                      binding_paths.end (),
+|    | 265|+                                                      [&](const std::
+|    | 266|+                                                          string &
+|    | 267|+                                                          binding_path)
+|    | 268|+                                                      {
+|    | 269|+                                                      return
+|    | 270|+                                                      read (binding_path);}
+|    | 271|+                                  );}
+|    | 272|+
+|    | 273|+                                  void BindingsConfiguration::
+|    | 274|+                                  generateDefaults ()
+|    | 275|+                                  {
+|    | 276|+                                  NC::Key::Type k = NC::Key::None;
+|    | 277|+                                  bind (NC::Key::EoF, Actions::Type::Quit);
+|    | 278|+                                  if (notBound (k = stringToKey ("mouse")))
+|    | 279|+                                  bind (k, Actions::Type::MouseEvent);
+|    | 280|+                                  if (notBound (k = stringToKey ("up")))
+|    | 281|+                                  bind (k, Actions::Type::ScrollUp);
+|    | 282|+                                  if (notBound (k = stringToKey ("shift-up")))
+|    | 283|+                                  bind (k, Binding::ActionChain (
+|    | 284|+                                                                                         {
+|    | 285|+                                                                                         Actions::
+|    | 286|+                                                                                         get_
+|    | 287|+                                                                                         (Actions::
+|    | 288|+                                                                                          Type::
+|    | 289|+                                                                                          SelectItem),
+|    | 290|+                                                                                         Actions::
+|    | 291|+                                                                                         get_
+|    | 292|+                                                                                         (Actions::
+|    | 293|+                                                                                          Type::
+|    | 294|+                                                                                          ScrollUp)}
+|    | 295|+                                        ));
+|    | 296|+                                  if (notBound (k = stringToKey ("down")))
+|    | 297|+                                  bind (k, Actions::Type::ScrollDown);
+|    | 298|+                                  if (notBound
+|    | 299|+                                      (k =
+|    | 300|+                                       stringToKey ("shift-down"))) bind (k,
+|    | 301|+                                                                          Binding::
+|    | 302|+                                                                          ActionChain
+|    | 303|+                                                                          (
+|    | 304|+                                                                                                      {
+|    | 305|+                                                                                                      Actions::
+|    | 306|+                                                                                                      get_
+|    | 307|+                                                                                                      (Actions::
+|    | 308|+                                                                                                       Type::
+|    | 309|+                                                                                                       SelectItem),
+|    | 310|+                                                                                                      Actions::
+|    | 311|+                                                                                                      get_
+|    | 312|+                                                                                                      (Actions::
+|    | 313|+                                                                                                       Type::
+|    | 314|+                                                                                                       ScrollDown)}
+|    | 315|+                                                                          ));
+|    | 316|+                                  if (notBound (k = stringToKey ("[")))
+|    | 317|+                                  bind (k, Actions::Type::ScrollUpAlbum);
+|    | 318|+                                  if (notBound (k = stringToKey ("]")))
+|    | 319|+                                  bind (k, Actions::Type::ScrollDownAlbum);
+|    | 320|+                                  if (notBound (k = stringToKey ("{")))
+|    | 321|+                                  bind (k, Actions::Type::ScrollUpArtist);
+|    | 322|+                                  if (notBound (k = stringToKey ("}")))
+|    | 323|+                                  bind (k, Actions::Type::ScrollDownArtist);
+|    | 324|+                                  if (notBound (k = stringToKey ("page_up")))
+|    | 325|+                                  bind (k, Actions::Type::PageUp);
+|    | 326|+                                  if (notBound (k = stringToKey ("page_down")))
+|    | 327|+                                  bind (k, Actions::Type::PageDown);
+|    | 328|+                                  if (notBound (k = stringToKey ("home")))
+|    | 329|+                                  bind (k, Actions::Type::MoveHome);
+|    | 330|+                                  if (notBound (k = stringToKey ("end")))
+|    | 331|+                                  bind (k, Actions::Type::MoveEnd);
+|    | 332|+                                  if (notBound (k = stringToKey ("insert")))
+|    | 333|+                                  bind (k, Actions::Type::SelectItem);
+|    | 334|+                                  if (notBound (k = stringToKey ("enter")))
+|    | 335|+                                  {
+|    | 336|+                                  bind (k, Actions::Type::EnterDirectory);
+|    | 337|+                                  bind (k, Actions::Type::ToggleOutput);
+|    | 338|+                                  bind (k, Actions::Type::RunAction);
+|    | 339|+                                  bind (k, Actions::Type::PlayItem);}
+|    | 340|+                                  if (notBound (k = stringToKey ("space")))
+|    | 341|+                                  {
+|    | 342|+                                  bind (k, Actions::Type::AddItemToPlaylist);
+|    | 343|+                                  bind (k,
+|    | 344|+                                        Actions::Type::
+|    | 345|+                                        ToggleLyricsUpdateOnSongChange);
+|    | 346|+                                  bind (k,
+|    | 347|+                                        Actions::Type::
+|    | 348|+                                        ToggleVisualizationType);}
+|    | 349|+                                  if (notBound (k = stringToKey ("delete")))
+|    | 350|+                                  {
+|    | 351|+                                  bind (k, Actions::Type::DeletePlaylistItems);
+|    | 352|+                                  bind (k, Actions::Type::DeleteBrowserItems);
+|    | 353|+                                  bind (k,
+|    | 354|+                                        Actions::Type::DeleteStoredPlaylist);}
+|    | 355|+                                  if (notBound (k = stringToKey ("right")))
+|    | 356|+                                  {
+|    | 357|+                                  bind (k, Actions::Type::NextColumn);
+|    | 358|+                                  bind (k, Actions::Type::SlaveScreen);
+|    | 359|+                                  bind (k, Actions::Type::VolumeUp);}
+|    | 360|+                                  if (notBound (k = stringToKey ("+")))
+|    | 361|+                                  bind (k, Actions::Type::VolumeUp);
+|    | 362|+                                  if (notBound (k = stringToKey ("left")))
+|    | 363|+                                  {
+|    | 364|+                                  bind (k, Actions::Type::PreviousColumn);
+|    | 365|+                                  bind (k, Actions::Type::MasterScreen);
+|    | 366|+                                  bind (k, Actions::Type::VolumeDown);}
+|    | 367|+                                  if (notBound (k = stringToKey ("-")))
+|    | 368|+                                  bind (k, Actions::Type::VolumeDown);
+|    | 369|+                                  if (notBound (k = stringToKey (":")))
+|    | 370|+                                  bind (k, Actions::Type::ExecuteCommand);
+|    | 371|+                                  if (notBound (k = stringToKey ("tab")))
+|    | 372|+                                  bind (k, Actions::Type::NextScreen);
+|    | 373|+                                  if (notBound (k = stringToKey ("shift-tab")))
+|    | 374|+                                  bind (k, Actions::Type::PreviousScreen);
+|    | 375|+                                  if (notBound (k = stringToKey ("f1")))
+|    | 376|+                                  bind (k, Actions::Type::ShowHelp);
+|    | 377|+                                  if (notBound (k = stringToKey ("1")))
+|    | 378|+                                  bind (k, Actions::Type::ShowPlaylist);
+|    | 379|+                                  if (notBound (k = stringToKey ("2")))
+|    | 380|+                                  {
+|    | 381|+                                  bind (k, Actions::Type::ShowBrowser);
+|    | 382|+                                  bind (k, Actions::Type::ChangeBrowseMode);}
+|    | 383|+                                  if (notBound (k = stringToKey ("3")))
+|    | 384|+                                  {
+|    | 385|+                                  bind (k, Actions::Type::ShowSearchEngine);
+|    | 386|+                                  bind (k, Actions::Type::ResetSearchEngine);}
+|    | 387|+                                  if (notBound (k = stringToKey ("4")))
+|    | 388|+                                  {
+|    | 389|+                                  bind (k, Actions::Type::ShowMediaLibrary);
+|    | 390|+                                  bind (k,
+|    | 391|+                                        Actions::Type::
+|    | 392|+                                        ToggleMediaLibraryColumnsMode);}
+|    | 393|+                                  if (notBound (k = stringToKey ("5")))
+|    | 394|+                                  bind (k, Actions::Type::ShowPlaylistEditor);
+|    | 395|+                                  if (notBound (k = stringToKey ("6")))
+|    | 396|+                                  bind (k, Actions::Type::ShowTagEditor);
+|    | 397|+                                  if (notBound (k = stringToKey ("7")))
+|    | 398|+                                  bind (k, Actions::Type::ShowOutputs);
+|    | 399|+                                  if (notBound (k = stringToKey ("8")))
+|    | 400|+                                  bind (k, Actions::Type::ShowVisualizer);
+|    | 401|+                                  if (notBound (k = stringToKey ("=")))
+|    | 402|+                                  bind (k, Actions::Type::ShowClock);
+|    | 403|+                                  if (notBound (k = stringToKey ("@")))
+|    | 404|+                                  bind (k, Actions::Type::ShowServerInfo);
+|    | 405|+                                  if (notBound (k = stringToKey ("s")))
+|    | 406|+                                  bind (k, Actions::Type::Stop);
+|    | 407|+                                  if (notBound (k = stringToKey ("p")))
+|    | 408|+                                  bind (k, Actions::Type::Pause);
+|    | 409|+                                  if (notBound (k = stringToKey (">")))
+|    | 410|+                                  bind (k, Actions::Type::Next);
+|    | 411|+                                  if (notBound (k = stringToKey ("<")))
+|    | 412|+                                  bind (k, Actions::Type::Previous);
+|    | 413|+                                  if (notBound (k = stringToKey ("ctrl-h")))
+|    | 414|+                                  {
+|    | 415|+                                  bind (k,
+|    | 416|+                                        Actions::Type::JumpToParentDirectory);
+|    | 417|+                                  bind (k, Actions::Type::ReplaySong);}
+|    | 418|+                                  if (notBound (k = stringToKey ("backspace")))
+|    | 419|+                                  {
+|    | 420|+                                  bind (k,
+|    | 421|+                                        Actions::Type::JumpToParentDirectory);
+|    | 422|+                                  bind (k, Actions::Type::ReplaySong);}
+|    | 423|+                                  if (notBound (k = stringToKey ("f")))
+|    | 424|+                                  bind (k, Actions::Type::SeekForward);
+|    | 425|+                                  if (notBound (k = stringToKey ("b")))
+|    | 426|+                                  bind (k, Actions::Type::SeekBackward);
+|    | 427|+                                  if (notBound (k = stringToKey ("r")))
+|    | 428|+                                  bind (k, Actions::Type::ToggleRepeat);
+|    | 429|+                                  if (notBound (k = stringToKey ("z")))
+|    | 430|+                                  bind (k, Actions::Type::ToggleRandom);
+|    | 431|+                                  if (notBound (k = stringToKey ("y")))
+|    | 432|+                                  {
+|    | 433|+                                  bind (k, Actions::Type::SaveTagChanges);
+|    | 434|+                                  bind (k, Actions::Type::StartSearching);
+|    | 435|+                                  bind (k, Actions::Type::ToggleSingle);}
+|    | 436|+                                  if (notBound (k = stringToKey ("R")))
+|    | 437|+                                  bind (k, Actions::Type::ToggleConsume);
+|    | 438|+                                  if (notBound (k = stringToKey ("Y")))
+|    | 439|+                                  bind (k,
+|    | 440|+                                        Actions::Type::ToggleReplayGainMode);
+|    | 441|+                                  if (notBound (k = stringToKey ("T")))
+|    | 442|+                                  bind (k, Actions::Type::ToggleAddMode);
+|    | 443|+                                  if (notBound (k = stringToKey ("|")))
+|    | 444|+                                  bind (k, Actions::Type::ToggleMouse);
+|    | 445|+                                  if (notBound (k = stringToKey ("#")))
+|    | 446|+                                  bind (k,
+|    | 447|+                                        Actions::Type::
+|    | 448|+                                        ToggleBitrateVisibility);
+|    | 449|+                                  if (notBound (k = stringToKey ("Z")))
+|    | 450|+                                  bind (k, Actions::Type::Shuffle);
+|    | 451|+                                  if (notBound (k = stringToKey ("x")))
+|    | 452|+                                  bind (k, Actions::Type::ToggleCrossfade);
+|    | 453|+                                  if (notBound (k = stringToKey ("X")))
+|    | 454|+                                  bind (k, Actions::Type::SetCrossfade);
+|    | 455|+                                  if (notBound (k = stringToKey ("u")))
+|    | 456|+                                  bind (k, Actions::Type::UpdateDatabase);
+|    | 457|+                                  if (notBound (k = stringToKey ("ctrl-s")))
+|    | 458|+                                  {
+|    | 459|+                                  bind (k, Actions::Type::SortPlaylist);
+|    | 460|+                                  bind (k,
+|    | 461|+                                        Actions::Type::ToggleBrowserSortMode);
+|    | 462|+                                  bind (k,
+|    | 463|+                                        Actions::Type::
+|    | 464|+                                        ToggleMediaLibrarySortMode);}
+|    | 465|+                                  if (notBound (k = stringToKey ("ctrl-r")))
+|    | 466|+                                  bind (k, Actions::Type::ReversePlaylist);
+|    | 467|+                                  if (notBound (k = stringToKey ("ctrl-f")))
+|    | 468|+                                  bind (k, Actions::Type::ApplyFilter);
+|    | 469|+                                  if (notBound (k = stringToKey ("ctrl-_")))
+|    | 470|+                                  bind (k, Actions::Type::SelectFoundItems);
+|    | 471|+                                  if (notBound (k = stringToKey ("/")))
+|    | 472|+                                  {
+|    | 473|+                                  bind (k, Actions::Type::Find);
+|    | 474|+                                  bind (k, Actions::Type::FindItemForward);}
+|    | 475|+                                  if (notBound (k = stringToKey ("?")))
+|    | 476|+                                  {
+|    | 477|+                                  bind (k, Actions::Type::Find);
+|    | 478|+                                  bind (k, Actions::Type::FindItemBackward);}
+|    | 479|+                                  if (notBound (k = stringToKey (".")))
+|    | 480|+                                  bind (k, Actions::Type::NextFoundItem);
+|    | 481|+                                  if (notBound (k = stringToKey (",")))
+|    | 482|+                                  bind (k, Actions::Type::PreviousFoundItem);
+|    | 483|+                                  if (notBound (k = stringToKey ("w")))
+|    | 484|+                                  bind (k, Actions::Type::ToggleFindMode);
+|    | 485|+                                  if (notBound (k = stringToKey ("e")))
+|    | 486|+                                  {
+|    | 487|+                                  bind (k, Actions::Type::EditSong);
+|    | 488|+                                  bind (k, Actions::Type::EditLibraryTag);
+|    | 489|+                                  bind (k, Actions::Type::EditLibraryAlbum);
+|    | 490|+                                  bind (k, Actions::Type::EditDirectoryName);
+|    | 491|+                                  bind (k, Actions::Type::EditPlaylistName);
+|    | 492|+                                  bind (k, Actions::Type::EditLyrics);}
+|    | 493|+                                  if (notBound (k = stringToKey ("i")))
+|    | 494|+                                  bind (k, Actions::Type::ShowSongInfo);
+|    | 495|+                                  if (notBound (k = stringToKey ("I")))
+|    | 496|+                                  bind (k, Actions::Type::ShowArtistInfo);
+|    | 497|+                                  if (notBound (k = stringToKey ("g")))
+|    | 498|+                                  bind (k,
+|    | 499|+                                        Actions::Type::JumpToPositionInSong);
+|    | 500|+                                  if (notBound (k = stringToKey ("l")))
+|    | 501|+                                  bind (k, Actions::Type::ShowLyrics);
+|    | 502|+                                  if (notBound (k = stringToKey ("ctrl-v")))
+|    | 503|+                                  bind (k, Actions::Type::SelectRange);
+|    | 504|+                                  if (notBound (k = stringToKey ("v")))
+|    | 505|+                                  bind (k, Actions::Type::ReverseSelection);
+|    | 506|+                                  if (notBound (k = stringToKey ("V")))
+|    | 507|+                                  bind (k, Actions::Type::RemoveSelection);
+|    | 508|+                                  if (notBound (k = stringToKey ("B")))
+|    | 509|+                                  bind (k, Actions::Type::SelectAlbum);
+|    | 510|+                                  if (notBound (k = stringToKey ("a")))
+|    | 511|+                                  bind (k, Actions::Type::AddSelectedItems);
+|    | 512|+                                  if (notBound (k = stringToKey ("c")))
+|    | 513|+                                  {
+|    | 514|+                                  bind (k, Actions::Type::ClearPlaylist);
+|    | 515|+                                  bind (k, Actions::Type::ClearMainPlaylist);}
+|    | 516|+                                  if (notBound (k = stringToKey ("C")))
+|    | 517|+                                  {
+|    | 518|+                                  bind (k, Actions::Type::CropPlaylist);
+|    | 519|+                                  bind (k, Actions::Type::CropMainPlaylist);}
+|    | 520|+                                  if (notBound (k = stringToKey ("m")))
+|    | 521|+                                  {
+|    | 522|+                                  bind (k, Actions::Type::MoveSortOrderUp);
+|    | 523|+                                  bind (k,
+|    | 524|+                                        Actions::Type::MoveSelectedItemsUp);}
+|    | 525|+                                  if (notBound (k = stringToKey ("n")))
+|    | 526|+                                  {
+|    | 527|+                                  bind (k, Actions::Type::MoveSortOrderDown);
+|    | 528|+                                  bind (k,
+|    | 529|+                                        Actions::Type::MoveSelectedItemsDown);}
+|    | 530|+                                  if (notBound (k = stringToKey ("M")))
+|    | 531|+                                  bind (k, Actions::Type::MoveSelectedItemsTo);
+|    | 532|+                                  if (notBound (k = stringToKey ("A")))
+|    | 533|+                                  bind (k, Actions::Type::Add);
+|    | 534|+                                  if (notBound (k = stringToKey ("S")))
+|    | 535|+                                  bind (k, Actions::Type::SavePlaylist);
+|    | 536|+                                  if (notBound (k = stringToKey ("o")))
+|    | 537|+                                  bind (k, Actions::Type::JumpToPlayingSong);
+|    | 538|+                                  if (notBound (k = stringToKey ("G")))
+|    | 539|+                                  {
+|    | 540|+                                  bind (k, Actions::Type::JumpToBrowser);
+|    | 541|+                                  bind (k,
+|    | 542|+                                        Actions::Type::JumpToPlaylistEditor);}
+|    | 543|+                                  if (notBound (k = stringToKey ("~")))
+|    | 544|+                                  bind (k, Actions::Type::JumpToMediaLibrary);
+|    | 545|+                                  if (notBound (k = stringToKey ("E")))
+|    | 546|+                                  bind (k, Actions::Type::JumpToTagEditor);
+|    | 547|+                                  if (notBound (k = stringToKey ("U")))
+|    | 548|+                                  bind (k,
+|    | 549|+                                        Actions::Type::
+|    | 550|+                                        TogglePlayingSongCentering);
+|    | 551|+                                  if (notBound (k = stringToKey ("P")))
+|    | 552|+                                  bind (k, Actions::Type::ToggleDisplayMode);
+|    | 553|+                                  if (notBound (k = stringToKey ("\\")))
+|    | 554|+                                  bind (k, Actions::Type::ToggleInterface);
+|    | 555|+                                  if (notBound (k = stringToKey ("!")))
+|    | 556|+                                  bind (k,
+|    | 557|+                                        Actions::Type::
+|    | 558|+                                        ToggleSeparatorsBetweenAlbums);
+|    | 559|+                                  if (notBound (k = stringToKey ("L")))
+|    | 560|+                                  bind (k, Actions::Type::ToggleLyricsFetcher);
+|    | 561|+                                  if (notBound (k = stringToKey ("F")))
+|    | 562|+                                  bind (k,
+|    | 563|+                                        Actions::Type::
+|    | 564|+                                        FetchLyricsInBackground);
+|    | 565|+                                  if (notBound (k = stringToKey ("alt-l")))
+|    | 566|+                                  bind (k,
+|    | 567|+                                        Actions::Type::
+|    | 568|+                                        ToggleFetchingLyricsInBackground);
+|    | 569|+                                  if (notBound (k = stringToKey ("ctrl-l")))
+|    | 570|+                                  bind (k, Actions::Type::ToggleScreenLock);
+|    | 571|+                                  if (notBound (k = stringToKey ("`")))
+|    | 572|+                                  {
+|    | 573|+                                  bind (k,
+|    | 574|+                                        Actions::Type::ToggleLibraryTagType);
+|    | 575|+                                  bind (k, Actions::Type::RefetchLyrics);
+|    | 576|+                                  bind (k, Actions::Type::AddRandomItems);}
+|    | 577|+                                  if (notBound (k = stringToKey ("ctrl-p")))
+|    | 578|+                                  bind (k,
+|    | 579|+                                        Actions::Type::
+|    | 580|+                                        SetSelectedItemsPriority);
+|    | 581|+                                  if (notBound (k = stringToKey ("q")))
+|    | 582|+                                  bind (k, Actions::Type::Quit);}
+|    | 583|+
+|    | 584|+                                  const Command *
+|    | 585|+                                  BindingsConfiguration::
+|    | 586|+                                  findCommand (const std::string & name)
+|    | 587|+                                  {
+|    | 588|+                                  const Command * ptr = nullptr;
+|    | 589|+                                  auto it = m_commands.find (name);
+|    | 590|+                                  if (it != m_commands.end ())ptr =
+|    | 591|+                                  &it->second; return ptr;}
+|    | 592|+
+|    | 593|+                                  BindingsConfiguration::
+|    | 594|+                                  BindingIteratorPair BindingsConfiguration::
+|    | 595|+                                  get (const NC::Key::Type & k)
+|    | 596|+                                  {
+|    | 597|+                                  std::pair < BindingIterator,
+|    | 598|+                                  BindingIterator > result;
+|    | 599|+                                  auto it = m_bindings.find (k);
+|    | 600|+                                  if (it != m_bindings.end ())
+|    | 601|+                                  {
+|    | 602|+                                  result.first = it->second.begin ();
+|    | 603|+                                  result.second = it->second.end ();}
+|    | 604|+                                  else
+|    | 605|+                                  {
+|    | 606|+                                  auto list_end =
+|    | 607|+                                  m_bindings.begin ()->second.end ();
+|    | 608|+                                  result.first = list_end;
+|    | 609|+                                  result.second = list_end;}
+|    | 610|+                                  return result;}
+
+src/bindings.cpp
+|  29| BindingsConfiguration•Bindings;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Bindings'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mpdpp.h
+|    |++++| /app/src/mpdpp.h
+|  30|  30| #include <mpd/client.h>
+|  31|  31| #include "song.h"
+|  32|  32| 
+|  33|    |-namespace MPD {
+|  34|    |-
+|  35|    |-void checkConnectionErrors(mpd_connection *conn);
+|  36|    |-
+|  37|    |-enum PlayerState { psUnknown, psStop, psPlay, psPause };
+|  38|    |-enum ReplayGainMode { rgmOff, rgmTrack, rgmAlbum };
+|  39|    |-
+|  40|    |-struct ClientError: public std::exception
+|    |  33|+namespace MPD
+|  41|  34| {
+|  42|    |-	ClientError(mpd_error code_, std::string msg, bool clearable_)
+|  43|    |-	: m_code(code_), m_msg(msg), m_clearable(clearable_) { }
+|  44|    |-	virtual ~ClientError() noexcept { }
+|  45|    |-	
+|  46|    |-	virtual const char *what() const noexcept { return m_msg.c_str(); }
+|  47|    |-	mpd_error code() const { return m_code; }
+|  48|    |-	bool clearable() const { return m_clearable; }
+|  49|    |-	
+|  50|    |-private:
+|  51|    |-	mpd_error m_code;
+|  52|    |-	std::string m_msg;
+|  53|    |-	bool m_clearable;
+|  54|    |-};
+|  55|    |-
+|  56|    |-struct ServerError: public std::exception
+|  57|    |-{
+|  58|    |-	ServerError(mpd_server_error code_, std::string msg, bool clearable_)
+|  59|    |-	: m_code(code_), m_msg(msg), m_clearable(clearable_) { }
+|  60|    |-	virtual ~ServerError() noexcept { }
+|  61|    |-	
+|  62|    |-	virtual const char *what() const noexcept { return m_msg.c_str(); }
+|  63|    |-	mpd_server_error code() const { return m_code; }
+|  64|    |-	bool clearable() const { return m_clearable; }
+|  65|    |-	
+|  66|    |-private:
+|  67|    |-	mpd_server_error m_code;
+|  68|    |-	std::string m_msg;
+|  69|    |-	bool m_clearable;
+|  70|    |-};
+|  71|    |-
+|  72|    |-struct Statistics
+|  73|    |-{
+|  74|    |-	friend struct Connection;
+|  75|    |-	
+|  76|    |-	bool empty() const { return m_stats.get() == nullptr; }
+|  77|    |-	
+|  78|    |-	unsigned artists() const { return mpd_stats_get_number_of_artists(m_stats.get()); }
+|  79|    |-	unsigned albums() const { return mpd_stats_get_number_of_albums(m_stats.get()); }
+|  80|    |-	unsigned songs() const { return mpd_stats_get_number_of_songs(m_stats.get()); }
+|  81|    |-	unsigned long playTime() const { return mpd_stats_get_play_time(m_stats.get()); }
+|  82|    |-	unsigned long uptime() const { return mpd_stats_get_uptime(m_stats.get()); }
+|  83|    |-	unsigned long dbUpdateTime() const { return mpd_stats_get_db_update_time(m_stats.get()); }
+|  84|    |-	unsigned long dbPlayTime() const { return mpd_stats_get_db_play_time(m_stats.get()); }
+|  85|    |-	
+|  86|    |-private:
+|  87|    |-	Statistics(mpd_stats *stats) : m_stats(stats, mpd_stats_free) { }
+|  88|    |-	
+|  89|    |-	std::shared_ptr<mpd_stats> m_stats;
+|  90|    |-};
+|  91|    |-
+|  92|    |-struct Status
+|  93|    |-{
+|  94|    |-	friend struct Connection;
+|  95|    |-	
+|  96|    |-	Status() { }
+|  97|    |-	
+|  98|    |-	void clear() { m_status.reset(); }
+|  99|    |-	bool empty() const { return m_status.get() == nullptr; }
+| 100|    |-	
+| 101|    |-	int volume() const { return mpd_status_get_volume(m_status.get()); }
+| 102|    |-	bool repeat() const { return mpd_status_get_repeat(m_status.get()); }
+| 103|    |-	bool random() const { return mpd_status_get_random(m_status.get()); }
+| 104|    |-	bool single() const { return mpd_status_get_single(m_status.get()); }
+| 105|    |-	bool consume() const { return mpd_status_get_consume(m_status.get()); }
+| 106|    |-	unsigned playlistLength() const { return mpd_status_get_queue_length(m_status.get()); }
+| 107|    |-	unsigned playlistVersion() const { return mpd_status_get_queue_version(m_status.get()); }
+| 108|    |-	PlayerState playerState() const { return PlayerState(mpd_status_get_state(m_status.get())); }
+| 109|    |-	unsigned crossfade() const { return mpd_status_get_crossfade(m_status.get()); }
+| 110|    |-	int currentSongPosition() const { return mpd_status_get_song_pos(m_status.get()); }
+| 111|    |-	int currentSongID() const { return mpd_status_get_song_id(m_status.get()); }
+| 112|    |-	int nextSongPosition() const { return mpd_status_get_next_song_pos(m_status.get()); }
+| 113|    |-	int nextSongID() const { return mpd_status_get_next_song_id(m_status.get()); }
+| 114|    |-	unsigned elapsedTime() const { return mpd_status_get_elapsed_time(m_status.get()); }
+| 115|    |-	unsigned totalTime() const { return mpd_status_get_total_time(m_status.get()); }
+| 116|    |-	unsigned kbps() const { return mpd_status_get_kbit_rate(m_status.get()); }
+| 117|    |-	unsigned updateID() const { return mpd_status_get_update_id(m_status.get()); }
+| 118|    |-	const char *error() const { return mpd_status_get_error(m_status.get()); }
+| 119|    |-	
+| 120|    |-private:
+| 121|    |-	Status(mpd_status *status) : m_status(status, mpd_status_free) { }
+| 122|    |-	
+| 123|    |-	std::shared_ptr<mpd_status> m_status;
+| 124|    |-};
+| 125|    |-
+| 126|    |-struct Directory
+| 127|    |-{
+| 128|    |-	Directory()
+| 129|    |-	: m_last_modified(0)
+| 130|    |-	{ }
+| 131|    |-	Directory(const mpd_directory *directory)
+| 132|    |-	{
+| 133|    |-		assert(directory != nullptr);
+| 134|    |-		m_path = mpd_directory_get_path(directory);
+| 135|    |-		m_last_modified = mpd_directory_get_last_modified(directory);
+| 136|    |-	}
+| 137|    |-	Directory(std::string path_, time_t last_modified = 0)
+| 138|    |-	: m_path(std::move(path_))
+| 139|    |-	, m_last_modified(last_modified)
+| 140|    |-	{ }
+| 141|    |-
+| 142|    |-	bool operator==(const Directory &rhs) const
+| 143|    |-	{
+| 144|    |-		return m_path == rhs.m_path
+| 145|    |-		    && m_last_modified == rhs.m_last_modified;
+| 146|    |-	}
+| 147|    |-	bool operator!=(const Directory &rhs) const
+| 148|    |-	{
+| 149|    |-		return !(*this == rhs);
+| 150|    |-	}
+| 151|    |-
+| 152|    |-	const std::string &path() const
+| 153|    |-	{
+| 154|    |-		return m_path;
+| 155|    |-	}
+| 156|    |-	time_t lastModified() const
+| 157|    |-	{
+| 158|    |-		return m_last_modified;
+| 159|    |-	}
+| 160|    |-
+| 161|    |-private:
+| 162|    |-	std::string m_path;
+| 163|    |-	time_t m_last_modified;
+| 164|    |-};
+| 165|    |-
+| 166|    |-struct Playlist
+| 167|    |-{
+| 168|    |-	Playlist()
+| 169|    |-	: m_last_modified(0)
+| 170|    |-	{ }
+| 171|    |-	Playlist(const mpd_playlist *playlist)
+| 172|    |-	{
+| 173|    |-		assert(playlist != nullptr);
+| 174|    |-		m_path = mpd_playlist_get_path(playlist);
+| 175|    |-		m_last_modified = mpd_playlist_get_last_modified(playlist);
+| 176|    |-	}
+| 177|    |-	Playlist(std::string path_, time_t last_modified = 0)
+| 178|    |-	: m_path(std::move(path_))
+| 179|    |-	, m_last_modified(last_modified)
+| 180|    |-	{
+| 181|    |-		if (m_path.empty())
+| 182|    |-			throw std::runtime_error("empty path");
+| 183|    |-	}
+| 184|    |-
+| 185|    |-	bool operator==(const Playlist &rhs) const
+| 186|    |-	{
+| 187|    |-		return m_path == rhs.m_path
+| 188|    |-		    && m_last_modified == rhs.m_last_modified;
+| 189|    |-	}
+| 190|    |-	bool operator!=(const Playlist &rhs) const
+| 191|    |-	{
+| 192|    |-		return !(*this == rhs);
+| 193|    |-	}
+| 194|    |-
+| 195|    |-	const std::string &path() const
+| 196|    |-	{
+| 197|    |-		return m_path;
+| 198|    |-	}
+| 199|    |-	time_t lastModified() const
+| 200|    |-	{
+| 201|    |-		return m_last_modified;
+| 202|    |-	}
+| 203|    |-
+| 204|    |-private:
+| 205|    |-	std::string m_path;
+| 206|    |-	time_t m_last_modified;
+| 207|    |-};
+| 208|    |-
+| 209|    |-struct Item
+| 210|    |-{
+| 211|    |-	enum class Type { Directory, Song, Playlist };
+| 212|    |-
+| 213|    |-	Item(mpd_entity *entity)
+| 214|    |-	{
+| 215|    |-		assert(entity != nullptr);
+| 216|    |-		switch (mpd_entity_get_type(entity))
+| 217|    |-		{
+| 218|    |-			case MPD_ENTITY_TYPE_DIRECTORY:
+| 219|    |-				m_type = Type::Directory;
+| 220|    |-				m_directory = Directory(mpd_entity_get_directory(entity));
+| 221|    |-				break;
+| 222|    |-			case MPD_ENTITY_TYPE_SONG:
+| 223|    |-				m_type = Type::Song;
+| 224|    |-				m_song = Song(mpd_song_dup(mpd_entity_get_song(entity)));
+| 225|    |-				break;
+| 226|    |-			case MPD_ENTITY_TYPE_PLAYLIST:
+| 227|    |-				m_type = Type::Playlist;
+| 228|    |-				m_playlist = Playlist(mpd_entity_get_playlist(entity));
+| 229|    |-				break;
+| 230|    |-			default:
+| 231|    |-				throw std::runtime_error("unknown mpd_entity type");
+| 232|    |-		}
+| 233|    |-		mpd_entity_free(entity);
+| 234|    |-	}
+| 235|    |-	Item(Directory directory_)
+| 236|    |-	: m_type(Type::Directory)
+| 237|    |-	, m_directory(std::move(directory_))
+| 238|    |-	{ }
+| 239|    |-	Item(Song song_)
+| 240|    |-	: m_type(Type::Song)
+| 241|    |-	, m_song(std::move(song_))
+| 242|    |-	{ }
+| 243|    |-	Item(Playlist playlist_)
+| 244|    |-	: m_type(Type::Playlist)
+| 245|    |-	, m_playlist(std::move(playlist_))
+| 246|    |-	{ }
+| 247|    |-
+| 248|    |-	bool operator==(const Item &rhs) const
+| 249|    |-	{
+| 250|    |-		return m_directory == rhs.m_directory
+| 251|    |-		    && m_song == rhs.m_song
+| 252|    |-		    && m_playlist == rhs.m_playlist;
+| 253|    |-	}
+| 254|    |-	bool operator!=(const Item &rhs) const
+| 255|    |-	{
+| 256|    |-		return !(*this == rhs);
+| 257|    |-	}
+| 258|    |-
+| 259|    |-	Type type() const
+| 260|    |-	{
+| 261|    |-		return m_type;
+| 262|    |-	}
+| 263|    |-
+| 264|    |-	Directory &directory()
+| 265|    |-	{
+| 266|    |-		return const_cast<Directory &>(
+| 267|    |-			static_cast<const Item &>(*this).directory());
+| 268|    |-	}
+| 269|    |-	Song &song()
+| 270|    |-	{
+| 271|    |-		return const_cast<Song &>(
+| 272|    |-			static_cast<const Item &>(*this).song());
+| 273|    |-	}
+| 274|    |-	Playlist &playlist()
+| 275|    |-	{
+| 276|    |-		return const_cast<Playlist &>(
+| 277|    |-			static_cast<const Item &>(*this).playlist());
+| 278|    |-	}
+| 279|    |-
+| 280|    |-	const Directory &directory() const
+| 281|    |-	{
+| 282|    |-		assert(m_type == Type::Directory);
+| 283|    |-		return m_directory;
+| 284|    |-	}
+| 285|    |-	const Song &song() const
+| 286|    |-	{
+| 287|    |-		assert(m_type == Type::Song);
+| 288|    |-		return m_song;
+| 289|    |-	}
+| 290|    |-	const Playlist &playlist() const
+| 291|    |-	{
+| 292|    |-		assert(m_type == Type::Playlist);
+| 293|    |-		return m_playlist;
+| 294|    |-	}
+| 295|    |-
+| 296|    |-private:
+| 297|    |-	Type m_type;
+| 298|    |-	Directory m_directory;
+| 299|    |-	Song m_song;
+| 300|    |-	Playlist m_playlist;
+| 301|    |-};
+| 302|    |-
+| 303|    |-struct Output
+| 304|    |-{
+| 305|    |-	Output() { }
+| 306|    |-	Output(mpd_output *output)
+| 307|    |-	: m_output(output, mpd_output_free)
+| 308|    |-	{ }
+| 309|    |-
+| 310|    |-	bool operator==(const Output &rhs) const
+| 311|    |-	{
+| 312|    |-		if (empty() && rhs.empty())
+| 313|    |-			return true;
+| 314|    |-		else if (!empty() && !rhs.empty())
+| 315|    |-			return id() == rhs.id()
+| 316|    |-			    && strcmp(name(), rhs.name()) == 0
+| 317|    |-			    && enabled() == rhs.enabled();
+| 318|    |-		else
+| 319|    |-			return false;
+| 320|    |-	}
+| 321|    |-	bool operator!=(const Output &rhs) const
+| 322|    |-	{
+| 323|    |-		return !(*this == rhs);
+| 324|    |-	}
+| 325|    |-
+| 326|    |-	unsigned id() const
+| 327|    |-	{
+| 328|    |-		assert(m_output.get() != nullptr);
+| 329|    |-		return mpd_output_get_id(m_output.get());
+| 330|    |-	}
+| 331|    |-	const char *name() const
+| 332|    |-	{
+| 333|    |-		assert(m_output.get() != nullptr);
+| 334|    |-		return mpd_output_get_name(m_output.get());
+| 335|    |-	}
+| 336|    |-	bool enabled() const
+| 337|    |-	{
+| 338|    |-		assert(m_output.get() != nullptr);
+| 339|    |-		return mpd_output_get_enabled(m_output.get());
+| 340|    |-	}
+| 341|    |-
+| 342|    |-	bool empty() const { return m_output.get() == nullptr; }
+| 343|    |-
+| 344|    |-private:
+| 345|    |-	std::shared_ptr<mpd_output> m_output;
+| 346|    |-};
+| 347|    |-
+| 348|    |-template <typename ObjectT>
+| 349|    |-struct Iterator: std::iterator<std::input_iterator_tag, ObjectT>
+| 350|    |-{
+| 351|    |-	// shared state of the iterator
+| 352|    |-	struct State
+| 353|    |-	{
+| 354|    |-		friend Iterator;
+| 355|    |-
+| 356|    |-		typedef std::function<bool(State &)> Fetcher;
+| 357|    |-
+| 358|    |-		State(mpd_connection *connection_, Fetcher fetcher)
+| 359|    |-		: m_connection(connection_)
+| 360|    |-		, m_fetcher(fetcher)
+| 361|    |-		{
+| 362|    |-			assert(m_connection != nullptr);
+| 363|    |-			assert(m_fetcher != nullptr);
+| 364|    |-		}
+| 365|    |-		~State()
+| 366|    |-		{
+| 367|    |-			mpd_response_finish(m_connection);
+| 368|    |-		}
+| 369|    |-
+| 370|    |-		mpd_connection *connection() const
+| 371|    |-		{
+| 372|    |-			return m_connection;
+| 373|    |-		}
+| 374|    |-
+| 375|    |-		void setObject(ObjectT object)
+| 376|    |-		{
+| 377|    |-			if (hasObject())
+| 378|    |-				*m_object = std::move(object);
+| 379|    |-			else
+| 380|    |-				m_object.reset(new ObjectT(std::move(object)));
+| 381|    |-		}
+| 382|    |-
+| 383|    |-	private:
+| 384|    |-		bool operator==(const State &rhs) const
+| 385|    |-		{
+| 386|    |-			return m_connection == rhs.m_connection
+| 387|    |-			    && m_object == m_object;
+| 388|    |-		}
+| 389|    |-		bool operator!=(const State &rhs) const
+| 390|    |-		{
+| 391|    |-			return !(*this == rhs);
+| 392|    |-		}
+| 393|    |-
+| 394|    |-		bool fetch()
+| 395|    |-		{
+| 396|    |-			return m_fetcher(*this);
+| 397|    |-		}
+| 398|    |-		ObjectT &getObject() const
+| 399|    |-		{
+| 400|    |-			return *m_object;
+| 401|    |-		}
+| 402|    |-		bool hasObject() const
+| 403|    |-		{
+| 404|    |-			return m_object.get() != nullptr;
+| 405|    |-		}
+| 406|    |-
+| 407|    |-		mpd_connection *m_connection;
+| 408|    |-		Fetcher m_fetcher;
+| 409|    |-		std::unique_ptr<ObjectT> m_object;
+| 410|    |-	};
+| 411|    |-
+| 412|    |-	Iterator()
+| 413|    |-	: m_state(nullptr)
+| 414|    |-	{ }
+| 415|    |-	Iterator(mpd_connection *connection, typename State::Fetcher fetcher)
+| 416|    |-	: m_state(std::make_shared<State>(connection, std::move(fetcher)))
+| 417|    |-	{
+| 418|    |-		// get the first element
+| 419|    |-		++*this;
+| 420|    |-	}
+| 421|    |-	~Iterator()
+| 422|    |-	{
+| 423|    |-		if (m_state)
+| 424|    |-			checkConnectionErrors(m_state->connection());
+| 425|    |-	}
+| 426|    |-
+| 427|    |-	void finish()
+| 428|    |-	{
+| 429|    |-		assert(m_state);
+| 430|    |-		// check errors and change the iterator into end iterator
+| 431|    |-		checkConnectionErrors(m_state->connection());
+| 432|    |-		m_state = nullptr;
+| 433|    |-	}
+| 434|    |-
+| 435|    |-	ObjectT &operator*() const
+| 436|    |-	{
+| 437|    |-		if (!m_state)
+| 438|    |-			throw std::runtime_error("no object associated with the iterator");
+| 439|    |-		assert(m_state->hasObject());
+| 440|    |-		return m_state->getObject();
+| 441|    |-	}
+| 442|    |-	ObjectT *operator->() const
+| 443|    |-	{
+| 444|    |-		return &**this;
+| 445|    |-	}
+| 446|    |-
+| 447|    |-	Iterator &operator++()
+| 448|    |-	{
+| 449|    |-		assert(m_state);
+| 450|    |-		if (!m_state->fetch())
+| 451|    |-			finish();
+| 452|    |-		return *this;
+| 453|    |-	}
+| 454|    |-	Iterator operator++(int)
+| 455|    |-	{
+| 456|    |-		Iterator it(*this);
+| 457|    |-		++*this;
+| 458|    |-		return it;
+| 459|    |-	}
+| 460|    |-
+| 461|    |-	bool operator==(const Iterator &rhs) const
+| 462|    |-	{
+| 463|    |-		return m_state == rhs.m_state;
+| 464|    |-	}
+| 465|    |-	bool operator!=(const Iterator &rhs) const
+| 466|    |-	{
+| 467|    |-		return !(*this == rhs);
+| 468|    |-	}
+| 469|    |-
+| 470|    |-private:
+| 471|    |-	std::shared_ptr<State> m_state;
+| 472|    |-};
+| 473|    |-
+| 474|    |-typedef Iterator<Directory> DirectoryIterator;
+| 475|    |-typedef Iterator<Item> ItemIterator;
+| 476|    |-typedef Iterator<Output> OutputIterator;
+| 477|    |-typedef Iterator<Playlist> PlaylistIterator;
+| 478|    |-typedef Iterator<Song> SongIterator;
+| 479|    |-typedef Iterator<std::string> StringIterator;
+| 480|    |-
+| 481|    |-struct Connection
+| 482|    |-{
+| 483|    |-	typedef std::function<void(int)> NoidleCallback;
+| 484|    |-
+| 485|    |-	Connection();
+| 486|    |-	
+| 487|    |-	void Connect();
+| 488|    |-	bool Connected() const;
+| 489|    |-	void Disconnect();
+| 490|    |-	
+| 491|    |-	const std::string &GetHostname() { return m_host; }
+| 492|    |-	int GetPort() { return m_port; }
+| 493|    |-	
+| 494|    |-	unsigned Version() const;
+| 495|    |-	
+| 496|    |-	int GetFD() const { return m_fd; }
+| 497|    |-	
+| 498|    |-	void SetHostname(const std::string &);
+| 499|    |-	void SetPort(int port) { m_port = port; }
+| 500|    |-	void SetTimeout(int timeout) { m_timeout = timeout; }
+| 501|    |-	void SetPassword(const std::string &password) { m_password = password; }
+| 502|    |-	void SendPassword();
+| 503|    |-	
+| 504|    |-	Statistics getStatistics();
+| 505|    |-	Status getStatus();
+| 506|    |-	
+| 507|    |-	void UpdateDirectory(const std::string &);
+| 508|    |-	
+| 509|    |-	void Play();
+| 510|    |-	void Play(int);
+| 511|    |-	void PlayID(int);
+| 512|    |-	void Pause(bool);
+| 513|    |-	void Toggle();
+| 514|    |-	void Stop();
+| 515|    |-	void Next();
+| 516|    |-	void Prev();
+| 517|    |-	void Move(unsigned int from, unsigned int to);
+| 518|    |-	void Swap(unsigned, unsigned);
+| 519|    |-	void Seek(unsigned int pos, unsigned int where);
+| 520|    |-	void Shuffle();
+| 521|    |-	void ShuffleRange(unsigned start, unsigned end);
+| 522|    |-	void ClearMainPlaylist();
+| 523|    |-	
+| 524|    |-	SongIterator GetPlaylistChanges(unsigned);
+| 525|    |-	
+| 526|    |-	Song GetCurrentSong();
+| 527|    |-	Song GetSong(const std::string &);
+| 528|    |-	SongIterator GetPlaylistContent(const std::string &name);
+| 529|    |-	SongIterator GetPlaylistContentNoInfo(const std::string &name);
+| 530|    |-	
+| 531|    |-	StringIterator GetSupportedExtensions();
+| 532|    |-	
+| 533|    |-	void SetRepeat(bool);
+| 534|    |-	void SetRandom(bool);
+| 535|    |-	void SetSingle(bool);
+| 536|    |-	void SetConsume(bool);
+| 537|    |-	void SetCrossfade(unsigned);
+| 538|    |-	void SetVolume(unsigned int vol);
+| 539|    |-	void ChangeVolume(int change);
+| 540|    |-
+| 541|    |-	std::string GetReplayGainMode();
+| 542|    |-	void SetReplayGainMode(ReplayGainMode);
+| 543|    |-	
+| 544|    |-	void SetPriority(const MPD::Song &s, int prio);
+| 545|    |-	
+| 546|    |-	int AddSong(const std::string &, int = -1); // returns id of added song
+| 547|    |-	int AddSong(const Song &, int = -1); // returns id of added song
+| 548|    |-	bool AddRandomTag(mpd_tag_type, size_t, std::mt19937 &rng);
+| 549|    |-	bool AddRandomSongs(size_t number, std::mt19937 &rng);
+| 550|    |-	void Add(const std::string &path);
+| 551|    |-	void Delete(unsigned int pos);
+| 552|    |-	void PlaylistDelete(const std::string &playlist, unsigned int pos);
+| 553|    |-	void StartCommandsList();
+| 554|    |-	void CommitCommandsList();
+| 555|    |-	
+| 556|    |-	void DeletePlaylist(const std::string &name);
+| 557|    |-	void LoadPlaylist(const std::string &name);
+| 558|    |-	void SavePlaylist(const std::string &);
+| 559|    |-	void ClearPlaylist(const std::string &playlist);
+| 560|    |-	void AddToPlaylist(const std::string &, const Song &);
+| 561|    |-	void AddToPlaylist(const std::string &, const std::string &);
+| 562|    |-	void PlaylistMove(const std::string &path, int from, int to);
+| 563|    |-	void Rename(const std::string &from, const std::string &to);
+| 564|    |-	
+| 565|    |-	void StartSearch(bool);
+| 566|    |-	void StartFieldSearch(mpd_tag_type);
+| 567|    |-	void AddSearch(mpd_tag_type item, const std::string &str) const;
+| 568|    |-	void AddSearchAny(const std::string &str) const;
+| 569|    |-	void AddSearchURI(const std::string &str) const;
+| 570|    |-	SongIterator CommitSearchSongs();
+| 571|    |-	
+| 572|    |-	PlaylistIterator GetPlaylists();
+| 573|    |-	StringIterator GetList(mpd_tag_type type);
+| 574|    |-	ItemIterator GetDirectory(const std::string &directory);
+| 575|    |-	SongIterator GetDirectoryRecursive(const std::string &directory);
+| 576|    |-	SongIterator GetSongs(const std::string &directory);
+| 577|    |-	DirectoryIterator GetDirectories(const std::string &directory);
+| 578|    |-	
+| 579|    |-	OutputIterator GetOutputs();
+| 580|    |-	void EnableOutput(int id);
+| 581|    |-	void DisableOutput(int id);
+| 582|    |-	
+| 583|    |-	StringIterator GetURLHandlers();
+| 584|    |-	StringIterator GetTagTypes();
+| 585|    |-	
+| 586|    |-	void idle();
+| 587|    |-	int noidle();
+| 588|    |-	void setNoidleCallback(NoidleCallback callback);
+| 589|    |-	
+| 590|    |-private:
+| 591|    |-	struct ConnectionDeleter {
+| 592|    |-		void operator()(mpd_connection *connection) {
+| 593|    |-			mpd_connection_free(connection);
+| 594|    |-		}
+| 595|    |-	};
+| 596|    |-
+| 597|    |-	void checkConnection() const;
+| 598|    |-	void prechecks();
+| 599|    |-	void prechecksNoCommandsList();
+| 600|    |-	void checkErrors() const;
+| 601|    |-
+| 602|    |-	NoidleCallback m_noidle_callback;
+| 603|    |-	std::unique_ptr<mpd_connection, ConnectionDeleter> m_connection;
+| 604|    |-	bool m_command_list_active;
+| 605|    |-	
+| 606|    |-	int m_fd;
+| 607|    |-	bool m_idle;
+| 608|    |-	
+| 609|    |-	std::string m_host;
+| 610|    |-	int m_port;
+| 611|    |-	int m_timeout;
+| 612|    |-	std::string m_password;
+| 613|    |-};
+|    |  35|+
+|    |  36|+    void checkConnectionErrors (mpd_connection * conn);
+|    |  37|+
+|    |  38|+    enum PlayerState
+|    |  39|+    { psUnknown, psStop, psPlay, psPause };
+|    |  40|+    enum ReplayGainMode
+|    |  41|+    { rgmOff, rgmTrack, rgmAlbum };
+|    |  42|+
+|    |  43|+    struct ClientError:public std::exception
+|    |  44|+    {
+|    |  45|+        ClientError (mpd_error code_, std::string msg,
+|    |  46|+                     bool clearable_):m_code (code_), m_msg (msg),
+|    |  47|+            m_clearable (clearable_)
+|    |  48|+        {
+|    |  49|+        }
+|    |  50|+        virtual ~ ClientError () noexcept
+|    |  51|+        {
+|    |  52|+        }
+|    |  53|+
+|    |  54|+        virtual const char *what () const noexcept
+|    |  55|+        {
+|    |  56|+            return m_msg.c_str ();
+|    |  57|+        }
+|    |  58|+        mpd_error code () const
+|    |  59|+        {
+|    |  60|+            return m_code;
+|    |  61|+        }
+|    |  62|+        bool clearable () const
+|    |  63|+        {
+|    |  64|+            return m_clearable;
+|    |  65|+        }
+|    |  66|+
+|    |  67|+      private:
+|    |  68|+          mpd_error m_code;
+|    |  69|+        std::string m_msg;
+|    |  70|+        bool m_clearable;
+|    |  71|+    };
+|    |  72|+
+|    |  73|+    struct ServerError:public std::exception
+|    |  74|+    {
+|    |  75|+        ServerError (mpd_server_error code_, std::string msg,
+|    |  76|+                     bool clearable_):m_code (code_), m_msg (msg),
+|    |  77|+            m_clearable (clearable_)
+|    |  78|+        {
+|    |  79|+        }
+|    |  80|+        virtual ~ ServerError () noexcept
+|    |  81|+        {
+|    |  82|+        }
+|    |  83|+
+|    |  84|+        virtual const char *what () const noexcept
+|    |  85|+        {
+|    |  86|+            return m_msg.c_str ();
+|    |  87|+        }
+|    |  88|+        mpd_server_error code () const
+|    |  89|+        {
+|    |  90|+            return m_code;
+|    |  91|+        }
+|    |  92|+        bool clearable () const
+|    |  93|+        {
+|    |  94|+            return m_clearable;
+|    |  95|+        }
+|    |  96|+
+|    |  97|+      private:
+|    |  98|+          mpd_server_error m_code;
+|    |  99|+        std::string m_msg;
+|    | 100|+        bool m_clearable;
+|    | 101|+    };
+|    | 102|+
+|    | 103|+    struct Statistics
+|    | 104|+    {
+|    | 105|+        friend struct Connection;
+|    | 106|+
+|    | 107|+        bool empty () const
+|    | 108|+        {
+|    | 109|+            return m_stats.get () == nullptr;
+|    | 110|+        }
+|    | 111|+
+|    | 112|+        unsigned artists () const
+|    | 113|+        {
+|    | 114|+            return mpd_stats_get_number_of_artists (m_stats.get ());
+|    | 115|+        }
+|    | 116|+        unsigned albums () const
+|    | 117|+        {
+|    | 118|+            return mpd_stats_get_number_of_albums (m_stats.get ());
+|    | 119|+        }
+|    | 120|+        unsigned songs () const
+|    | 121|+        {
+|    | 122|+            return mpd_stats_get_number_of_songs (m_stats.get ());
+|    | 123|+        }
+|    | 124|+        unsigned long playTime () const
+|    | 125|+        {
+|    | 126|+            return mpd_stats_get_play_time (m_stats.get ());
+|    | 127|+        }
+|    | 128|+        unsigned long uptime () const
+|    | 129|+        {
+|    | 130|+            return mpd_stats_get_uptime (m_stats.get ());
+|    | 131|+        }
+|    | 132|+        unsigned long dbUpdateTime () const
+|    | 133|+        {
+|    | 134|+            return mpd_stats_get_db_update_time (m_stats.get ());
+|    | 135|+        }
+|    | 136|+        unsigned long dbPlayTime () const
+|    | 137|+        {
+|    | 138|+            return mpd_stats_get_db_play_time (m_stats.get ());
+|    | 139|+        }
+|    | 140|+
+|    | 141|+      private:
+|    | 142|+          Statistics (mpd_stats * stats):m_stats (stats, mpd_stats_free)
+|    | 143|+        {
+|    | 144|+        }
+|    | 145|+
+|    | 146|+        std::shared_ptr < mpd_stats > m_stats;
+|    | 147|+    };
+|    | 148|+
+|    | 149|+    struct Status
+|    | 150|+    {
+|    | 151|+        friend struct Connection;
+|    | 152|+
+|    | 153|+          Status ()
+|    | 154|+        {
+|    | 155|+        }
+|    | 156|+
+|    | 157|+        void clear ()
+|    | 158|+        {
+|    | 159|+            m_status.reset ();
+|    | 160|+        }
+|    | 161|+        bool empty () const
+|    | 162|+        {
+|    | 163|+            return m_status.get () == nullptr;
+|    | 164|+        }
+|    | 165|+
+|    | 166|+        int volume () const
+|    | 167|+        {
+|    | 168|+            return mpd_status_get_volume (m_status.get ());
+|    | 169|+        }
+|    | 170|+        bool repeat () const
+|    | 171|+        {
+|    | 172|+            return mpd_status_get_repeat (m_status.get ());
+|    | 173|+        }
+|    | 174|+        bool random () const
+|    | 175|+        {
+|    | 176|+            return mpd_status_get_random (m_status.get ());
+|    | 177|+        }
+|    | 178|+        bool single () const
+|    | 179|+        {
+|    | 180|+            return mpd_status_get_single (m_status.get ());
+|    | 181|+        }
+|    | 182|+        bool consume () const
+|    | 183|+        {
+|    | 184|+            return mpd_status_get_consume (m_status.get ());
+|    | 185|+        }
+|    | 186|+        unsigned playlistLength () const
+|    | 187|+        {
+|    | 188|+            return mpd_status_get_queue_length (m_status.get ());
+|    | 189|+        }
+|    | 190|+        unsigned playlistVersion () const
+|    | 191|+        {
+|    | 192|+            return mpd_status_get_queue_version (m_status.get ());
+|    | 193|+        }
+|    | 194|+        PlayerState playerState () const
+|    | 195|+        {
+|    | 196|+            return PlayerState (mpd_status_get_state (m_status.get ()));
+|    | 197|+        }
+|    | 198|+        unsigned crossfade () const
+|    | 199|+        {
+|    | 200|+            return mpd_status_get_crossfade (m_status.get ());
+|    | 201|+        }
+|    | 202|+        int currentSongPosition () const
+|    | 203|+        {
+|    | 204|+            return mpd_status_get_song_pos (m_status.get ());
+|    | 205|+        }
+|    | 206|+        int currentSongID () const
+|    | 207|+        {
+|    | 208|+            return mpd_status_get_song_id (m_status.get ());
+|    | 209|+        }
+|    | 210|+        int nextSongPosition () const
+|    | 211|+        {
+|    | 212|+            return mpd_status_get_next_song_pos (m_status.get ());
+|    | 213|+        }
+|    | 214|+        int nextSongID () const
+|    | 215|+        {
+|    | 216|+            return mpd_status_get_next_song_id (m_status.get ());
+|    | 217|+        }
+|    | 218|+        unsigned elapsedTime () const
+|    | 219|+        {
+|    | 220|+            return mpd_status_get_elapsed_time (m_status.get ());
+|    | 221|+        }
+|    | 222|+        unsigned totalTime () const
+|    | 223|+        {
+|    | 224|+            return mpd_status_get_total_time (m_status.get ());
+|    | 225|+        }
+|    | 226|+        unsigned kbps () const
+|    | 227|+        {
+|    | 228|+            return mpd_status_get_kbit_rate (m_status.get ());
+|    | 229|+        }
+|    | 230|+        unsigned updateID () const
+|    | 231|+        {
+|    | 232|+            return mpd_status_get_update_id (m_status.get ());
+|    | 233|+        }
+|    | 234|+        const char *error () const
+|    | 235|+        {
+|    | 236|+            return mpd_status_get_error (m_status.get ());
+|    | 237|+        }
+|    | 238|+
+|    | 239|+      private:
+|    | 240|+          Status (mpd_status * status):m_status (status, mpd_status_free)
+|    | 241|+        {
+|    | 242|+        }
+|    | 243|+
+|    | 244|+        std::shared_ptr < mpd_status > m_status;
+|    | 245|+    };
+|    | 246|+
+|    | 247|+    struct Directory
+|    | 248|+    {
+|    | 249|+        Directory ():m_last_modified (0)
+|    | 250|+        {
+|    | 251|+        }
+|    | 252|+        Directory (const mpd_directory * directory)
+|    | 253|+        {
+|    | 254|+            assert (directory != nullptr);
+|    | 255|+            m_path = mpd_directory_get_path (directory);
+|    | 256|+            m_last_modified = mpd_directory_get_last_modified (directory);
+|    | 257|+        }
+|    | 258|+      Directory (std::string path_, time_t last_modified = 0):m_path (std::move (path_)),
+|    | 259|+            m_last_modified
+|    | 260|+            (last_modified)
+|    | 261|+        {
+|    | 262|+        }
+|    | 263|+
+|    | 264|+        bool operator== (const Directory & rhs) const
+|    | 265|+        {
+|    | 266|+            return m_path == rhs.m_path
+|    | 267|+                && m_last_modified == rhs.m_last_modified;
+|    | 268|+        }
+|    | 269|+        bool operator!= (const Directory & rhs) const
+|    | 270|+        {
+|    | 271|+            return !(*this == rhs);
+|    | 272|+        }
+|    | 273|+
+|    | 274|+        const std::string & path () const
+|    | 275|+        {
+|    | 276|+            return m_path;
+|    | 277|+        }
+|    | 278|+        time_t lastModified () const
+|    | 279|+        {
+|    | 280|+            return m_last_modified;
+|    | 281|+        }
+|    | 282|+
+|    | 283|+      private:
+|    | 284|+          std::string m_path;
+|    | 285|+        time_t m_last_modified;
+|    | 286|+    };
+|    | 287|+
+|    | 288|+    struct Playlist
+|    | 289|+    {
+|    | 290|+        Playlist ():m_last_modified (0)
+|    | 291|+        {
+|    | 292|+        }
+|    | 293|+        Playlist (const mpd_playlist * playlist)
+|    | 294|+        {
+|    | 295|+            assert (playlist != nullptr);
+|    | 296|+            m_path = mpd_playlist_get_path (playlist);
+|    | 297|+            m_last_modified = mpd_playlist_get_last_modified (playlist);
+|    | 298|+        }
+|    | 299|+      Playlist (std::string path_, time_t last_modified = 0):m_path (std::move (path_)),
+|    | 300|+            m_last_modified
+|    | 301|+            (last_modified)
+|    | 302|+        {
+|    | 303|+            if (m_path.empty ())
+|    | 304|+                throw std::runtime_error ("empty path");
+|    | 305|+        }
+|    | 306|+
+|    | 307|+        bool operator== (const Playlist & rhs) const
+|    | 308|+        {
+|    | 309|+            return m_path == rhs.m_path
+|    | 310|+                && m_last_modified == rhs.m_last_modified;
+|    | 311|+        }
+|    | 312|+        bool operator!= (const Playlist & rhs) const
+|    | 313|+        {
+|    | 314|+            return !(*this == rhs);
+|    | 315|+        }
+|    | 316|+
+|    | 317|+        const std::string & path () const
+|    | 318|+        {
+|    | 319|+            return m_path;
+|    | 320|+        }
+|    | 321|+        time_t lastModified () const
+|    | 322|+        {
+|    | 323|+            return m_last_modified;
+|    | 324|+        }
+|    | 325|+
+|    | 326|+      private:
+|    | 327|+          std::string m_path;
+|    | 328|+        time_t m_last_modified;
+|    | 329|+    };
+|    | 330|+
+|    | 331|+    struct Item
+|    | 332|+    {
+|    | 333|+        enum class Type
+|    | 334|+        { Directory, Song, Playlist };
+|    | 335|+
+|    | 336|+          Item (mpd_entity * entity)
+|    | 337|+        {
+|    | 338|+            assert (entity != nullptr);
+|    | 339|+            switch (mpd_entity_get_type (entity))
+|    | 340|+              {
+|    | 341|+              case MPD_ENTITY_TYPE_DIRECTORY:
+|    | 342|+                  m_type = Type::Directory;
+|    | 343|+                  m_directory = Directory (mpd_entity_get_directory (entity));
+|    | 344|+                  break;
+|    | 345|+                  case MPD_ENTITY_TYPE_SONG:m_type = Type::Song;
+|    | 346|+                  m_song = Song (mpd_song_dup (mpd_entity_get_song (entity)));
+|    | 347|+                  break;
+|    | 348|+                  case MPD_ENTITY_TYPE_PLAYLIST:m_type = Type::Playlist;
+|    | 349|+                  m_playlist = Playlist (mpd_entity_get_playlist (entity));
+|    | 350|+                  break;
+|    | 351|+                  default:throw std::runtime_error ("unknown mpd_entity type");
+|    | 352|+              }
+|    | 353|+            mpd_entity_free (entity);
+|    | 354|+        }
+|    | 355|+      Item (Directory directory_):m_type (Type::Directory),
+|    | 356|+            m_directory (std::
+|    | 357|+                         move (directory_))
+|    | 358|+        {
+|    | 359|+        }
+|    | 360|+      Item (Song song_):m_type (Type::Song),
+|    | 361|+            m_song (std::move (song_))
+|    | 362|+        {
+|    | 363|+        }
+|    | 364|+      Item (Playlist playlist_):m_type (Type::Playlist),
+|    | 365|+            m_playlist (std::move (playlist_))
+|    | 366|+        {
+|    | 367|+        }
+|    | 368|+
+|    | 369|+        bool operator== (const Item & rhs) const
+|    | 370|+        {
+|    | 371|+            return m_directory == rhs.m_directory
+|    | 372|+                && m_song == rhs.m_song && m_playlist == rhs.m_playlist;
+|    | 373|+        }
+|    | 374|+        bool operator!= (const Item & rhs) const
+|    | 375|+        {
+|    | 376|+            return !(*this == rhs);
+|    | 377|+        }
+|    | 378|+
+|    | 379|+        Type type () const
+|    | 380|+        {
+|    | 381|+            return m_type;
+|    | 382|+        }
+|    | 383|+
+|    | 384|+        Directory & directory ()
+|    | 385|+        {
+|    | 386|+            return const_cast < Directory & >(static_cast <
+|    | 387|+                                              const Item & >(*this).
+|    | 388|+                                              directory ());
+|    | 389|+        }
+|    | 390|+        Song & song ()
+|    | 391|+        {
+|    | 392|+            return const_cast < Song & >(static_cast <
+|    | 393|+                                         const Item & >(*this).song ());
+|    | 394|+        }
+|    | 395|+        Playlist & playlist ()
+|    | 396|+        {
+|    | 397|+            return const_cast < Playlist & >(static_cast <
+|    | 398|+                                             const Item & >(*this).
+|    | 399|+                                             playlist ());
+|    | 400|+        }
+|    | 401|+
+|    | 402|+        const Directory & directory () const
+|    | 403|+        {
+|    | 404|+            assert (m_type == Type::Directory);
+|    | 405|+            return m_directory;
+|    | 406|+        }
+|    | 407|+        const Song & song () const
+|    | 408|+        {
+|    | 409|+            assert (m_type == Type::Song);
+|    | 410|+            return m_song;
+|    | 411|+        }
+|    | 412|+        const Playlist & playlist () const
+|    | 413|+        {
+|    | 414|+            assert (m_type == Type::Playlist);
+|    | 415|+            return m_playlist;
+|    | 416|+        }
+|    | 417|+
+|    | 418|+      private:
+|    | 419|+          Type m_type;
+|    | 420|+        Directory m_directory;
+|    | 421|+        Song m_song;
+|    | 422|+        Playlist m_playlist;
+|    | 423|+    };
+|    | 424|+
+|    | 425|+    struct Output
+|    | 426|+    {
+|    | 427|+        Output ()
+|    | 428|+        {
+|    | 429|+        }
+|    | 430|+        Output (mpd_output * output):m_output (output, mpd_output_free)
+|    | 431|+        {
+|    | 432|+        }
+|    | 433|+
+|    | 434|+        bool operator== (const Output & rhs) const
+|    | 435|+        {
+|    | 436|+            if (empty () && rhs.empty ())
+|    | 437|+                return true;
+|    | 438|+            else if (!empty () && !rhs.empty ())
+|    | 439|+                return id () == rhs.id ()
+|    | 440|+                    && strcmp (name (), rhs.name ()) == 0
+|    | 441|+                    && enabled () == rhs.enabled ();
+|    | 442|+            else
+|    | 443|+                return false;
+|    | 444|+        }
+|    | 445|+        bool operator!= (const Output & rhs) const
+|    | 446|+        {
+|    | 447|+            return !(*this == rhs);
+|    | 448|+        }
+|    | 449|+
+|    | 450|+        unsigned id () const
+|    | 451|+        {
+|    | 452|+            assert (m_output.get () != nullptr);
+|    | 453|+            return mpd_output_get_id (m_output.get ());
+|    | 454|+        }
+|    | 455|+        const char *name () const
+|    | 456|+        {
+|    | 457|+            assert (m_output.get () != nullptr);
+|    | 458|+            return mpd_output_get_name (m_output.get ());
+|    | 459|+        }
+|    | 460|+        bool enabled () const
+|    | 461|+        {
+|    | 462|+            assert (m_output.get () != nullptr);
+|    | 463|+            return mpd_output_get_enabled (m_output.get ());
+|    | 464|+        }
+|    | 465|+
+|    | 466|+        bool empty () const
+|    | 467|+        {
+|    | 468|+            return m_output.get () == nullptr;
+|    | 469|+        }
+|    | 470|+
+|    | 471|+      private:
+|    | 472|+          std::shared_ptr < mpd_output > m_output;
+|    | 473|+    };
+|    | 474|+
+|    | 475|+    template < typename ObjectT >
+|    | 476|+        struct Iterator:std::iterator < std::input_iterator_tag, ObjectT >
+|    | 477|+    {
+|    | 478|+        // shared state of the iterator
+|    | 479|+        struct State
+|    | 480|+        {
+|    | 481|+            friend Iterator;
+|    | 482|+
+|    | 483|+            typedef std::function < bool (State &) > Fetcher;
+|    | 484|+
+|    | 485|+              State (mpd_connection * connection_,
+|    | 486|+                     Fetcher fetcher):m_connection (connection_),
+|    | 487|+                m_fetcher (fetcher)
+|    | 488|+            {
+|    | 489|+                assert (m_connection != nullptr);
+|    | 490|+                assert (m_fetcher != nullptr);
+|    | 491|+            }
+|    | 492|+             ~State ()
+|    | 493|+            {
+|    | 494|+                mpd_response_finish (m_connection);
+|    | 495|+            }
+|    | 496|+
+|    | 497|+            mpd_connection *connection () const
+|    | 498|+            {
+|    | 499|+                return m_connection;
+|    | 500|+            }
+|    | 501|+
+|    | 502|+            void setObject (ObjectT object)
+|    | 503|+            {
+|    | 504|+                if (hasObject ())
+|    | 505|+                    *m_object = std::move (object);
+|    | 506|+                else
+|    | 507|+                    m_object.reset (new ObjectT (std::move (object)));
+|    | 508|+            }
+|    | 509|+
+|    | 510|+          private:
+|    | 511|+            bool operator== (const State & rhs) const
+|    | 512|+            {
+|    | 513|+                return m_connection == rhs.m_connection
+|    | 514|+                    && m_object == m_object;
+|    | 515|+            }
+|    | 516|+            bool operator!= (const State & rhs) const
+|    | 517|+            {
+|    | 518|+                return !(*this == rhs);
+|    | 519|+            }
+|    | 520|+
+|    | 521|+            bool fetch ()
+|    | 522|+            {
+|    | 523|+                return m_fetcher (*this);
+|    | 524|+            }
+|    | 525|+            ObjectT & getObject ()const
+|    | 526|+            {
+|    | 527|+                return *m_object;
+|    | 528|+            }
+|    | 529|+            bool hasObject () const
+|    | 530|+            {
+|    | 531|+                return m_object.get () != nullptr;
+|    | 532|+            }
+|    | 533|+
+|    | 534|+            mpd_connection *m_connection;
+|    | 535|+            Fetcher m_fetcher;
+|    | 536|+            std::unique_ptr < ObjectT > m_object;
+|    | 537|+        };
+|    | 538|+
+|    | 539|+      Iterator ():m_state (nullptr)
+|    | 540|+        {
+|    | 541|+        }
+|    | 542|+      Iterator (mpd_connection * connection, typename State::Fetcher fetcher):m_state (std::make_shared < State >
+|    | 543|+                 (connection,
+|    | 544|+                  std::move (fetcher)))
+|    | 545|+        {
+|    | 546|+            // get the first element
+|    | 547|+            ++*this;
+|    | 548|+        }
+|    | 549|+        ~Iterator ()
+|    | 550|+        {
+|    | 551|+            if (m_state)
+|    | 552|+                checkConnectionErrors (m_state->connection ());
+|    | 553|+        }
+|    | 554|+
+|    | 555|+        void finish ()
+|    | 556|+        {
+|    | 557|+            assert (m_state);
+|    | 558|+            // check errors and change the iterator into end iterator
+|    | 559|+            checkConnectionErrors (m_state->connection ());
+|    | 560|+            m_state = nullptr;
+|    | 561|+        }
+|    | 562|+
+|    | 563|+        ObjectT & operator* ()const
+|    | 564|+        {
+|    | 565|+            if (!m_state)
+|    | 566|+                throw std::
+|    | 567|+                    runtime_error ("no object associated with the iterator");
+|    | 568|+              assert (m_state->hasObject ());
+|    | 569|+              return m_state->getObject ();
+|    | 570|+        }
+|    | 571|+        ObjectT *operator-> () const
+|    | 572|+        {
+|    | 573|+            return &**this;
+|    | 574|+        }
+|    | 575|+
+|    | 576|+        Iterator & operator++ ()
+|    | 577|+        {
+|    | 578|+            assert (m_state);
+|    | 579|+            if (!m_state->fetch ())
+|    | 580|+                finish ();
+|    | 581|+            return *this;
+|    | 582|+        }
+|    | 583|+        Iterator operator++ (int)
+|    | 584|+        {
+|    | 585|+            Iterator it (*this);
+|    | 586|+            ++*this;
+|    | 587|+            return it;
+|    | 588|+        }
+|    | 589|+
+|    | 590|+        bool operator== (const Iterator & rhs) const
+|    | 591|+        {
+|    | 592|+            return m_state == rhs.m_state;
+|    | 593|+        }
+|    | 594|+        bool operator!= (const Iterator & rhs) const
+|    | 595|+        {
+|    | 596|+            return !(*this == rhs);
+|    | 597|+        }
+|    | 598|+
+|    | 599|+      private:
+|    | 600|+          std::shared_ptr < State > m_state;
+|    | 601|+    };
+|    | 602|+
+|    | 603|+    typedef Iterator < Directory > DirectoryIterator;
+|    | 604|+    typedef Iterator < Item > ItemIterator;
+|    | 605|+    typedef Iterator < Output > OutputIterator;
+|    | 606|+    typedef Iterator < Playlist > PlaylistIterator;
+|    | 607|+    typedef Iterator < Song > SongIterator;
+|    | 608|+    typedef Iterator < std::string > StringIterator;
+|    | 609|+
+|    | 610|+    struct Connection
+|    | 611|+    {
+|    | 612|+        typedef std::function < void (int) > NoidleCallback;
+|    | 613|+
+|    | 614|+          Connection ();
+|    | 615|+
+|    | 616|+        void Connect ();
+|    | 617|+        bool Connected () const;
+|    | 618|+        void Disconnect ();
+|    | 619|+
+|    | 620|+        const std::string & GetHostname ()
+|    | 621|+        {
+|    | 622|+            return m_host;
+|    | 623|+        }
+|    | 624|+        int GetPort ()
+|    | 625|+        {
+|    | 626|+            return m_port;
+|    | 627|+        }
+|    | 628|+
+|    | 629|+        unsigned Version () const;
+|    | 630|+
+|    | 631|+        int GetFD () const
+|    | 632|+        {
+|    | 633|+            return m_fd;
+|    | 634|+        }
+|    | 635|+
+|    | 636|+        void SetHostname (const std::string &);
+|    | 637|+        void SetPort (int port)
+|    | 638|+        {
+|    | 639|+            m_port = port;
+|    | 640|+        }
+|    | 641|+        void SetTimeout (int timeout)
+|    | 642|+        {
+|    | 643|+            m_timeout = timeout;
+|    | 644|+        }
+|    | 645|+        void SetPassword (const std::string & password)
+|    | 646|+        {
+|    | 647|+            m_password = password;
+|    | 648|+        }
+|    | 649|+        void SendPassword ();
+|    | 650|+
+|    | 651|+        Statistics getStatistics ();
+|    | 652|+        Status getStatus ();
+|    | 653|+
+|    | 654|+        void UpdateDirectory (const std::string &);
+|    | 655|+
+|    | 656|+        void Play ();
+|    | 657|+        void Play (int);
+|    | 658|+        void PlayID (int);
+|    | 659|+        void Pause (bool);
+|    | 660|+        void Toggle ();
+|    | 661|+        void Stop ();
+|    | 662|+        void Next ();
+|    | 663|+        void Prev ();
+|    | 664|+        void Move (unsigned int from, unsigned int to);
+|    | 665|+        void Swap (unsigned, unsigned);
+|    | 666|+        void Seek (unsigned int pos, unsigned int where);
+|    | 667|+        void Shuffle ();
+|    | 668|+        void ShuffleRange (unsigned start, unsigned end);
+|    | 669|+        void ClearMainPlaylist ();
+|    | 670|+
+|    | 671|+        SongIterator GetPlaylistChanges (unsigned);
+|    | 672|+
+|    | 673|+        Song GetCurrentSong ();
+|    | 674|+        Song GetSong (const std::string &);
+|    | 675|+        SongIterator GetPlaylistContent (const std::string & name);
+|    | 676|+        SongIterator GetPlaylistContentNoInfo (const std::string & name);
+|    | 677|+
+|    | 678|+        StringIterator GetSupportedExtensions ();
+|    | 679|+
+|    | 680|+        void SetRepeat (bool);
+|    | 681|+        void SetRandom (bool);
+|    | 682|+        void SetSingle (bool);
+|    | 683|+        void SetConsume (bool);
+|    | 684|+        void SetCrossfade (unsigned);
+|    | 685|+        void SetVolume (unsigned int vol);
+|    | 686|+        void ChangeVolume (int change);
+|    | 687|+
+|    | 688|+        std::string GetReplayGainMode ();
+|    | 689|+        void SetReplayGainMode (ReplayGainMode);
+|    | 690|+
+|    | 691|+        void SetPriority (const MPD::Song & s, int prio);
+|    | 692|+
+|    | 693|+        int AddSong (const std::string &, int = -1);    // returns id of added song
+|    | 694|+        int AddSong (const Song &, int = -1);   // returns id of added song
+|    | 695|+        bool AddRandomTag (mpd_tag_type, size_t, std::mt19937 & rng);
+|    | 696|+        bool AddRandomSongs (size_t number, std::mt19937 & rng);
+|    | 697|+        void Add (const std::string & path);
+|    | 698|+        void Delete (unsigned int pos);
+|    | 699|+        void PlaylistDelete (const std::string & playlist, unsigned int pos);
+|    | 700|+        void StartCommandsList ();
+|    | 701|+        void CommitCommandsList ();
+|    | 702|+
+|    | 703|+        void DeletePlaylist (const std::string & name);
+|    | 704|+        void LoadPlaylist (const std::string & name);
+|    | 705|+        void SavePlaylist (const std::string &);
+|    | 706|+        void ClearPlaylist (const std::string & playlist);
+|    | 707|+        void AddToPlaylist (const std::string &, const Song &);
+|    | 708|+        void AddToPlaylist (const std::string &, const std::string &);
+|    | 709|+        void PlaylistMove (const std::string & path, int from, int to);
+|    | 710|+        void Rename (const std::string & from, const std::string & to);
+|    | 711|+
+|    | 712|+        void StartSearch (bool);
+|    | 713|+        void StartFieldSearch (mpd_tag_type);
+|    | 714|+        void AddSearch (mpd_tag_type item, const std::string & str) const;
+|    | 715|+        void AddSearchAny (const std::string & str) const;
+|    | 716|+        void AddSearchURI (const std::string & str) const;
+|    | 717|+        SongIterator CommitSearchSongs ();
+|    | 718|+
+|    | 719|+        PlaylistIterator GetPlaylists ();
+|    | 720|+        StringIterator GetList (mpd_tag_type type);
+|    | 721|+        ItemIterator GetDirectory (const std::string & directory);
+|    | 722|+        SongIterator GetDirectoryRecursive (const std::string & directory);
+|    | 723|+        SongIterator GetSongs (const std::string & directory);
+|    | 724|+        DirectoryIterator GetDirectories (const std::string & directory);
+|    | 725|+
+|    | 726|+        OutputIterator GetOutputs ();
+|    | 727|+        void EnableOutput (int id);
+|    | 728|+        void DisableOutput (int id);
+|    | 729|+
+|    | 730|+        StringIterator GetURLHandlers ();
+|    | 731|+        StringIterator GetTagTypes ();
+|    | 732|+
+|    | 733|+        void idle ();
+|    | 734|+        int noidle ();
+|    | 735|+        void setNoidleCallback (NoidleCallback callback);
+|    | 736|+
+|    | 737|+      private:
+|    | 738|+        struct ConnectionDeleter
+|    | 739|+        {
+|    | 740|+            void operator () (mpd_connection * connection)
+|    | 741|+            {
+|    | 742|+                mpd_connection_free (connection);
+|    | 743|+            }
+|    | 744|+        };
+|    | 745|+
+|    | 746|+        void checkConnection () const;
+|    | 747|+        void prechecks ();
+|    | 748|+        void prechecksNoCommandsList ();
+|    | 749|+        void checkErrors () const;
+|    | 750|+
+|    | 751|+        NoidleCallback m_noidle_callback;
+|    | 752|+        std::unique_ptr < mpd_connection, ConnectionDeleter > m_connection;
+|    | 753|+        bool m_command_list_active;
+|    | 754|+
+|    | 755|+        int m_fd;
+|    | 756|+        bool m_idle;
+|    | 757|+
+|    | 758|+        std::string m_host;
+|    | 759|+        int m_port;
+|    | 760|+        int m_timeout;
+|    | 761|+        std::string m_password;
+|    | 762|+    };
+| 614| 763| 
+| 615| 764| }
+| 616| 765| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mpdpp.h
+|    |++++| /app/src/mpdpp.h
+| 614| 614| 
+| 615| 615| }
+| 616| 616| 
+| 617|    |-extern MPD::Connection Mpd;
+|    | 617|+extern
+|    | 618|+    MPD::Connection
+|    | 619|+    Mpd;
+| 618| 620| 
+| 619| 621| #endif // NCMPCPP_MPDPP_H
+
+src/mpdpp.h
+| 617| extern•MPD::Connection•Mpd;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Mpd'
+
+src/mpdpp.h
+| 211| »   enum•class•Type•{•Directory,•Song,•Playlist•};
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sort_playlist.h
+|    |++++| /app/src/screens/sort_playlist.h
+|  26|  26| #include "screens/screen.h"
+|  27|  27| #include "song.h"
+|  28|  28| 
+|  29|    |-struct SortPlaylistDialog
+|  30|    |-	: Screen<NC::Menu<RunnableItem<std::pair<std::string, MPD::Song::GetFunction>, void()>>>, HasActions, Tabbable
+|    |  29|+struct SortPlaylistDialog:Screen <
+|    |  30|+    NC::Menu <
+|    |  31|+    RunnableItem <
+|    |  32|+    std::pair <
+|    |  33|+    std::string,
+|    |  34|+MPD::Song::GetFunction >, void () >>>,
+|    |  35|+    HasActions,
+|    |  36|+    Tabbable
+|  31|  37| {
+|  32|    |-	typedef SortPlaylistDialog Self;
+|  33|    |-	
+|  34|    |-	SortPlaylistDialog();
+|  35|    |-	
+|  36|    |-	virtual void switchTo() override;
+|  37|    |-	virtual void resize() override;
+|  38|    |-	
+|  39|    |-	virtual std::wstring title() override;
+|  40|    |-	virtual ScreenType type() override { return ScreenType::SortPlaylistDialog; }
+|  41|    |-	
+|  42|    |-	virtual void update() override { }
+|  43|    |-	
+|  44|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  45|    |-	
+|  46|    |-	virtual bool isLockable() override { return false; }
+|  47|    |-	virtual bool isMergable() override { return false; }
+|    |  38|+    typedef SortPlaylistDialog
+|    |  39|+        Self;
+|  48|  40| 
+|  49|    |-	// HasActions implementation
+|  50|    |-	virtual bool actionRunnable() override;
+|  51|    |-	virtual void runAction() override;
+|    |  41|+    SortPlaylistDialog ();
+|  52|  42| 
+|  53|    |-	// private members
+|  54|    |-	void moveSortOrderUp();
+|  55|    |-	void moveSortOrderDown();
+|  56|    |-	
+|  57|    |-private:
+|  58|    |-	void moveSortOrderHint() const;
+|  59|    |-	void sort() const;
+|  60|    |-	void cancel() const;
+|  61|    |-	
+|  62|    |-	void setDimensions();
+|  63|    |-	
+|  64|    |-	size_t m_height;
+|  65|    |-	size_t m_width;
+|    |  43|+    virtual void
+|    |  44|+    switchTo ()
+|    |  45|+        override;
+|    |  46|+    virtual void
+|    |  47|+    resize ()
+|    |  48|+        override;
+|    |  49|+
+|    |  50|+    virtual
+|    |  51|+        std::wstring
+|    |  52|+    title ()
+|    |  53|+        override;
+|    |  54|+    virtual ScreenType
+|    |  55|+    type ()
+|    |  56|+        override
+|    |  57|+    {
+|    |  58|+        return ScreenType::SortPlaylistDialog;
+|    |  59|+    }
+|    |  60|+
+|    |  61|+    virtual void
+|    |  62|+    update ()
+|    |  63|+        override
+|    |  64|+    {
+|    |  65|+    }
+|    |  66|+
+|    |  67|+    virtual void
+|    |  68|+    mouseButtonPressed (MEVENT me)
+|    |  69|+        override;
+|    |  70|+
+|    |  71|+    virtual bool
+|    |  72|+    isLockable ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+        return false;
+|    |  76|+    }
+|    |  77|+    virtual bool
+|    |  78|+    isMergable ()
+|    |  79|+        override
+|    |  80|+    {
+|    |  81|+        return false;
+|    |  82|+    }
+|    |  83|+
+|    |  84|+    // HasActions implementation
+|    |  85|+    virtual bool
+|    |  86|+    actionRunnable ()
+|    |  87|+        override;
+|    |  88|+    virtual void
+|    |  89|+    runAction ()
+|    |  90|+        override;
+|    |  91|+
+|    |  92|+    // private members
+|    |  93|+    void
+|    |  94|+    moveSortOrderUp ();
+|    |  95|+    void
+|    |  96|+    moveSortOrderDown ();
+|    |  97|+
+|    |  98|+  private:
+|    |  99|+    void
+|    | 100|+    moveSortOrderHint () const;
+|    | 101|+    void
+|    | 102|+    sort () const;
+|    | 103|+    void
+|    | 104|+    cancel () const;
+|    | 105|+
+|    | 106|+    void
+|    | 107|+    setDimensions ();
+|    | 108|+
+|    | 109|+    size_t
+|    | 110|+        m_height;
+|    | 111|+    size_t
+|    | 112|+        m_width;
+|  66| 113| };
+|  67| 114| 
+|  68| 115| extern SortPlaylistDialog *mySortPlaylistDialog;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/sort_playlist.h
+|    |++++| /app/src/screens/sort_playlist.h
+|  65|  65| 	size_t m_width;
+|  66|  66| };
+|  67|  67| 
+|  68|    |-extern SortPlaylistDialog *mySortPlaylistDialog;
+|    |  68|+extern SortPlaylistDialog *
+|    |  69|+    mySortPlaylistDialog;
+|  69|  70| 
+|  70|  71| #endif // NCMPCPP_SORT_PLAYLIST_H
+
+src/screens/sort_playlist.h
+|  24| #include•"runnable_item.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'runnable_item.h'
+
+src/screens/sort_playlist.h
+|  25| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/sort_playlist.h
+|  26| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/sort_playlist.h
+|  27| #include•"song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song.h'
+
+src/screens/sort_playlist.h
+|  68| extern•SortPlaylistDialog•*mySortPlaylistDialog;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'mySortPlaylistDialog'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/enums.cpp
+|    |++++| /app/src/enums.cpp
+|  20|  20| 
+|  21|  21| #include "enums.h"
+|  22|  22| 
+|  23|    |-std::ostream &operator<<(std::ostream &os, SearchDirection sd)
+|  24|    |-{
+|  25|    |-	switch (sd)
+|  26|    |-	{
+|  27|    |-		case SearchDirection::Backward:
+|  28|    |-			os << "backward";
+|  29|    |-			break;
+|  30|    |-		case SearchDirection::Forward:
+|  31|    |-			os << "forward";
+|  32|    |-			break;
+|  33|    |-	}
+|  34|    |-	return os;
+|  35|    |-}
+|  36|    |-
+|  37|    |-std::istream &operator>>(std::istream &is, SearchDirection &sd)
+|  38|    |-{
+|  39|    |-	std::string ssd;
+|  40|    |-	is >> ssd;
+|  41|    |-	if (ssd == "backward")
+|  42|    |-		sd = SearchDirection::Backward;
+|  43|    |-	else if (ssd == "forward")
+|  44|    |-		sd = SearchDirection::Forward;
+|  45|    |-	else
+|  46|    |-		is.setstate(std::ios::failbit);
+|  47|    |-	return is;
+|  48|    |-}
+|  49|    |-
+|  50|    |-std::ostream &operator<<(std::ostream &os, SpaceAddMode sam)
+|  51|    |-{
+|  52|    |-	switch (sam)
+|  53|    |-	{
+|  54|    |-		case SpaceAddMode::AddRemove:
+|  55|    |-			os << "add_remove";
+|  56|    |-			break;
+|  57|    |-		case SpaceAddMode::AlwaysAdd:
+|  58|    |-			os << "always_add";
+|  59|    |-			break;
+|  60|    |-	}
+|  61|    |-	return os;
+|  62|    |-}
+|  63|    |-
+|  64|    |-std::istream &operator>>(std::istream &is, SpaceAddMode &sam)
+|  65|    |-{
+|  66|    |-	std::string ssam;
+|  67|    |-	is >> ssam;
+|  68|    |-	if (ssam == "add_remove")
+|  69|    |-		sam = SpaceAddMode::AddRemove;
+|  70|    |-	else if (ssam == "always_add")
+|  71|    |-		sam = SpaceAddMode::AlwaysAdd;
+|  72|    |-	else
+|  73|    |-		is.setstate(std::ios::failbit);
+|  74|    |-	return is;
+|  75|    |-}
+|  76|    |-
+|  77|    |-std::ostream &operator<<(std::ostream &os, SortMode sm)
+|  78|    |-{
+|  79|    |-	switch (sm)
+|  80|    |-	{
+|  81|    |-		case SortMode::Name:
+|  82|    |-			os << "name";
+|  83|    |-			break;
+|  84|    |-		case SortMode::ModificationTime:
+|  85|    |-			os << "mtime";
+|  86|    |-			break;
+|  87|    |-		case SortMode::CustomFormat:
+|  88|    |-			os << "format";
+|  89|    |-			break;
+|  90|    |-		case SortMode::NoOp:
+|  91|    |-			os << "noop";
+|  92|    |-			break;
+|  93|    |-	}
+|  94|    |-	return os;
+|  95|    |-}
+|  96|    |-
+|  97|    |-std::istream &operator>>(std::istream &is, SortMode &sm)
+|  98|    |-{
+|  99|    |-	std::string ssm;
+| 100|    |-	is >> ssm;
+| 101|    |-	if (ssm == "name")
+| 102|    |-		sm = SortMode::Name;
+| 103|    |-	else if (ssm == "mtime")
+| 104|    |-		sm = SortMode::ModificationTime;
+| 105|    |-	else if (ssm == "format")
+| 106|    |-		sm = SortMode::CustomFormat;
+| 107|    |-	else if (ssm == "noop")
+| 108|    |-		sm = SortMode::NoOp;
+| 109|    |-	else
+| 110|    |-		is.setstate(std::ios::failbit);
+| 111|    |-	return is;
+| 112|    |-}
+| 113|    |-
+| 114|    |-std::ostream &operator<<(std::ostream &os, DisplayMode dm)
+| 115|    |-{
+| 116|    |-	switch (dm)
+| 117|    |-	{
+| 118|    |-		case DisplayMode::Classic:
+| 119|    |-			os << "classic";
+| 120|    |-			break;
+| 121|    |-		case DisplayMode::Columns:
+| 122|    |-			os << "columns";
+| 123|    |-			break;
+| 124|    |-	}
+| 125|    |-	return os;
+| 126|    |-}
+| 127|    |-
+| 128|    |-std::istream &operator>>(std::istream &is, DisplayMode &dm)
+| 129|    |-{
+| 130|    |-	std::string sdm;
+| 131|    |-	is >> sdm;
+| 132|    |-	if (sdm == "classic")
+| 133|    |-		dm = DisplayMode::Classic;
+| 134|    |-	else if (sdm == "columns")
+| 135|    |-		dm = DisplayMode::Columns;
+| 136|    |-	else
+| 137|    |-		is.setstate(std::ios::failbit);
+| 138|    |-	return is;
+| 139|    |-}
+| 140|    |-
+| 141|    |-std::ostream &operator<<(std::ostream &os, Design ui)
+| 142|    |-{
+| 143|    |-	switch (ui)
+| 144|    |-	{
+| 145|    |-		case Design::Classic:
+| 146|    |-			os << "classic";
+| 147|    |-			break;
+| 148|    |-		case Design::Alternative:
+| 149|    |-			os << "alternative";
+| 150|    |-			break;
+| 151|    |-	}
+| 152|    |-	return os;
+| 153|    |-}
+| 154|    |-
+| 155|    |-std::istream &operator>>(std::istream &is, Design &ui)
+| 156|    |-{
+| 157|    |-	std::string sui;
+| 158|    |-	is >> sui;
+| 159|    |-	if (sui == "classic")
+| 160|    |-		ui = Design::Classic;
+| 161|    |-	else if (sui == "alternative")
+| 162|    |-		ui = Design::Alternative;
+| 163|    |-	else
+| 164|    |-		is.setstate(std::ios::failbit);
+| 165|    |-	return is;
+| 166|    |-}
+| 167|    |-
+| 168|    |-std::ostream &operator<<(std::ostream& os, VisualizerType vt)
+| 169|    |-{
+| 170|    |-	switch (vt)
+| 171|    |-	{
+| 172|    |-		case VisualizerType::Wave:
+| 173|    |-			os << "sound wave";
+| 174|    |-			break;
+| 175|    |-		case VisualizerType::WaveFilled:
+| 176|    |-			os << "sound wave filled";
+| 177|    |-			break;
+|    |  23|+std::ostream & operator<< (std::ostream & os, SearchDirection sd)
+|    |  24|+{
+|    |  25|+    switch (sd)
+|    |  26|+      {
+|    |  27|+      case SearchDirection::Backward:
+|    |  28|+          os << "backward";
+|    |  29|+          break;
+|    |  30|+      case SearchDirection::Forward:
+|    |  31|+          os << "forward";
+|    |  32|+          break;
+|    |  33|+      }
+|    |  34|+    return os;
+|    |  35|+}
+|    |  36|+
+|    |  37|+std::istream & operator>> (std::istream & is, SearchDirection & sd)
+|    |  38|+{
+|    |  39|+    std::string ssd;
+|    |  40|+    is >> ssd;
+|    |  41|+    if (ssd == "backward")
+|    |  42|+        sd = SearchDirection::Backward;
+|    |  43|+    else if (ssd == "forward")
+|    |  44|+        sd = SearchDirection::Forward;
+|    |  45|+    else
+|    |  46|+        is.setstate (std::ios::failbit);
+|    |  47|+    return is;
+|    |  48|+}
+|    |  49|+
+|    |  50|+std::ostream & operator<< (std::ostream & os, SpaceAddMode sam)
+|    |  51|+{
+|    |  52|+    switch (sam)
+|    |  53|+      {
+|    |  54|+      case SpaceAddMode::AddRemove:
+|    |  55|+          os << "add_remove";
+|    |  56|+          break;
+|    |  57|+      case SpaceAddMode::AlwaysAdd:
+|    |  58|+          os << "always_add";
+|    |  59|+          break;
+|    |  60|+      }
+|    |  61|+    return os;
+|    |  62|+}
+|    |  63|+
+|    |  64|+std::istream & operator>> (std::istream & is, SpaceAddMode & sam)
+|    |  65|+{
+|    |  66|+    std::string ssam;
+|    |  67|+    is >> ssam;
+|    |  68|+    if (ssam == "add_remove")
+|    |  69|+        sam = SpaceAddMode::AddRemove;
+|    |  70|+    else if (ssam == "always_add")
+|    |  71|+        sam = SpaceAddMode::AlwaysAdd;
+|    |  72|+    else
+|    |  73|+        is.setstate (std::ios::failbit);
+|    |  74|+    return is;
+|    |  75|+}
+|    |  76|+
+|    |  77|+std::ostream & operator<< (std::ostream & os, SortMode sm)
+|    |  78|+{
+|    |  79|+    switch (sm)
+|    |  80|+      {
+|    |  81|+      case SortMode::Name:
+|    |  82|+          os << "name";
+|    |  83|+          break;
+|    |  84|+      case SortMode::ModificationTime:
+|    |  85|+          os << "mtime";
+|    |  86|+          break;
+|    |  87|+      case SortMode::CustomFormat:
+|    |  88|+          os << "format";
+|    |  89|+          break;
+|    |  90|+      case SortMode::NoOp:
+|    |  91|+          os << "noop";
+|    |  92|+          break;
+|    |  93|+      }
+|    |  94|+    return os;
+|    |  95|+}
+|    |  96|+
+|    |  97|+std::istream & operator>> (std::istream & is, SortMode & sm)
+|    |  98|+{
+|    |  99|+    std::string ssm;
+|    | 100|+    is >> ssm;
+|    | 101|+    if (ssm == "name")
+|    | 102|+        sm = SortMode::Name;
+|    | 103|+    else if (ssm == "mtime")
+|    | 104|+        sm = SortMode::ModificationTime;
+|    | 105|+    else if (ssm == "format")
+|    | 106|+        sm = SortMode::CustomFormat;
+|    | 107|+    else if (ssm == "noop")
+|    | 108|+        sm = SortMode::NoOp;
+|    | 109|+    else
+|    | 110|+        is.setstate (std::ios::failbit);
+|    | 111|+    return is;
+|    | 112|+}
+|    | 113|+
+|    | 114|+std::ostream & operator<< (std::ostream & os, DisplayMode dm)
+|    | 115|+{
+|    | 116|+    switch (dm)
+|    | 117|+      {
+|    | 118|+      case DisplayMode::Classic:
+|    | 119|+          os << "classic";
+|    | 120|+          break;
+|    | 121|+      case DisplayMode::Columns:
+|    | 122|+          os << "columns";
+|    | 123|+          break;
+|    | 124|+      }
+|    | 125|+    return os;
+|    | 126|+}
+|    | 127|+
+|    | 128|+std::istream & operator>> (std::istream & is, DisplayMode & dm)
+|    | 129|+{
+|    | 130|+    std::string sdm;
+|    | 131|+    is >> sdm;
+|    | 132|+    if (sdm == "classic")
+|    | 133|+        dm = DisplayMode::Classic;
+|    | 134|+    else if (sdm == "columns")
+|    | 135|+        dm = DisplayMode::Columns;
+|    | 136|+    else
+|    | 137|+        is.setstate (std::ios::failbit);
+|    | 138|+    return is;
+|    | 139|+}
+|    | 140|+
+|    | 141|+std::ostream & operator<< (std::ostream & os, Design ui)
+|    | 142|+{
+|    | 143|+    switch (ui)
+|    | 144|+      {
+|    | 145|+      case Design::Classic:
+|    | 146|+          os << "classic";
+|    | 147|+          break;
+|    | 148|+      case Design::Alternative:
+|    | 149|+          os << "alternative";
+|    | 150|+          break;
+|    | 151|+      }
+|    | 152|+    return os;
+|    | 153|+}
+|    | 154|+
+|    | 155|+std::istream & operator>> (std::istream & is, Design & ui)
+|    | 156|+{
+|    | 157|+    std::string sui;
+|    | 158|+    is >> sui;
+|    | 159|+    if (sui == "classic")
+|    | 160|+        ui = Design::Classic;
+|    | 161|+    else if (sui == "alternative")
+|    | 162|+        ui = Design::Alternative;
+|    | 163|+    else
+|    | 164|+        is.setstate (std::ios::failbit);
+|    | 165|+    return is;
+|    | 166|+}
+|    | 167|+
+|    | 168|+std::ostream & operator<< (std::ostream & os, VisualizerType vt)
+|    | 169|+{
+|    | 170|+    switch (vt)
+|    | 171|+      {
+|    | 172|+      case VisualizerType::Wave:
+|    | 173|+          os << "sound wave";
+|    | 174|+          break;
+|    | 175|+      case VisualizerType::WaveFilled:
+|    | 176|+          os << "sound wave filled";
+|    | 177|+          break;
+| 178| 178| #		ifdef HAVE_FFTW3_H
+| 179|    |-		case VisualizerType::Spectrum:
+| 180|    |-			os << "frequency spectrum";
+| 181|    |-			break;
+|    | 179|+      case VisualizerType::Spectrum:
+|    | 180|+          os << "frequency spectrum";
+|    | 181|+          break;
+| 182| 182| #		endif // HAVE_FFTW3_H
+| 183|    |-		case VisualizerType::Ellipse:
+| 184|    |-			os << "sound ellipse";
+| 185|    |-			break;
+| 186|    |-	}
+| 187|    |-	return os;
+| 188|    |-}
+| 189|    |-
+| 190|    |-std::istream &operator>>(std::istream& is, VisualizerType &vt)
+| 191|    |-{
+| 192|    |-	std::string svt;
+| 193|    |-	is >> svt;
+| 194|    |-	if (svt == "wave")
+| 195|    |-		vt = VisualizerType::Wave;
+| 196|    |-	else if (svt == "wave_filled")
+| 197|    |-		vt = VisualizerType::WaveFilled;
+|    | 183|+      case VisualizerType::Ellipse:
+|    | 184|+          os << "sound ellipse";
+|    | 185|+          break;
+|    | 186|+      }
+|    | 187|+    return os;
+|    | 188|+}
+|    | 189|+
+|    | 190|+std::istream & operator>> (std::istream & is, VisualizerType & vt)
+|    | 191|+{
+|    | 192|+    std::string svt;
+|    | 193|+    is >> svt;
+|    | 194|+    if (svt == "wave")
+|    | 195|+        vt = VisualizerType::Wave;
+|    | 196|+    else if (svt == "wave_filled")
+|    | 197|+        vt = VisualizerType::WaveFilled;
+| 198| 198| #	ifdef HAVE_FFTW3_H
+| 199|    |-	else if (svt == "spectrum")
+| 200|    |-		vt = VisualizerType::Spectrum;
+|    | 199|+    else if (svt == "spectrum")
+|    | 200|+        vt = VisualizerType::Spectrum;
+| 201| 201| #	endif // HAVE_FFTW3_H
+| 202|    |-	else if (svt == "ellipse")
+| 203|    |-		vt = VisualizerType::Ellipse;
+| 204|    |-	else
+| 205|    |-		is.setstate(std::ios::failbit);
+| 206|    |-	return is;
+| 207|    |-}
+|    | 202|+    else if (svt == "ellipse")
+|    | 203|+        vt = VisualizerType::Ellipse;
+|    | 204|+    else
+|    | 205|+        is.setstate (std::ios::failbit);
+|    | 206|+    return is;
+|    | 207|+}
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/macro_utilities.h
+|    |++++| /app/src/macro_utilities.h
+|  25|  25| #include "actions.h"
+|  26|  26| #include "screens/screen_type.h"
+|  27|  27| 
+|  28|    |-namespace Actions {
+|    |  28|+namespace Actions
+|    |  29|+{
+|  29|  30| 
+|  30|    |-struct PushCharacters: BaseAction
+|  31|    |-{
+|  32|    |-	PushCharacters(NC::Window **w, std::vector<NC::Key::Type> &&queue);
+|    |  31|+    struct PushCharacters:BaseAction
+|    |  32|+    {
+|    |  33|+        PushCharacters (NC::Window ** w,
+|    |  34|+                        std::vector < NC::Key::Type > &&queue);
+|  33|  35| 
+|  34|    |-private:
+|  35|    |-	virtual void run() override;
+|  36|    |-	
+|  37|    |-	NC::Window **m_window;
+|  38|    |-	std::vector<NC::Key::Type> m_queue;
+|  39|    |-};
+|    |  36|+      private:
+|    |  37|+        virtual void run () override;
+|  40|  38| 
+|  41|    |-struct RequireRunnable: BaseAction
+|  42|    |-{
+|  43|    |-	RequireRunnable(std::shared_ptr<BaseAction> action);
+|  44|    |-	
+|  45|    |-private:
+|  46|    |-	virtual bool canBeRun() override;
+|  47|    |-	virtual void run() override { }
+|  48|    |-	
+|  49|    |-	std::shared_ptr<BaseAction> m_action;
+|  50|    |-};
+|    |  39|+          NC::Window ** m_window;
+|    |  40|+          std::vector < NC::Key::Type > m_queue;
+|    |  41|+    };
+|  51|  42| 
+|  52|    |-struct RequireScreen: BaseAction
+|  53|    |-{
+|  54|    |-	RequireScreen(ScreenType screen_type);
+|  55|    |-	
+|  56|    |-private:
+|  57|    |-	virtual bool canBeRun() override;
+|  58|    |-	virtual void run() override { }
+|  59|    |-	
+|  60|    |-	ScreenType m_screen_type;
+|  61|    |-};
+|    |  43|+    struct RequireRunnable:BaseAction
+|    |  44|+    {
+|    |  45|+        RequireRunnable (std::shared_ptr < BaseAction > action);
+|  62|  46| 
+|  63|    |-struct RunExternalCommand: BaseAction
+|  64|    |-{
+|  65|    |-	RunExternalCommand(std::string &&command);
+|  66|    |-	
+|  67|    |-private:
+|  68|    |-	virtual void run() override;
+|  69|    |-	
+|  70|    |-	std::string m_command;
+|  71|    |-};
+|    |  47|+      private:
+|    |  48|+        virtual bool canBeRun () override;
+|    |  49|+        virtual void run () override
+|    |  50|+        {
+|    |  51|+        }
+|    |  52|+
+|    |  53|+        std::shared_ptr < BaseAction > m_action;
+|    |  54|+    };
+|    |  55|+
+|    |  56|+    struct RequireScreen:BaseAction
+|    |  57|+    {
+|    |  58|+        RequireScreen (ScreenType screen_type);
+|    |  59|+
+|    |  60|+      private:
+|    |  61|+        virtual bool canBeRun () override;
+|    |  62|+        virtual void run () override
+|    |  63|+        {
+|    |  64|+        }
+|    |  65|+
+|    |  66|+        ScreenType m_screen_type;
+|    |  67|+    };
+|    |  68|+
+|    |  69|+    struct RunExternalCommand:BaseAction
+|    |  70|+    {
+|    |  71|+        RunExternalCommand (std::string && command);
+|    |  72|+
+|    |  73|+      private:
+|    |  74|+        virtual void run () override;
+|    |  75|+
+|    |  76|+          std::string m_command;
+|    |  77|+    };
+|  72|  78| 
+|  73|  79| }
+|  74|  80| 
+
+src/macro_utilities.h
+| 196| The line belonging to the following result cannot be printed because it refers to a line that doesn't seem to exist in the given file.
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers/song_iterator_maker.h
+|    |++++| /app/src/helpers/song_iterator_maker.h
+|  25|  25| #include "curses/menu.h"
+|  26|  26| #include "song_list.h"
+|  27|  27| 
+|  28|    |-template <typename SongT>
+|  29|    |-struct SongPropertiesExtractor
+|    |  28|+template < typename SongT > struct SongPropertiesExtractor
+|  30|  29| {
+|  31|    |-	template <typename ItemT>
+|  32|    |-	auto &operator()(ItemT &item) const
+|  33|    |-	{
+|  34|    |-		return m_cache.assign(&item.properties(), &item.value());
+|  35|    |-	}
+|    |  30|+    template < typename ItemT > auto & operator () (ItemT & item) const
+|    |  31|+    {
+|    |  32|+        return m_cache.assign (&item.properties (), &item.value ());
+|    |  33|+    }
+|  36|  34| 
+|  37|    |-private:
+|  38|    |-	mutable SongProperties m_cache;
+|    |  35|+  private:
+|    |  36|+      mutable SongProperties m_cache;
+|  39|  37| };
+|  40|  38| 
+|  41|  39| template <typename IteratorT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers/song_iterator_maker.h
+|    |++++| /app/src/helpers/song_iterator_maker.h
+|  38|  38| 	mutable SongProperties m_cache;
+|  39|  39| };
+|  40|  40| 
+|  41|    |-template <typename IteratorT>
+|  42|    |-SongIterator makeSongIterator(IteratorT it)
+|    |  41|+template < typename IteratorT > SongIterator makeSongIterator (IteratorT it)
+|  43|  42| {
+|  44|    |-	typedef SongPropertiesExtractor<
+|  45|    |-		typename IteratorT::value_type::Type
+|  46|    |-		> Extractor;
+|  47|    |-	static_assert(
+|  48|    |-		std::is_convertible<
+|  49|    |-		  typename std::result_of<Extractor(typename IteratorT::reference)>::type,
+|  50|    |-		  SongProperties &
+|  51|    |-		>::value, "invalid result type of SongPropertiesExtractor");
+|  52|    |-	return SongIterator(boost::make_transform_iterator(it, Extractor{}));
+|    |  43|+    typedef SongPropertiesExtractor <
+|    |  44|+        typename IteratorT::value_type::Type > Extractor;
+|    |  45|+    static_assert (std::is_convertible <
+|    |  46|+                   typename std::result_of <
+|    |  47|+                   Extractor (typename IteratorT::reference) >::type,
+|    |  48|+                   SongProperties & >::value,
+|    |  49|+                   "invalid result type of SongPropertiesExtractor");
+|    |  50|+    return SongIterator (boost::make_transform_iterator (it, Extractor
+|    |  51|+                                                         {
+|    |  52|+                                                         }
+|    |  53|+                         ));
+|  53|  54| }
+|  54|  55| 
+|  55|  56| template <typename ConstIteratorT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers/song_iterator_maker.h
+|    |++++| /app/src/helpers/song_iterator_maker.h
+|  52|  52| 	return SongIterator(boost::make_transform_iterator(it, Extractor{}));
+|  53|  53| }
+|  54|  54| 
+|  55|    |-template <typename ConstIteratorT>
+|  56|    |-ConstSongIterator makeConstSongIterator(ConstIteratorT it)
+|    |  55|+template < typename ConstIteratorT >
+|    |  56|+    ConstSongIterator makeConstSongIterator (ConstIteratorT it)
+|  57|  57| {
+|  58|    |-	typedef SongPropertiesExtractor<
+|  59|    |-		typename ConstIteratorT::value_type::Type
+|  60|    |-		> Extractor;
+|  61|    |-	static_assert(
+|  62|    |-		std::is_convertible<
+|  63|    |-		  typename std::result_of<Extractor(typename ConstIteratorT::reference)>::type,
+|  64|    |-		  const SongProperties &
+|  65|    |-		>::value, "invalid result type of SongPropertiesExtractor");
+|  66|    |-	return ConstSongIterator(boost::make_transform_iterator(it, Extractor{}));
+|    |  58|+    typedef SongPropertiesExtractor <
+|    |  59|+        typename ConstIteratorT::value_type::Type > Extractor;
+|    |  60|+    static_assert (std::is_convertible <
+|    |  61|+                   typename std::result_of <
+|    |  62|+                   Extractor (typename ConstIteratorT::reference) >::type,
+|    |  63|+                   const SongProperties & >::value,
+|    |  64|+                   "invalid result type of SongPropertiesExtractor");
+|    |  65|+    return ConstSongIterator (boost::make_transform_iterator (it, Extractor
+|    |  66|+                                                              {
+|    |  67|+                                                              }
+|    |  68|+                              ));
+|  67|  69| }
+|  68|  70| 
+|  69|  71| #endif // NCMPCPP_HELPERS_SONG_ITERATOR_MAKER_H
+
+src/helpers/song_iterator_maker.h
+|  25| #include•"curses/menu.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/menu.h'
+
+src/helpers/song_iterator_maker.h
+|  26| #include•"song_list.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song_list.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/configuration.h
+|    |++++| /app/src/configuration.h
+|  21|  21| #ifndef NCMPCPP_CONFIGURATION_H
+|  22|  22| #define NCMPCPP_CONFIGURATION_H
+|  23|  23| 
+|  24|    |-void expand_home(std::string &path);
+|    |  24|+void expand_home (std::string & path);
+|  25|  25| 
+|  26|    |-bool configure(int argc, char **argv);
+|    |  26|+bool configure (int argc, char **argv);
+|  27|  27| 
+|  28|  28| #endif // NCMPCPP_CONFIGURATION_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format_impl.h
+|    |++++| /app/src/format_impl.h
+|  30|  30| #include "utility/functional.h"
+|  31|  31| #include "utility/wide_string.h"
+|  32|  32| 
+|  33|    |-namespace Format {
+|    |  33|+namespace Format
+|    |  34|+{
+|  34|  35| 
+|  35|  36| // Commutative binary operation such that:
+|  36|  37| // - Empty + Empty = Empty
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format_impl.h
+|    |++++| /app/src/format_impl.h
+|  39|  39| // - Missing + Missing = Missing
+|  40|  40| // - Missing + Ok = Missing
+|  41|  41| // - Ok + Ok = Ok
+|  42|    |-inline Result &operator+=(Result &base, Result result)
+|  43|    |-{
+|  44|    |-	if (base == Result::Missing || result == Result::Missing)
+|  45|    |-		base = Result::Missing;
+|  46|    |-	else if (base == Result::Ok || result == Result::Ok)
+|  47|    |-		base = Result::Ok;
+|  48|    |-	return base;
+|  49|    |-}
+|    |  42|+    inline Result & operator+= (Result & base, Result result)
+|    |  43|+    {
+|    |  44|+        if (base == Result::Missing || result == Result::Missing)
+|    |  45|+            base = Result::Missing;
+|    |  46|+        else if (base == Result::Ok || result == Result::Ok)
+|    |  47|+            base = Result::Ok;
+|    |  48|+        return base;
+|    |  49|+    }
+|  50|  50| 
+|  51|  51| /*inline std::ostream &operator<<(std::ostream &os, Result r)
+|  52|  52| {
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format_impl.h
+|    |++++| /app/src/format_impl.h
+| 260| 260| 		boost::apply_visitor(visitor, ex);
+| 261| 261| }
+| 262| 262| 
+| 263|    |-template <typename CharT, typename ItemT>
+| 264|    |-void print(const AST<CharT> &ast, NC::Menu<ItemT> &menu, const MPD::Song *song,
+| 265|    |-           NC::BasicBuffer<CharT> *buffer, const unsigned flags)
+| 266|    |-{
+| 267|    |-	Printer<CharT, NC::Menu<ItemT>, NC::Buffer> printer(menu, song, buffer, flags);
+| 268|    |-	visit(printer, ast);
+| 269|    |-}
+| 270|    |-
+| 271|    |-template <typename CharT>
+| 272|    |-void print(const AST<CharT> &ast, NC::BasicBuffer<CharT> &buffer,
+| 273|    |-           const MPD::Song *song, const unsigned flags)
+| 274|    |-{
+| 275|    |-	Printer<CharT, NC::BasicBuffer<CharT>> printer(buffer, song, &buffer, flags);
+| 276|    |-	visit(printer, ast);
+| 277|    |-}
+| 278|    |-
+| 279|    |-template <typename CharT>
+| 280|    |-std::basic_string<CharT> stringify(const AST<CharT> &ast, const MPD::Song *song)
+| 281|    |-{
+| 282|    |-	std::basic_string<CharT> result;
+| 283|    |-	Printer<CharT, std::basic_string<CharT>> printer(result, song, &result, Flags::Tag);
+| 284|    |-	visit(printer, ast);
+| 285|    |-	return result;
+| 286|    |-}
+| 287|    |-
+| 288|    |-template <typename CharT>
+| 289|    |-TagVector<CharT> flatten(const AST<CharT> &ast, const MPD::Song &song)
+| 290|    |-{
+| 291|    |-	TagVector<CharT> result;
+| 292|    |-	Printer<CharT, TagVector<CharT>> printer(result, &song, &result, Flags::Tag);
+| 293|    |-	visit(printer, ast);
+| 294|    |-	return result;
+| 295|    |-}
+| 296|    |-
+| 297|    |-}
+| 298|    |-
+| 299| 263| #endif // NCMPCPP_HAVE_FORMAT__IMPL_H
+
+src/format_impl.h
+|  40| //•-•Missing•+•Ok•=•Missing
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/menu_impl.h
+|    |++++| /app/src/curses/menu_impl.h
+|  23|  23| 
+|  24|  24| #include "menu.h"
+|  25|  25| 
+|  26|    |-namespace NC {
+|  27|    |-
+|  28|    |-template <typename ItemT>
+|  29|    |-Menu<ItemT>::Menu()
+|  30|    |-{
+|  31|    |-	m_items = &m_all_items;
+|    |  26|+namespace NC
+|    |  27|+{
+|    |  28|+
+|    |  29|+    template < typename ItemT > Menu < ItemT >::Menu ()
+|    |  30|+    {
+|    |  31|+        m_items = &m_all_items;
+|    |  32|+    }
+|    |  33|+
+|    |  34|+    template < typename ItemT >
+|    |  35|+        Menu < ItemT >::Menu (size_t startx,
+|    |  36|+                              size_t starty,
+|    |  37|+                              size_t width,
+|    |  38|+                              size_t height,
+|    |  39|+                              const std::string & title,
+|    |  40|+                              Color color,
+|    |  41|+                              Border border):Window (startx, starty, width,
+|    |  42|+                                                     height, title, color,
+|    |  43|+                                                     border),
+|    |  44|+        m_item_displayer (nullptr), m_filter_predicate (nullptr),
+|    |  45|+        m_beginning (0), m_highlight (0), m_highlight_enabled (true),
+|    |  46|+        m_cyclic_scroll_enabled (false), m_autocenter_cursor (false)
+|    |  47|+    {
+|    |  48|+        auto fc = FormattedColor (m_base_color, { Format::Reverse });
+|    |  49|+        m_highlight_prefix << fc;
+|    |  50|+        m_highlight_suffix << FormattedColor::End <> (fc);
+|    |  51|+        m_items = &m_all_items;
+|    |  52|+    }
+|    |  53|+
+|    |  54|+    template < typename ItemT >
+|    |  55|+        Menu < ItemT >::Menu (const Menu & rhs):Window (rhs),
+|    |  56|+        m_item_displayer (rhs.m_item_displayer),
+|    |  57|+        m_filter_predicate (rhs.m_filter_predicate),
+|    |  58|+        m_beginning (rhs.m_beginning), m_highlight (rhs.m_highlight),
+|    |  59|+        m_highlight_enabled (rhs.m_highlight_enabled),
+|    |  60|+        m_cyclic_scroll_enabled (rhs.m_cyclic_scroll_enabled),
+|    |  61|+        m_autocenter_cursor (rhs.m_autocenter_cursor),
+|    |  62|+        m_drawn_position (rhs.m_drawn_position),
+|    |  63|+        m_highlight_prefix (rhs.m_highlight_prefix),
+|    |  64|+        m_highlight_suffix (rhs.m_highlight_suffix),
+|    |  65|+        m_selected_prefix (rhs.m_selected_prefix),
+|    |  66|+        m_selected_suffix (rhs.m_selected_suffix)
+|    |  67|+    {
+|    |  68|+        // TODO: move filtered items
+|    |  69|+        m_all_items.reserve (rhs.m_all_items.size ());
+|    |  70|+      for (const auto & item:rhs.m_all_items)
+|    |  71|+            m_all_items.push_back (item.copy ());
+|    |  72|+        m_items = &m_all_items;
+|    |  73|+    }
+|    |  74|+
+|    |  75|+  template < typename ItemT > Menu < ItemT >::Menu (Menu && rhs):Window (rhs), m_item_displayer (std::move (rhs.m_item_displayer)),
+|    |  76|+        m_filter_predicate (std::move (rhs.m_filter_predicate)),
+|    |  77|+        m_all_items (std::move (rhs.m_all_items)),
+|    |  78|+        m_filtered_items (std::move (rhs.m_filtered_items)),
+|    |  79|+        m_beginning (rhs.m_beginning), m_highlight (rhs.m_highlight),
+|    |  80|+        m_highlight_enabled (rhs.m_highlight_enabled),
+|    |  81|+        m_cyclic_scroll_enabled (rhs.m_cyclic_scroll_enabled),
+|    |  82|+        m_autocenter_cursor (rhs.m_autocenter_cursor),
+|    |  83|+        m_drawn_position (rhs.m_drawn_position),
+|    |  84|+        m_highlight_prefix (std::move (rhs.m_highlight_prefix)),
+|    |  85|+        m_highlight_suffix (std::move (rhs.m_highlight_suffix)),
+|    |  86|+        m_selected_prefix (std::move (rhs.m_selected_prefix)),
+|    |  87|+        m_selected_suffix (std::move (rhs.m_selected_suffix))
+|    |  88|+    {
+|    |  89|+        if (rhs.m_items == &rhs.m_all_items)
+|    |  90|+            m_items = &m_all_items;
+|    |  91|+        else
+|    |  92|+            m_items = &m_filtered_items;
+|    |  93|+    }
+|    |  94|+
+|    |  95|+    template < typename ItemT >
+|    |  96|+        Menu < ItemT > &Menu < ItemT >::operator= (Menu rhs)
+|    |  97|+    {
+|    |  98|+        std::swap (static_cast < Window & >(*this),
+|    |  99|+                   static_cast < Window & >(rhs));
+|    | 100|+        std::swap (m_item_displayer, rhs.m_item_displayer);
+|    | 101|+        std::swap (m_filter_predicate, rhs.m_filter_predicate);
+|    | 102|+        std::swap (m_all_items, rhs.m_all_items);
+|    | 103|+        std::swap (m_filtered_items, rhs.m_filtered_items);
+|    | 104|+        std::swap (m_beginning, rhs.m_beginning);
+|    | 105|+        std::swap (m_highlight, rhs.m_highlight);
+|    | 106|+        std::swap (m_highlight_enabled, rhs.m_highlight_enabled);
+|    | 107|+        std::swap (m_cyclic_scroll_enabled, rhs.m_cyclic_scroll_enabled);
+|    | 108|+        std::swap (m_autocenter_cursor, rhs.m_autocenter_cursor);
+|    | 109|+        std::swap (m_drawn_position, rhs.m_drawn_position);
+|    | 110|+        std::swap (m_highlight_prefix, rhs.m_highlight_prefix);
+|    | 111|+        std::swap (m_highlight_suffix, rhs.m_highlight_suffix);
+|    | 112|+        std::swap (m_selected_prefix, rhs.m_selected_prefix);
+|    | 113|+        std::swap (m_selected_suffix, rhs.m_selected_suffix);
+|    | 114|+        if (rhs.m_items == &rhs.m_all_items)
+|    | 115|+            m_items = &m_all_items;
+|    | 116|+        else
+|    | 117|+            m_items = &m_filtered_items;
+|    | 118|+        return *this;
+|    | 119|+    }
+|    | 120|+
+|    | 121|+    template < typename ItemT > template < typename ItemDisplayerT >
+|    | 122|+        void Menu < ItemT >::setItemDisplayer (ItemDisplayerT && displayer)
+|    | 123|+    {
+|    | 124|+        m_item_displayer = std::forward < ItemDisplayerT > (displayer);
+|    | 125|+    }
+|    | 126|+
+|    | 127|+    template < typename ItemT >
+|    | 128|+        void Menu < ItemT >::resizeList (size_t new_size)
+|    | 129|+    {
+|    | 130|+        m_all_items.resize (new_size);
+|    | 131|+    }
+|    | 132|+
+|    | 133|+    template < typename ItemT >
+|    | 134|+        void Menu < ItemT >::addItem (ItemT item, Properties::Type properties)
+|    | 135|+    {
+|    | 136|+        m_all_items.push_back (Item (std::move (item), properties));
+|    | 137|+    }
+|    | 138|+
+|    | 139|+    template < typename ItemT > void Menu < ItemT >::addSeparator ()
+|    | 140|+    {
+|    | 141|+        m_all_items.push_back (Item::mkSeparator ());
+|    | 142|+    }
+|    | 143|+
+|    | 144|+    template < typename ItemT >
+|    | 145|+        void Menu < ItemT >::insertItem (size_t pos, ItemT item,
+|    | 146|+                                         Properties::Type properties)
+|    | 147|+    {
+|    | 148|+        m_all_items.insert (m_all_items.begin () + pos,
+|    | 149|+                            Item (std::move (item), properties));
+|    | 150|+    }
+|    | 151|+
+|    | 152|+    template < typename ItemT >
+|    | 153|+        void Menu < ItemT >::insertSeparator (size_t pos)
+|    | 154|+    {
+|    | 155|+        m_all_items.insert (m_all_items.begin () + pos, Item::mkSeparator ());
+|    | 156|+    }
+|    | 157|+
+|    | 158|+    template < typename ItemT > bool Menu < ItemT >::Goto (size_t y)
+|    | 159|+    {
+|    | 160|+        if (!isHighlightable (m_beginning + y))
+|    | 161|+            return false;
+|    | 162|+        m_highlight = m_beginning + y;
+|    | 163|+        return true;
+|    | 164|+    }
+|    | 165|+
+|    | 166|+    template < typename ItemT > void Menu < ItemT >::refresh ()
+|    | 167|+    {
+|    | 168|+        if (m_items->empty ())
+|    | 169|+          {
+|    | 170|+              Window::clear ();
+|    | 171|+              Window::refresh ();
+|    | 172|+              return;
+|    | 173|+          }
+|    | 174|+
+|    | 175|+        size_t max_beginning = 0;
+|    | 176|+        if (m_items->size () > m_height)
+|    | 177|+            max_beginning = m_items->size () - m_height;
+|    | 178|+        m_beginning = std::min (m_beginning, max_beginning);
+|    | 179|+
+|    | 180|+        // if highlighted position is off the screen, make it visible
+|    | 181|+        m_highlight = std::min (m_highlight, m_beginning + m_height - 1);
+|    | 182|+        // if highlighted position is invalid, correct it
+|    | 183|+        m_highlight = std::min (m_highlight, m_items->size () - 1);
+|    | 184|+
+|    | 185|+        if (!isHighlightable (m_highlight))
+|    | 186|+          {
+|    | 187|+              scroll (Scroll::Up);
+|    | 188|+              if (!isHighlightable (m_highlight))
+|    | 189|+                  scroll (Scroll::Down);
+|    | 190|+          }
+|    | 191|+
+|    | 192|+        size_t line = 0;
+|    | 193|+        const size_t end_ = m_beginning + m_height;
+|    | 194|+        m_drawn_position = m_beginning;
+|    | 195|+        for (; m_drawn_position < end_; ++m_drawn_position, ++line)
+|    | 196|+          {
+|    | 197|+              goToXY (0, line);
+|    | 198|+              if (m_drawn_position >= m_items->size ())
+|    | 199|+                {
+|    | 200|+                    for (; line < m_height; ++line)
+|    | 201|+                        mvwhline (m_window, line, 0, NC::Key::Space, m_width);
+|    | 202|+                    break;
+|    | 203|+                }
+|    | 204|+              if ((*m_items)[m_drawn_position].isSeparator ())
+|    | 205|+                {
+|    | 206|+                    mvwhline (m_window, line, 0, 0, m_width);
+|    | 207|+                    continue;
+|    | 208|+                }
+|    | 209|+              if (m_highlight_enabled && m_drawn_position == m_highlight)
+|    | 210|+                  *this << m_highlight_prefix;
+|    | 211|+              if ((*m_items)[m_drawn_position].isSelected ())
+|    | 212|+                  *this << m_selected_prefix;
+|    | 213|+              *this << NC::TermManip::ClearToEOL;
+|    | 214|+              if (m_item_displayer)
+|    | 215|+                  m_item_displayer (*this);
+|    | 216|+              if ((*m_items)[m_drawn_position].isSelected ())
+|    | 217|+                  *this << m_selected_suffix;
+|    | 218|+              if (m_highlight_enabled && m_drawn_position == m_highlight)
+|    | 219|+                  *this << m_highlight_suffix;
+|    | 220|+          }
+|    | 221|+        Window::refresh ();
+|    | 222|+    }
+|    | 223|+
+|    | 224|+    template < typename ItemT > void Menu < ItemT >::scroll (Scroll where)
+|    | 225|+    {
+|    | 226|+        if (m_items->empty ())
+|    | 227|+            return;
+|    | 228|+        size_t max_highlight = m_items->size () - 1;
+|    | 229|+        size_t max_beginning =
+|    | 230|+            m_items->size () < m_height ? 0 : m_items->size () - m_height;
+|    | 231|+        size_t max_visible_highlight = m_beginning + m_height - 1;
+|    | 232|+        switch (where)
+|    | 233|+          {
+|    | 234|+          case Scroll::Up:
+|    | 235|+              {
+|    | 236|+                  if (m_highlight <= m_beginning && m_highlight > 0)
+|    | 237|+                      --m_beginning;
+|    | 238|+                  if (m_highlight == 0)
+|    | 239|+                    {
+|    | 240|+                        if (m_cyclic_scroll_enabled)
+|    | 241|+                            return scroll (Scroll::End);
+|    | 242|+                        break;
+|    | 243|+                    }
+|    | 244|+                  else
+|    | 245|+                      --m_highlight;
+|    | 246|+                  if (!isHighlightable (m_highlight))
+|    | 247|+                      scroll (m_highlight == 0
+|    | 248|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 249|+                              Down : Scroll::Up);
+|    | 250|+                  break;
+|    | 251|+              }
+|    | 252|+          case Scroll::Down:
+|    | 253|+              {
+|    | 254|+                  if (m_highlight >= max_visible_highlight
+|    | 255|+                      && m_highlight < max_highlight)
+|    | 256|+                      ++m_beginning;
+|    | 257|+                  if (m_highlight == max_highlight)
+|    | 258|+                    {
+|    | 259|+                        if (m_cyclic_scroll_enabled)
+|    | 260|+                            return scroll (Scroll::Home);
+|    | 261|+                        break;
+|    | 262|+                    }
+|    | 263|+                  else
+|    | 264|+                      ++m_highlight;
+|    | 265|+                  if (!isHighlightable (m_highlight))
+|    | 266|+                      scroll (m_highlight == max_highlight
+|    | 267|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 268|+                              Up : Scroll::Down);
+|    | 269|+                  break;
+|    | 270|+              }
+|    | 271|+          case Scroll::PageUp:
+|    | 272|+              {
+|    | 273|+                  if (m_cyclic_scroll_enabled && m_highlight == 0)
+|    | 274|+                      return scroll (Scroll::End);
+|    | 275|+                  if (m_highlight < m_height)
+|    | 276|+                      m_highlight = 0;
+|    | 277|+                  else
+|    | 278|+                      m_highlight -= m_height;
+|    | 279|+                  if (m_beginning < m_height)
+|    | 280|+                      m_beginning = 0;
+|    | 281|+                  else
+|    | 282|+                      m_beginning -= m_height;
+|    | 283|+                  if (!isHighlightable (m_highlight))
+|    | 284|+                      scroll (m_highlight == 0
+|    | 285|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 286|+                              Down : Scroll::Up);
+|    | 287|+                  break;
+|    | 288|+              }
+|    | 289|+          case Scroll::PageDown:
+|    | 290|+              {
+|    | 291|+                  if (m_cyclic_scroll_enabled && m_highlight == max_highlight)
+|    | 292|+                      return scroll (Scroll::Home);
+|    | 293|+                  m_highlight += m_height;
+|    | 294|+                  m_beginning += m_height;
+|    | 295|+                  m_beginning = std::min (m_beginning, max_beginning);
+|    | 296|+                  m_highlight = std::min (m_highlight, max_highlight);
+|    | 297|+                  if (!isHighlightable (m_highlight))
+|    | 298|+                      scroll (m_highlight == max_highlight
+|    | 299|+                              && !m_cyclic_scroll_enabled ? Scroll::
+|    | 300|+                              Up : Scroll::Down);
+|    | 301|+                  break;
+|    | 302|+              }
+|    | 303|+          case Scroll::Home:
+|    | 304|+              {
+|    | 305|+                  m_highlight = 0;
+|    | 306|+                  m_beginning = 0;
+|    | 307|+                  if (!isHighlightable (m_highlight))
+|    | 308|+                      scroll (Scroll::Down);
+|    | 309|+                  break;
+|    | 310|+              }
+|    | 311|+          case Scroll::End:
+|    | 312|+              {
+|    | 313|+                  m_highlight = max_highlight;
+|    | 314|+                  m_beginning = max_beginning;
+|    | 315|+                  if (!isHighlightable (m_highlight))
+|    | 316|+                      scroll (Scroll::Up);
+|    | 317|+                  break;
+|    | 318|+              }
+|    | 319|+          }
+|    | 320|+        if (m_autocenter_cursor)
+|    | 321|+            highlight (m_highlight);
+|    | 322|+    }
+|    | 323|+
+|    | 324|+    template < typename ItemT > void Menu < ItemT >::reset ()
+|    | 325|+    {
+|    | 326|+        m_highlight = 0;
+|    | 327|+        m_beginning = 0;
+|    | 328|+    }
+|    | 329|+
+|    | 330|+    template < typename ItemT > void Menu < ItemT >::clear ()
+|    | 331|+    {
+|    | 332|+        // Don't clear filter related stuff here.
+|    | 333|+        m_all_items.clear ();
+|    | 334|+        m_filtered_items.clear ();
+|    | 335|+    }
+|    | 336|+
+|    | 337|+    template < typename ItemT > void Menu < ItemT >::highlight (size_t pos)
+|    | 338|+    {
+|    | 339|+        assert (pos < m_items->size ());
+|    | 340|+        m_highlight = pos;
+|    | 341|+        size_t half_height = m_height / 2;
+|    | 342|+        if (pos < half_height)
+|    | 343|+            m_beginning = 0;
+|    | 344|+        else
+|    | 345|+            m_beginning = pos - half_height;
+|    | 346|+    }
+|    | 347|+
+|    | 348|+    template < typename ItemT > size_t Menu < ItemT >::choice ()const
+|    | 349|+    {
+|    | 350|+        assert (!empty ());
+|    | 351|+        return m_highlight;
+|    | 352|+    }
+|    | 353|+
+|    | 354|+    template < typename ItemT > template < typename PredicateT >
+|    | 355|+        void Menu < ItemT >::applyFilter (PredicateT && pred)
+|    | 356|+    {
+|    | 357|+        m_filter_predicate = std::forward < PredicateT > (pred);
+|    | 358|+        m_filtered_items.clear ();
+|    | 359|+
+|    | 360|+      for (const auto & item:m_all_items)
+|    | 361|+            if (m_filter_predicate (item))
+|    | 362|+                m_filtered_items.push_back (item);
+|    | 363|+
+|    | 364|+        m_items = &m_filtered_items;
+|    | 365|+    }
+|    | 366|+
+|    | 367|+    template < typename ItemT > void Menu < ItemT >::reapplyFilter ()
+|    | 368|+    {
+|    | 369|+        applyFilter (m_filter_predicate);
+|    | 370|+    }
+|    | 371|+
+|    | 372|+    template < typename ItemT > template < typename TargetT >
+|    | 373|+        const TargetT *Menu < ItemT >::filterPredicate () const
+|    | 374|+    {
+|    | 375|+        return m_filter_predicate.template target < TargetT > ();
+|    | 376|+    }
+|    | 377|+
+|    | 378|+    template < typename ItemT > void Menu < ItemT >::clearFilter ()
+|    | 379|+    {
+|    | 380|+        m_filter_predicate = nullptr;
+|    | 381|+        m_filtered_items.clear ();
+|    | 382|+        m_items = &m_all_items;
+|    | 383|+    }
+|    | 384|+
+|  32| 385| }
+|  33| 386| 
+|  34| 387| template <typename ItemT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/menu_impl.h
+|    |++++| /app/src/curses/menu_impl.h
+|  31|  31| 	m_items = &m_all_items;
+|  32|  32| }
+|  33|  33| 
+|  34|    |-template <typename ItemT>
+|  35|    |-Menu<ItemT>::Menu(size_t startx,
+|  36|    |-                  size_t starty,
+|  37|    |-                  size_t width,
+|  38|    |-                  size_t height,
+|  39|    |-                  const std::string &title,
+|  40|    |-                  Color color,
+|  41|    |-                  Border border)
+|  42|    |-	: Window(startx, starty, width, height, title, color, border)
+|  43|    |-	, m_item_displayer(nullptr)
+|  44|    |-	, m_filter_predicate(nullptr)
+|  45|    |-	, m_beginning(0)
+|  46|    |-	, m_highlight(0)
+|  47|    |-	, m_highlight_enabled(true)
+|  48|    |-	, m_cyclic_scroll_enabled(false)
+|  49|    |-	, m_autocenter_cursor(false)
+|  50|    |-{
+|  51|    |-	auto fc = FormattedColor(m_base_color, {Format::Reverse});
+|  52|    |-	m_highlight_prefix << fc;
+|  53|    |-	m_highlight_suffix << FormattedColor::End<>(fc);
+|  54|    |-	m_items = &m_all_items;
+|  55|    |-}
+|  56|    |-
+|  57|    |-template <typename ItemT>
+|  58|    |-Menu<ItemT>::Menu(const Menu &rhs)
+|  59|    |-	: Window(rhs)
+|  60|    |-	, m_item_displayer(rhs.m_item_displayer)
+|  61|    |-	, m_filter_predicate(rhs.m_filter_predicate)
+|  62|    |-	, m_beginning(rhs.m_beginning)
+|  63|    |-	, m_highlight(rhs.m_highlight)
+|  64|    |-	, m_highlight_enabled(rhs.m_highlight_enabled)
+|  65|    |-	, m_cyclic_scroll_enabled(rhs.m_cyclic_scroll_enabled)
+|  66|    |-	, m_autocenter_cursor(rhs.m_autocenter_cursor)
+|  67|    |-	, m_drawn_position(rhs.m_drawn_position)
+|  68|    |-	, m_highlight_prefix(rhs.m_highlight_prefix)
+|  69|    |-	, m_highlight_suffix(rhs.m_highlight_suffix)
+|  70|    |-	, m_selected_prefix(rhs.m_selected_prefix)
+|  71|    |-	, m_selected_suffix(rhs.m_selected_suffix)
+|  72|    |-{
+|  73|    |-	// TODO: move filtered items
+|  74|    |-	m_all_items.reserve(rhs.m_all_items.size());
+|  75|    |-	for (const auto &item : rhs.m_all_items)
+|  76|    |-		m_all_items.push_back(item.copy());
+|  77|    |-	m_items = &m_all_items;
+|  78|    |-}
+|  79|    |-
+|  80|    |-template <typename ItemT>
+|  81|    |-Menu<ItemT>::Menu(Menu &&rhs)
+|  82|    |-	: Window(rhs)
+|  83|    |-	, m_item_displayer(std::move(rhs.m_item_displayer))
+|  84|    |-	, m_filter_predicate(std::move(rhs.m_filter_predicate))
+|  85|    |-	, m_all_items(std::move(rhs.m_all_items))
+|  86|    |-	, m_filtered_items(std::move(rhs.m_filtered_items))
+|  87|    |-	, m_beginning(rhs.m_beginning)
+|  88|    |-	, m_highlight(rhs.m_highlight)
+|  89|    |-	, m_highlight_enabled(rhs.m_highlight_enabled)
+|  90|    |-	, m_cyclic_scroll_enabled(rhs.m_cyclic_scroll_enabled)
+|  91|    |-	, m_autocenter_cursor(rhs.m_autocenter_cursor)
+|  92|    |-	, m_drawn_position(rhs.m_drawn_position)
+|  93|    |-	, m_highlight_prefix(std::move(rhs.m_highlight_prefix))
+|  94|    |-	, m_highlight_suffix(std::move(rhs.m_highlight_suffix))
+|  95|    |-	, m_selected_prefix(std::move(rhs.m_selected_prefix))
+|  96|    |-	, m_selected_suffix(std::move(rhs.m_selected_suffix))
+|  97|    |-{
+|  98|    |-	if (rhs.m_items == &rhs.m_all_items)
+|  99|    |-		m_items = &m_all_items;
+| 100|    |-	else
+| 101|    |-		m_items = &m_filtered_items;
+| 102|    |-}
+| 103|    |-
+| 104|    |-template <typename ItemT>
+| 105|    |-Menu<ItemT> &Menu<ItemT>::operator=(Menu rhs)
+| 106|    |-{
+| 107|    |-	std::swap(static_cast<Window &>(*this), static_cast<Window &>(rhs));
+| 108|    |-	std::swap(m_item_displayer, rhs.m_item_displayer);
+| 109|    |-	std::swap(m_filter_predicate, rhs.m_filter_predicate);
+| 110|    |-	std::swap(m_all_items, rhs.m_all_items);
+| 111|    |-	std::swap(m_filtered_items, rhs.m_filtered_items);
+| 112|    |-	std::swap(m_beginning, rhs.m_beginning);
+| 113|    |-	std::swap(m_highlight, rhs.m_highlight);
+| 114|    |-	std::swap(m_highlight_enabled, rhs.m_highlight_enabled);
+| 115|    |-	std::swap(m_cyclic_scroll_enabled, rhs.m_cyclic_scroll_enabled);
+| 116|    |-	std::swap(m_autocenter_cursor, rhs.m_autocenter_cursor);
+| 117|    |-	std::swap(m_drawn_position, rhs.m_drawn_position);
+| 118|    |-	std::swap(m_highlight_prefix, rhs.m_highlight_prefix);
+| 119|    |-	std::swap(m_highlight_suffix, rhs.m_highlight_suffix);
+| 120|    |-	std::swap(m_selected_prefix, rhs.m_selected_prefix);
+| 121|    |-	std::swap(m_selected_suffix, rhs.m_selected_suffix);
+| 122|    |-	if (rhs.m_items == &rhs.m_all_items)
+| 123|    |-		m_items = &m_all_items;
+| 124|    |-	else
+| 125|    |-		m_items = &m_filtered_items;
+| 126|    |-	return *this;
+| 127|    |-}
+| 128|    |-
+| 129|    |-template <typename ItemT> template <typename ItemDisplayerT>
+| 130|    |-void Menu<ItemT>::setItemDisplayer(ItemDisplayerT &&displayer)
+| 131|    |-{
+| 132|    |-	m_item_displayer = std::forward<ItemDisplayerT>(displayer);
+| 133|    |-}
+| 134|    |-
+| 135|    |-template <typename ItemT>
+| 136|    |-void Menu<ItemT>::resizeList(size_t new_size)
+| 137|    |-{
+| 138|    |-	m_all_items.resize(new_size);
+| 139|    |-}
+| 140|    |-
+| 141|    |-template <typename ItemT>
+| 142|    |-void Menu<ItemT>::addItem(ItemT item, Properties::Type properties)
+| 143|    |-{
+| 144|    |-	m_all_items.push_back(Item(std::move(item), properties));
+| 145|    |-}
+| 146|    |-
+| 147|    |-template <typename ItemT>
+| 148|    |-void Menu<ItemT>::addSeparator()
+| 149|    |-{
+| 150|    |-	m_all_items.push_back(Item::mkSeparator());
+| 151|    |-}
+| 152|    |-
+| 153|    |-template <typename ItemT>
+| 154|    |-void Menu<ItemT>::insertItem(size_t pos, ItemT item, Properties::Type properties)
+| 155|    |-{
+| 156|    |-	m_all_items.insert(m_all_items.begin()+pos, Item(std::move(item), properties));
+| 157|    |-}
+| 158|    |-
+| 159|    |-template <typename ItemT>
+| 160|    |-void Menu<ItemT>::insertSeparator(size_t pos)
+| 161|    |-{
+| 162|    |-	m_all_items.insert(m_all_items.begin()+pos, Item::mkSeparator());
+| 163|    |-}
+| 164|    |-
+| 165|    |-template <typename ItemT>
+| 166|    |-bool Menu<ItemT>::Goto(size_t y)
+| 167|    |-{
+| 168|    |-	if (!isHighlightable(m_beginning+y))
+| 169|    |-		return false;
+| 170|    |-	m_highlight = m_beginning+y;
+| 171|    |-	return true;
+| 172|    |-}
+| 173|    |-
+| 174|    |-template <typename ItemT>
+| 175|    |-void Menu<ItemT>::refresh()
+| 176|    |-{
+| 177|    |-	if (m_items->empty())
+| 178|    |-	{
+| 179|    |-		Window::clear();
+| 180|    |-		Window::refresh();
+| 181|    |-		return;
+| 182|    |-	}
+| 183|    |-
+| 184|    |-	size_t max_beginning = 0;
+| 185|    |-	if (m_items->size() > m_height)
+| 186|    |-		max_beginning = m_items->size() - m_height;
+| 187|    |-	m_beginning = std::min(m_beginning, max_beginning);
+| 188|    |-
+| 189|    |-	// if highlighted position is off the screen, make it visible
+| 190|    |-	m_highlight = std::min(m_highlight, m_beginning+m_height-1);
+| 191|    |-	// if highlighted position is invalid, correct it
+| 192|    |-	m_highlight = std::min(m_highlight, m_items->size()-1);
+| 193|    |-
+| 194|    |-	if (!isHighlightable(m_highlight))
+| 195|    |-	{
+| 196|    |-		scroll(Scroll::Up);
+| 197|    |-		if (!isHighlightable(m_highlight))
+| 198|    |-			scroll(Scroll::Down);
+| 199|    |-	}
+| 200|    |-
+| 201|    |-	size_t line = 0;
+| 202|    |-	const size_t end_ = m_beginning+m_height;
+| 203|    |-	m_drawn_position = m_beginning;
+| 204|    |-	for (; m_drawn_position < end_; ++m_drawn_position, ++line)
+| 205|    |-	{
+| 206|    |-		goToXY(0, line);
+| 207|    |-		if (m_drawn_position >= m_items->size())
+| 208|    |-		{
+| 209|    |-			for (; line < m_height; ++line)
+| 210|    |-				mvwhline(m_window, line, 0, NC::Key::Space, m_width);
+| 211|    |-			break;
+| 212|    |-		}
+| 213|    |-		if ((*m_items)[m_drawn_position].isSeparator())
+| 214|    |-		{
+| 215|    |-			mvwhline(m_window, line, 0, 0, m_width);
+| 216|    |-			continue;
+| 217|    |-		}
+| 218|    |-		if (m_highlight_enabled && m_drawn_position == m_highlight)
+| 219|    |-			*this << m_highlight_prefix;
+| 220|    |-		if ((*m_items)[m_drawn_position].isSelected())
+| 221|    |-			*this << m_selected_prefix;
+| 222|    |-		*this << NC::TermManip::ClearToEOL;
+| 223|    |-		if (m_item_displayer)
+| 224|    |-			m_item_displayer(*this);
+| 225|    |-		if ((*m_items)[m_drawn_position].isSelected())
+| 226|    |-			*this << m_selected_suffix;
+| 227|    |-		if (m_highlight_enabled && m_drawn_position == m_highlight)
+| 228|    |-			*this << m_highlight_suffix;
+| 229|    |-	}
+| 230|    |-	Window::refresh();
+| 231|    |-}
+| 232|    |-
+| 233|    |-template <typename ItemT>
+| 234|    |-void Menu<ItemT>::scroll(Scroll where)
+| 235|    |-{
+| 236|    |-	if (m_items->empty())
+| 237|    |-		return;
+| 238|    |-	size_t max_highlight = m_items->size()-1;
+| 239|    |-	size_t max_beginning = m_items->size() < m_height ? 0 : m_items->size()-m_height;
+| 240|    |-	size_t max_visible_highlight = m_beginning+m_height-1;
+| 241|    |-	switch (where)
+| 242|    |-	{
+| 243|    |-		case Scroll::Up:
+| 244|    |-		{
+| 245|    |-			if (m_highlight <= m_beginning && m_highlight > 0)
+| 246|    |-				--m_beginning;
+| 247|    |-			if (m_highlight == 0)
+| 248|    |-			{
+| 249|    |-				if (m_cyclic_scroll_enabled)
+| 250|    |-					return scroll(Scroll::End);
+| 251|    |-				break;
+| 252|    |-			}
+| 253|    |-			else
+| 254|    |-				--m_highlight;
+| 255|    |-			if (!isHighlightable(m_highlight))
+| 256|    |-				scroll(m_highlight == 0 && !m_cyclic_scroll_enabled ? Scroll::Down : Scroll::Up);
+| 257|    |-			break;
+| 258|    |-		}
+| 259|    |-		case Scroll::Down:
+| 260|    |-		{
+| 261|    |-			if (m_highlight >= max_visible_highlight && m_highlight < max_highlight)
+| 262|    |-				++m_beginning;
+| 263|    |-			if (m_highlight == max_highlight)
+| 264|    |-			{
+| 265|    |-				if (m_cyclic_scroll_enabled)
+| 266|    |-					return scroll(Scroll::Home);
+| 267|    |-				break;
+| 268|    |-			}
+| 269|    |-			else
+| 270|    |-				++m_highlight;
+| 271|    |-			if (!isHighlightable(m_highlight))
+| 272|    |-				scroll(m_highlight == max_highlight && !m_cyclic_scroll_enabled ? Scroll::Up : Scroll::Down);
+| 273|    |-			break;
+| 274|    |-		}
+| 275|    |-		case Scroll::PageUp:
+| 276|    |-		{
+| 277|    |-			if (m_cyclic_scroll_enabled && m_highlight == 0)
+| 278|    |-				return scroll(Scroll::End);
+| 279|    |-			if (m_highlight < m_height)
+| 280|    |-				m_highlight = 0;
+| 281|    |-			else
+| 282|    |-				m_highlight -= m_height;
+| 283|    |-			if (m_beginning < m_height)
+| 284|    |-				m_beginning = 0;
+| 285|    |-			else
+| 286|    |-				m_beginning -= m_height;
+| 287|    |-			if (!isHighlightable(m_highlight))
+| 288|    |-				scroll(m_highlight == 0 && !m_cyclic_scroll_enabled ? Scroll::Down : Scroll::Up);
+| 289|    |-			break;
+| 290|    |-		}
+| 291|    |-		case Scroll::PageDown:
+| 292|    |-		{
+| 293|    |-			if (m_cyclic_scroll_enabled && m_highlight == max_highlight)
+| 294|    |-				return scroll(Scroll::Home);
+| 295|    |-			m_highlight += m_height;
+| 296|    |-			m_beginning += m_height;
+| 297|    |-			m_beginning = std::min(m_beginning, max_beginning);
+| 298|    |-			m_highlight = std::min(m_highlight, max_highlight);
+| 299|    |-			if (!isHighlightable(m_highlight))
+| 300|    |-				scroll(m_highlight == max_highlight && !m_cyclic_scroll_enabled ? Scroll::Up : Scroll::Down);
+| 301|    |-			break;
+| 302|    |-		}
+| 303|    |-		case Scroll::Home:
+| 304|    |-		{
+| 305|    |-			m_highlight = 0;
+| 306|    |-			m_beginning = 0;
+| 307|    |-			if (!isHighlightable(m_highlight))
+| 308|    |-				scroll(Scroll::Down);
+| 309|    |-			break;
+| 310|    |-		}
+| 311|    |-		case Scroll::End:
+| 312|    |-		{
+| 313|    |-			m_highlight = max_highlight;
+| 314|    |-			m_beginning = max_beginning;
+| 315|    |-			if (!isHighlightable(m_highlight))
+| 316|    |-				scroll(Scroll::Up);
+| 317|    |-			break;
+| 318|    |-		}
+| 319|    |-	}
+| 320|    |-	if (m_autocenter_cursor)
+| 321|    |-		highlight(m_highlight);
+| 322|    |-}
+| 323|    |-
+| 324|    |-template <typename ItemT>
+| 325|    |-void Menu<ItemT>::reset()
+| 326|    |-{
+| 327|    |-	m_highlight = 0;
+| 328|    |-	m_beginning = 0;
+| 329|    |-}
+| 330|    |-
+| 331|    |-template <typename ItemT>
+| 332|    |-void Menu<ItemT>::clear()
+| 333|    |-{
+| 334|    |-	// Don't clear filter related stuff here.
+| 335|    |-	m_all_items.clear();
+| 336|    |-	m_filtered_items.clear();
+| 337|    |-}
+| 338|    |-
+| 339|    |-template <typename ItemT>
+| 340|    |-void Menu<ItemT>::highlight(size_t pos)
+| 341|    |-{
+| 342|    |-	assert(pos < m_items->size());
+| 343|    |-	m_highlight = pos;
+| 344|    |-	size_t half_height = m_height/2;
+| 345|    |-	if (pos < half_height)
+| 346|    |-		m_beginning = 0;
+| 347|    |-	else
+| 348|    |-		m_beginning = pos-half_height;
+| 349|    |-}
+| 350|    |-
+| 351|    |-template <typename ItemT>
+| 352|    |-size_t Menu<ItemT>::choice() const
+| 353|    |-{
+| 354|    |-	assert(!empty());
+| 355|    |-	return m_highlight;
+| 356|    |-}
+| 357|    |-
+| 358|    |-template <typename ItemT> template <typename PredicateT>
+| 359|    |-void Menu<ItemT>::applyFilter(PredicateT &&pred)
+| 360|    |-{
+| 361|    |-	m_filter_predicate = std::forward<PredicateT>(pred);
+| 362|    |-	m_filtered_items.clear();
+| 363|    |-
+| 364|    |-	for (const auto &item : m_all_items)
+| 365|    |-		if (m_filter_predicate(item))
+| 366|    |-			m_filtered_items.push_back(item);
+| 367|    |-
+| 368|    |-	m_items = &m_filtered_items;
+| 369|    |-}
+| 370|    |-
+| 371|    |-template <typename ItemT>
+| 372|    |-void Menu<ItemT>::reapplyFilter()
+| 373|    |-{
+| 374|    |-	applyFilter(m_filter_predicate);
+| 375|    |-}
+| 376|    |-
+| 377|    |-template <typename ItemT> template <typename TargetT>
+| 378|    |-const TargetT *Menu<ItemT>::filterPredicate() const
+| 379|    |-{
+| 380|    |-	return m_filter_predicate.template target<TargetT>();
+| 381|    |-}
+| 382|    |-
+| 383|    |-template <typename ItemT>
+| 384|    |-void Menu<ItemT>::clearFilter()
+| 385|    |-{
+| 386|    |-	m_filter_predicate = nullptr;
+| 387|    |-	m_filtered_items.clear();
+| 388|    |-	m_items = &m_all_items;
+| 389|    |-}
+| 390|    |-
+| 391|    |-}
+| 392|    |-
+| 393|  34| #endif // NCMPCPP_MENU_IMPL_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/settings.cpp
+|    |++++| /app/src/settings.cpp
+|  37|  37| 
+|  38|  38| namespace ph = std::placeholders;
+|  39|  39| 
+|  40|    |-Configuration Config;
+|  41|    |-
+|  42|    |-namespace {
+|  43|    |-
+|  44|    |-std::vector<Column> generate_columns(const std::string &format)
+|  45|    |-{
+|  46|    |-	std::vector<Column> result;
+|  47|    |-	std::string width;
+|  48|    |-	size_t pos = 0;
+|  49|    |-	while (!(width = getEnclosedString(format, '(', ')', &pos)).empty())
+|  50|    |-	{
+|  51|    |-		Column col;
+|  52|    |-		auto scolor = getEnclosedString(format, '[', ']', &pos);
+|  53|    |-		if (scolor.empty())
+|  54|    |-			col.color = NC::Color::Default;
+|  55|    |-		else
+|  56|    |-			col.color = boost::lexical_cast<NC::Color>(scolor);
+|  57|    |-
+|  58|    |-		if (*width.rbegin() == 'f')
+|  59|    |-		{
+|  60|    |-			col.fixed = true;
+|  61|    |-			width.resize(width.size()-1);
+|  62|    |-		}
+|  63|    |-		else
+|  64|    |-			col.fixed = false;
+|  65|    |-
+|  66|    |-		auto tag_type = getEnclosedString(format, '{', '}', &pos);
+|  67|    |-		// alternative name
+|  68|    |-		size_t tag_type_colon_pos = tag_type.find(':');
+|  69|    |-		if (tag_type_colon_pos != std::string::npos)
+|  70|    |-		{
+|  71|    |-			col.name = ToWString(tag_type.substr(tag_type_colon_pos+1));
+|  72|    |-			tag_type.resize(tag_type_colon_pos);
+|  73|    |-		}
+|  74|    |-
+|  75|    |-		if (!tag_type.empty())
+|  76|    |-		{
+|  77|    |-			size_t i = -1;
+|  78|    |-
+|  79|    |-			// extract tag types in format a|b|c etc.
+|  80|    |-			do
+|  81|    |-				col.type += tag_type[(++i)++]; // nice one.
+|  82|    |-			while (tag_type[i] == '|');
+|  83|    |-
+|  84|    |-			// apply attributes
+|  85|    |-			for (; i < tag_type.length(); ++i)
+|  86|    |-			{
+|  87|    |-				switch (tag_type[i])
+|  88|    |-				{
+|  89|    |-					case 'r':
+|  90|    |-						col.right_alignment = 1;
+|  91|    |-						break;
+|  92|    |-					case 'E':
+|  93|    |-						col.display_empty_tag = 0;
+|  94|    |-						break;
+|  95|    |-				}
+|  96|    |-			}
+|  97|    |-		}
+|  98|    |-		else // empty column
+|  99|    |-			col.display_empty_tag = 0;
+| 100|    |-
+| 101|    |-		col.width = boost::lexical_cast<int>(width);
+| 102|    |-		result.push_back(col);
+| 103|    |-	}
+| 104|    |-
+| 105|    |-	// calculate which column is the last one to have relative width and stretch it accordingly
+| 106|    |-	if (!result.empty())
+| 107|    |-	{
+| 108|    |-		int stretch_limit = 0;
+| 109|    |-		auto it = result.rbegin();
+| 110|    |-		for (; it != result.rend(); ++it)
+| 111|    |-		{
+| 112|    |-			if (it->fixed)
+| 113|    |-				stretch_limit += it->width;
+| 114|    |-			else
+| 115|    |-				break;
+| 116|    |-		}
+| 117|    |-		// if it's false, all columns are fixed
+| 118|    |-		if (it != result.rend())
+| 119|    |-			it->stretch_limit = stretch_limit;
+| 120|    |-	}
+| 121|    |-
+| 122|    |-	return result;
+|    |  40|+Configuration
+|    |  41|+    Config;
+|    |  42|+
+|    |  43|+namespace
+|    |  44|+{
+|    |  45|+
+|    |  46|+    std::vector < Column > generate_columns (const std::string & format)
+|    |  47|+    {
+|    |  48|+        std::vector < Column > result;
+|    |  49|+        std::string width;
+|    |  50|+        size_t
+|    |  51|+            pos = 0;
+|    |  52|+        while (!(width = getEnclosedString (format, '(', ')', &pos)).empty ())
+|    |  53|+          {
+|    |  54|+              Column
+|    |  55|+                  col;
+|    |  56|+              auto
+|    |  57|+                  scolor = getEnclosedString (format, '[', ']', &pos);
+|    |  58|+              if (scolor.empty ())
+|    |  59|+                  col.color = NC::Color::Default;
+|    |  60|+              else
+|    |  61|+                  col.color = boost::lexical_cast < NC::Color > (scolor);
+|    |  62|+
+|    |  63|+              if (*width.rbegin () == 'f')
+|    |  64|+                {
+|    |  65|+                    col.fixed = true;
+|    |  66|+                    width.resize (width.size () - 1);
+|    |  67|+                }
+|    |  68|+              else
+|    |  69|+                  col.fixed = false;
+|    |  70|+
+|    |  71|+              auto
+|    |  72|+                  tag_type = getEnclosedString (format, '{', '}', &pos);
+|    |  73|+              // alternative name
+|    |  74|+              size_t
+|    |  75|+                  tag_type_colon_pos = tag_type.find (':');
+|    |  76|+              if (tag_type_colon_pos != std::string::npos)
+|    |  77|+                {
+|    |  78|+                    col.name =
+|    |  79|+                        ToWString (tag_type.substr (tag_type_colon_pos + 1));
+|    |  80|+                    tag_type.resize (tag_type_colon_pos);
+|    |  81|+                }
+|    |  82|+
+|    |  83|+              if (!tag_type.empty ())
+|    |  84|+                {
+|    |  85|+                    size_t
+|    |  86|+                        i = -1;
+|    |  87|+
+|    |  88|+                    // extract tag types in format a|b|c etc.
+|    |  89|+                    do
+|    |  90|+                        col.type += tag_type[(++i)++];  // nice one.
+|    |  91|+                    while (tag_type[i] == '|');
+|    |  92|+
+|    |  93|+                    // apply attributes
+|    |  94|+                    for (; i < tag_type.length (); ++i)
+|    |  95|+                      {
+|    |  96|+                          switch (tag_type[i])
+|    |  97|+                            {
+|    |  98|+                            case 'r':
+|    |  99|+                                col.right_alignment = 1;
+|    | 100|+                                break;
+|    | 101|+                            case 'E':
+|    | 102|+                                col.display_empty_tag = 0;
+|    | 103|+                                break;
+|    | 104|+                            }
+|    | 105|+                      }
+|    | 106|+                }
+|    | 107|+              else              // empty column
+|    | 108|+                  col.display_empty_tag = 0;
+|    | 109|+
+|    | 110|+              col.width = boost::lexical_cast < int >(width);
+|    | 111|+              result.push_back (col);
+|    | 112|+          }
+|    | 113|+
+|    | 114|+        // calculate which column is the last one to have relative width and stretch it accordingly
+|    | 115|+        if (!result.empty ())
+|    | 116|+          {
+|    | 117|+              int
+|    | 118|+                  stretch_limit = 0;
+|    | 119|+              auto
+|    | 120|+                  it = result.rbegin ();
+|    | 121|+              for (; it != result.rend (); ++it)
+|    | 122|+                {
+|    | 123|+                    if (it->fixed)
+|    | 124|+                        stretch_limit += it->width;
+|    | 125|+                    else
+|    | 126|+                        break;
+|    | 127|+                }
+|    | 128|+              // if it's false, all columns are fixed
+|    | 129|+              if (it != result.rend ())
+|    | 130|+                  it->stretch_limit = stretch_limit;
+|    | 131|+          }
+|    | 132|+
+|    | 133|+        return result;
+|    | 134|+    }
+|    | 135|+
+|    | 136|+    Format::AST < char >
+|    | 137|+    columns_to_format (const std::vector < Column > &columns)
+|    | 138|+    {
+|    | 139|+        std::vector < Format::Expression < char >>
+|    | 140|+            result;
+|    | 141|+
+|    | 142|+        auto
+|    | 143|+            column = columns.begin ();
+|    | 144|+        while (true)
+|    | 145|+          {
+|    | 146|+              Format::FirstOf < char >
+|    | 147|+                  first_of;
+|    | 148|+            for (const auto & type:column->type)
+|    | 149|+                {
+|    | 150|+                    auto
+|    | 151|+                        f = charToGetFunction (type);
+|    | 152|+                    assert (f != nullptr);
+|    | 153|+                    first_of.base ().push_back (f);
+|    | 154|+                }
+|    | 155|+              result.push_back (std::move (first_of));
+|    | 156|+
+|    | 157|+              if (++column != columns.end ())
+|    | 158|+                  result.push_back (" ");
+|    | 159|+              else
+|    | 160|+                  break;
+|    | 161|+          }
+|    | 162|+
+|    | 163|+        return Format::AST < char >(std::move (result));
+|    | 164|+    }
+|    | 165|+
+|    | 166|+    void
+|    | 167|+    add_slash_at_the_end (std::string & s)
+|    | 168|+    {
+|    | 169|+        if (s.empty () || *s.rbegin () != '/')
+|    | 170|+          {
+|    | 171|+              s.resize (s.size () + 1);
+|    | 172|+              *s.rbegin () = '/';
+|    | 173|+          }
+|    | 174|+    }
+|    | 175|+
+|    | 176|+    std::string adjust_directory (std::string s)
+|    | 177|+    {
+|    | 178|+        add_slash_at_the_end (s);
+|    | 179|+        expand_home (s);
+|    | 180|+        return s;
+|    | 181|+    }
+|    | 182|+
+|    | 183|+    std::string adjust_path (std::string s)
+|    | 184|+    {
+|    | 185|+        expand_home (s);
+|    | 186|+        return s;
+|    | 187|+    }
+|    | 188|+
+|    | 189|+    NC::Buffer buffer (const std::string & v)
+|    | 190|+    {
+|    | 191|+        NC::Buffer result;
+|    | 192|+        Format::print (Format::
+|    | 193|+                       parse (v, Format::Flags::Color | Format::Flags::Format),
+|    | 194|+                       result, nullptr);
+|    | 195|+        return result;
+|    | 196|+    }
+|    | 197|+
+|    | 198|+    NC::Buffer buffer_wlength (const NC::Buffer * target,
+|    | 199|+                               size_t & wlength, const std::string & v)
+|    | 200|+    {
+|    | 201|+        // Compatibility layer between highlight color and new highlight prefix and
+|    | 202|+        // suffix. Basically, for older configurations if highlight color is provided,
+|    | 203|+        // we don't want to override it with default prefix and suffix.
+|    | 204|+        if (target == nullptr || target->empty ())
+|    | 205|+          {
+|    | 206|+              NC::Buffer result = buffer (v);
+|    | 207|+              wlength = wideLength (ToWString (result.str ()));
+|    | 208|+              return result;
+|    | 209|+          }
+|    | 210|+        else
+|    | 211|+            return *target;
+|    | 212|+    }
+|    | 213|+
+|    | 214|+    void
+|    | 215|+    deprecated (const char *option, double version_removal,
+|    | 216|+                const std::string & advice)
+|    | 217|+    {
+|    | 218|+        std::cerr << "WARNING: Variable '" << option
+|    | 219|+            << "' is deprecated and will be removed in " << version_removal;
+|    | 220|+        if (!advice.empty ())
+|    | 221|+            std::cerr << " (" << advice << ")";
+|    | 222|+        std::cerr << ".\n";
+|    | 223|+    }
+|    | 224|+
+| 123| 225| }
+| 124| 226| 
+| 125| 227| Format::AST<char> columns_to_format(const std::vector<Column> &columns)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/settings.cpp
+|    |++++| /app/src/settings.cpp
+| 122| 122| 	return result;
+| 123| 123| }
+| 124| 124| 
+| 125|    |-Format::AST<char> columns_to_format(const std::vector<Column> &columns)
+|    | 125|+bool
+|    | 126|+Configuration::read (const std::vector < std::string > &config_paths,
+|    | 127|+                     bool ignore_errors)
+| 126| 128| {
+| 127|    |-	std::vector<Format::Expression<char>> result;
+| 128|    |-
+| 129|    |-	auto column = columns.begin();
+| 130|    |-	while (true)
+| 131|    |-	{
+| 132|    |-		Format::FirstOf<char> first_of;
+| 133|    |-		for (const auto &type : column->type)
+| 134|    |-		{
+| 135|    |-			auto f = charToGetFunction(type);
+| 136|    |-			assert(f != nullptr);
+| 137|    |-			first_of.base().push_back(f);
+| 138|    |-		}
+| 139|    |-		result.push_back(std::move(first_of));
+| 140|    |-
+| 141|    |-		if (++column != columns.end())
+| 142|    |-			result.push_back(" ");
+| 143|    |-		else
+| 144|    |-			break;
+| 145|    |-	}
+| 146|    |-
+| 147|    |-	return Format::AST<char>(std::move(result));
+|    | 129|+    option_parser p;
+|    | 130|+
+|    | 131|+    // Deprecated options.
+|    | 132|+    p.add < void >("visualizer_sample_multiplier", nullptr, "",
+|    | 133|+                   [](std::string v)
+|    | 134|+                   {
+|    | 135|+                   if (!v.empty ())deprecated ("visualizer_sample_multiplier",
+|    | 136|+                                               0.9,
+|    | 137|+                                               "visualizer scales automatically");}
+|    | 138|+    ) ;
+|    | 139|+    p.add < void >("progressbar_boldness", nullptr, "",[](std::string v)
+|    | 140|+                   {
+|    | 141|+                   if (!v.empty ())deprecated ("progressbar_boldness",
+|    | 142|+                                               0.9,
+|    | 143|+                                               "use extended progressbar_color and progressbar_elapsed_color instead");}
+|    | 144|+    ) ;
+|    | 145|+
+|    | 146|+    p.add < void >("main_window_highlight_color", nullptr, "",
+|    | 147|+                   [this] (std::string v)
+|    | 148|+                   {
+|    | 149|+                   if (!v.empty ())
+|    | 150|+                   {
+|    | 151|+                   const std::string current_item_prefix_str =
+|    | 152|+                   "$(" + v + ")$r";
+|    | 153|+                   const std::string current_item_suffix_str = "$/r$(end)";
+|    | 154|+                   current_item_prefix =
+|    | 155|+                   buffer_wlength (nullptr, current_item_prefix_length,
+|    | 156|+                                   current_item_prefix_str);
+|    | 157|+                   current_item_suffix =
+|    | 158|+                   buffer_wlength (nullptr, current_item_suffix_length,
+|    | 159|+                                   current_item_suffix_str);
+|    | 160|+                   deprecated ("main_window_highlight_color", 0.9,
+|    | 161|+                               "set current_item_prefix = \"" +
+|    | 162|+                               current_item_prefix_str +
+|    | 163|+                               "\" and current_item_suffix = \"" +
+|    | 164|+                               current_item_suffix_str +
+|    | 165|+                               "\" to preserve current behavior");};}) ;
+|    | 166|+    p.add < void >("active_column_color", nullptr, "",[this] (std::string v)
+|    | 167|+                   {
+|    | 168|+                   if (!v.empty ())
+|    | 169|+                   {
+|    | 170|+                   deprecated ("active_column_color",
+|    | 171|+                               0.9,
+|    | 172|+                               "replaced by current_item_inactive_column_prefix"
+|    | 173|+                               " and current_item_inactive_column_suffix");};}
+|    | 174|+    ) ;
+|    | 175|+
+|    | 176|+    // keep the same order of variables as in configuration file
+|    | 177|+    p.add ("ncmpcpp_directory", &ncmpcpp_directory, "~/.ncmpcpp/",
+|    | 178|+           adjust_directory);
+|    | 179|+    p.add ("lyrics_directory", &lyrics_directory, "~/.lyrics/",
+|    | 180|+           adjust_directory);
+|    | 181|+    p.add < void >("mpd_host", nullptr, "localhost",[](std::string host)
+|    | 182|+                   {
+|    | 183|+                   expand_home (host); Mpd.SetHostname (host);});
+|    | 184|+    p.add < void >("mpd_port", nullptr, "6600",[](std::string port)
+|    | 185|+                   {
+|    | 186|+                   Mpd.SetPort (verbose_lexical_cast < unsigned >(port));});
+|    | 187|+    p.add ("mpd_music_dir", &mpd_music_dir, "~/music", adjust_directory);
+|    | 188|+    p.add ("mpd_connection_timeout", &mpd_connection_timeout, "5");
+|    | 189|+    p.add ("mpd_crossfade_time", &crossfade_time, "5");
+|    | 190|+    p.add ("visualizer_fifo_path", &visualizer_fifo_path, "/tmp/mpd.fifo",
+|    | 191|+           adjust_path);
+|    | 192|+    p.add ("visualizer_output_name", &visualizer_output_name,
+|    | 193|+           "Visualizer feed");
+|    | 194|+    p.add ("visualizer_in_stereo", &visualizer_in_stereo, "yes", yes_no);
+|    | 195|+    p.add ("visualizer_sync_interval", &visualizer_sync_interval, "30",
+|    | 196|+           [](std::string v)
+|    | 197|+           {
+|    | 198|+           unsigned sync_interval = verbose_lexical_cast < unsigned >(v);
+|    | 199|+           lowerBoundCheck < unsigned >(sync_interval, 10);
+|    | 200|+           return boost::posix_time::seconds (sync_interval);}
+|    | 201|+    );
+|    | 202|+    p.add ("visualizer_type", &visualizer_type, "wave");
+|    | 203|+    p.add ("visualizer_look", &visualizer_chars, "●▮",[](std::string s)
+|    | 204|+           {
+|    | 205|+           auto result = ToWString (std::move (s));
+|    | 206|+           boundsCheck < std::wstring::size_type > (result.size (), 2, 2);
+|    | 207|+           return result;}
+|    | 208|+    );
+|    | 209|+    p.add ("visualizer_color", &visualizer_colors,
+|    | 210|+           "blue, cyan, green, yellow, magenta, red",
+|    | 211|+           list_of < NC::FormattedColor >);
+|    | 212|+    p.add ("system_encoding", &system_encoding, "",[](std::string encoding)
+|    | 213|+           {
+|    | 214|+#ifdef HAVE_LANGINFO_H
+|    | 215|+           // try to autodetect system encoding
+|    | 216|+           if (encoding.empty ())
+|    | 217|+           {
+|    | 218|+           encoding = nl_langinfo (CODESET); if (encoding == "UTF-8")   // mpd uses utf-8 by default so no need to convert
+|    | 219|+           encoding.clear ();}
+|    | 220|+#endif // HAVE_LANGINFO_H
+|    | 221|+           return encoding;}
+|    | 222|+    ) ;
+|    | 223|+    p.add ("playlist_disable_highlight_delay",
+|    | 224|+           &playlist_disable_highlight_delay, "5",[](std::string v)
+|    | 225|+           {
+|    | 226|+           return boost::posix_time::seconds (verbose_lexical_cast <
+|    | 227|+                                              unsigned >(v));});
+|    | 228|+    p.add ("message_delay_time", &message_delay_time, "5");
+|    | 229|+    p.add ("song_list_format", &song_list_format,
+|    | 230|+           "{%a - }{%t}|{$8%f$9}$R{$3(%l)$9}",[](std::string v)
+|    | 231|+           {
+|    | 232|+           return Format::parse (v);}
+|    | 233|+    );
+|    | 234|+    p.add ("song_status_format", &song_status_format,
+|    | 235|+           "{{%a{ \"%b\"{ (%y)}} - }{%t}}|{%f}",[this] (std::string v)
+|    | 236|+           {
+|    | 237|+           auto flags = Format::Flags::All ^ Format::Flags::OutputSwitch;
+|    | 238|+           // precompute wide format for status display
+|    | 239|+           song_status_wformat = Format::parse (ToWString (v), flags);
+|    | 240|+           return Format::parse (v, flags);}
+|    | 241|+    );
+|    | 242|+    p.add ("song_library_format", &song_library_format,
+|    | 243|+           "{%n - }{%t}|{%f}",[](std::string v)
+|    | 244|+           {
+|    | 245|+           return Format::parse (v);}
+|    | 246|+    );
+|    | 247|+    p.add ("alternative_header_first_line_format", &new_header_first_line,
+|    | 248|+           "$b$1$aqqu$/a$9 {%t}|{%f} $1$atqq$/a$9$/b",[](std::string v)
+|    | 249|+           {
+|    | 250|+           return Format::parse (ToWString (std::move (v)),
+|    | 251|+                                 Format::Flags::All ^ Format::Flags::
+|    | 252|+                                 OutputSwitch);}
+|    | 253|+    );
+|    | 254|+    p.add ("alternative_header_second_line_format", &new_header_second_line,
+|    | 255|+           "{{$4$b%a$/b$9}{ - $7%b$9}{ ($4%y$9)}}|{%D}",[](std::string v)
+|    | 256|+           {
+|    | 257|+           return Format::parse (ToWString (std::move (v)),
+|    | 258|+                                 Format::Flags::All ^ Format::Flags::
+|    | 259|+                                 OutputSwitch);}
+|    | 260|+    );
+|    | 261|+    p.add ("current_item_prefix", &current_item_prefix, "$(yellow)$r",
+|    | 262|+           std::bind (buffer_wlength,
+|    | 263|+                      &current_item_prefix,
+|    | 264|+                      std::ref (current_item_prefix_length), ph::_1));
+|    | 265|+    p.add ("current_item_suffix", &current_item_suffix, "$/r$(end)",
+|    | 266|+           std::bind (buffer_wlength,
+|    | 267|+                      &current_item_suffix,
+|    | 268|+                      std::ref (current_item_suffix_length), ph::_1));
+|    | 269|+    p.add ("current_item_inactive_column_prefix",
+|    | 270|+           &current_item_inactive_column_prefix, "$(white)$r",
+|    | 271|+           std::bind (buffer_wlength, &current_item_inactive_column_prefix,
+|    | 272|+                      std::ref (current_item_inactive_column_prefix_length),
+|    | 273|+                      ph::_1));
+|    | 274|+    p.add ("current_item_inactive_column_suffix",
+|    | 275|+           &current_item_inactive_column_suffix, "$/r$(end)",
+|    | 276|+           std::bind (buffer_wlength, &current_item_inactive_column_suffix,
+|    | 277|+                      std::ref (current_item_inactive_column_suffix_length),
+|    | 278|+                      ph::_1));
+|    | 279|+    p.add ("now_playing_prefix", &now_playing_prefix, "$b",
+|    | 280|+           std::bind (buffer_wlength, nullptr,
+|    | 281|+                      std::ref (now_playing_prefix_length), ph::_1));
+|    | 282|+    p.add ("now_playing_suffix", &now_playing_suffix, "$/b",
+|    | 283|+           std::bind (buffer_wlength, nullptr,
+|    | 284|+                      std::ref (now_playing_suffix_length), ph::_1));
+|    | 285|+    p.add ("browser_playlist_prefix", &browser_playlist_prefix,
+|    | 286|+           "$2playlist$9 ", buffer);
+|    | 287|+    p.add ("selected_item_prefix", &selected_item_prefix, "$6",
+|    | 288|+           std::bind (buffer_wlength, nullptr,
+|    | 289|+                      std::ref (selected_item_prefix_length), ph::_1));
+|    | 290|+    p.add ("selected_item_suffix", &selected_item_suffix, "$9",
+|    | 291|+           std::bind (buffer_wlength, nullptr,
+|    | 292|+                      std::ref (selected_item_suffix_length), ph::_1));
+|    | 293|+    p.add ("modified_item_prefix", &modified_item_prefix, "$3>$9 ", buffer);
+|    | 294|+    p.add ("song_window_title_format", &song_window_title_format,
+|    | 295|+           "{%a - }{%t}|{%f}",[](std::string v)
+|    | 296|+           {
+|    | 297|+           return Format::parse (v, Format::Flags::Tag);}
+|    | 298|+    );
+|    | 299|+    p.add ("browser_sort_mode", &browser_sort_mode, "name");
+|    | 300|+    p.add ("browser_sort_format", &browser_sort_format,
+|    | 301|+           "{%a - }{%t}|{%f} {(%l)}",[](std::string v)
+|    | 302|+           {
+|    | 303|+           return Format::parse (v, Format::Flags::Tag);}
+|    | 304|+    );
+|    | 305|+    p.add ("song_columns_list_format", &song_columns_mode_format,
+|    | 306|+           "(20)[]{a} (6f)[green]{NE} (50)[white]{t|f:Title} (20)[cyan]{b} (7f)[magenta]{l}",
+|    | 307|+           [this] (std::string v)
+|    | 308|+           {
+|    | 309|+           columns = generate_columns (v); return columns_to_format (columns);}
+|    | 310|+    );
+|    | 311|+    p.add ("execute_on_song_change", &execute_on_song_change, "", adjust_path);
+|    | 312|+    p.add ("execute_on_player_state_change", &execute_on_player_state_change,
+|    | 313|+           "", adjust_path);
+|    | 314|+    p.add ("playlist_show_mpd_host", &playlist_show_mpd_host, "no", yes_no);
+|    | 315|+    p.add ("playlist_show_remaining_time", &playlist_show_remaining_time, "no",
+|    | 316|+           yes_no);
+|    | 317|+    p.add ("playlist_shorten_total_times", &playlist_shorten_total_times, "no",
+|    | 318|+           yes_no);
+|    | 319|+    p.add ("playlist_separate_albums", &playlist_separate_albums, "no",
+|    | 320|+           yes_no);
+|    | 321|+    p.add ("playlist_display_mode", &playlist_display_mode, "columns");
+|    | 322|+    p.add ("browser_display_mode", &browser_display_mode, "classic");
+|    | 323|+    p.add ("search_engine_display_mode", &search_engine_display_mode,
+|    | 324|+           "classic");
+|    | 325|+    p.add ("playlist_editor_display_mode", &playlist_editor_display_mode,
+|    | 326|+           "classic");
+|    | 327|+    p.add ("discard_colors_if_item_is_selected",
+|    | 328|+           &discard_colors_if_item_is_selected, "yes", yes_no);
+|    | 329|+    p.add ("show_duplicate_tags", &MPD::Song::ShowDuplicateTags, "yes",
+|    | 330|+           yes_no);
+|    | 331|+    p.add ("incremental_seeking", &incremental_seeking, "yes", yes_no);
+|    | 332|+    p.add ("seek_time", &seek_time, "1");
+|    | 333|+    p.add ("volume_change_step", &volume_change_step, "2");
+|    | 334|+    p.add ("autocenter_mode", &autocenter_mode, "no", yes_no);
+|    | 335|+    p.add ("centered_cursor", &centered_cursor, "no", yes_no);
+|    | 336|+    p.add ("progressbar_look", &progressbar, "=>",[](std::string v)
+|    | 337|+           {
+|    | 338|+           auto result = ToWString (std::move (v));
+|    | 339|+           boundsCheck < std::wstring::size_type > (result.size (), 2, 3);
+|    | 340|+           // If two characters were specified, fill \0 as the third one.
+|    | 341|+           result.resize (3); return result;}
+|    | 342|+    );
+|    | 343|+    p.add ("default_place_to_search_in", &search_in_db, "database",
+|    | 344|+           [](std::string v)
+|    | 345|+           {
+|    | 346|+           if (v == "database") return true;
+|    | 347|+           else
+|    | 348|+           if (v == "playlist") return false;
+|    | 349|+           else
+|    | 350|+           invalid_value (v);}
+|    | 351|+    ) ;
+|    | 352|+    p.add ("user_interface", &design, "classic");
+|    | 353|+    p.add ("data_fetching_delay", &data_fetching_delay, "yes", yes_no);
+|    | 354|+    p.add ("media_library_primary_tag", &media_lib_primary_tag, "artist",
+|    | 355|+           [](std::string v)
+|    | 356|+           {
+|    | 357|+           if (v == "artist") return MPD_TAG_ARTIST;
+|    | 358|+           else
+|    | 359|+           if (v == "album_artist") return MPD_TAG_ALBUM_ARTIST;
+|    | 360|+           else
+|    | 361|+           if (v == "date") return MPD_TAG_DATE;
+|    | 362|+           else
+|    | 363|+           if (v == "genre") return MPD_TAG_GENRE;
+|    | 364|+           else
+|    | 365|+           if (v == "composer") return MPD_TAG_COMPOSER;
+|    | 366|+           else
+|    | 367|+           if (v == "performer") return MPD_TAG_PERFORMER;
+|    | 368|+           else
+|    | 369|+           invalid_value (v);}
+|    | 370|+    ) ;
+|    | 371|+    p.add ("media_library_albums_split_by_date",
+|    | 372|+           &media_library_albums_split_by_date, "yes", yes_no);
+|    | 373|+    p.add ("default_find_mode", &wrapped_search, "wrapped",[](std::string v)
+|    | 374|+           {
+|    | 375|+           if (v == "wrapped") return true;
+|    | 376|+           else
+|    | 377|+           if (v == "normal") return false;
+|    | 378|+           else
+|    | 379|+           invalid_value (v);}
+|    | 380|+    ) ;
+|    | 381|+    p.add ("default_tag_editor_pattern", &pattern, "%n - %t");
+|    | 382|+    p.add ("header_visibility", &header_visibility, "yes", yes_no);
+|    | 383|+    p.add ("statusbar_visibility", &statusbar_visibility, "yes", yes_no);
+|    | 384|+    p.add ("titles_visibility", &titles_visibility, "yes", yes_no);
+|    | 385|+    p.add ("header_text_scrolling", &header_text_scrolling, "yes", yes_no);
+|    | 386|+    p.add ("cyclic_scrolling", &use_cyclic_scrolling, "no", yes_no);
+|    | 387|+    p.add ("lines_scrolled", &lines_scrolled, "2");
+|    | 388|+    p.add ("lyrics_fetchers", &lyrics_fetchers,
+|    | 389|+           "lyricwiki, azlyrics, genius, sing365, lyricsmania, metrolyrics, justsomelyrics, jahlyrics, plyrics, tekstowo, internet",
+|    | 390|+           list_of < LyricsFetcher_ >);
+|    | 391|+    p.add ("follow_now_playing_lyrics", &now_playing_lyrics, "no", yes_no);
+|    | 392|+    p.add ("fetch_lyrics_for_current_song_in_background",
+|    | 393|+           &fetch_lyrics_in_background, "no", yes_no);
+|    | 394|+    p.add ("store_lyrics_in_song_dir", &store_lyrics_in_song_dir, "no",
+|    | 395|+           yes_no);
+|    | 396|+    p.add ("generate_win32_compatible_filenames",
+|    | 397|+           &generate_win32_compatible_filenames, "yes", yes_no);
+|    | 398|+    p.add ("allow_for_physical_item_deletion",
+|    | 399|+           &allow_for_physical_item_deletion, "no", yes_no);
+|    | 400|+    p.add ("lastfm_preferred_language", &lastfm_preferred_language, "en");
+|    | 401|+    p.add ("space_add_mode", &space_add_mode, "add_remove");
+|    | 402|+    p.add ("show_hidden_files_in_local_browser",
+|    | 403|+           &local_browser_show_hidden_files, "no", yes_no);
+|    | 404|+    p.add < void >("screen_switcher_mode", nullptr, "playlist, browser",
+|    | 405|+                   [this] (std::string v)
+|    | 406|+                   {
+|    | 407|+                   if (v == "previous") screen_switcher_previous = true;
+|    | 408|+                   else
+|    | 409|+                   {
+|    | 410|+                   screen_switcher_previous = false;
+|    | 411|+                   screen_sequence =
+|    | 412|+                   list_of < ScreenType > (v,[](std::string s)
+|    | 413|+                                           {
+|    | 414|+                                           auto screen =
+|    | 415|+                                           stringtoStartupScreenType (s);
+|    | 416|+                                           if (screen ==
+|    | 417|+                                               ScreenType::
+|    | 418|+                                               Unknown) invalid_value (s);
+|    | 419|+                                           return screen;}
+|    | 420|+                   );}
+|    | 421|+                   }
+|    | 422|+    ) ;
+|    | 423|+    p.add ("startup_screen", &startup_screen_type, "playlist",[](std::string v)
+|    | 424|+           {
+|    | 425|+           auto screen = stringtoStartupScreenType (v);
+|    | 426|+           if (screen == ScreenType::Unknown)
+|    | 427|+           invalid_value (v); return screen;}
+|    | 428|+    ) ;
+|    | 429|+    p.add ("startup_slave_screen", &startup_slave_screen_type, "",
+|    | 430|+           [](std::string v)
+|    | 431|+           {
+|    | 432|+           boost::optional < ScreenType > screen; if (!v.empty ())
+|    | 433|+           {
+|    | 434|+           screen = stringtoStartupScreenType (v);
+|    | 435|+           if (screen == ScreenType::Unknown) invalid_value (v);}
+|    | 436|+           return screen;}
+|    | 437|+    ) ;
+|    | 438|+    p.add ("startup_slave_screen_focus", &startup_slave_screen_focus, "no",
+|    | 439|+           yes_no);
+|    | 440|+    p.add ("locked_screen_width_part", &locked_screen_width_part, "50",
+|    | 441|+           [](std::string v)
+|    | 442|+           {
+|    | 443|+           return verbose_lexical_cast < double >(v) / 100;});
+|    | 444|+    p.add ("ask_for_locked_screen_width_part",
+|    | 445|+           &ask_for_locked_screen_width_part, "yes", yes_no);
+|    | 446|+    p.add ("jump_to_now_playing_song_at_start",
+|    | 447|+           &jump_to_now_playing_song_at_start, "yes", yes_no);
+|    | 448|+    p.add ("ask_before_clearing_playlists", &ask_before_clearing_playlists,
+|    | 449|+           "yes", yes_no);
+|    | 450|+    p.add ("ask_before_shuffling_playlists", &ask_before_shuffling_playlists,
+|    | 451|+           "yes", yes_no);
+|    | 452|+    p.add ("clock_display_seconds", &clock_display_seconds, "no", yes_no);
+|    | 453|+    p.add ("display_volume_level", &display_volume_level, "yes", yes_no);
+|    | 454|+    p.add ("display_bitrate", &display_bitrate, "no", yes_no);
+|    | 455|+    p.add ("display_remaining_time", &display_remaining_time, "no", yes_no);
+|    | 456|+    p.add ("regular_expressions", &regex_type, "perl",[](std::string v)
+|    | 457|+           {
+|    | 458|+           if (v == "none") return boost::regex::icase | boost::regex::literal;
+|    | 459|+           else
+|    | 460|+           if (v == "basic") return boost::regex::icase | boost::regex::basic;
+|    | 461|+           else
+|    | 462|+           if (v == "extended")
+|    | 463|+           return boost::regex::icase | boost::regex::extended;
+|    | 464|+           else
+|    | 465|+           if (v == "perl") return boost::regex::icase | boost::regex::perl;
+|    | 466|+           else
+|    | 467|+           invalid_value (v);}
+|    | 468|+    ) ;
+|    | 469|+    p.add ("ignore_leading_the", &ignore_leading_the, "no", yes_no);
+|    | 470|+    p.add ("ignore_diacritics", &ignore_diacritics, "no", yes_no);
+|    | 471|+    p.add ("block_search_constraints_change_if_items_found",
+|    | 472|+           &block_search_constraints_change, "yes", yes_no);
+|    | 473|+    p.add ("mouse_support", &mouse_support, "yes", yes_no);
+|    | 474|+    p.add ("mouse_list_scroll_whole_page", &mouse_list_scroll_whole_page,
+|    | 475|+           "yes", yes_no);
+|    | 476|+    p.add ("empty_tag_marker", &empty_tag, "<empty>");
+|    | 477|+    p.add ("tags_separator", &MPD::Song::TagsSeparator, " | ");
+|    | 478|+    p.add ("tag_editor_extended_numeration", &tag_editor_extended_numeration,
+|    | 479|+           "no", yes_no);
+|    | 480|+    p.add ("media_library_sort_by_mtime", &media_library_sort_by_mtime, "no",
+|    | 481|+           yes_no);
+|    | 482|+    p.add ("enable_window_title", &set_window_title, "yes",[](std::string v)
+|    | 483|+           {
+|    | 484|+           // Consider this variable only if TERM variable is available and we're not
+|    | 485|+           // in emacs terminal nor tty (through any wrapper like screen).
+|    | 486|+           auto term = getenv ("TERM");
+|    | 487|+           if (term != nullptr
+|    | 488|+               && strstr (term, "linux") == nullptr
+|    | 489|+               && strncmp (term, "eterm", const_strlen ("eterm")))
+|    | 490|+           return yes_no (v);
+|    | 491|+           else
+|    | 492|+           {
+|    | 493|+           std::
+|    | 494|+           clog <<
+|    | 495|+           "Terminal doesn't support window title, skipping 'enable_window_title'.\n";
+|    | 496|+           return false;}
+|    | 497|+           }
+|    | 498|+    ) ;
+|    | 499|+    p.add ("search_engine_default_search_mode",
+|    | 500|+           &search_engine_default_search_mode, "1",[](std::string v)
+|    | 501|+           {
+|    | 502|+           auto mode = verbose_lexical_cast < unsigned >(v);
+|    | 503|+           boundsCheck < unsigned >(mode, 1, 3); return --mode;}
+|    | 504|+    );
+|    | 505|+    p.add ("external_editor", &external_editor, "nano", adjust_path);
+|    | 506|+    p.add ("use_console_editor", &use_console_editor, "yes", yes_no);
+|    | 507|+    p.add ("colors_enabled", &colors_enabled, "yes", yes_no);
+|    | 508|+    p.add ("empty_tag_color", &empty_tags_color, "cyan");
+|    | 509|+    p.add ("header_window_color", &header_color, "default");
+|    | 510|+    p.add ("volume_color", &volume_color, "default");
+|    | 511|+    p.add ("state_line_color", &state_line_color, "default");
+|    | 512|+    p.add ("state_flags_color", &state_flags_color, "default:b");
+|    | 513|+    p.add ("main_window_color", &main_color, "yellow");
+|    | 514|+    p.add ("color1", &color1, "white");
+|    | 515|+    p.add ("color2", &color2, "green");
+|    | 516|+    p.add ("progressbar_color", &progressbar_color, "black:b");
+|    | 517|+    p.add ("progressbar_elapsed_color", &progressbar_elapsed_color, "green:b");
+|    | 518|+    p.add ("statusbar_color", &statusbar_color, "default");
+|    | 519|+    p.add ("statusbar_time_color", &statusbar_time_color, "default:b");
+|    | 520|+    p.add ("player_state_color", &player_state_color, "default:b");
+|    | 521|+    p.add ("alternative_ui_separator_color", &alternative_ui_separator_color,
+|    | 522|+           "black:b");
+|    | 523|+    p.add ("window_border_color", &window_border, "green",
+|    | 524|+           verbose_lexical_cast < NC::Color >);
+|    | 525|+    p.add ("active_window_border", &active_window_border, "red",
+|    | 526|+           verbose_lexical_cast < NC::Color >);
+|    | 527|+
+|    | 528|+    return std::all_of (config_paths.begin (),
+|    | 529|+                        config_paths.end (),
+|    | 530|+                        [&](const std::string & config_path)
+|    | 531|+                        {
+|    | 532|+                        std::ifstream f (config_path);
+|    | 533|+                        if (f.
+|    | 534|+                            is_open ())std::
+|    | 535|+                        clog << "Reading configuration from " << config_path <<
+|    | 536|+                        "...\n"; return p.run (f, ignore_errors);}
+|    | 537|+    )
+|    | 538|+        &&p.initialize_undefined (ignore_errors);
+| 148| 539| }
+| 149|    |-
+| 150|    |-void add_slash_at_the_end(std::string &s)
+| 151|    |-{
+| 152|    |-	if (s.empty() || *s.rbegin() != '/')
+| 153|    |-	{
+| 154|    |-		s.resize(s.size()+1);
+| 155|    |-		*s.rbegin() = '/';
+| 156|    |-	}
+| 157|    |-}
+| 158|    |-
+| 159|    |-std::string adjust_directory(std::string s)
+| 160|    |-{
+| 161|    |-	add_slash_at_the_end(s);
+| 162|    |-	expand_home(s);
+| 163|    |-	return s;
+| 164|    |-}
+| 165|    |-
+| 166|    |-std::string adjust_path(std::string s)
+| 167|    |-{
+| 168|    |-	expand_home(s);
+| 169|    |-	return s;
+| 170|    |-}
+| 171|    |-
+| 172|    |-NC::Buffer buffer(const std::string &v)
+| 173|    |-{
+| 174|    |-	NC::Buffer result;
+| 175|    |-	Format::print(
+| 176|    |-		Format::parse(v, Format::Flags::Color | Format::Flags::Format),
+| 177|    |-		result,
+| 178|    |-		nullptr);
+| 179|    |-	return result;
+| 180|    |-}
+| 181|    |-
+| 182|    |-NC::Buffer buffer_wlength(const NC::Buffer *target,
+| 183|    |-                          size_t &wlength,
+| 184|    |-                          const std::string &v)
+| 185|    |-{
+| 186|    |-	// Compatibility layer between highlight color and new highlight prefix and
+| 187|    |-	// suffix. Basically, for older configurations if highlight color is provided,
+| 188|    |-	// we don't want to override it with default prefix and suffix.
+| 189|    |-	if (target == nullptr || target->empty())
+| 190|    |-	{
+| 191|    |-		NC::Buffer result = buffer(v);
+| 192|    |-		wlength = wideLength(ToWString(result.str()));
+| 193|    |-		return result;
+| 194|    |-	}
+| 195|    |-	else
+| 196|    |-		return *target;
+| 197|    |-}
+| 198|    |-
+| 199|    |-void deprecated(const char *option, double version_removal, const std::string &advice)
+| 200|    |-{
+| 201|    |-	std::cerr << "WARNING: Variable '" << option
+| 202|    |-	          << "' is deprecated and will be removed in "
+| 203|    |-	          << version_removal;
+| 204|    |-	if (!advice.empty())
+| 205|    |-		std::cerr << " (" << advice << ")";
+| 206|    |-	std::cerr << ".\n";
+| 207|    |-}
+| 208|    |-
+| 209|    |-}
+| 210|    |-
+| 211|    |-bool Configuration::read(const std::vector<std::string> &config_paths, bool ignore_errors)
+| 212|    |-{
+| 213|    |-	option_parser p;
+| 214|    |-
+| 215|    |-	// Deprecated options.
+| 216|    |-	p.add<void>("visualizer_sample_multiplier", nullptr, "", [](std::string v) {
+| 217|    |-			if (!v.empty())
+| 218|    |-				deprecated(
+| 219|    |-					"visualizer_sample_multiplier",
+| 220|    |-					0.9,
+| 221|    |-					"visualizer scales automatically");
+| 222|    |-		});
+| 223|    |-	p.add<void>("progressbar_boldness", nullptr, "", [](std::string v) {
+| 224|    |-			if (!v.empty())
+| 225|    |-				deprecated(
+| 226|    |-					"progressbar_boldness",
+| 227|    |-					0.9,
+| 228|    |-					"use extended progressbar_color and progressbar_elapsed_color instead");
+| 229|    |-		});
+| 230|    |-
+| 231|    |-	p.add<void>("main_window_highlight_color", nullptr, "", [this](std::string v) {
+| 232|    |-			if (!v.empty())
+| 233|    |-			{
+| 234|    |-				const std::string current_item_prefix_str = "$(" + v + ")$r";
+| 235|    |-				const std::string current_item_suffix_str = "$/r$(end)";
+| 236|    |-				current_item_prefix = buffer_wlength(
+| 237|    |-					nullptr,
+| 238|    |-					current_item_prefix_length,
+| 239|    |-					current_item_prefix_str);
+| 240|    |-				current_item_suffix = buffer_wlength(
+| 241|    |-					nullptr,
+| 242|    |-					current_item_suffix_length,
+| 243|    |-					current_item_suffix_str);
+| 244|    |-				deprecated(
+| 245|    |-					"main_window_highlight_color",
+| 246|    |-					0.9,
+| 247|    |-					"set current_item_prefix = \""
+| 248|    |-					+ current_item_prefix_str
+| 249|    |-					+ "\" and current_item_suffix = \""
+| 250|    |-					+ current_item_suffix_str
+| 251|    |-					+ "\" to preserve current behavior");
+| 252|    |-			};
+| 253|    |-		});
+| 254|    |-	p.add<void>("active_column_color", nullptr, "", [this](std::string v) {
+| 255|    |-			if (!v.empty())
+| 256|    |-			{
+| 257|    |-				deprecated(
+| 258|    |-					"active_column_color",
+| 259|    |-					0.9,
+| 260|    |-					"replaced by current_item_inactive_column_prefix"
+| 261|    |-					" and current_item_inactive_column_suffix");
+| 262|    |-			};
+| 263|    |-		});
+| 264|    |-
+| 265|    |-	// keep the same order of variables as in configuration file
+| 266|    |-	p.add("ncmpcpp_directory", &ncmpcpp_directory, "~/.ncmpcpp/", adjust_directory);
+| 267|    |-	p.add("lyrics_directory", &lyrics_directory, "~/.lyrics/", adjust_directory);
+| 268|    |-	p.add<void>("mpd_host", nullptr, "localhost", [](std::string host) {
+| 269|    |-			expand_home(host);
+| 270|    |-			Mpd.SetHostname(host);
+| 271|    |-		});
+| 272|    |-	p.add<void>("mpd_port", nullptr, "6600", [](std::string port) {
+| 273|    |-			Mpd.SetPort(verbose_lexical_cast<unsigned>(port));
+| 274|    |-		});
+| 275|    |-	p.add("mpd_music_dir", &mpd_music_dir, "~/music", adjust_directory);
+| 276|    |-	p.add("mpd_connection_timeout", &mpd_connection_timeout, "5");
+| 277|    |-	p.add("mpd_crossfade_time", &crossfade_time, "5");
+| 278|    |-	p.add("visualizer_fifo_path", &visualizer_fifo_path, "/tmp/mpd.fifo", adjust_path);
+| 279|    |-	p.add("visualizer_output_name", &visualizer_output_name, "Visualizer feed");
+| 280|    |-	p.add("visualizer_in_stereo", &visualizer_in_stereo, "yes", yes_no);
+| 281|    |-	p.add("visualizer_sync_interval", &visualizer_sync_interval, "30",
+| 282|    |-	      [](std::string v) {
+| 283|    |-		      unsigned sync_interval = verbose_lexical_cast<unsigned>(v);
+| 284|    |-		      lowerBoundCheck<unsigned>(sync_interval, 10);
+| 285|    |-		      return boost::posix_time::seconds(sync_interval);
+| 286|    |-	});
+| 287|    |-	p.add("visualizer_type", &visualizer_type, "wave");
+| 288|    |-	p.add("visualizer_look", &visualizer_chars, "●▮", [](std::string s) {
+| 289|    |-			auto result = ToWString(std::move(s));
+| 290|    |-			boundsCheck<std::wstring::size_type>(result.size(), 2, 2);
+| 291|    |-			return result;
+| 292|    |-	});
+| 293|    |-	p.add("visualizer_color", &visualizer_colors,
+| 294|    |-	      "blue, cyan, green, yellow, magenta, red", list_of<NC::FormattedColor>);
+| 295|    |-	p.add("system_encoding", &system_encoding, "", [](std::string encoding) {
+| 296|    |-#ifdef HAVE_LANGINFO_H
+| 297|    |-			// try to autodetect system encoding
+| 298|    |-			if (encoding.empty())
+| 299|    |-			{
+| 300|    |-				encoding = nl_langinfo(CODESET);
+| 301|    |-				if (encoding == "UTF-8") // mpd uses utf-8 by default so no need to convert
+| 302|    |-					encoding.clear();
+| 303|    |-			}
+| 304|    |-#endif // HAVE_LANGINFO_H
+| 305|    |-			return encoding;
+| 306|    |-		});
+| 307|    |-	p.add("playlist_disable_highlight_delay", &playlist_disable_highlight_delay,
+| 308|    |-	      "5", [](std::string v) {
+| 309|    |-		      return boost::posix_time::seconds(verbose_lexical_cast<unsigned>(v));
+| 310|    |-	      });
+| 311|    |-	p.add("message_delay_time", &message_delay_time, "5");
+| 312|    |-	p.add("song_list_format", &song_list_format,
+| 313|    |-	      "{%a - }{%t}|{$8%f$9}$R{$3(%l)$9}", [](std::string v) {
+| 314|    |-		      return Format::parse(v);
+| 315|    |-	      });
+| 316|    |-	p.add("song_status_format", &song_status_format,
+| 317|    |-	      "{{%a{ \"%b\"{ (%y)}} - }{%t}}|{%f}", [this](std::string v) {
+| 318|    |-		      auto flags = Format::Flags::All ^ Format::Flags::OutputSwitch;
+| 319|    |-		      // precompute wide format for status display
+| 320|    |-		      song_status_wformat = Format::parse(ToWString(v), flags);
+| 321|    |-		      return Format::parse(v, flags);
+| 322|    |-	});
+| 323|    |-	p.add("song_library_format", &song_library_format,
+| 324|    |-	      "{%n - }{%t}|{%f}", [](std::string v) {
+| 325|    |-		      return Format::parse(v);
+| 326|    |-	      });
+| 327|    |-	p.add("alternative_header_first_line_format", &new_header_first_line,
+| 328|    |-	      "$b$1$aqqu$/a$9 {%t}|{%f} $1$atqq$/a$9$/b", [](std::string v) {
+| 329|    |-		      return Format::parse(ToWString(std::move(v)),
+| 330|    |-		                           Format::Flags::All ^ Format::Flags::OutputSwitch);
+| 331|    |-	});
+| 332|    |-	p.add("alternative_header_second_line_format", &new_header_second_line,
+| 333|    |-	      "{{$4$b%a$/b$9}{ - $7%b$9}{ ($4%y$9)}}|{%D}", [](std::string v) {
+| 334|    |-		      return Format::parse(ToWString(std::move(v)),
+| 335|    |-		                           Format::Flags::All ^ Format::Flags::OutputSwitch);
+| 336|    |-	});
+| 337|    |-	p.add("current_item_prefix", &current_item_prefix, "$(yellow)$r",
+| 338|    |-	      std::bind(buffer_wlength,
+| 339|    |-	                &current_item_prefix,
+| 340|    |-	                std::ref(current_item_prefix_length),
+| 341|    |-	                ph::_1));
+| 342|    |-	p.add("current_item_suffix", &current_item_suffix, "$/r$(end)",
+| 343|    |-	      std::bind(buffer_wlength,
+| 344|    |-	                &current_item_suffix,
+| 345|    |-	                std::ref(current_item_suffix_length),
+| 346|    |-	                ph::_1));
+| 347|    |-	p.add("current_item_inactive_column_prefix", &current_item_inactive_column_prefix,
+| 348|    |-	      "$(white)$r",
+| 349|    |-	      std::bind(buffer_wlength,
+| 350|    |-	                &current_item_inactive_column_prefix,
+| 351|    |-	                std::ref(current_item_inactive_column_prefix_length),
+| 352|    |-	                ph::_1));
+| 353|    |-	p.add("current_item_inactive_column_suffix", &current_item_inactive_column_suffix,
+| 354|    |-	      "$/r$(end)",
+| 355|    |-	      std::bind(buffer_wlength,
+| 356|    |-	                &current_item_inactive_column_suffix,
+| 357|    |-	                std::ref(current_item_inactive_column_suffix_length),
+| 358|    |-	                ph::_1));
+| 359|    |-	p.add("now_playing_prefix", &now_playing_prefix, "$b",
+| 360|    |-	      std::bind(buffer_wlength,
+| 361|    |-	                nullptr,
+| 362|    |-	                std::ref(now_playing_prefix_length),
+| 363|    |-	                ph::_1));
+| 364|    |-	p.add("now_playing_suffix", &now_playing_suffix, "$/b",
+| 365|    |-	      std::bind(buffer_wlength,
+| 366|    |-	                nullptr,
+| 367|    |-	                std::ref(now_playing_suffix_length),
+| 368|    |-	                ph::_1));
+| 369|    |-	p.add("browser_playlist_prefix", &browser_playlist_prefix, "$2playlist$9 ", buffer);
+| 370|    |-	p.add("selected_item_prefix", &selected_item_prefix, "$6",
+| 371|    |-	      std::bind(buffer_wlength,
+| 372|    |-	                nullptr,
+| 373|    |-	                std::ref(selected_item_prefix_length),
+| 374|    |-	                ph::_1));
+| 375|    |-	p.add("selected_item_suffix", &selected_item_suffix, "$9",
+| 376|    |-	      std::bind(buffer_wlength,
+| 377|    |-	                nullptr,
+| 378|    |-	                std::ref(selected_item_suffix_length),
+| 379|    |-	                ph::_1));
+| 380|    |-	p.add("modified_item_prefix", &modified_item_prefix, "$3>$9 ", buffer);
+| 381|    |-	p.add("song_window_title_format", &song_window_title_format,
+| 382|    |-	      "{%a - }{%t}|{%f}", [](std::string v) {
+| 383|    |-		      return Format::parse(v, Format::Flags::Tag);
+| 384|    |-	      });
+| 385|    |-	p.add("browser_sort_mode", &browser_sort_mode, "name");
+| 386|    |-	p.add("browser_sort_format", &browser_sort_format,
+| 387|    |-	      "{%a - }{%t}|{%f} {(%l)}", [](std::string v) {
+| 388|    |-		      return Format::parse(v, Format::Flags::Tag);
+| 389|    |-	      });
+| 390|    |-	p.add("song_columns_list_format", &song_columns_mode_format,
+| 391|    |-	      "(20)[]{a} (6f)[green]{NE} (50)[white]{t|f:Title} (20)[cyan]{b} (7f)[magenta]{l}",
+| 392|    |-	      [this](std::string v) {
+| 393|    |-		      columns = generate_columns(v);
+| 394|    |-		      return columns_to_format(columns);
+| 395|    |-	      });
+| 396|    |-	p.add("execute_on_song_change", &execute_on_song_change, "", adjust_path);
+| 397|    |-	p.add("execute_on_player_state_change", &execute_on_player_state_change,
+| 398|    |-	      "", adjust_path);
+| 399|    |-	p.add("playlist_show_mpd_host", &playlist_show_mpd_host, "no", yes_no);
+| 400|    |-	p.add("playlist_show_remaining_time", &playlist_show_remaining_time, "no", yes_no);
+| 401|    |-	p.add("playlist_shorten_total_times", &playlist_shorten_total_times, "no", yes_no);
+| 402|    |-	p.add("playlist_separate_albums", &playlist_separate_albums, "no", yes_no);
+| 403|    |-	p.add("playlist_display_mode", &playlist_display_mode, "columns");
+| 404|    |-	p.add("browser_display_mode", &browser_display_mode, "classic");
+| 405|    |-	p.add("search_engine_display_mode", &search_engine_display_mode, "classic");
+| 406|    |-	p.add("playlist_editor_display_mode", &playlist_editor_display_mode, "classic");
+| 407|    |-	p.add("discard_colors_if_item_is_selected", &discard_colors_if_item_is_selected,
+| 408|    |-	      "yes", yes_no);
+| 409|    |-	p.add("show_duplicate_tags", &MPD::Song::ShowDuplicateTags, "yes", yes_no);
+| 410|    |-	p.add("incremental_seeking", &incremental_seeking, "yes", yes_no);
+| 411|    |-	p.add("seek_time", &seek_time, "1");
+| 412|    |-	p.add("volume_change_step", &volume_change_step, "2");
+| 413|    |-	p.add("autocenter_mode", &autocenter_mode, "no", yes_no);
+| 414|    |-	p.add("centered_cursor", &centered_cursor, "no", yes_no);
+| 415|    |-	p.add("progressbar_look", &progressbar, "=>", [](std::string v) {
+| 416|    |-			auto result = ToWString(std::move(v));
+| 417|    |-			boundsCheck<std::wstring::size_type>(result.size(), 2, 3);
+| 418|    |-			// If two characters were specified, fill \0 as the third one.
+| 419|    |-			result.resize(3);
+| 420|    |-			return result;
+| 421|    |-	});
+| 422|    |-	p.add("default_place_to_search_in", &search_in_db, "database", [](std::string v) {
+| 423|    |-			if (v == "database")
+| 424|    |-				return true;
+| 425|    |-			else if (v == "playlist")
+| 426|    |-				return false;
+| 427|    |-			else
+| 428|    |-				invalid_value(v);
+| 429|    |-	});
+| 430|    |-	p.add("user_interface", &design, "classic");
+| 431|    |-	p.add("data_fetching_delay", &data_fetching_delay, "yes", yes_no);
+| 432|    |-	p.add("media_library_primary_tag", &media_lib_primary_tag, "artist", [](std::string v) {
+| 433|    |-			if (v == "artist")
+| 434|    |-				return MPD_TAG_ARTIST;
+| 435|    |-			else if (v == "album_artist")
+| 436|    |-				return MPD_TAG_ALBUM_ARTIST;
+| 437|    |-			else if (v == "date")
+| 438|    |-				return MPD_TAG_DATE;
+| 439|    |-			else if (v == "genre")
+| 440|    |-				return MPD_TAG_GENRE;
+| 441|    |-			else if (v == "composer")
+| 442|    |-				return MPD_TAG_COMPOSER;
+| 443|    |-			else if (v == "performer")
+| 444|    |-				return MPD_TAG_PERFORMER;
+| 445|    |-			else
+| 446|    |-				invalid_value(v);
+| 447|    |-		});
+| 448|    |-	p.add("media_library_albums_split_by_date", &media_library_albums_split_by_date, "yes", yes_no);
+| 449|    |-	p.add("default_find_mode", &wrapped_search, "wrapped", [](std::string v) {
+| 450|    |-			if (v == "wrapped")
+| 451|    |-				return true;
+| 452|    |-			else if (v == "normal")
+| 453|    |-				return false;
+| 454|    |-			else
+| 455|    |-				invalid_value(v);
+| 456|    |-		});
+| 457|    |-	p.add("default_tag_editor_pattern", &pattern, "%n - %t");
+| 458|    |-	p.add("header_visibility", &header_visibility, "yes", yes_no);
+| 459|    |-	p.add("statusbar_visibility", &statusbar_visibility, "yes", yes_no);
+| 460|    |-	p.add("titles_visibility", &titles_visibility, "yes", yes_no);
+| 461|    |-	p.add("header_text_scrolling", &header_text_scrolling, "yes", yes_no);
+| 462|    |-	p.add("cyclic_scrolling", &use_cyclic_scrolling, "no", yes_no);
+| 463|    |-	p.add("lines_scrolled", &lines_scrolled, "2");
+| 464|    |-	p.add("lyrics_fetchers", &lyrics_fetchers,
+| 465|    |-	      "lyricwiki, azlyrics, genius, sing365, lyricsmania, metrolyrics, justsomelyrics, jahlyrics, plyrics, tekstowo, internet",
+| 466|    |-	      list_of<LyricsFetcher_>);
+| 467|    |-	p.add("follow_now_playing_lyrics", &now_playing_lyrics, "no", yes_no);
+| 468|    |-	p.add("fetch_lyrics_for_current_song_in_background", &fetch_lyrics_in_background,
+| 469|    |-	      "no", yes_no);
+| 470|    |-	p.add("store_lyrics_in_song_dir", &store_lyrics_in_song_dir, "no", yes_no);
+| 471|    |-	p.add("generate_win32_compatible_filenames", &generate_win32_compatible_filenames,
+| 472|    |-	      "yes", yes_no);
+| 473|    |-	p.add("allow_for_physical_item_deletion", &allow_for_physical_item_deletion,
+| 474|    |-	      "no", yes_no);
+| 475|    |-	p.add("lastfm_preferred_language", &lastfm_preferred_language, "en");
+| 476|    |-	p.add("space_add_mode", &space_add_mode, "add_remove");
+| 477|    |-	p.add("show_hidden_files_in_local_browser", &local_browser_show_hidden_files,
+| 478|    |-	      "no", yes_no);
+| 479|    |-	p.add<void>(
+| 480|    |-		"screen_switcher_mode", nullptr, "playlist, browser",
+| 481|    |-		[this](std::string v) {
+| 482|    |-			if (v == "previous")
+| 483|    |-				screen_switcher_previous = true;
+| 484|    |-			else
+| 485|    |-			{
+| 486|    |-				screen_switcher_previous = false;
+| 487|    |-				screen_sequence = list_of<ScreenType>(v, [](std::string s) {
+| 488|    |-						auto screen = stringtoStartupScreenType(s);
+| 489|    |-						if (screen == ScreenType::Unknown)
+| 490|    |-							invalid_value(s);
+| 491|    |-						return screen;
+| 492|    |-					});
+| 493|    |-			}
+| 494|    |-		});
+| 495|    |-	p.add("startup_screen", &startup_screen_type, "playlist", [](std::string v) {
+| 496|    |-			auto screen = stringtoStartupScreenType(v);
+| 497|    |-			if (screen == ScreenType::Unknown)
+| 498|    |-				invalid_value(v);
+| 499|    |-			return screen;
+| 500|    |-		});
+| 501|    |-	p.add("startup_slave_screen", &startup_slave_screen_type, "", [](std::string v) {
+| 502|    |-			boost::optional<ScreenType> screen;
+| 503|    |-			if (!v.empty())
+| 504|    |-			{
+| 505|    |-				screen = stringtoStartupScreenType(v);
+| 506|    |-				if (screen == ScreenType::Unknown)
+| 507|    |-					invalid_value(v);
+| 508|    |-			}
+| 509|    |-			return screen;
+| 510|    |-		});
+| 511|    |-	p.add("startup_slave_screen_focus", &startup_slave_screen_focus, "no", yes_no);
+| 512|    |-	p.add("locked_screen_width_part", &locked_screen_width_part,
+| 513|    |-	      "50", [](std::string v) {
+| 514|    |-		      return verbose_lexical_cast<double>(v) / 100;
+| 515|    |-	      });
+| 516|    |-	p.add("ask_for_locked_screen_width_part", &ask_for_locked_screen_width_part,
+| 517|    |-	      "yes", yes_no);
+| 518|    |-	p.add("jump_to_now_playing_song_at_start", &jump_to_now_playing_song_at_start,
+| 519|    |-	      "yes", yes_no);
+| 520|    |-	p.add("ask_before_clearing_playlists", &ask_before_clearing_playlists,
+| 521|    |-	      "yes", yes_no);
+| 522|    |-	p.add("ask_before_shuffling_playlists", &ask_before_shuffling_playlists,
+| 523|    |-	      "yes", yes_no);
+| 524|    |-	p.add("clock_display_seconds", &clock_display_seconds, "no", yes_no);
+| 525|    |-	p.add("display_volume_level", &display_volume_level, "yes", yes_no);
+| 526|    |-	p.add("display_bitrate", &display_bitrate, "no", yes_no);
+| 527|    |-	p.add("display_remaining_time", &display_remaining_time, "no", yes_no);
+| 528|    |-	p.add("regular_expressions", &regex_type, "perl", [](std::string v) {
+| 529|    |-			if (v == "none")
+| 530|    |-				return boost::regex::icase | boost::regex::literal;
+| 531|    |-			else if (v == "basic")
+| 532|    |-				return boost::regex::icase | boost::regex::basic;
+| 533|    |-			else if (v == "extended")
+| 534|    |-				return boost::regex::icase |  boost::regex::extended;
+| 535|    |-			else if (v == "perl")
+| 536|    |-				return boost::regex::icase | boost::regex::perl;
+| 537|    |-			else
+| 538|    |-				invalid_value(v);
+| 539|    |-	});
+| 540|    |-	p.add("ignore_leading_the", &ignore_leading_the, "no", yes_no);
+| 541|    |-	p.add("ignore_diacritics", &ignore_diacritics, "no", yes_no);
+| 542|    |-	p.add("block_search_constraints_change_if_items_found",
+| 543|    |-	      &block_search_constraints_change, "yes", yes_no);
+| 544|    |-	p.add("mouse_support", &mouse_support, "yes", yes_no);
+| 545|    |-	p.add("mouse_list_scroll_whole_page", &mouse_list_scroll_whole_page, "yes", yes_no);
+| 546|    |-	p.add("empty_tag_marker", &empty_tag, "<empty>");
+| 547|    |-	p.add("tags_separator", &MPD::Song::TagsSeparator, " | ");
+| 548|    |-	p.add("tag_editor_extended_numeration", &tag_editor_extended_numeration, "no", yes_no);
+| 549|    |-	p.add("media_library_sort_by_mtime", &media_library_sort_by_mtime, "no", yes_no);
+| 550|    |-	p.add("enable_window_title", &set_window_title, "yes", [](std::string v) {
+| 551|    |-			// Consider this variable only if TERM variable is available and we're not
+| 552|    |-			// in emacs terminal nor tty (through any wrapper like screen).
+| 553|    |-			auto term = getenv("TERM");
+| 554|    |-			if (term != nullptr
+| 555|    |-			    && strstr(term, "linux") == nullptr
+| 556|    |-			    && strncmp(term, "eterm", const_strlen("eterm")))
+| 557|    |-				return yes_no(v);
+| 558|    |-			else
+| 559|    |-			{
+| 560|    |-				std::clog << "Terminal doesn't support window title, skipping 'enable_window_title'.\n";
+| 561|    |-				return false;
+| 562|    |-			}
+| 563|    |-		});
+| 564|    |-	p.add("search_engine_default_search_mode", &search_engine_default_search_mode,
+| 565|    |-	      "1", [](std::string v) {
+| 566|    |-		      auto mode = verbose_lexical_cast<unsigned>(v);
+| 567|    |-		      boundsCheck<unsigned>(mode, 1, 3);
+| 568|    |-		      return --mode;
+| 569|    |-	      });
+| 570|    |-	p.add("external_editor", &external_editor, "nano", adjust_path);
+| 571|    |-	p.add("use_console_editor", &use_console_editor, "yes", yes_no);
+| 572|    |-	p.add("colors_enabled", &colors_enabled, "yes", yes_no);
+| 573|    |-	p.add("empty_tag_color", &empty_tags_color, "cyan");
+| 574|    |-	p.add("header_window_color", &header_color, "default");
+| 575|    |-	p.add("volume_color", &volume_color, "default");
+| 576|    |-	p.add("state_line_color", &state_line_color, "default");
+| 577|    |-	p.add("state_flags_color", &state_flags_color, "default:b");
+| 578|    |-	p.add("main_window_color", &main_color, "yellow");
+| 579|    |-	p.add("color1", &color1, "white");
+| 580|    |-	p.add("color2", &color2, "green");
+| 581|    |-	p.add("progressbar_color", &progressbar_color, "black:b");
+| 582|    |-	p.add("progressbar_elapsed_color", &progressbar_elapsed_color, "green:b");
+| 583|    |-	p.add("statusbar_color", &statusbar_color, "default");
+| 584|    |-	p.add("statusbar_time_color", &statusbar_time_color, "default:b");
+| 585|    |-	p.add("player_state_color", &player_state_color, "default:b");
+| 586|    |-	p.add("alternative_ui_separator_color", &alternative_ui_separator_color, "black:b");
+| 587|    |-	p.add("window_border_color", &window_border, "green", verbose_lexical_cast<NC::Color>);
+| 588|    |-	p.add("active_window_border", &active_window_border, "red",
+| 589|    |-	      verbose_lexical_cast<NC::Color>);
+| 590|    |-
+| 591|    |-	return std::all_of(
+| 592|    |-		config_paths.begin(),
+| 593|    |-		config_paths.end(),
+| 594|    |-		[&](const std::string &config_path) {
+| 595|    |-			std::ifstream f(config_path);
+| 596|    |-			if (f.is_open())
+| 597|    |-				std::clog << "Reading configuration from " << config_path << "...\n";
+| 598|    |-			return p.run(f, ignore_errors);
+| 599|    |-		}
+| 600|    |-	) && p.initialize_undefined(ignore_errors);
+| 601|    |-}
+
+src/settings.cpp
+|  40| Configuration•Config;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Config'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  24|  24| #include "curses/window.h"
+|  25|  25| #include "curses/strbuffer.h"
+|  26|  26| 
+|  27|    |-namespace NC {
+|    |  27|+namespace NC
+|    |  28|+{
+|  28|  29| 
+|  29|  30| /// Scrollpad is specialized window that holds large portions of text and
+|  30|  31| /// supports scrolling if the amount of it is bigger than the window area.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  28|  28| 
+|  29|  29| /// Scrollpad is specialized window that holds large portions of text and
+|  30|  30| /// supports scrolling if the amount of it is bigger than the window area.
+|  31|    |-struct Scrollpad: public Window
+|  32|    |-{
+|  33|    |-	Scrollpad() { }
+|  34|    |-	
+|  35|    |-	Scrollpad(size_t startx, size_t starty, size_t width, size_t height,
+|  36|    |-	          const std::string &title, Color color, Border border);
+|  37|    |-	
+|  38|    |-	// override a few Window functions
+|  39|    |-	virtual void refresh() override;
+|  40|    |-	virtual void scroll(Scroll where) override;
+|  41|    |-	virtual void resize(size_t new_width, size_t new_height) override;
+|  42|    |-	virtual void clear() override;
+|  43|    |-	
+|  44|    |-	const std::string &buffer();
+|  45|    |-	
+|  46|    |-	void flush();
+|  47|    |-	void reset();
+|  48|    |-	
+|  49|    |-	bool setProperties(const Color &begin, const std::string &s, const Color &end,
+|  50|    |-	                   size_t flags, size_t id = -2);
+|  51|    |-	bool setProperties(const Format &begin, const std::string &s, const Format &end,
+|  52|    |-	                   size_t flags, size_t id = -2);
+|  53|    |-	bool setProperties(const FormattedColor &fc, const std::string &s,
+|  54|    |-	                   size_t flags, size_t id = -2);
+|  55|    |-	void removeProperties(size_t id = -2);
+|  56|    |-	
+|  57|    |-	Scrollpad &operator<<(int n) { return write(n); }
+|  58|    |-	Scrollpad &operator<<(long int n) { return write(n); }
+|  59|    |-	Scrollpad &operator<<(unsigned int n) { return write(n); }
+|  60|    |-	Scrollpad &operator<<(unsigned long int n) { return write(n); }
+|  61|    |-	Scrollpad &operator<<(char c) { return write(c); }
+|  62|    |-	Scrollpad &operator<<(const char *s) { return write(s); }
+|  63|    |-	Scrollpad &operator<<(const std::string &s) { return write(s); }
+|  64|    |-	Scrollpad &operator<<(Color color) { return write(color); }
+|  65|    |-	Scrollpad &operator<<(Format format) { return write(format); }
+|    |  31|+    struct Scrollpad:public Window
+|    |  32|+    {
+|    |  33|+        Scrollpad ()
+|    |  34|+        {
+|    |  35|+        }
+|  66|  36| 
+|  67|    |-private:
+|  68|    |-	template <typename ItemT>
+|  69|    |-	Scrollpad &write(ItemT &&item)
+|  70|    |-	{
+|  71|    |-		m_buffer << std::forward<ItemT>(item);
+|  72|    |-		return *this;
+|  73|    |-	}
+|    |  37|+        Scrollpad (size_t startx, size_t starty, size_t width, size_t height,
+|    |  38|+                   const std::string & title, Color color, Border border);
+|  74|  39| 
+|  75|    |-	Buffer m_buffer;
+|  76|    |-	
+|  77|    |-	size_t m_beginning;
+|  78|    |-	size_t m_real_height;
+|  79|    |-};
+|    |  40|+        // override a few Window functions
+|    |  41|+        virtual void refresh () override;
+|    |  42|+        virtual void scroll (Scroll where) override;
+|    |  43|+        virtual void resize (size_t new_width, size_t new_height) override;
+|    |  44|+        virtual void clear () override;
+|    |  45|+
+|    |  46|+        const std::string & buffer ();
+|    |  47|+
+|    |  48|+        void flush ();
+|    |  49|+        void reset ();
+|    |  50|+
+|    |  51|+        bool setProperties (const Color & begin, const std::string & s,
+|    |  52|+                            const Color & end, size_t flags, size_t id = -2);
+|    |  53|+        bool setProperties (const Format & begin, const std::string & s,
+|    |  54|+                            const Format & end, size_t flags, size_t id = -2);
+|    |  55|+        bool setProperties (const FormattedColor & fc, const std::string & s,
+|    |  56|+                            size_t flags, size_t id = -2);
+|    |  57|+        void removeProperties (size_t id = -2);
+|    |  58|+
+|    |  59|+          Scrollpad & operator<< (int n)
+|    |  60|+        {
+|    |  61|+            return write (n);
+|    |  62|+        }
+|    |  63|+        Scrollpad & operator<< (long int n)
+|    |  64|+        {
+|    |  65|+            return write (n);
+|    |  66|+        }
+|    |  67|+        Scrollpad & operator<< (unsigned int n)
+|    |  68|+        {
+|    |  69|+            return write (n);
+|    |  70|+        }
+|    |  71|+        Scrollpad & operator<< (unsigned long int n)
+|    |  72|+        {
+|    |  73|+            return write (n);
+|    |  74|+        }
+|    |  75|+        Scrollpad & operator<< (char c)
+|    |  76|+        {
+|    |  77|+            return write (c);
+|    |  78|+        }
+|    |  79|+        Scrollpad & operator<< (const char *s)
+|    |  80|+        {
+|    |  81|+            return write (s);
+|    |  82|+        }
+|    |  83|+        Scrollpad & operator<< (const std::string & s)
+|    |  84|+        {
+|    |  85|+            return write (s);
+|    |  86|+        }
+|    |  87|+        Scrollpad & operator<< (Color color)
+|    |  88|+        {
+|    |  89|+            return write (color);
+|    |  90|+        }
+|    |  91|+        Scrollpad & operator<< (Format format)
+|    |  92|+        {
+|    |  93|+            return write (format);
+|    |  94|+        }
+|    |  95|+
+|    |  96|+      private:
+|    |  97|+        template < typename ItemT > Scrollpad & write (ItemT && item)
+|    |  98|+        {
+|    |  99|+            m_buffer << std::forward < ItemT > (item);
+|    | 100|+            return *this;
+|    | 101|+        }
+|    | 102|+
+|    | 103|+        Buffer m_buffer;
+|    | 104|+
+|    | 105|+        size_t m_beginning;
+|    | 106|+        size_t m_real_height;
+|    | 107|+    };
+|  80| 108| 
+|  81| 109| }
+|  82| 110| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  81|  81| }
+|  82|  82| 
+|  83|  83| #endif // NCMPCPP_SCROLLPAD_H
+|  84|    |-
+
+src/curses/scrollpad.h
+|  24| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+
+src/curses/scrollpad.h
+|  25| #include•"curses/strbuffer.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/strbuffer.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.cpp
+|    |++++| /app/src/helpers.cpp
+|  29|  29| #include "statusbar.h"
+|  30|  30| #include "utility/functional.h"
+|  31|  31| 
+|  32|    |-const MPD::Song *currentSong(const BaseScreen *screen)
+|  33|    |-{
+|  34|    |-	const MPD::Song *ptr = nullptr;
+|  35|    |-	const auto *list = dynamic_cast<const SongList *>(screen->activeWindow());
+|  36|    |-	if (list != nullptr)
+|  37|    |-	{
+|  38|    |-		const auto it = list->currentS();
+|  39|    |-		if (it != list->endS())
+|  40|    |-			ptr = it->song();
+|  41|    |-	}
+|  42|    |-	return ptr;
+|  43|    |-}
+|  44|    |-
+|  45|    |-MPD::SongIterator getDatabaseIterator(MPD::Connection &mpd)
+|  46|    |-{
+|  47|    |-	MPD::SongIterator result;
+|  48|    |-	try
+|  49|    |-	{
+|  50|    |-		result = mpd.GetDirectoryRecursive("/");
+|  51|    |-	}
+|  52|    |-	catch (MPD::ClientError &e)
+|  53|    |-	{
+|  54|    |-		if (e.code() == MPD_ERROR_CLOSED)
+|  55|    |-		{
+|  56|    |-			// If we can't get the database, display appropriate
+|  57|    |-			// error message and reconnect with the MPD server.
+|  58|    |-			Statusbar::print("Unable to fetch the data, increase max_output_buffer_size in your MPD configuration file");
+|  59|    |-			mpd.Disconnect();
+|  60|    |-			mpd.Connect();
+|  61|    |-		}
+|  62|    |-		else
+|  63|    |-			throw;
+|  64|    |-	}
+|  65|    |-	catch (MPD::ServerError &e)
+|  66|    |-	{
+|  67|    |-		// mopidy blacklists 'listallinfo' command by default and throws server
+|  68|    |-		// error when it receives it. Work around that to prevent ncmpcpp from
+|  69|    |-		// continuously retrying to send the command and looping.
+|  70|    |-		if (strstr(e.what(), "listallinfo") != nullptr
+|  71|    |-		    && strstr(e.what(), "disabled") != nullptr)
+|  72|    |-			Statusbar::print("Unable to fetch the data, server refused to process 'listallinfo' command");
+|  73|    |-		else
+|  74|    |-			throw;
+|  75|    |-	}
+|  76|    |-	return result;
+|  77|    |-}
+|  78|    |-
+|  79|    |-void removeSongFromPlaylist(const SongMenu &playlist, const MPD::Song &s)
+|  80|    |-{
+|  81|    |-	Mpd.StartCommandsList();
+|  82|    |-	for (auto &item : boost::adaptors::reverse(playlist))
+|  83|    |-		if (item.value() == s)
+|  84|    |-			Mpd.Delete(item.value().getPosition());
+|  85|    |-	Mpd.CommitCommandsList();
+|  86|    |-}
+|  87|    |-
+|  88|    |-bool addSongToPlaylist(const MPD::Song &s, bool play, int position)
+|  89|    |-{
+|  90|    |-	bool result = false;
+|  91|    |-	if (Config.space_add_mode == SpaceAddMode::AddRemove
+|  92|    |-	&&  myPlaylist->checkForSong(s)
+|  93|    |-	   )
+|  94|    |-	{
+|  95|    |-		result = true;
+|  96|    |-		if (play)
+|  97|    |-		{
+|  98|    |-			const auto begin = myPlaylist->main().beginV(), end = myPlaylist->main().endV();
+|  99|    |-			auto it = find_map_first(begin, end, s, [](const MPD::Song &found) {
+| 100|    |-				Mpd.PlayID(found.getID());
+| 101|    |-			});
+| 102|    |-			assert(it != end);
+| 103|    |-		}
+| 104|    |-		else
+| 105|    |-			removeSongFromPlaylist(myPlaylist->main(), s);
+| 106|    |-		return result;
+| 107|    |-	}
+| 108|    |-	int id = Mpd.AddSong(s, position);
+| 109|    |-	if (id >= 0)
+| 110|    |-	{
+| 111|    |-		Statusbar::printf("Added to playlist: %s",
+| 112|    |-			Format::stringify<char>(Config.song_status_format, &s)
+| 113|    |-		);
+| 114|    |-		if (play)
+| 115|    |-			Mpd.PlayID(id);
+| 116|    |-		result = true;
+| 117|    |-	}
+| 118|    |-	return result;
+| 119|    |-}
+| 120|    |-
+| 121|    |-std::string timeFormat(const char *format, time_t t)
+| 122|    |-{
+| 123|    |-	char result[32];
+| 124|    |-	tm tinfo;
+| 125|    |-	localtime_r(&t, &tinfo);
+| 126|    |-	strftime(result, sizeof(result), format, &tinfo);
+| 127|    |-	return result;
+| 128|    |-}
+| 129|    |-
+| 130|    |-std::string Timestamp(time_t t)
+| 131|    |-{
+| 132|    |-	char result[32];
+| 133|    |-	tm info;
+| 134|    |-	result[strftime(result, 31, "%x %X", localtime_r(&t, &info))] = 0;
+| 135|    |-	return result;
+| 136|    |-}
+| 137|    |-
+| 138|    |-std::wstring Scroller(const std::wstring &str, size_t &pos, size_t width)
+| 139|    |-{
+| 140|    |-	std::wstring s(str);
+| 141|    |-	if (!Config.header_text_scrolling)
+| 142|    |-		return s;
+| 143|    |-	std::wstring result;
+| 144|    |-	size_t len = wideLength(s);
+| 145|    |-	
+| 146|    |-	if (len > width)
+| 147|    |-	{
+| 148|    |-		s += L" ** ";
+| 149|    |-		len = 0;
+| 150|    |-		auto b = s.begin(), e = s.end();
+| 151|    |-		for (auto it = b+pos; it < e && len < width; ++it)
+| 152|    |-		{
+| 153|    |-			if ((len += wcwidth(*it)) > width)
+| 154|    |-				break;
+| 155|    |-			result += *it;
+| 156|    |-		}
+| 157|    |-		if (++pos >= s.length())
+| 158|    |-			pos = 0;
+| 159|    |-		for (; len < width; ++b)
+| 160|    |-		{
+| 161|    |-			if ((len += wcwidth(*b)) > width)
+| 162|    |-				break;
+| 163|    |-			result += *b;
+| 164|    |-		}
+| 165|    |-	}
+| 166|    |-	else
+| 167|    |-		result = s;
+| 168|    |-	return result;
+| 169|    |-}
+| 170|    |-
+| 171|    |-void writeCyclicBuffer(const NC::WBuffer &buf, NC::Window &w, size_t &start_pos,
+| 172|    |-                       size_t width, const std::wstring &separator)
+| 173|    |-{
+| 174|    |-	const auto &s = buf.str();
+| 175|    |-	size_t len = wideLength(s);
+| 176|    |-	if (len > width)
+| 177|    |-	{
+| 178|    |-		len = 0;
+| 179|    |-		const auto &ps = buf.properties();
+| 180|    |-		auto p = ps.begin();
+| 181|    |-		
+| 182|    |-		// load attributes from before starting pos
+| 183|    |-		for (; p != ps.end() && p->first < start_pos; ++p)
+| 184|    |-			w << p->second;
+| 185|    |-		
+| 186|    |-		auto write_buffer = [&](size_t start) {
+| 187|    |-			for (size_t i = start; i < s.length() && len < width; ++i)
+| 188|    |-			{
+| 189|    |-				for (; p != ps.end() && p->first == i; ++p)
+| 190|    |-					w << p->second;
+| 191|    |-				len += wcwidth(s[i]);
+| 192|    |-				if (len > width)
+| 193|    |-					break;
+| 194|    |-				w << s[i];
+| 195|    |-			}
+| 196|    |-			for (; p != ps.end(); ++p)
+| 197|    |-				w << p->second;
+| 198|    |-			p = ps.begin();
+| 199|    |-		};
+| 200|    |-		
+| 201|    |-		write_buffer(start_pos);
+| 202|    |-		size_t i = 0;
+| 203|    |-		if (start_pos > s.length())
+| 204|    |-			i = start_pos - s.length();
+| 205|    |-		for (; i < separator.length() && len < width; ++i)
+| 206|    |-		{
+| 207|    |-			len += wcwidth(separator[i]);
+| 208|    |-			if (len > width)
+| 209|    |-				break;
+| 210|    |-			w << separator[i];
+| 211|    |-		}
+| 212|    |-		write_buffer(0);
+| 213|    |-		
+| 214|    |-		++start_pos;
+| 215|    |-		if (start_pos >= s.length() + separator.length())
+| 216|    |-			start_pos = 0;
+| 217|    |-	}
+| 218|    |-	else
+| 219|    |-		w << buf;
+| 220|    |-}
+|    |  32|+const
+|    |  33|+    MPD::Song *
+|    |  34|+currentSong (const BaseScreen * screen)
+|    |  35|+{
+|    |  36|+    const MPD::Song * ptr = nullptr;
+|    |  37|+    const auto *list =
+|    |  38|+        dynamic_cast < const SongList * >(screen->activeWindow ());
+|    |  39|+    if (list != nullptr)
+|    |  40|+      {
+|    |  41|+          const auto it = list->currentS ();
+|    |  42|+          if (it != list->endS ())
+|    |  43|+              ptr = it->song ();
+|    |  44|+      }
+|    |  45|+    return ptr;
+|    |  46|+}
+|    |  47|+
+|    |  48|+MPD::SongIterator getDatabaseIterator (MPD::Connection & mpd)
+|    |  49|+{
+|    |  50|+    MPD::SongIterator result;
+|    |  51|+    try
+|    |  52|+    {
+|    |  53|+        result = mpd.GetDirectoryRecursive ("/");
+|    |  54|+    }
+|    |  55|+    catch (MPD::ClientError & e)
+|    |  56|+    {
+|    |  57|+        if (e.code () == MPD_ERROR_CLOSED)
+|    |  58|+          {
+|    |  59|+              // If we can't get the database, display appropriate
+|    |  60|+              // error message and reconnect with the MPD server.
+|    |  61|+              Statusbar::
+|    |  62|+                  print
+|    |  63|+                  ("Unable to fetch the data, increase max_output_buffer_size in your MPD configuration file");
+|    |  64|+              mpd.Disconnect ();
+|    |  65|+              mpd.Connect ();
+|    |  66|+          }
+|    |  67|+        else
+|    |  68|+            throw;
+|    |  69|+    }
+|    |  70|+    catch (MPD::ServerError & e)
+|    |  71|+    {
+|    |  72|+        // mopidy blacklists 'listallinfo' command by default and throws server
+|    |  73|+        // error when it receives it. Work around that to prevent ncmpcpp from
+|    |  74|+        // continuously retrying to send the command and looping.
+|    |  75|+        if (strstr (e.what (), "listallinfo") != nullptr
+|    |  76|+            && strstr (e.what (), "disabled") != nullptr)
+|    |  77|+            Statusbar::
+|    |  78|+                print
+|    |  79|+                ("Unable to fetch the data, server refused to process 'listallinfo' command");
+|    |  80|+        else
+|    |  81|+            throw;
+|    |  82|+    }
+|    |  83|+    return result;
+|    |  84|+}
+|    |  85|+
+|    |  86|+void
+|    |  87|+removeSongFromPlaylist (const SongMenu & playlist, const MPD::Song & s)
+|    |  88|+{
+|    |  89|+    Mpd.StartCommandsList ();
+|    |  90|+  for (auto & item:boost::adaptors::reverse (playlist))
+|    |  91|+        if (item.value () == s)
+|    |  92|+            Mpd.Delete (item.value ().getPosition ());
+|    |  93|+    Mpd.CommitCommandsList ();
+|    |  94|+}
+|    |  95|+
+|    |  96|+bool
+|    |  97|+addSongToPlaylist (const MPD::Song & s, bool play, int position)
+|    |  98|+{
+|    |  99|+    bool result = false;
+|    | 100|+    if (Config.space_add_mode == SpaceAddMode::AddRemove
+|    | 101|+        && myPlaylist->checkForSong (s))
+|    | 102|+      {
+|    | 103|+          result = true;
+|    | 104|+          if (play)
+|    | 105|+            {
+|    | 106|+                const auto begin = myPlaylist->main ().beginV (), end =
+|    | 107|+                    myPlaylist->main ().endV ();
+|    | 108|+                auto it =
+|    | 109|+                    find_map_first (begin, end, s,[](const MPD::Song & found) {
+|    | 110|+                                    Mpd.PlayID (found.getID ());});
+|    | 111|+                assert (it != end);
+|    | 112|+            }
+|    | 113|+          else
+|    | 114|+              removeSongFromPlaylist (myPlaylist->main (), s);
+|    | 115|+          return result;
+|    | 116|+      }
+|    | 117|+    int id = Mpd.AddSong (s, position);
+|    | 118|+    if (id >= 0)
+|    |