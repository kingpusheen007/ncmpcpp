diff --git a/.coafile b/.coafile
new file mode 100644
index 0000000..8d3c698
--- /dev/null
+++ b/.coafile
@@ -0,0 +1,14 @@
+# Generated by coala-quickstart on 12 Jan 2018.
+[default]
+bears = InvalidLinkBear, FilenameBear, coalaBear
+files = **.cpp, **.yml, **.h
+ignore = 
+[c++]
+bears = GNUIndentBear, ClangComplexityBear, CPPCleanBear, CPPCheckBear
+files = **.cpp, **.h
+[c]
+bears = GNUIndentBear, ClangComplexityBear, CSecurityBear
+files = **.h
+[yaml]
+bears = LineLengthBear, YAMLLintBear
+files = **.yml
diff --git a/coala-ci.log b/coala-ci.log
new file mode 100644
index 0000000..5c4d02b
--- /dev/null
+++ b/coala-ci.log
@@ -0,0 +1,79284 @@
+Executing section Default...
+
+.travis.yml
+|  12| ••#•Create•two•diff•files,•and•upload•to•https://clbin.com
+|    | [MAJOR] InvalidLinkBear:
+|    | Broken link - unable to connect to https://clbin.com
+
+.travis.yml
+|  20| ••#•Upload•logs•to•https://clbin.com
+|    | [MAJOR] InvalidLinkBear:
+|    | Broken link - unable to connect to https://clbin.com
+Executing section c++...
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/menu.h
+|    |++++| /app/src/curses/menu.h
+|  34|  34| #include "curses/window.h"
+|  35|  35| #include "utility/const.h"
+|  36|  36| 
+|  37|    |-namespace NC {
+|  38|    |-
+|  39|    |-struct List
+|    |  37|+namespace NC
+|  40|  38| {
+|  41|    |-	struct Properties
+|  42|    |-	{
+|  43|    |-		enum Type {
+|  44|    |-			None       = 0,
+|  45|    |-			Selectable = (1 << 0),
+|  46|    |-			Selected   = (1 << 1),
+|  47|    |-			Inactive   = (1 << 2),
+|  48|    |-			Separator  = (1 << 3)
+|  49|    |-		};
+|  50|    |-
+|  51|    |-		Properties(Type properties = Selectable)
+|  52|    |-		: m_properties(properties)
+|  53|    |-		{ }
+|  54|    |-
+|  55|    |-		void setSelectable(bool is_selectable)
+|  56|    |-		{
+|  57|    |-			if (is_selectable)
+|  58|    |-				m_properties |= Selectable;
+|  59|    |-			else
+|  60|    |-				m_properties &= ~(Selectable | Selected);
+|  61|    |-		}
+|  62|    |-		void setSelected(bool is_selected)
+|  63|    |-		{
+|  64|    |-			if (!isSelectable())
+|  65|    |-				return;
+|  66|    |-			if (is_selected)
+|  67|    |-				m_properties |= Selected;
+|  68|    |-			else
+|  69|    |-				m_properties &= ~Selected;
+|  70|    |-		}
+|  71|    |-		void setInactive(bool is_inactive)
+|  72|    |-		{
+|  73|    |-			if (is_inactive)
+|  74|    |-				m_properties |= Inactive;
+|  75|    |-			else
+|  76|    |-				m_properties &= ~Inactive;
+|  77|    |-		}
+|  78|    |-		void setSeparator(bool is_separator)
+|  79|    |-		{
+|  80|    |-			if (is_separator)
+|  81|    |-				m_properties |= Separator;
+|  82|    |-			else
+|  83|    |-				m_properties &= ~Separator;
+|  84|    |-		}
+|  85|    |-
+|  86|    |-		bool isSelectable() const { return m_properties & Selectable; }
+|  87|    |-		bool isSelected() const { return m_properties & Selected; }
+|  88|    |-		bool isInactive() const { return m_properties & Inactive; }
+|  89|    |-		bool isSeparator() const { return m_properties & Separator; }
+|  90|    |-
+|  91|    |-	private:
+|  92|    |-		unsigned m_properties;
+|  93|    |-	};
+|  94|    |-
+|  95|    |-	template <typename ValueT>
+|  96|    |-	using PropertiesIterator = boost::range_detail::any_iterator<
+|  97|    |-		ValueT,
+|  98|    |-		boost::random_access_traversal_tag,
+|  99|    |-		ValueT &,
+| 100|    |-		std::ptrdiff_t
+| 101|    |-	>;
+| 102|    |-
+| 103|    |-	typedef PropertiesIterator<Properties> Iterator;
+| 104|    |-	typedef PropertiesIterator<const Properties> ConstIterator;
+| 105|    |-
+| 106|    |-	virtual ~List() { }
+| 107|    |-
+| 108|    |-	virtual bool empty() const = 0;
+| 109|    |-	virtual size_t size() const = 0;
+| 110|    |-	virtual size_t choice() const = 0;
+| 111|    |-	virtual void highlight(size_t pos) = 0;
+| 112|    |-
+| 113|    |-	virtual Iterator currentP() = 0;
+| 114|    |-	virtual ConstIterator currentP() const = 0;
+| 115|    |-	virtual Iterator beginP() = 0;
+| 116|    |-	virtual ConstIterator beginP() const = 0;
+| 117|    |-	virtual Iterator endP() = 0;
+| 118|    |-	virtual ConstIterator endP() const = 0;
+| 119|    |-};
+| 120|    |-
+| 121|    |-inline List::Properties::Type operator|(List::Properties::Type lhs, List::Properties::Type rhs)
+| 122|    |-{
+| 123|    |-	return List::Properties::Type(unsigned(lhs) | unsigned(rhs));
+|    |  39|+
+|    |  40|+    struct List
+|    |  41|+    {
+|    |  42|+        struct Properties
+|    |  43|+        {
+|    |  44|+            enum Type
+|    |  45|+            {
+|    |  46|+                None = 0,
+|    |  47|+                Selectable = (1 << 0),
+|    |  48|+                Selected = (1 << 1),
+|    |  49|+                Inactive = (1 << 2),
+|    |  50|+                Separator = (1 << 3)
+|    |  51|+            };
+|    |  52|+
+|    |  53|+            Properties (Type properties = Selectable):m_properties
+|    |  54|+                (properties)
+|    |  55|+            {
+|    |  56|+            }
+|    |  57|+
+|    |  58|+            void setSelectable (bool is_selectable)
+|    |  59|+            {
+|    |  60|+                if (is_selectable)
+|    |  61|+                    m_properties |= Selectable;
+|    |  62|+                else
+|    |  63|+                    m_properties &= ~(Selectable | Selected);
+|    |  64|+            }
+|    |  65|+            void setSelected (bool is_selected)
+|    |  66|+            {
+|    |  67|+                if (!isSelectable ())
+|    |  68|+                    return;
+|    |  69|+                if (is_selected)
+|    |  70|+                    m_properties |= Selected;
+|    |  71|+                else
+|    |  72|+                    m_properties &= ~Selected;
+|    |  73|+            }
+|    |  74|+            void setInactive (bool is_inactive)
+|    |  75|+            {
+|    |  76|+                if (is_inactive)
+|    |  77|+                    m_properties |= Inactive;
+|    |  78|+                else
+|    |  79|+                    m_properties &= ~Inactive;
+|    |  80|+            }
+|    |  81|+            void setSeparator (bool is_separator)
+|    |  82|+            {
+|    |  83|+                if (is_separator)
+|    |  84|+                    m_properties |= Separator;
+|    |  85|+                else
+|    |  86|+                    m_properties &= ~Separator;
+|    |  87|+            }
+|    |  88|+
+|    |  89|+            bool isSelectable () const
+|    |  90|+            {
+|    |  91|+                return m_properties & Selectable;
+|    |  92|+            }
+|    |  93|+            bool isSelected () const
+|    |  94|+            {
+|    |  95|+                return m_properties & Selected;
+|    |  96|+            }
+|    |  97|+            bool isInactive () const
+|    |  98|+            {
+|    |  99|+                return m_properties & Inactive;
+|    | 100|+            }
+|    | 101|+            bool isSeparator () const
+|    | 102|+            {
+|    | 103|+                return m_properties & Separator;
+|    | 104|+            }
+|    | 105|+
+|    | 106|+          private:
+|    | 107|+            unsigned m_properties;
+|    | 108|+        };
+|    | 109|+
+|    | 110|+        template < typename ValueT >
+|    | 111|+            using PropertiesIterator = boost::range_detail::any_iterator <
+|    | 112|+            ValueT,
+|    | 113|+            boost::random_access_traversal_tag, ValueT &, std::ptrdiff_t >;
+|    | 114|+
+|    | 115|+        typedef PropertiesIterator < Properties > Iterator;
+|    | 116|+        typedef PropertiesIterator < const Properties > ConstIterator;
+|    | 117|+
+|    | 118|+        virtual ~ List ()
+|    | 119|+        {
+|    | 120|+        }
+|    | 121|+
+|    | 122|+        virtual bool empty () const = 0;
+|    | 123|+        virtual size_t size () const = 0;
+|    | 124|+        virtual size_t choice () const = 0;
+|    | 125|+        virtual void highlight (size_t pos) = 0;
+|    | 126|+
+|    | 127|+        virtual Iterator currentP () = 0;
+|    | 128|+        virtual ConstIterator currentP () const = 0;
+|    | 129|+        virtual Iterator beginP () = 0;
+|    | 130|+        virtual ConstIterator beginP () const = 0;
+|    | 131|+        virtual Iterator endP () = 0;
+|    | 132|+        virtual ConstIterator endP () const = 0;
+|    | 133|+    };
+|    | 134|+
+|    | 135|+    inline List::Properties::Type operator| (List::Properties::Type lhs,
+|    | 136|+                                             List::Properties::Type rhs)
+|    | 137|+    {
+|    | 138|+        return List::Properties::Type (unsigned (lhs) | unsigned (rhs));
+|    | 139|+    }
+|    | 140|+    inline List::Properties::Type & operator|= (List::Properties::Type & lhs,
+|    | 141|+                                                List::Properties::Type rhs)
+|    | 142|+    {
+|    | 143|+        lhs = lhs | rhs;
+|    | 144|+        return lhs;
+|    | 145|+    }
+|    | 146|+    inline List::Properties::Type operator& (List::Properties::Type lhs,
+|    | 147|+                                             List::Properties::Type rhs)
+|    | 148|+    {
+|    | 149|+        return List::Properties::Type (unsigned (lhs) & unsigned (rhs));
+|    | 150|+    }
+|    | 151|+    inline List::Properties::Type & operator&= (List::Properties::Type & lhs,
+|    | 152|+                                                List::Properties::Type rhs)
+|    | 153|+    {
+|    | 154|+        lhs = lhs & rhs;
+|    | 155|+        return lhs;
+|    | 156|+    }
+|    | 157|+
+|    | 158|+// for range-based for loop
+|    | 159|+    inline List::Iterator begin (List & list)
+|    | 160|+    {
+|    | 161|+        return list.beginP ();
+|    | 162|+    }
+|    | 163|+    inline List::ConstIterator begin (const List & list)
+|    | 164|+    {
+|    | 165|+        return list.beginP ();
+|    | 166|+    }
+|    | 167|+    inline List::Iterator end (List & list)
+|    | 168|+    {
+|    | 169|+        return list.endP ();
+|    | 170|+    }
+|    | 171|+    inline List::ConstIterator end (const List & list)
+|    | 172|+    {
+|    | 173|+        return list.endP ();
+|    | 174|+    }
+|    | 175|+
+|    | 176|+/// Generic menu capable of holding any std::vector compatible values.
+|    | 177|+    template < typename ItemT > struct Menu:Window, List
+|    | 178|+    {
+|    | 179|+        struct Item
+|    | 180|+        {
+|    | 181|+            friend struct Menu <ItemT >;
+|    | 182|+
+|    | 183|+            typedef ItemT Type;
+|    | 184|+
+|    | 185|+              Item ():m_impl (std::make_shared < std::tuple < ItemT,
+|    | 186|+                              Properties >> ())
+|    | 187|+            {
+|    | 188|+            }
+|    | 189|+
+|    | 190|+            template < typename ValueT, typename PropertiesT >
+|    | 191|+                Item (ValueT
+|    | 192|+                      && value_,
+|    | 193|+                      PropertiesT properties_):m_impl (std::make_shared <
+|    | 194|+                                                       std::tuple < ItemT,
+|    | 195|+                                                       List::
+|    | 196|+                                                       Properties >> (std::
+|    | 197|+                                                                      forward <
+|    | 198|+                                                                      ValueT >
+|    | 199|+                                                                      (value_),
+|    | 200|+                                                                      std::
+|    | 201|+                                                                      forward <
+|    | 202|+                                                                      PropertiesT
+|    | 203|+                                                                      >
+|    | 204|+                                                                      (properties_)))
+|    | 205|+            {
+|    | 206|+            }
+|    | 207|+
+|    | 208|+            ItemT & value ()
+|    | 209|+            {
+|    | 210|+                return std::get < 0 > (*m_impl);
+|    | 211|+            }
+|    | 212|+            const ItemT & value () const
+|    | 213|+            {
+|    | 214|+                return std::get < 0 > (*m_impl);
+|    | 215|+            }
+|    | 216|+
+|    | 217|+            Properties & properties ()
+|    | 218|+            {
+|    | 219|+                return std::get < 1 > (*m_impl);
+|    | 220|+            }
+|    | 221|+            const Properties & properties () const
+|    | 222|+            {
+|    | 223|+                return std::get < 1 > (*m_impl);
+|    | 224|+            }
+|    | 225|+
+|    | 226|+            // Forward methods to List::Properties.
+|    | 227|+            void setSelectable (bool is_selectable)
+|    | 228|+            {
+|    | 229|+                properties ().setSelectable (is_selectable);
+|    | 230|+            }
+|    | 231|+            void setSelected (bool is_selected)
+|    | 232|+            {
+|    | 233|+                properties ().setSelected (is_selected);
+|    | 234|+            }
+|    | 235|+            void setInactive (bool is_inactive)
+|    | 236|+            {
+|    | 237|+                properties ().setInactive (is_inactive);
+|    | 238|+            }
+|    | 239|+            void setSeparator (bool is_separator)
+|    | 240|+            {
+|    | 241|+                properties ().setSeparator (is_separator);
+|    | 242|+            }
+|    | 243|+
+|    | 244|+            bool isSelectable () const
+|    | 245|+            {
+|    | 246|+                return properties ().isSelectable ();
+|    | 247|+            }
+|    | 248|+            bool isSelected () const
+|    | 249|+            {
+|    | 250|+                return properties ().isSelected ();
+|    | 251|+            }
+|    | 252|+            bool isInactive () const
+|    | 253|+            {
+|    | 254|+                return properties ().isInactive ();
+|    | 255|+            }
+|    | 256|+            bool isSeparator () const
+|    | 257|+            {
+|    | 258|+                return properties ().isSeparator ();
+|    | 259|+            }
+|    | 260|+
+|    | 261|+            // Make a deep copy of Item.
+|    | 262|+            Item copy () const
+|    | 263|+            {
+|    | 264|+                return Item (value (), properties ());
+|    | 265|+            }
+|    | 266|+
+|    | 267|+          private:
+|    | 268|+              template < Const const_ > struct ExtractProperties
+|    | 269|+            {
+|    | 270|+                typedef ExtractProperties type;
+|    | 271|+
+|    | 272|+                typedef typename std::conditional <
+|    | 273|+                    const_ == Const::Yes,
+|    | 274|+                    const Properties, Properties >::type Properties_;
+|    | 275|+                typedef typename std::conditional <
+|    | 276|+                    const_ == Const::Yes, const Item, Item >::type Item_;
+|    | 277|+
+|    | 278|+                  Properties_ & operator () (Item_ & i) const
+|    | 279|+                {
+|    | 280|+                    return i.properties ();
+|    | 281|+                }
+|    | 282|+            };
+|    | 283|+
+|    | 284|+            template < Const const_ > struct ExtractValue
+|    | 285|+            {
+|    | 286|+                typedef ExtractValue type;
+|    | 287|+
+|    | 288|+                typedef typename std::conditional <
+|    | 289|+                    const_ == Const::Yes, const ItemT, ItemT >::type Value_;
+|    | 290|+                typedef typename std::conditional <
+|    | 291|+                    const_ == Const::Yes, const Item, Item >::type Item_;
+|    | 292|+
+|    | 293|+                  Value_ & operator () (Item_ & i) const
+|    | 294|+                {
+|    | 295|+                    return i.value ();
+|    | 296|+                }
+|    | 297|+            };
+|    | 298|+
+|    | 299|+            static Item mkSeparator ()
+|    | 300|+            {
+|    | 301|+                Item item;
+|    | 302|+                item.setSelectable (false);
+|    | 303|+                item.setSeparator (true);
+|    | 304|+                return item;
+|    | 305|+            }
+|    | 306|+
+|    | 307|+            std::shared_ptr < std::tuple < ItemT, Properties >> m_impl;
+|    | 308|+        };
+|    | 309|+
+|    | 310|+        typedef typename std::vector < Item >::iterator Iterator;
+|    | 311|+        typedef typename std::vector < Item >::const_iterator ConstIterator;
+|    | 312|+        typedef std::reverse_iterator < Iterator > ReverseIterator;
+|    | 313|+        typedef std::reverse_iterator < ConstIterator > ConstReverseIterator;
+|    | 314|+
+|    | 315|+        typedef boost::transform_iterator <
+|    | 316|+            typename Item::template ExtractValue < Const::No >,
+|    | 317|+            Iterator > ValueIterator;
+|    | 318|+        typedef boost::transform_iterator <
+|    | 319|+            typename Item::template ExtractValue < Const::Yes >,
+|    | 320|+            ConstIterator > ConstValueIterator;
+|    | 321|+        typedef std::reverse_iterator < ValueIterator > ReverseValueIterator;
+|    | 322|+        typedef std::reverse_iterator < ConstValueIterator >
+|    | 323|+            ConstReverseValueIterator;
+|    | 324|+
+|    | 325|+        typedef boost::transform_iterator <
+|    | 326|+            typename Item::template ExtractProperties < Const::No >,
+|    | 327|+            Iterator > PropertiesIterator;
+|    | 328|+        typedef boost::transform_iterator <
+|    | 329|+            typename Item::template ExtractProperties < Const::Yes >,
+|    | 330|+            ConstIterator > ConstPropertiesIterator;
+|    | 331|+
+|    | 332|+        // For compliance with boost utilities.
+|    | 333|+        typedef Iterator iterator;
+|    | 334|+        typedef ConstIterator const_iterator;
+|    | 335|+
+|    | 336|+        /// Function helper prototype used to display each option on the screen.
+|    | 337|+        /// If not set by setItemDisplayer(), menu won't display anything.
+|    | 338|+        /// @see setItemDisplayer()
+|    | 339|+        typedef std::function < void (Menu < ItemT > &) > ItemDisplayer;
+|    | 340|+
+|    | 341|+        typedef std::function < bool (const Item &) > FilterPredicate;
+|    | 342|+
+|    | 343|+        Menu ();
+|    | 344|+
+|    | 345|+        Menu (size_t startx, size_t starty, size_t width, size_t height,
+|    | 346|+              const std::string & title, Color color, Border border);
+|    | 347|+
+|    | 348|+        Menu (const Menu & rhs);
+|    | 349|+        Menu (Menu && rhs);
+|    | 350|+        Menu & operator= (Menu rhs);
+|    | 351|+
+|    | 352|+        /// Sets helper function that is responsible for displaying items
+|    | 353|+        /// @param ptr function pointer that matches the ItemDisplayer prototype
+|    | 354|+        template < typename ItemDisplayerT >
+|    | 355|+            void setItemDisplayer (ItemDisplayerT && displayer);
+|    | 356|+
+|    | 357|+        /// Resizes the list to given size (adequate to std::vector::resize())
+|    | 358|+        /// @param size requested size
+|    | 359|+        void resizeList (size_t new_size);
+|    | 360|+
+|    | 361|+        /// Adds a new option to list
+|    | 362|+        void addItem (ItemT item, Properties::Type properties =
+|    | 363|+                      Properties::Selectable);
+|    | 364|+
+|    | 365|+        /// Adds separator to list
+|    | 366|+        void addSeparator ();
+|    | 367|+
+|    | 368|+        /// Inserts a new option to the list at given position
+|    | 369|+        void insertItem (size_t pos, ItemT item, Properties::Type properties =
+|    | 370|+                         Properties::Selectable);
+|    | 371|+
+|    | 372|+        /// Inserts separator to list at given position
+|    | 373|+        /// @param pos initial position of inserted separator
+|    | 374|+        void insertSeparator (size_t pos);
+|    | 375|+
+|    | 376|+        /// Moves the highlighted position to the given line of window
+|    | 377|+        /// @param y Y position of menu window to be highlighted
+|    | 378|+        /// @return true if the position is reachable, false otherwise
+|    | 379|+        bool Goto (size_t y);
+|    | 380|+
+|    | 381|+        /// Checks if list is empty
+|    | 382|+        /// @return true if list is empty, false otherwise
+|    | 383|+        virtual bool empty () const override
+|    | 384|+        {
+|    | 385|+            return m_items->empty ();
+|    | 386|+        }
+|    | 387|+
+|    | 388|+        /// @return size of the list
+|    | 389|+        virtual size_t size () const override
+|    | 390|+        {
+|    | 391|+            return m_items->size ();
+|    | 392|+        }
+|    | 393|+
+|    | 394|+        /// @return currently highlighted position
+|    | 395|+        virtual size_t choice () const override;
+|    | 396|+
+|    | 397|+        /// Highlights given position
+|    | 398|+        /// @param pos position to be highlighted
+|    | 399|+        virtual void highlight (size_t position) override;
+|    | 400|+
+|    | 401|+        /// Refreshes the menu window
+|    | 402|+        /// @see Window::refresh()
+|    | 403|+        virtual void refresh () override;
+|    | 404|+
+|    | 405|+        /// Scrolls by given amount of lines
+|    | 406|+        /// @param where indicated where exactly one wants to go
+|    | 407|+        /// @see Window::scroll()
+|    | 408|+        virtual void scroll (Scroll where) override;
+|    | 409|+
+|    | 410|+        /// Cleares all options, used filters etc. It doesn't reset highlighted position though.
+|    | 411|+        /// @see reset()
+|    | 412|+        virtual void clear () override;
+|    | 413|+
+|    | 414|+        /// Sets highlighted position to 0
+|    | 415|+        void reset ();
+|    | 416|+
+|    | 417|+        /// Apply filter predicate to items in the menu and show the ones for which it
+|    | 418|+        /// returned true.
+|    | 419|+        template < typename PredicateT > void applyFilter (PredicateT && pred);
+|    | 420|+
+|    | 421|+        /// Reapply previously applied filter.
+|    | 422|+        void reapplyFilter ();
+|    | 423|+
+|    | 424|+        /// Get current filter predicate.
+|    | 425|+        template < typename TargetT > const TargetT *filterPredicate () const;
+|    | 426|+
+|    | 427|+        /// Clear results of applyFilter and show all items.
+|    | 428|+        void clearFilter ();
+|    | 429|+
+|    | 430|+        /// @return true if menu is filtered.
+|    | 431|+        bool isFiltered () const
+|    | 432|+        {
+|    | 433|+            return m_items == &m_filtered_items;
+|    | 434|+        }
+|    | 435|+
+|    | 436|+        /// Show all items.
+|    | 437|+        void showAllItems ()
+|    | 438|+        {
+|    | 439|+            m_items = &m_all_items;
+|    | 440|+        }
+|    | 441|+
+|    | 442|+        /// Show filtered items.
+|    | 443|+        void showFilteredItems ()
+|    | 444|+        {
+|    | 445|+            m_items = &m_filtered_items;
+|    | 446|+        }
+|    | 447|+
+|    | 448|+        /// Sets prefix, that is put before each selected item to indicate its selection
+|    | 449|+        /// Note that the passed variable is not deleted along with menu object.
+|    | 450|+        /// @param b pointer to buffer that contains the prefix
+|    | 451|+        void setSelectedPrefix (const Buffer & b)
+|    | 452|+        {
+|    | 453|+            m_selected_prefix = b;
+|    | 454|+        }
+|    | 455|+
+|    | 456|+        /// Sets suffix, that is put after each selected item to indicate its selection
+|    | 457|+        /// Note that the passed variable is not deleted along with menu object.
+|    | 458|+        /// @param b pointer to buffer that contains the suffix
+|    | 459|+        void setSelectedSuffix (const Buffer & b)
+|    | 460|+        {
+|    | 461|+            m_selected_suffix = b;
+|    | 462|+        }
+|    | 463|+
+|    | 464|+        void setHighlightPrefix (const Buffer & b)
+|    | 465|+        {
+|    | 466|+            m_highlight_prefix = b;
+|    | 467|+        }
+|    | 468|+        void setHighlightSuffix (const Buffer & b)
+|    | 469|+        {
+|    | 470|+            m_highlight_suffix = b;
+|    | 471|+        }
+|    | 472|+
+|    | 473|+        const Buffer & highlightPrefix () const
+|    | 474|+        {
+|    | 475|+            return m_highlight_prefix;
+|    | 476|+        }
+|    | 477|+        const Buffer & highlightSuffix () const
+|    | 478|+        {
+|    | 479|+            return m_highlight_suffix;
+|    | 480|+        }
+|    | 481|+
+|    | 482|+        /// @return state of highlighting
+|    | 483|+        bool isHighlighted ()
+|    | 484|+        {
+|    | 485|+            return m_highlight_enabled;
+|    | 486|+        }
+|    | 487|+
+|    | 488|+        /// Turns on/off highlighting
+|    | 489|+        /// @param state state of hihglighting
+|    | 490|+        void setHighlighting (bool state)
+|    | 491|+        {
+|    | 492|+            m_highlight_enabled = state;
+|    | 493|+        }
+|    | 494|+
+|    | 495|+        /// Turns on/off cyclic scrolling
+|    | 496|+        /// @param state state of cyclic scrolling
+|    | 497|+        void cyclicScrolling (bool state)
+|    | 498|+        {
+|    | 499|+            m_cyclic_scroll_enabled = state;
+|    | 500|+        }
+|    | 501|+
+|    | 502|+        /// Turns on/off centered cursor
+|    | 503|+        /// @param state state of centered cursor
+|    | 504|+        void centeredCursor (bool state)
+|    | 505|+        {
+|    | 506|+            m_autocenter_cursor = state;
+|    | 507|+        }
+|    | 508|+
+|    | 509|+        /// @return currently drawn item. The result is defined only within
+|    | 510|+        /// drawing function that is called by refresh()
+|    | 511|+        /// @see refresh()
+|    | 512|+        ConstIterator drawn () const
+|    | 513|+        {
+|    | 514|+            return begin () + m_drawn_position;
+|    | 515|+        }
+|    | 516|+
+|    | 517|+        /// @param pos requested position
+|    | 518|+        /// @return reference to item at given position
+|    | 519|+        /// @throw std::out_of_range if given position is out of range
+|    | 520|+        Menu < ItemT >::Item & at (size_t pos)
+|    | 521|+        {
+|    | 522|+            return m_items->at (pos);
+|    | 523|+        }
+|    | 524|+
+|    | 525|+        /// @param pos requested position
+|    | 526|+        /// @return const reference to item at given position
+|    | 527|+        /// @throw std::out_of_range if given position is out of range
+|    | 528|+        const Menu < ItemT >::Item & at (size_t pos) const
+|    | 529|+        {
+|    | 530|+            return m_items->at (pos);
+|    | 531|+        }
+|    | 532|+
+|    | 533|+        /// @param pos requested position
+|    | 534|+        /// @return const reference to item at given position
+|    | 535|+        const Menu < ItemT >::Item & operator[] (size_t pos) const
+|    | 536|+        {
+|    | 537|+            return (*m_items)[pos];
+|    | 538|+        }
+|    | 539|+
+|    | 540|+        /// @param pos requested position
+|    | 541|+        /// @return const reference to item at given position
+|    | 542|+        Menu < ItemT >::Item & operator[] (size_t pos)
+|    | 543|+        {
+|    | 544|+            return (*m_items)[pos];
+|    | 545|+        }
+|    | 546|+
+|    | 547|+        Iterator current ()
+|    | 548|+        {
+|    | 549|+            return Iterator (m_items->begin () + m_highlight);
+|    | 550|+        }
+|    | 551|+        ConstIterator current () const
+|    | 552|+        {
+|    | 553|+            return ConstIterator (m_items->begin () + m_highlight);
+|    | 554|+        }
+|    | 555|+        ReverseIterator rcurrent ()
+|    | 556|+        {
+|    | 557|+            if (empty ())
+|    | 558|+                return rend ();
+|    | 559|+            else
+|    | 560|+                return ReverseIterator (++current ());
+|    | 561|+        }
+|    | 562|+        ConstReverseIterator rcurrent () const
+|    | 563|+        {
+|    | 564|+            if (empty ())
+|    | 565|+                return rend ();
+|    | 566|+            else
+|    | 567|+                return ConstReverseIterator (++current ());
+|    | 568|+        }
+|    | 569|+
+|    | 570|+        ValueIterator currentV ()
+|    | 571|+        {
+|    | 572|+            return ValueIterator (m_items->begin () + m_highlight);
+|    | 573|+        }
+|    | 574|+        ConstValueIterator currentV () const
+|    | 575|+        {
+|    | 576|+            return ConstValueIterator (m_items->begin () + m_highlight);
+|    | 577|+        }
+|    | 578|+        ReverseValueIterator rcurrentV ()
+|    | 579|+        {
+|    | 580|+            if (empty ())
+|    | 581|+                return rendV ();
+|    | 582|+            else
+|    | 583|+                return ReverseValueIterator (++currentV ());
+|    | 584|+        }
+|    | 585|+        ConstReverseValueIterator rcurrentV () const
+|    | 586|+        {
+|    | 587|+            if (empty ())
+|    | 588|+                return rendV ();
+|    | 589|+            else
+|    | 590|+                return ConstReverseValueIterator (++currentV ());
+|    | 591|+        }
+|    | 592|+
+|    | 593|+        Iterator begin ()
+|    | 594|+        {
+|    | 595|+            return Iterator (m_items->begin ());
+|    | 596|+        }
+|    | 597|+        ConstIterator begin () const
+|    | 598|+        {
+|    | 599|+            return ConstIterator (m_items->begin ());
+|    | 600|+        }
+|    | 601|+        Iterator end ()
+|    | 602|+        {
+|    | 603|+            return Iterator (m_items->end ());
+|    | 604|+        }
+|    | 605|+        ConstIterator end () const
+|    | 606|+        {
+|    | 607|+            return ConstIterator (m_items->end ());
+|    | 608|+        }
+|    | 609|+
+|    | 610|+        ReverseIterator rbegin ()
+|    | 611|+        {
+|    | 612|+            return ReverseIterator (end ());
+|    | 613|+        }
+|    | 614|+        ConstReverseIterator rbegin () const
+|    | 615|+        {
+|    | 616|+            return ConstReverseIterator (end ());
+|    | 617|+        }
+|    | 618|+        ReverseIterator rend ()
+|    | 619|+        {
+|    | 620|+            return ReverseIterator (begin ());
+|    | 621|+        }
+|    | 622|+        ConstReverseIterator rend () const
+|    | 623|+        {
+|    | 624|+            return ConstReverseIterator (begin ());
+|    | 625|+        }
+|    | 626|+
+|    | 627|+        ValueIterator beginV ()
+|    | 628|+        {
+|    | 629|+            return ValueIterator (begin ());
+|    | 630|+        }
+|    | 631|+        ConstValueIterator beginV () const
+|    | 632|+        {
+|    | 633|+            return ConstValueIterator (begin ());
+|    | 634|+        }
+|    | 635|+        ValueIterator endV ()
+|    | 636|+        {
+|    | 637|+            return ValueIterator (end ());
+|    | 638|+        }
+|    | 639|+        ConstValueIterator endV () const
+|    | 640|+        {
+|    | 641|+            return ConstValueIterator (end ());
+|    | 642|+        }
+|    | 643|+
+|    | 644|+        ReverseValueIterator rbeginV ()
+|    | 645|+        {
+|    | 646|+            return ReverseValueIterator (endV ());
+|    | 647|+        }
+|    | 648|+        ConstReverseIterator rbeginV () const
+|    | 649|+        {
+|    | 650|+            return ConstReverseValueIterator (endV ());
+|    | 651|+        }
+|    | 652|+        ReverseValueIterator rendV ()
+|    | 653|+        {
+|    | 654|+            return ReverseValueIterator (beginV ());
+|    | 655|+        }
+|    | 656|+        ConstReverseValueIterator rendV () const
+|    | 657|+        {
+|    | 658|+            return ConstReverseValueIterator (beginV ());
+|    | 659|+        }
+|    | 660|+
+|    | 661|+        virtual List::Iterator currentP () override
+|    | 662|+        {
+|    | 663|+            return List::
+|    | 664|+                Iterator (PropertiesIterator
+|    | 665|+                          (m_items->begin () + m_highlight));
+|    | 666|+        }
+|    | 667|+        virtual List::ConstIterator currentP () const override
+|    | 668|+        {
+|    | 669|+            return List::
+|    | 670|+                ConstIterator (ConstPropertiesIterator
+|    | 671|+                               (m_items->begin () + m_highlight));
+|    | 672|+        }
+|    | 673|+        virtual List::Iterator beginP () override
+|    | 674|+        {
+|    | 675|+            return List::Iterator (PropertiesIterator (m_items->begin ()));
+|    | 676|+        }
+|    | 677|+        virtual List::ConstIterator beginP () const override
+|    | 678|+        {
+|    | 679|+            return List::
+|    | 680|+                ConstIterator (ConstPropertiesIterator (m_items->begin ()));
+|    | 681|+        }
+|    | 682|+        virtual List::Iterator endP () override
+|    | 683|+        {
+|    | 684|+            return List::Iterator (PropertiesIterator (m_items->end ()));
+|    | 685|+        }
+|    | 686|+        virtual List::ConstIterator endP () const override
+|    | 687|+        {
+|    | 688|+            return List::
+|    | 689|+                ConstIterator (ConstPropertiesIterator (m_items->end ()));
+|    | 690|+        }
+|    | 691|+
+|    | 692|+      private:
+|    | 693|+          bool isHighlightable (size_t pos)
+|    | 694|+        {
+|    | 695|+            return !(*m_items)[pos].isSeparator ()
+|    | 696|+                && !(*m_items)[pos].isInactive ();
+|    | 697|+        }
+|    | 698|+
+|    | 699|+        ItemDisplayer m_item_displayer;
+|    | 700|+        FilterPredicate m_filter_predicate;
+|    | 701|+
+|    | 702|+        std::vector < Item > *m_items;
+|    | 703|+        std::vector < Item > m_all_items;
+|    | 704|+        std::vector < Item > m_filtered_items;
+|    | 705|+
+|    | 706|+        size_t m_beginning;
+|    | 707|+        size_t m_highlight;
+|    | 708|+
+|    | 709|+        bool m_highlight_enabled;
+|    | 710|+        bool m_cyclic_scroll_enabled;
+|    | 711|+
+|    | 712|+        bool m_autocenter_cursor;
+|    | 713|+
+|    | 714|+        size_t m_drawn_position;
+|    | 715|+
+|    | 716|+        Buffer m_highlight_prefix;
+|    | 717|+        Buffer m_highlight_suffix;
+|    | 718|+
+|    | 719|+        Buffer m_selected_prefix;
+|    | 720|+        Buffer m_selected_suffix;
+|    | 721|+    };
+|    | 722|+
+| 124| 723| }
+| 125|    |-inline List::Properties::Type &operator|=(List::Properties::Type &lhs, List::Properties::Type rhs)
+| 126|    |-{
+| 127|    |-	lhs = lhs | rhs;
+| 128|    |-	return lhs;
+| 129|    |-}
+| 130|    |-inline List::Properties::Type operator&(List::Properties::Type lhs, List::Properties::Type rhs)
+| 131|    |-{
+| 132|    |-	return List::Properties::Type(unsigned(lhs) & unsigned(rhs));
+| 133|    |-}
+| 134|    |-inline List::Properties::Type &operator&=(List::Properties::Type &lhs, List::Properties::Type rhs)
+| 135|    |-{
+| 136|    |-	lhs = lhs & rhs;
+| 137|    |-	return lhs;
+| 138|    |-}
+| 139|    |-
+| 140|    |-// for range-based for loop
+| 141|    |-inline List::Iterator begin(List &list) { return list.beginP(); }
+| 142|    |-inline List::ConstIterator begin(const List &list) { return list.beginP(); }
+| 143|    |-inline List::Iterator end(List &list) { return list.endP(); }
+| 144|    |-inline List::ConstIterator end(const List &list) { return list.endP(); }
+| 145|    |-
+| 146|    |-/// Generic menu capable of holding any std::vector compatible values.
+| 147|    |-template <typename ItemT>
+| 148|    |-struct Menu: Window, List
+| 149|    |-{
+| 150|    |-	struct Item
+| 151|    |-	{
+| 152|    |-		friend struct Menu<ItemT>;
+| 153|    |-
+| 154|    |-		typedef ItemT Type;
+| 155|    |-
+| 156|    |-		Item()
+| 157|    |-			: m_impl(std::make_shared<std::tuple<ItemT, Properties>>())
+| 158|    |-		{ }
+| 159|    |-
+| 160|    |-		template <typename ValueT, typename PropertiesT>
+| 161|    |-		Item(ValueT &&value_, PropertiesT properties_)
+| 162|    |-			: m_impl(
+| 163|    |-				std::make_shared<std::tuple<ItemT, List::Properties>>(
+| 164|    |-					std::forward<ValueT>(value_),
+| 165|    |-					std::forward<PropertiesT>(properties_)))
+| 166|    |-		{ }
+| 167|    |-
+| 168|    |-		ItemT &value() { return std::get<0>(*m_impl); }
+| 169|    |-		const ItemT &value() const { return std::get<0>(*m_impl); }
+| 170|    |-
+| 171|    |-		Properties &properties() { return std::get<1>(*m_impl); }
+| 172|    |-		const Properties &properties() const { return std::get<1>(*m_impl); }
+| 173|    |-
+| 174|    |-		// Forward methods to List::Properties.
+| 175|    |-		void setSelectable(bool is_selectable) { properties().setSelectable(is_selectable); }
+| 176|    |-		void setSelected (bool is_selected) { properties().setSelected(is_selected); }
+| 177|    |-		void setInactive (bool is_inactive) { properties().setInactive(is_inactive); }
+| 178|    |-		void setSeparator (bool is_separator) { properties().setSeparator(is_separator); }
+| 179|    |-
+| 180|    |-		bool isSelectable() const { return properties().isSelectable(); }
+| 181|    |-		bool isSelected() const { return properties().isSelected(); }
+| 182|    |-		bool isInactive() const { return properties().isInactive(); }
+| 183|    |-		bool isSeparator() const { return properties().isSeparator(); }
+| 184|    |-
+| 185|    |-		// Make a deep copy of Item.
+| 186|    |-		Item copy() const {
+| 187|    |-			return Item(value(), properties());
+| 188|    |-		}
+| 189|    |-
+| 190|    |-	private:
+| 191|    |-		template <Const const_>
+| 192|    |-		struct ExtractProperties
+| 193|    |-		{
+| 194|    |-			typedef ExtractProperties type;
+| 195|    |-
+| 196|    |-			typedef typename std::conditional<
+| 197|    |-				const_ == Const::Yes,
+| 198|    |-				const Properties,
+| 199|    |-				Properties>::type Properties_;
+| 200|    |-			typedef typename std::conditional<
+| 201|    |-				const_ == Const::Yes,
+| 202|    |-				const Item,
+| 203|    |-				Item>::type Item_;
+| 204|    |-
+| 205|    |-			Properties_ &operator()(Item_ &i) const {
+| 206|    |-				return i.properties();
+| 207|    |-			}
+| 208|    |-		};
+| 209|    |-
+| 210|    |-		template <Const const_>
+| 211|    |-		struct ExtractValue
+| 212|    |-		{
+| 213|    |-			typedef ExtractValue type;
+| 214|    |-
+| 215|    |-			typedef typename std::conditional<
+| 216|    |-				const_ == Const::Yes,
+| 217|    |-				const ItemT,
+| 218|    |-				ItemT>::type Value_;
+| 219|    |-			typedef typename std::conditional<
+| 220|    |-				const_ == Const::Yes,
+| 221|    |-				const Item,
+| 222|    |-				Item>::type Item_;
+| 223|    |-
+| 224|    |-			Value_ &operator()(Item_ &i) const {
+| 225|    |-				return i.value();
+| 226|    |-			}
+| 227|    |-		};
+| 228|    |-
+| 229|    |-		static Item mkSeparator()
+| 230|    |-		{
+| 231|    |-			Item item;
+| 232|    |-			item.setSelectable(false);
+| 233|    |-			item.setSeparator(true);
+| 234|    |-			return item;
+| 235|    |-		}
+| 236|    |-		
+| 237|    |-		std::shared_ptr<std::tuple<ItemT, Properties>> m_impl;
+| 238|    |-	};
+| 239|    |-
+| 240|    |-	typedef typename std::vector<Item>::iterator Iterator;
+| 241|    |-	typedef typename std::vector<Item>::const_iterator ConstIterator;
+| 242|    |-	typedef std::reverse_iterator<Iterator> ReverseIterator;
+| 243|    |-	typedef std::reverse_iterator<ConstIterator> ConstReverseIterator;
+| 244|    |-
+| 245|    |-	typedef boost::transform_iterator<
+| 246|    |-		typename Item::template ExtractValue<Const::No>,
+| 247|    |-		Iterator> ValueIterator;
+| 248|    |-	typedef boost::transform_iterator<
+| 249|    |-		typename Item::template ExtractValue<Const::Yes>,
+| 250|    |-		ConstIterator> ConstValueIterator;
+| 251|    |-	typedef std::reverse_iterator<ValueIterator> ReverseValueIterator;
+| 252|    |-	typedef std::reverse_iterator<ConstValueIterator> ConstReverseValueIterator;
+| 253|    |-	
+| 254|    |-	typedef boost::transform_iterator<
+| 255|    |-		typename Item::template ExtractProperties<Const::No>,
+| 256|    |-		Iterator> PropertiesIterator;
+| 257|    |-	typedef boost::transform_iterator<
+| 258|    |-		typename Item::template ExtractProperties<Const::Yes>,
+| 259|    |-		ConstIterator> ConstPropertiesIterator;
+| 260|    |-
+| 261|    |-	// For compliance with boost utilities.
+| 262|    |-	typedef Iterator iterator;
+| 263|    |-	typedef ConstIterator const_iterator;
+| 264|    |-
+| 265|    |-	/// Function helper prototype used to display each option on the screen.
+| 266|    |-	/// If not set by setItemDisplayer(), menu won't display anything.
+| 267|    |-	/// @see setItemDisplayer()
+| 268|    |-	typedef std::function<void(Menu<ItemT> &)> ItemDisplayer;
+| 269|    |-
+| 270|    |-	typedef std::function<bool(const Item &)> FilterPredicate;
+| 271|    |-
+| 272|    |-	Menu();
+| 273|    |-	
+| 274|    |-	Menu(size_t startx, size_t starty, size_t width, size_t height,
+| 275|    |-			const std::string &title, Color color, Border border);
+| 276|    |-	
+| 277|    |-	Menu(const Menu &rhs);
+| 278|    |-	Menu(Menu &&rhs);
+| 279|    |-	Menu &operator=(Menu rhs);
+| 280|    |-	
+| 281|    |-	/// Sets helper function that is responsible for displaying items
+| 282|    |-	/// @param ptr function pointer that matches the ItemDisplayer prototype
+| 283|    |-	template <typename ItemDisplayerT>
+| 284|    |-	void setItemDisplayer(ItemDisplayerT &&displayer);
+| 285|    |-	
+| 286|    |-	/// Resizes the list to given size (adequate to std::vector::resize())
+| 287|    |-	/// @param size requested size
+| 288|    |-	void resizeList(size_t new_size);
+| 289|    |-	
+| 290|    |-	/// Adds a new option to list
+| 291|    |-	void addItem(ItemT item, Properties::Type properties = Properties::Selectable);
+| 292|    |-	
+| 293|    |-	/// Adds separator to list
+| 294|    |-	void addSeparator();
+| 295|    |-	
+| 296|    |-	/// Inserts a new option to the list at given position
+| 297|    |-	void insertItem(size_t pos, ItemT item, Properties::Type properties = Properties::Selectable);
+| 298|    |-	
+| 299|    |-	/// Inserts separator to list at given position
+| 300|    |-	/// @param pos initial position of inserted separator
+| 301|    |-	void insertSeparator(size_t pos);
+| 302|    |-	
+| 303|    |-	/// Moves the highlighted position to the given line of window
+| 304|    |-	/// @param y Y position of menu window to be highlighted
+| 305|    |-	/// @return true if the position is reachable, false otherwise
+| 306|    |-	bool Goto(size_t y);
+| 307|    |-	
+| 308|    |-	/// Checks if list is empty
+| 309|    |-	/// @return true if list is empty, false otherwise
+| 310|    |-	virtual bool empty() const override { return m_items->empty(); }
+| 311|    |-
+| 312|    |-	/// @return size of the list
+| 313|    |-	virtual size_t size() const override { return m_items->size(); }
+| 314|    |-
+| 315|    |-	/// @return currently highlighted position
+| 316|    |-	virtual size_t choice() const override;
+| 317|    |-
+| 318|    |-	/// Highlights given position
+| 319|    |-	/// @param pos position to be highlighted
+| 320|    |-	virtual void highlight(size_t position) override;
+| 321|    |-	
+| 322|    |-	/// Refreshes the menu window
+| 323|    |-	/// @see Window::refresh()
+| 324|    |-	virtual void refresh() override;
+| 325|    |-	
+| 326|    |-	/// Scrolls by given amount of lines
+| 327|    |-	/// @param where indicated where exactly one wants to go
+| 328|    |-	/// @see Window::scroll()
+| 329|    |-	virtual void scroll(Scroll where) override;
+| 330|    |-	
+| 331|    |-	/// Cleares all options, used filters etc. It doesn't reset highlighted position though.
+| 332|    |-	/// @see reset()
+| 333|    |-	virtual void clear() override;
+| 334|    |-	
+| 335|    |-	/// Sets highlighted position to 0
+| 336|    |-	void reset();
+| 337|    |-
+| 338|    |-	/// Apply filter predicate to items in the menu and show the ones for which it
+| 339|    |-	/// returned true.
+| 340|    |-	template <typename PredicateT>
+| 341|    |-	void applyFilter(PredicateT &&pred);
+| 342|    |-
+| 343|    |-	/// Reapply previously applied filter.
+| 344|    |-	void reapplyFilter();
+| 345|    |-
+| 346|    |-	/// Get current filter predicate.
+| 347|    |-	template <typename TargetT>
+| 348|    |-	const TargetT *filterPredicate() const;
+| 349|    |-
+| 350|    |-	/// Clear results of applyFilter and show all items.
+| 351|    |-	void clearFilter();
+| 352|    |-
+| 353|    |-	/// @return true if menu is filtered.
+| 354|    |-	bool isFiltered() const { return m_items == &m_filtered_items; }
+| 355|    |-
+| 356|    |-	/// Show all items.
+| 357|    |-	void showAllItems() { m_items = &m_all_items; }
+| 358|    |-
+| 359|    |-	/// Show filtered items.
+| 360|    |-	void showFilteredItems() { m_items = &m_filtered_items; }
+| 361|    |-
+| 362|    |-	/// Sets prefix, that is put before each selected item to indicate its selection
+| 363|    |-	/// Note that the passed variable is not deleted along with menu object.
+| 364|    |-	/// @param b pointer to buffer that contains the prefix
+| 365|    |-	void setSelectedPrefix(const Buffer &b) { m_selected_prefix = b; }
+| 366|    |-	
+| 367|    |-	/// Sets suffix, that is put after each selected item to indicate its selection
+| 368|    |-	/// Note that the passed variable is not deleted along with menu object.
+| 369|    |-	/// @param b pointer to buffer that contains the suffix
+| 370|    |-	void setSelectedSuffix(const Buffer &b) { m_selected_suffix = b; }
+| 371|    |-
+| 372|    |-	void setHighlightPrefix(const Buffer &b) { m_highlight_prefix = b; }
+| 373|    |-	void setHighlightSuffix(const Buffer &b) { m_highlight_suffix = b; }
+| 374|    |-
+| 375|    |-	const Buffer &highlightPrefix() const { return m_highlight_prefix; }
+| 376|    |-	const Buffer &highlightSuffix() const { return m_highlight_suffix; }
+| 377|    |-
+| 378|    |-	/// @return state of highlighting
+| 379|    |-	bool isHighlighted() { return m_highlight_enabled; }
+| 380|    |-	
+| 381|    |-	/// Turns on/off highlighting
+| 382|    |-	/// @param state state of hihglighting
+| 383|    |-	void setHighlighting(bool state) { m_highlight_enabled = state; }
+| 384|    |-	
+| 385|    |-	/// Turns on/off cyclic scrolling
+| 386|    |-	/// @param state state of cyclic scrolling
+| 387|    |-	void cyclicScrolling(bool state) { m_cyclic_scroll_enabled = state; }
+| 388|    |-	
+| 389|    |-	/// Turns on/off centered cursor
+| 390|    |-	/// @param state state of centered cursor
+| 391|    |-	void centeredCursor(bool state) { m_autocenter_cursor = state; }
+| 392|    |-	
+| 393|    |-	/// @return currently drawn item. The result is defined only within
+| 394|    |-	/// drawing function that is called by refresh()
+| 395|    |-	/// @see refresh()
+| 396|    |-	ConstIterator drawn() const { return begin() + m_drawn_position; }
+| 397|    |-	
+| 398|    |-	/// @param pos requested position
+| 399|    |-	/// @return reference to item at given position
+| 400|    |-	/// @throw std::out_of_range if given position is out of range
+| 401|    |-	Menu<ItemT>::Item &at(size_t pos) { return m_items->at(pos); }
+| 402|    |-	
+| 403|    |-	/// @param pos requested position
+| 404|    |-	/// @return const reference to item at given position
+| 405|    |-	/// @throw std::out_of_range if given position is out of range
+| 406|    |-	const Menu<ItemT>::Item &at(size_t pos) const { return m_items->at(pos); }
+| 407|    |-	
+| 408|    |-	/// @param pos requested position
+| 409|    |-	/// @return const reference to item at given position
+| 410|    |-	const Menu<ItemT>::Item &operator[](size_t pos) const { return (*m_items)[pos]; }
+| 411|    |-	
+| 412|    |-	/// @param pos requested position
+| 413|    |-	/// @return const reference to item at given position
+| 414|    |-	Menu<ItemT>::Item &operator[](size_t pos) { return (*m_items)[pos]; }
+| 415|    |-	
+| 416|    |-	Iterator current() { return Iterator(m_items->begin() + m_highlight); }
+| 417|    |-	ConstIterator current() const { return ConstIterator(m_items->begin() + m_highlight); }
+| 418|    |-	ReverseIterator rcurrent() {
+| 419|    |-		if (empty())
+| 420|    |-			return rend();
+| 421|    |-		else
+| 422|    |-			return ReverseIterator(++current());
+| 423|    |-	}
+| 424|    |-	ConstReverseIterator rcurrent() const {
+| 425|    |-		if (empty())
+| 426|    |-			return rend();
+| 427|    |-		else
+| 428|    |-			return ConstReverseIterator(++current());
+| 429|    |-	}
+| 430|    |-
+| 431|    |-	ValueIterator currentV() { return ValueIterator(m_items->begin() + m_highlight); }
+| 432|    |-	ConstValueIterator currentV() const { return ConstValueIterator(m_items->begin() + m_highlight); }
+| 433|    |-	ReverseValueIterator rcurrentV() {
+| 434|    |-		if (empty())
+| 435|    |-			return rendV();
+| 436|    |-		else
+| 437|    |-			return ReverseValueIterator(++currentV());
+| 438|    |-	}
+| 439|    |-	ConstReverseValueIterator rcurrentV() const {
+| 440|    |-		if (empty())
+| 441|    |-			return rendV();
+| 442|    |-		else
+| 443|    |-			return ConstReverseValueIterator(++currentV());
+| 444|    |-	}
+| 445|    |-	
+| 446|    |-	Iterator begin() { return Iterator(m_items->begin()); }
+| 447|    |-	ConstIterator begin() const { return ConstIterator(m_items->begin()); }
+| 448|    |-	Iterator end() { return Iterator(m_items->end()); }
+| 449|    |-	ConstIterator end() const { return ConstIterator(m_items->end()); }
+| 450|    |-	
+| 451|    |-	ReverseIterator rbegin() { return ReverseIterator(end()); }
+| 452|    |-	ConstReverseIterator rbegin() const { return ConstReverseIterator(end()); }
+| 453|    |-	ReverseIterator rend() { return ReverseIterator(begin()); }
+| 454|    |-	ConstReverseIterator rend() const { return ConstReverseIterator(begin()); }
+| 455|    |-	
+| 456|    |-	ValueIterator beginV() { return ValueIterator(begin()); }
+| 457|    |-	ConstValueIterator beginV() const { return ConstValueIterator(begin()); }
+| 458|    |-	ValueIterator endV() { return ValueIterator(end()); }
+| 459|    |-	ConstValueIterator endV() const { return ConstValueIterator(end()); }
+| 460|    |-	
+| 461|    |-	ReverseValueIterator rbeginV() { return ReverseValueIterator(endV()); }
+| 462|    |-	ConstReverseIterator rbeginV() const { return ConstReverseValueIterator(endV()); }
+| 463|    |-	ReverseValueIterator rendV() { return ReverseValueIterator(beginV()); }
+| 464|    |-	ConstReverseValueIterator rendV() const { return ConstReverseValueIterator(beginV()); }
+| 465|    |-	
+| 466|    |-	virtual List::Iterator currentP() override {
+| 467|    |-		return List::Iterator(PropertiesIterator(m_items->begin() + m_highlight));
+| 468|    |-	}
+| 469|    |-	virtual List::ConstIterator currentP() const override {
+| 470|    |-		return List::ConstIterator(ConstPropertiesIterator(m_items->begin() + m_highlight));
+| 471|    |-	}
+| 472|    |-	virtual List::Iterator beginP() override {
+| 473|    |-		return List::Iterator(PropertiesIterator(m_items->begin()));
+| 474|    |-	}
+| 475|    |-	virtual List::ConstIterator beginP() const override {
+| 476|    |-		return List::ConstIterator(ConstPropertiesIterator(m_items->begin()));
+| 477|    |-	}
+| 478|    |-	virtual List::Iterator endP() override {
+| 479|    |-		return List::Iterator(PropertiesIterator(m_items->end()));
+| 480|    |-	}
+| 481|    |-	virtual List::ConstIterator endP() const override {
+| 482|    |-		return List::ConstIterator(ConstPropertiesIterator(m_items->end()));
+| 483|    |-	}
+| 484|    |-
+| 485|    |-private:
+| 486|    |-	bool isHighlightable(size_t pos)
+| 487|    |-	{
+| 488|    |-		return !(*m_items)[pos].isSeparator()
+| 489|    |-			&& !(*m_items)[pos].isInactive();
+| 490|    |-	}
+| 491|    |-
+| 492|    |-	ItemDisplayer m_item_displayer;
+| 493|    |-	FilterPredicate m_filter_predicate;
+| 494|    |-
+| 495|    |-	std::vector<Item> *m_items;
+| 496|    |-	std::vector<Item> m_all_items;
+| 497|    |-	std::vector<Item> m_filtered_items;
+| 498|    |-	
+| 499|    |-	size_t m_beginning;
+| 500|    |-	size_t m_highlight;
+| 501|    |-	
+| 502|    |-	bool m_highlight_enabled;
+| 503|    |-	bool m_cyclic_scroll_enabled;
+| 504|    |-	
+| 505|    |-	bool m_autocenter_cursor;
+| 506|    |-	
+| 507|    |-	size_t m_drawn_position;
+| 508|    |-
+| 509|    |-	Buffer m_highlight_prefix;
+| 510|    |-	Buffer m_highlight_suffix;
+| 511|    |-
+| 512|    |-	Buffer m_selected_prefix;
+| 513|    |-	Buffer m_selected_suffix;
+| 514|    |-};
+| 515|    |-
+| 516|    |-}
+| 517| 724| 
+| 518| 725| #endif // NCMPCPP_MENU_H
+
+src/curses/menu.h
+|  32| #include•"curses/formatted_color.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/formatted_color.h'
+
+src/curses/menu.h
+|  33| #include•"curses/strbuffer.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/strbuffer.h'
+
+src/curses/menu.h
+|  34| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+
+src/curses/menu.h
+|  35| #include•"utility/const.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/const.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/shared_resource.h
+|    |++++| /app/src/utility/shared_resource.h
+|  23|  23| 
+|  24|  24| #include <mutex>
+|  25|  25| 
+|  26|    |-template <typename ResourceT>
+|  27|    |-struct Shared
+|    |  26|+template < typename ResourceT > struct Shared
+|  28|  27| {
+|  29|    |-	struct Resource
+|  30|    |-	{
+|  31|    |-		Resource(std::mutex &mutex, ResourceT &resource)
+|  32|    |-			: m_lock(std::unique_lock<std::mutex>(mutex)), m_resource(resource)
+|  33|    |-		{ }
+|    |  28|+    struct Resource
+|    |  29|+    {
+|    |  30|+        Resource (std::mutex & mutex,
+|    |  31|+                  ResourceT & resource):m_lock (std::unique_lock < std::mutex >
+|    |  32|+                                                (mutex)), m_resource (resource)
+|    |  33|+        {
+|    |  34|+        }
+|  34|  35| 
+|  35|    |-		ResourceT &operator*() { return m_resource; }
+|  36|    |-		const ResourceT &operator*() const { return m_resource; }
+|    |  36|+        ResourceT & operator* ()
+|    |  37|+        {
+|    |  38|+            return m_resource;
+|    |  39|+        }
+|    |  40|+        const ResourceT & operator* () const
+|    |  41|+        {
+|    |  42|+            return m_resource;
+|    |  43|+        }
+|  37|  44| 
+|  38|    |-		ResourceT *operator->() { return &m_resource; }
+|  39|    |-		const ResourceT *operator->() const { return &m_resource; }
+|    |  45|+        ResourceT *operator-> ()
+|    |  46|+        {
+|    |  47|+            return &m_resource;
+|    |  48|+        }
+|    |  49|+        const ResourceT *operator-> () const
+|    |  50|+        {
+|    |  51|+            return &m_resource;
+|    |  52|+        }
+|  40|  53| 
+|  41|    |-	private:
+|  42|    |-		std::unique_lock<std::mutex> m_lock;
+|  43|    |-		ResourceT &m_resource;
+|  44|    |-	};
+|    |  54|+      private:
+|    |  55|+          std::unique_lock < std::mutex > m_lock;
+|    |  56|+        ResourceT & m_resource;
+|    |  57|+    };
+|  45|  58| 
+|  46|    |-	Shared(){ }
+|    |  59|+    Shared ()
+|    |  60|+    {
+|    |  61|+    }
+|  47|  62| 
+|  48|    |-	template <typename ValueT>
+|  49|    |-	Shared(ValueT &&value)
+|  50|    |-		: m_resource(std::forward<ValueT>(value))
+|  51|    |-	{ }
+|    |  63|+  template < typename ValueT > Shared (ValueT && value):m_resource (std::forward < ValueT >
+|    |  64|+                (value))
+|    |  65|+    {
+|    |  66|+    }
+|  52|  67| 
+|  53|    |-	Resource acquire() { return Resource(m_mutex, m_resource); }
+|    |  68|+    Resource acquire ()
+|    |  69|+    {
+|    |  70|+        return Resource (m_mutex, m_resource);
+|    |  71|+    }
+|  54|  72| 
+|  55|    |-private:
+|  56|    |-	std::mutex m_mutex;
+|  57|    |-	ResourceT m_resource;
+|    |  73|+  private:
+|    |  74|+    std::mutex m_mutex;
+|    |  75|+    ResourceT m_resource;
+|  58|  76| };
+|  59|  77| 
+|  60|  78| #endif // NCMPCPP_UTILITY_SHARED_RESOURCE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/display.h
+|    |++++| /app/src/display.h
+|  28|  28| #include "screens/search_engine.h"
+|  29|  29| #include "song_list.h"
+|  30|  30| 
+|  31|    |-namespace Display {
+|    |  31|+namespace Display
+|    |  32|+{
+|  32|  33| 
+|  33|    |-std::string Columns(size_t);
+|    |  34|+    std::string Columns (size_t);
+|  34|  35| 
+|  35|    |-void SongsInColumns(NC::Menu<MPD::Song> &menu, const SongList &list);
+|    |  36|+    void SongsInColumns (NC::Menu < MPD::Song > &menu, const SongList & list);
+|  36|  37| 
+|  37|    |-void Songs(NC::Menu<MPD::Song> &menu, const SongList &list, const Format::AST<char> &ast);
+|    |  38|+    void Songs (NC::Menu < MPD::Song > &menu, const SongList & list,
+|    |  39|+                const Format::AST < char >&ast);
+|  38|  40| 
+|  39|    |-void Tags(NC::Menu<MPD::MutableSong> &menu);
+|    |  41|+    void Tags (NC::Menu < MPD::MutableSong > &menu);
+|  40|  42| 
+|  41|    |-void SEItems(NC::Menu<SEItem> &menu, const SongList &list);
+|    |  43|+    void SEItems (NC::Menu < SEItem > &menu, const SongList & list);
+|  42|  44| 
+|  43|    |-void Items(NC::Menu<MPD::Item> &menu, const SongList &list);
+|    |  45|+    void Items (NC::Menu < MPD::Item > &menu, const SongList & list);
+|  44|  46| 
+|  45|  47| }
+|  46|  48| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/display.h
+|    |++++| /app/src/display.h
+|  44|  44| 
+|  45|  45| }
+|  46|  46| 
+|  47|    |-#endif // NCMPCPP_DISPLAY_H
+|  48|    |-
+|    |  47|+#endif                          // NCMPCPP_DISPLAY_H
+
+src/display.h
+|  24| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'interfaces.h' does not need to be #included
+
+src/display.h
+|  25| #include•"format.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'format.h' does not need to be #included
+
+src/display.h
+|  26| #include•"menu.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'menu.h'
+
+src/display.h
+|  27| #include•"mutable_song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'mutable_song.h' does not need to be #included; use a forward declaration instead
+
+src/display.h
+|  28| #include•"screens/search_engine.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'screens/search_engine.h' does not need to be #included; use a forward declaration instead
+
+src/display.h
+|  29| #include•"song_list.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'song_list.h' does not need to be #included; use a forward declaration instead
+
+src/display.h
+|  27| #include•"mutable_song.h"
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/title.cpp
+|    |++++| /app/src/title.cpp
+|  26|  26| #include "title.h"
+|  27|  27| #include "utility/wide_string.h"
+|  28|  28| 
+|  29|    |-void windowTitle(const std::string &status)
+|    |  29|+void
+|    |  30|+windowTitle (const std::string & status)
+|  30|  31| {
+|  31|    |-	if (Config.set_window_title)
+|  32|    |-		std::cout << "\033]0;" << status << "\7" << std::flush;
+|    |  32|+    if (Config.set_window_title)
+|    |  33|+        std::cout << "\033]0;" << status << "\7" << std::flush;
+|  33|  34| }
+|  34|  35| 
+|  35|  36| void drawHeader()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/title.cpp
+|    |++++| /app/src/title.cpp
+|  32|  32| 		std::cout << "\033]0;" << status << "\7" << std::flush;
+|  33|  33| }
+|  34|  34| 
+|  35|    |-void drawHeader()
+|    |  35|+void
+|    |  36|+drawHeader ()
+|  36|  37| {
+|  37|    |-	using Global::myScreen;
+|  38|    |-	using Global::wHeader;
+|  39|    |-	using Global::VolumeState;
+|  40|    |-	
+|  41|    |-	if (!Config.header_visibility)
+|  42|    |-		return;
+|  43|    |-	switch (Config.design)
+|  44|    |-	{
+|  45|    |-		case Design::Classic:
+|  46|    |-			*wHeader << NC::XY(0, 0)
+|  47|    |-			         << NC::TermManip::ClearToEOL
+|  48|    |-			         << NC::Format::Bold
+|  49|    |-			         << myScreen->title()
+|  50|    |-			         << NC::Format::NoBold
+|  51|    |-			         << NC::XY(wHeader->getWidth()-VolumeState.length(), 0)
+|  52|    |-			         << Config.volume_color
+|  53|    |-			         << VolumeState
+|  54|    |-			         << NC::FormattedColor::End<>(Config.volume_color);
+|  55|    |-			break;
+|  56|    |-		case Design::Alternative:
+|  57|    |-			std::wstring title = myScreen->title();
+|  58|    |-			*wHeader << NC::XY(0, 3)
+|  59|    |-			         << NC::TermManip::ClearToEOL
+|  60|    |-			         << Config.alternative_ui_separator_color;
+|  61|    |-			mvwhline(wHeader->raw(), 2, 0, 0, COLS);
+|  62|    |-			mvwhline(wHeader->raw(), 4, 0, 0, COLS);
+|  63|    |-			*wHeader << NC::FormattedColor::End<>(Config.alternative_ui_separator_color)
+|  64|    |-			         << NC::XY((COLS-wideLength(title))/2, 3)
+|  65|    |-			         << NC::Format::Bold
+|  66|    |-			         << title
+|  67|    |-			         << NC::Format::NoBold;
+|  68|    |-			break;
+|  69|    |-	}
+|  70|    |-	wHeader->refresh();
+|    |  38|+    using Global::myScreen;
+|    |  39|+    using Global::wHeader;
+|    |  40|+    using Global::VolumeState;
+|    |  41|+
+|    |  42|+    if (!Config.header_visibility)
+|    |  43|+        return;
+|    |  44|+    switch (Config.design)
+|    |  45|+      {
+|    |  46|+      case Design::Classic:
+|    |  47|+          *wHeader << NC::XY (0, 0)
+|    |  48|+              << NC::TermManip::ClearToEOL
+|    |  49|+              << NC::Format::Bold
+|    |  50|+              << myScreen->title ()
+|    |  51|+              << NC::Format::NoBold
+|    |  52|+              << NC::XY (wHeader->getWidth () - VolumeState.length (), 0)
+|    |  53|+              << Config.volume_color
+|    |  54|+              << VolumeState
+|    |  55|+              << NC::FormattedColor::End <> (Config.volume_color);
+|    |  56|+          break;
+|    |  57|+      case Design::Alternative:
+|    |  58|+          std::wstring title = myScreen->title ();
+|    |  59|+          *wHeader << NC::XY (0, 3)
+|    |  60|+              << NC::TermManip::ClearToEOL
+|    |  61|+              << Config.alternative_ui_separator_color;
+|    |  62|+          mvwhline (wHeader->raw (), 2, 0, 0, COLS);
+|    |  63|+          mvwhline (wHeader->raw (), 4, 0, 0, COLS);
+|    |  64|+          *wHeader << NC::FormattedColor::End <> (Config.
+|    |  65|+                                                  alternative_ui_separator_color)
+|    |  66|+              << NC::XY ((COLS - wideLength (title)) / 2,
+|    |  67|+                         3) << NC::Format::Bold << title << NC::Format::NoBold;
+|    |  68|+          break;
+|    |  69|+      }
+|    |  70|+    wHeader->refresh ();
+|  71|  71| }
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.h
+|    |++++| /app/src/screens/song_info.h
+|  25|  25| #include "mutable_song.h"
+|  26|  26| #include "screens/screen.h"
+|  27|  27| 
+|  28|    |-struct SongInfo: Screen<NC::Scrollpad>, Tabbable
+|    |  28|+struct SongInfo:Screen <
+|    |  29|+    NC::Scrollpad >,
+|    |  30|+    Tabbable
+|  29|  31| {
+|  30|    |-	struct Metadata
+|  31|    |-	{
+|  32|    |-		const char *Name;
+|  33|    |-		MPD::Song::GetFunction Get;
+|  34|    |-		MPD::MutableSong::SetFunction Set;
+|  35|    |-	};
+|  36|    |-	
+|  37|    |-	SongInfo();
+|  38|    |-	
+|  39|    |-	// Screen<NC::Scrollpad> implementation
+|  40|    |-	virtual void switchTo() override;
+|  41|    |-	virtual void resize() override;
+|  42|    |-	
+|  43|    |-	virtual std::wstring title() override;
+|  44|    |-	virtual ScreenType type() override { return ScreenType::SongInfo; }
+|  45|    |-	
+|  46|    |-	virtual void update() override { }
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return false; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// private members
+|  52|    |-	static const Metadata Tags[];
+|  53|    |-	
+|  54|    |-private:
+|  55|    |-	void PrepareSong(const MPD::Song &s);
+|    |  32|+    struct Metadata
+|    |  33|+    {
+|    |  34|+        const char *
+|    |  35|+            Name;
+|    |  36|+        MPD::Song::GetFunction
+|    |  37|+            Get;
+|    |  38|+        MPD::MutableSong::SetFunction
+|    |  39|+            Set;
+|    |  40|+    };
+|    |  41|+
+|    |  42|+    SongInfo ();
+|    |  43|+
+|    |  44|+    // Screen<NC::Scrollpad> implementation
+|    |  45|+    virtual void
+|    |  46|+    switchTo ()
+|    |  47|+        override;
+|    |  48|+    virtual void
+|    |  49|+    resize ()
+|    |  50|+        override;
+|    |  51|+
+|    |  52|+    virtual
+|    |  53|+        std::wstring
+|    |  54|+    title ()
+|    |  55|+        override;
+|    |  56|+    virtual ScreenType
+|    |  57|+    type ()
+|    |  58|+        override
+|    |  59|+    {
+|    |  60|+        return ScreenType::SongInfo;
+|    |  61|+    }
+|    |  62|+
+|    |  63|+    virtual void
+|    |  64|+    update ()
+|    |  65|+        override
+|    |  66|+    {
+|    |  67|+    }
+|    |  68|+
+|    |  69|+    virtual bool
+|    |  70|+    isLockable ()
+|    |  71|+        override
+|    |  72|+    {
+|    |  73|+        return false;
+|    |  74|+    }
+|    |  75|+    virtual bool
+|    |  76|+    isMergable ()
+|    |  77|+        override
+|    |  78|+    {
+|    |  79|+        return true;
+|    |  80|+    }
+|    |  81|+
+|    |  82|+    // private members
+|    |  83|+    static const Metadata
+|    |  84|+        Tags[];
+|    |  85|+
+|    |  86|+  private:
+|    |  87|+    void
+|    |  88|+    PrepareSong (const MPD::Song & s);
+|  56|  89| };
+|  57|  90| 
+|  58|  91| extern SongInfo *mySongInfo;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.h
+|    |++++| /app/src/screens/song_info.h
+|  55|  55| 	void PrepareSong(const MPD::Song &s);
+|  56|  56| };
+|  57|  57| 
+|  58|    |-extern SongInfo *mySongInfo;
+|    |  58|+extern SongInfo *
+|    |  59|+    mySongInfo;
+|  59|  60| 
+|  60|  61| #endif // NCMPCPP_SONG_INFO_H
+|  61|  62| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.h
+|    |++++| /app/src/screens/song_info.h
+|  58|  58| extern SongInfo *mySongInfo;
+|  59|  59| 
+|  60|  60| #endif // NCMPCPP_SONG_INFO_H
+|  61|    |-
+
+src/screens/song_info.h
+|  24| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/song_info.h
+|  25| #include•"mutable_song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'mutable_song.h'
+
+src/screens/song_info.h
+|  26| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/song_info.h
+|  58| extern•SongInfo•*mySongInfo;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'mySongInfo'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  24|  24| #include "screens/screen.h"
+|  25|  25| #include "settings.h"
+|  26|  26| 
+|  27|    |-using Global::myScreen;
+|  28|    |-using Global::myLockedScreen;
+|  29|    |-using Global::myInactiveScreen;
+|    |  27|+using
+|    |  28|+    Global::myScreen;
+|    |  29|+using
+|    |  30|+    Global::myLockedScreen;
+|    |  31|+using
+|    |  32|+    Global::myInactiveScreen;
+|  30|  33| 
+|  31|    |-void drawSeparator(int x)
+|    |  34|+void
+|    |  35|+drawSeparator (int x)
+|  32|  36| {
+|  33|    |-	color_set(Config.main_color.pairNumber(), nullptr);
+|  34|    |-	mvvline(Global::MainStartY, x, 0, Global::MainHeight);
+|  35|    |-	standend();
+|  36|    |-	refresh();
+|    |  37|+    color_set (Config.main_color.pairNumber (), nullptr);
+|    |  38|+    mvvline (Global::MainStartY, x, 0, Global::MainHeight);
+|    |  39|+    standend ();
+|    |  40|+    refresh ();
+|  37|  41| }
+|  38|  42| 
+|  39|  43| void genericMouseButtonPressed(NC::Window &w, MEVENT me)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  36|  36| 	refresh();
+|  37|  37| }
+|  38|  38| 
+|  39|    |-void genericMouseButtonPressed(NC::Window &w, MEVENT me)
+|    |  39|+void
+|    |  40|+genericMouseButtonPressed (NC::Window & w, MEVENT me)
+|  40|  41| {
+|  41|    |-	if (me.bstate & BUTTON5_PRESSED)
+|  42|    |-	{
+|  43|    |-		if (Config.mouse_list_scroll_whole_page)
+|  44|    |-			w.scroll(NC::Scroll::PageDown);
+|  45|    |-		else
+|  46|    |-			for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  47|    |-				w.scroll(NC::Scroll::Down);
+|  48|    |-	}
+|  49|    |-	else if (me.bstate & BUTTON4_PRESSED)
+|  50|    |-	{
+|  51|    |-		if (Config.mouse_list_scroll_whole_page)
+|  52|    |-			w.scroll(NC::Scroll::PageUp);
+|  53|    |-		else
+|  54|    |-			for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  55|    |-				w.scroll(NC::Scroll::Up);
+|  56|    |-	}
+|    |  42|+    if (me.bstate & BUTTON5_PRESSED)
+|    |  43|+      {
+|    |  44|+          if (Config.mouse_list_scroll_whole_page)
+|    |  45|+              w.scroll (NC::Scroll::PageDown);
+|    |  46|+          else
+|    |  47|+              for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  48|+                  w.scroll (NC::Scroll::Down);
+|    |  49|+      }
+|    |  50|+    else if (me.bstate & BUTTON4_PRESSED)
+|    |  51|+      {
+|    |  52|+          if (Config.mouse_list_scroll_whole_page)
+|    |  53|+              w.scroll (NC::Scroll::PageUp);
+|    |  54|+          else
+|    |  55|+              for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  56|+                  w.scroll (NC::Scroll::Up);
+|    |  57|+      }
+|  57|  58| }
+|  58|  59| 
+|  59|  60| void scrollpadMouseButtonPressed(NC::Scrollpad &w, MEVENT me)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  56|  56| 	}
+|  57|  57| }
+|  58|  58| 
+|  59|    |-void scrollpadMouseButtonPressed(NC::Scrollpad &w, MEVENT me)
+|    |  59|+void
+|    |  60|+scrollpadMouseButtonPressed (NC::Scrollpad & w, MEVENT me)
+|  60|  61| {
+|  61|    |-	if (me.bstate & BUTTON5_PRESSED)
+|  62|    |-	{
+|  63|    |-		for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  64|    |-			w.scroll(NC::Scroll::Down);
+|  65|    |-	}
+|  66|    |-	else if (me.bstate & BUTTON4_PRESSED)
+|  67|    |-	{
+|  68|    |-		for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|  69|    |-			w.scroll(NC::Scroll::Up);
+|  70|    |-	}
+|    |  62|+    if (me.bstate & BUTTON5_PRESSED)
+|    |  63|+      {
+|    |  64|+          for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  65|+              w.scroll (NC::Scroll::Down);
+|    |  66|+      }
+|    |  67|+    else if (me.bstate & BUTTON4_PRESSED)
+|    |  68|+      {
+|    |  69|+          for (size_t i = 0; i < Config.lines_scrolled; ++i)
+|    |  70|+              w.scroll (NC::Scroll::Up);
+|    |  71|+      }
+|  71|  72| }
+|  72|  73| 
+|  73|  74| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  72|  72| 
+|  73|  73| /***********************************************************************/
+|  74|  74| 
+|  75|    |-void BaseScreen::getWindowResizeParams(size_t &x_offset, size_t &width, bool adjust_locked_screen)
+|    |  75|+void
+|    |  76|+BaseScreen::getWindowResizeParams (size_t & x_offset, size_t & width,
+|    |  77|+                                   bool adjust_locked_screen)
+|  76|  78| {
+|  77|    |-	width = COLS;
+|  78|    |-	x_offset = 0;
+|  79|    |-	if (myLockedScreen && myInactiveScreen)
+|  80|    |-	{
+|  81|    |-		size_t locked_width = COLS*Config.locked_screen_width_part;
+|  82|    |-		if (myLockedScreen == this)
+|  83|    |-			width = locked_width;
+|  84|    |-		else
+|  85|    |-		{
+|  86|    |-			width = COLS-locked_width-1;
+|  87|    |-			x_offset = locked_width+1;
+|  88|    |-			
+|  89|    |-			if (adjust_locked_screen)
+|  90|    |-			{
+|  91|    |-				myLockedScreen->resize();
+|  92|    |-				myLockedScreen->refresh();
+|  93|    |-				drawSeparator(x_offset-1);
+|  94|    |-			}
+|  95|    |-		}
+|  96|    |-	}
+|    |  79|+    width = COLS;
+|    |  80|+    x_offset = 0;
+|    |  81|+    if (myLockedScreen && myInactiveScreen)
+|    |  82|+      {
+|    |  83|+          size_t locked_width = COLS * Config.locked_screen_width_part;
+|    |  84|+          if (myLockedScreen == this)
+|    |  85|+              width = locked_width;
+|    |  86|+          else
+|    |  87|+            {
+|    |  88|+                width = COLS - locked_width - 1;
+|    |  89|+                x_offset = locked_width + 1;
+|    |  90|+
+|    |  91|+                if (adjust_locked_screen)
+|    |  92|+                  {
+|    |  93|+                      myLockedScreen->resize ();
+|    |  94|+                      myLockedScreen->refresh ();
+|    |  95|+                      drawSeparator (x_offset - 1);
+|    |  96|+                  }
+|    |  97|+            }
+|    |  98|+      }
+|  97|  99| }
+|  98| 100| 
+|  99| 101| bool BaseScreen::lock()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+|  96|  96| 	}
+|  97|  97| }
+|  98|  98| 
+|  99|    |-bool BaseScreen::lock()
+|    |  99|+bool
+|    | 100|+BaseScreen::lock ()
+| 100| 101| {
+| 101|    |-	assert(myLockedScreen == nullptr);
+| 102|    |-	if (isLockable())
+| 103|    |-	{
+| 104|    |-		myLockedScreen = this;
+| 105|    |-		return true;
+| 106|    |-	}
+| 107|    |-	else
+| 108|    |-		return false;
+|    | 102|+    assert (myLockedScreen == nullptr);
+|    | 103|+    if (isLockable ())
+|    | 104|+      {
+|    | 105|+          myLockedScreen = this;
+|    | 106|+          return true;
+|    | 107|+      }
+|    | 108|+    else
+|    | 109|+        return false;
+| 109| 110| }
+| 110| 111| 
+| 111| 112| void BaseScreen::unlock()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 108| 108| 		return false;
+| 109| 109| }
+| 110| 110| 
+| 111|    |-void BaseScreen::unlock()
+|    | 111|+void
+|    | 112|+BaseScreen::unlock ()
+| 112| 113| {
+| 113|    |-	if (myInactiveScreen && myInactiveScreen != myLockedScreen)
+| 114|    |-		myScreen = myInactiveScreen;
+| 115|    |-	if (myScreen != myLockedScreen)
+| 116|    |-		myLockedScreen->switchTo();
+| 117|    |-	myLockedScreen = 0;
+| 118|    |-	myInactiveScreen = 0;
+|    | 114|+    if (myInactiveScreen && myInactiveScreen != myLockedScreen)
+|    | 115|+        myScreen = myInactiveScreen;
+|    | 116|+    if (myScreen != myLockedScreen)
+|    | 117|+        myLockedScreen->switchTo ();
+|    | 118|+    myLockedScreen = 0;
+|    | 119|+    myInactiveScreen = 0;
+| 119| 120| }
+| 120| 121| 
+| 121| 122| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 120| 120| 
+| 121| 121| /***********************************************************************/
+| 122| 122| 
+| 123|    |-void applyToVisibleWindows(std::function<void(BaseScreen *)> f)
+|    | 123|+void
+|    | 124|+applyToVisibleWindows (std::function < void (BaseScreen *) > f)
+| 124| 125| {
+| 125|    |-	if (myLockedScreen && myScreen->isMergable())
+| 126|    |-	{
+| 127|    |-		if (myScreen == myLockedScreen)
+| 128|    |-		{
+| 129|    |-			if (myInactiveScreen)
+| 130|    |-				f(myInactiveScreen);
+| 131|    |-		}
+| 132|    |-		else
+| 133|    |-			f(myLockedScreen);
+| 134|    |-	}
+| 135|    |-	f(myScreen);
+|    | 126|+    if (myLockedScreen && myScreen->isMergable ())
+|    | 127|+      {
+|    | 128|+          if (myScreen == myLockedScreen)
+|    | 129|+            {
+|    | 130|+                if (myInactiveScreen)
+|    | 131|+                    f (myInactiveScreen);
+|    | 132|+            }
+|    | 133|+          else
+|    | 134|+              f (myLockedScreen);
+|    | 135|+      }
+|    | 136|+    f (myScreen);
+| 136| 137| }
+| 137| 138| 
+| 138| 139| void updateInactiveScreen(BaseScreen *screen_to_be_set)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 135| 135| 	f(myScreen);
+| 136| 136| }
+| 137| 137| 
+| 138|    |-void updateInactiveScreen(BaseScreen *screen_to_be_set)
+|    | 138|+void
+|    | 139|+updateInactiveScreen (BaseScreen * screen_to_be_set)
+| 139| 140| {
+| 140|    |-	if (myInactiveScreen && myLockedScreen != myInactiveScreen && myLockedScreen == screen_to_be_set)
+| 141|    |-	{
+| 142|    |-		// if we're here, the following conditions are (or at least should be) met:
+| 143|    |-		// 1. screen is split (myInactiveScreen is not null)
+| 144|    |-		// 2. current screen (myScreen) is not splittable, ie. is stacked on top of split screens
+| 145|    |-		// 3. current screen was activated while master screen was active
+| 146|    |-		// 4. we are returning to master screen
+| 147|    |-		// in such case we want to keep slave screen visible, so we never set it to null
+| 148|    |-		// as in "else" case. we also need to refresh it and redraw separator between
+| 149|    |-		// them as stacked screen probably has overwritten part ot it.
+| 150|    |-		myInactiveScreen->refresh();
+| 151|    |-		drawSeparator(COLS*Config.locked_screen_width_part);
+| 152|    |-	}
+| 153|    |-	else
+| 154|    |-	{
+| 155|    |-		if (myLockedScreen == screen_to_be_set)
+| 156|    |-			myInactiveScreen = 0;
+| 157|    |-		else
+| 158|    |-			myInactiveScreen = myLockedScreen;
+| 159|    |-	}
+|    | 141|+    if (myInactiveScreen && myLockedScreen != myInactiveScreen
+|    | 142|+        && myLockedScreen == screen_to_be_set)
+|    | 143|+      {
+|    | 144|+          // if we're here, the following conditions are (or at least should be) met:
+|    | 145|+          // 1. screen is split (myInactiveScreen is not null)
+|    | 146|+          // 2. current screen (myScreen) is not splittable, ie. is stacked on top of split screens
+|    | 147|+          // 3. current screen was activated while master screen was active
+|    | 148|+          // 4. we are returning to master screen
+|    | 149|+          // in such case we want to keep slave screen visible, so we never set it to null
+|    | 150|+          // as in "else" case. we also need to refresh it and redraw separator between
+|    | 151|+          // them as stacked screen probably has overwritten part ot it.
+|    | 152|+          myInactiveScreen->refresh ();
+|    | 153|+          drawSeparator (COLS * Config.locked_screen_width_part);
+|    | 154|+      }
+|    | 155|+    else
+|    | 156|+      {
+|    | 157|+          if (myLockedScreen == screen_to_be_set)
+|    | 158|+              myInactiveScreen = 0;
+|    | 159|+          else
+|    | 160|+              myInactiveScreen = myLockedScreen;
+|    | 161|+      }
+| 160| 162| }
+| 161| 163| 
+| 162| 164| bool isVisible(BaseScreen *screen)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen.cpp
+|    |++++| /app/src/screens/screen.cpp
+| 159| 159| 	}
+| 160| 160| }
+| 161| 161| 
+| 162|    |-bool isVisible(BaseScreen *screen)
+|    | 162|+bool
+|    | 163|+isVisible (BaseScreen * screen)
+| 163| 164| {
+| 164|    |-	assert(screen != 0);
+| 165|    |-	if (myLockedScreen && myScreen->isMergable())
+| 166|    |-		return screen == myScreen || screen == myInactiveScreen || screen == myLockedScreen;
+| 167|    |-	else
+| 168|    |-		return screen == myScreen;
+|    | 165|+    assert (screen != 0);
+|    | 166|+    if (myLockedScreen && myScreen->isMergable ())
+|    | 167|+        return screen == myScreen || screen == myInactiveScreen
+|    | 168|+            || screen == myLockedScreen;
+|    | 169|+    else
+|    | 170|+        return screen == myScreen;
+| 169| 171| }
+
+src/screens/screen.cpp
+|  23| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/screen.cpp
+|  24| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/screen.cpp
+|  25| #include•"settings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'settings.h'
+
+src/screens/screen.cpp
+|  31| void•drawSeparator(int•x)
+|    | [NORMAL] CPPCleanBear:
+|    | 'drawSeparator' not found in any directly #included header
+
+src/screens/screen.cpp
+|  39| void•genericMouseButtonPressed(NC::Window•&w,•MEVENT•me)
+|    | [NORMAL] CPPCleanBear:
+|    | 'genericMouseButtonPressed' not found in any directly #included header
+
+src/screens/screen.cpp
+|  59| void•scrollpadMouseButtonPressed(NC::Scrollpad•&w,•MEVENT•me)
+|    | [NORMAL] CPPCleanBear:
+|    | 'scrollpadMouseButtonPressed' not found in any directly #included header
+
+src/screens/screen.cpp
+| 123| void•applyToVisibleWindows(std::function<void(BaseScreen•*)>•f)
+|    | [NORMAL] CPPCleanBear:
+|    | 'applyToVisibleWindows' not found in any directly #included header
+
+src/screens/screen.cpp
+| 138| void•updateInactiveScreen(BaseScreen•*screen_to_be_set)
+|    | [NORMAL] CPPCleanBear:
+|    | 'updateInactiveScreen' not found in any directly #included header
+
+src/screens/screen.cpp
+| 162| bool•isVisible(BaseScreen•*screen)
+|    | [NORMAL] CPPCleanBear:
+|    | 'isVisible' not found in any directly #included header
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/clock.cpp
+|    |++++| /app/src/screens/clock.cpp
+|  35|  35| #include "title.h"
+|  36|  36| #include "screens/screen_switcher.h"
+|  37|  37| 
+|  38|    |-using Global::MainHeight;
+|  39|    |-using Global::MainStartY;
+|  40|    |-using Global::myScreen;
+|    |  38|+using
+|    |  39|+    Global::MainHeight;
+|    |  40|+using
+|    |  41|+    Global::MainStartY;
+|    |  42|+using
+|    |  43|+    Global::myScreen;
+|  41|  44| 
+|  42|    |-Clock *myClock;
+|    |  45|+Clock *
+|    |  46|+    myClock;
+|  43|  47| 
+|  44|    |-short Clock::disp[11] =
+|  45|    |-{
+|  46|    |-	075557, 011111, 071747, 071717,
+|  47|    |-	055711, 074717, 074757, 071111,
+|  48|    |-	075757, 075717, 002020
+|    |  48|+short
+|    |  49|+    Clock::disp[11] = {
+|    |  50|+    075557, 011111, 071747, 071717,
+|    |  51|+    055711, 074717, 074757, 071111,
+|    |  52|+    075757, 075717, 002020
+|  49|  53| };
+|  50|  54| 
+|  51|  55| long Clock::older[6], Clock::next[6], Clock::newer[6], Clock::mask;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/clock.cpp
+|    |++++| /app/src/screens/clock.cpp
+|  48|  48| 	075757, 075717, 002020
+|  49|  49| };
+|  50|  50| 
+|  51|    |-long Clock::older[6], Clock::next[6], Clock::newer[6], Clock::mask;
+|  52|    |-
+|  53|    |-size_t Clock::Width;
+|  54|    |-const size_t Clock::Height = 8;
+|  55|    |-
+|  56|    |-Clock::Clock()
+|  57|    |-{
+|  58|    |-	Width = Config.clock_display_seconds ? 60 : 40;
+|  59|    |-	
+|  60|    |-	m_pane = NC::Window(0, MainStartY, COLS, MainHeight, "", Config.main_color, NC::Border());
+|  61|    |-	w = NC::Window((COLS-Width)/2, (MainHeight-Height)/2+MainStartY, Width, Height-1, "", Config.main_color, Config.main_color);
+|  62|    |-}
+|  63|    |-
+|  64|    |-void Clock::resize()
+|  65|    |-{
+|  66|    |-	size_t x_offset, width;
+|  67|    |-	getWindowResizeParams(x_offset, width);
+|  68|    |-	
+|  69|    |-	// used for clearing area out of clock window while resizing terminal
+|  70|    |-	m_pane.resize(width, MainHeight);
+|  71|    |-	m_pane.moveTo(x_offset, MainStartY);
+|  72|    |-	m_pane.refresh();
+|  73|    |-	
+|  74|    |-	if (Width <= width && Height <= MainHeight)
+|  75|    |-		w.moveTo(x_offset+(width-Width)/2, MainStartY+(MainHeight-Height)/2);
+|  76|    |-}
+|  77|    |-
+|  78|    |-void Clock::switchTo()
+|  79|    |-{
+|  80|    |-	size_t x_offset, width;
+|  81|    |-	getWindowResizeParams(x_offset, width, false);
+|  82|    |-	if (Width > width || Height > MainHeight)
+|  83|    |-		Statusbar::print("Screen is too small to display clock");
+|  84|    |-	else
+|  85|    |-	{
+|  86|    |-		SwitchTo::execute(this);
+|  87|    |-		drawHeader();
+|  88|    |-		Prepare();
+|  89|    |-		m_pane.refresh();
+|  90|    |-		// clearing screen apparently fixes the problem with last digits being misrendered
+|  91|    |-		w.clear();
+|  92|    |-		w.display();
+|  93|    |-	}
+|  94|    |-}
+|  95|    |-
+|  96|    |-std::wstring Clock::title()
+|  97|    |-{
+|  98|    |-	return L"Clock";
+|  99|    |-}
+| 100|    |-
+| 101|    |-void Clock::update()
+| 102|    |-{
+| 103|    |-	if (Width > m_pane.getWidth() || Height > MainHeight)
+| 104|    |-	{
+| 105|    |-		using Global::myLockedScreen;
+| 106|    |-		using Global::myInactiveScreen;
+| 107|    |-		
+| 108|    |-		if (myLockedScreen)
+| 109|    |-		{
+| 110|    |-			if (myInactiveScreen != myLockedScreen)
+| 111|    |-				myScreen = myInactiveScreen;
+| 112|    |-			myLockedScreen->switchTo();
+| 113|    |-		}
+| 114|    |-		else
+| 115|    |-			myPlaylist->switchTo();
+| 116|    |-	}
+| 117|    |-	
+| 118|    |-	auto time = boost::posix_time::to_tm(Global::Timer);
+| 119|    |-	
+| 120|    |-	mask = 0;
+| 121|    |-	Set(time.tm_sec % 10, 0);
+| 122|    |-	Set(time.tm_sec / 10, 4);
+| 123|    |-	Set(time.tm_min % 10, 10);
+| 124|    |-	Set(time.tm_min / 10, 14);
+| 125|    |-	Set(time.tm_hour % 10, 20);
+| 126|    |-	Set(time.tm_hour / 10, 24);
+| 127|    |-	Set(10, 7);
+| 128|    |-	Set(10, 17);
+| 129|    |-	
+| 130|    |-	char buf[64];
+| 131|    |-	std::strftime(buf, 64, "%x", &time);
+| 132|    |-	color_set(Config.main_color.pairNumber(), nullptr);
+| 133|    |-	mvprintw(w.getStarty()+w.getHeight(), w.getStartX()+(w.getWidth()-strlen(buf))/2, "%s", buf);
+| 134|    |-	standend();
+| 135|    |-	refresh();
+| 136|    |-	
+| 137|    |-	for (int k = 0; k < 6; ++k)
+| 138|    |-	{
+| 139|    |-		newer[k] = (newer[k] & ~mask) | (next[k] & mask);
+| 140|    |-		next[k] = 0;
+| 141|    |-		for (int s = 1; s >= 0; --s)
+| 142|    |-		{
+| 143|    |-			w << (s ? NC::Format::Reverse : NC::Format::NoReverse);
+| 144|    |-			for (int i = 0; i < 6; ++i)
+| 145|    |-			{
+| 146|    |-				long a = (newer[i] ^ older[i]) & (s ? newer : older)[i];
+| 147|    |-				if (a != 0)
+| 148|    |-				{
+| 149|    |-					long t = 1 << 26;
+| 150|    |-					for (int j = 0; t; t >>= 1, ++j)
+| 151|    |-					{
+| 152|    |-						if (a & t)
+| 153|    |-						{
+| 154|    |-							if (!(a & (t << 1)))
+| 155|    |-							{
+| 156|    |-								w.goToXY(2*j+2, i);
+| 157|    |-							}
+| 158|    |-							if (Config.clock_display_seconds || j < 18)
+| 159|    |-								w << "  ";
+| 160|    |-						}
+| 161|    |-					}
+| 162|    |-				}
+| 163|    |-				if (!s)
+| 164|    |-				{
+| 165|    |-					older[i] = newer[i];
+| 166|    |-				}
+| 167|    |-			}
+| 168|    |-		}
+| 169|    |-	}
+| 170|    |-	w.refresh();
+| 171|    |-}
+| 172|    |-
+| 173|    |-void Clock::Prepare()
+| 174|    |-{
+| 175|    |-	for (int i = 0; i < 5; ++i)
+| 176|    |-		older[i] = newer[i] = next[i] = 0;
+| 177|    |-}
+| 178|    |-
+| 179|    |-void Clock::Set(int t, int n)
+| 180|    |-{
+| 181|    |-	int m = 7 << n;
+| 182|    |-	for (int i = 0; i < 5; ++i)
+| 183|    |-	{
+| 184|    |-		next[i] |= ((disp[t] >> ((4 - i) * 3)) & 07) << n;
+| 185|    |-		mask |= (next[i] ^ older[i]) & m;
+| 186|    |-	}
+| 187|    |-	if (mask & m)
+| 188|    |-		mask |= m;
+|    |  51|+long
+|    |  52|+    Clock::older[6],
+|    |  53|+    Clock::next[6],
+|    |  54|+    Clock::newer[6],
+|    |  55|+    Clock::mask;
+|    |  56|+
+|    |  57|+size_t
+|    |  58|+    Clock::Width;
+|    |  59|+const size_t
+|    |  60|+    Clock::Height = 8;
+|    |  61|+
+|    |  62|+Clock::Clock ()
+|    |  63|+{
+|    |  64|+    Width = Config.clock_display_seconds ? 60 : 40;
+|    |  65|+
+|    |  66|+    m_pane =
+|    |  67|+        NC::Window (0, MainStartY, COLS, MainHeight, "", Config.main_color,
+|    |  68|+                    NC::Border ());
+|    |  69|+    w = NC::Window ((COLS - Width) / 2, (MainHeight - Height) / 2 + MainStartY,
+|    |  70|+                    Width, Height - 1, "", Config.main_color,
+|    |  71|+                    Config.main_color);
+|    |  72|+}
+|    |  73|+
+|    |  74|+void
+|    |  75|+Clock::resize ()
+|    |  76|+{
+|    |  77|+    size_t x_offset, width;
+|    |  78|+    getWindowResizeParams (x_offset, width);
+|    |  79|+
+|    |  80|+    // used for clearing area out of clock window while resizing terminal
+|    |  81|+    m_pane.resize (width, MainHeight);
+|    |  82|+    m_pane.moveTo (x_offset, MainStartY);
+|    |  83|+    m_pane.refresh ();
+|    |  84|+
+|    |  85|+    if (Width <= width && Height <= MainHeight)
+|    |  86|+        w.moveTo (x_offset + (width - Width) / 2,
+|    |  87|+                  MainStartY + (MainHeight - Height) / 2);
+|    |  88|+}
+|    |  89|+
+|    |  90|+void
+|    |  91|+Clock::switchTo ()
+|    |  92|+{
+|    |  93|+    size_t x_offset, width;
+|    |  94|+    getWindowResizeParams (x_offset, width, false);
+|    |  95|+    if (Width > width || Height > MainHeight)
+|    |  96|+        Statusbar::print ("Screen is too small to display clock");
+|    |  97|+    else
+|    |  98|+      {
+|    |  99|+          SwitchTo::execute (this);
+|    | 100|+          drawHeader ();
+|    | 101|+          Prepare ();
+|    | 102|+          m_pane.refresh ();
+|    | 103|+          // clearing screen apparently fixes the problem with last digits being misrendered
+|    | 104|+          w.clear ();
+|    | 105|+          w.display ();
+|    | 106|+      }
+|    | 107|+}
+|    | 108|+
+|    | 109|+std::wstring Clock::title ()
+|    | 110|+{
+|    | 111|+    return L"Clock";
+|    | 112|+}
+|    | 113|+
+|    | 114|+void
+|    | 115|+Clock::update ()
+|    | 116|+{
+|    | 117|+    if (Width > m_pane.getWidth () || Height > MainHeight)
+|    | 118|+      {
+|    | 119|+          using Global::myLockedScreen;
+|    | 120|+          using Global::myInactiveScreen;
+|    | 121|+
+|    | 122|+          if (myLockedScreen)
+|    | 123|+            {
+|    | 124|+                if (myInactiveScreen != myLockedScreen)
+|    | 125|+                    myScreen = myInactiveScreen;
+|    | 126|+                myLockedScreen->switchTo ();
+|    | 127|+            }
+|    | 128|+          else
+|    | 129|+              myPlaylist->switchTo ();
+|    | 130|+      }
+|    | 131|+
+|    | 132|+    auto time = boost::posix_time::to_tm (Global::Timer);
+|    | 133|+
+|    | 134|+    mask = 0;
+|    | 135|+    Set (time.tm_sec % 10, 0);
+|    | 136|+    Set (time.tm_sec / 10, 4);
+|    | 137|+    Set (time.tm_min % 10, 10);
+|    | 138|+    Set (time.tm_min / 10, 14);
+|    | 139|+    Set (time.tm_hour % 10, 20);
+|    | 140|+    Set (time.tm_hour / 10, 24);
+|    | 141|+    Set (10, 7);
+|    | 142|+    Set (10, 17);
+|    | 143|+
+|    | 144|+    char buf[64];
+|    | 145|+    std::strftime (buf, 64, "%x", &time);
+|    | 146|+    color_set (Config.main_color.pairNumber (), nullptr);
+|    | 147|+    mvprintw (w.getStarty () + w.getHeight (),
+|    | 148|+              w.getStartX () + (w.getWidth () - strlen (buf)) / 2, "%s", buf);
+|    | 149|+    standend ();
+|    | 150|+    refresh ();
+|    | 151|+
+|    | 152|+    for (int k = 0; k < 6; ++k)
+|    | 153|+      {
+|    | 154|+          newer[k] = (newer[k] & ~mask) | (next[k] & mask);
+|    | 155|+          next[k] = 0;
+|    | 156|+          for (int s = 1; s >= 0; --s)
+|    | 157|+            {
+|    | 158|+                w << (s ? NC::Format::Reverse : NC::Format::NoReverse);
+|    | 159|+                for (int i = 0; i < 6; ++i)
+|    | 160|+                  {
+|    | 161|+                      long a = (newer[i] ^ older[i]) & (s ? newer : older)[i];
+|    | 162|+                      if (a != 0)
+|    | 163|+                        {
+|    | 164|+                            long t = 1 << 26;
+|    | 165|+                            for (int j = 0; t; t >>= 1, ++j)
+|    | 166|+                              {
+|    | 167|+                                  if (a & t)
+|    | 168|+                                    {
+|    | 169|+                                        if (!(a & (t << 1)))
+|    | 170|+                                          {
+|    | 171|+                                              w.goToXY (2 * j + 2, i);
+|    | 172|+                                          }
+|    | 173|+                                        if (Config.clock_display_seconds
+|    | 174|+                                            || j < 18)
+|    | 175|+                                            w << "  ";
+|    | 176|+                                    }
+|    | 177|+                              }
+|    | 178|+                        }
+|    | 179|+                      if (!s)
+|    | 180|+                        {
+|    | 181|+                            older[i] = newer[i];
+|    | 182|+                        }
+|    | 183|+                  }
+|    | 184|+            }
+|    | 185|+      }
+|    | 186|+    w.refresh ();
+|    | 187|+}
+|    | 188|+
+|    | 189|+void
+|    | 190|+Clock::Prepare ()
+|    | 191|+{
+|    | 192|+    for (int i = 0; i < 5; ++i)
+|    | 193|+        older[i] = newer[i] = next[i] = 0;
+|    | 194|+}
+|    | 195|+
+|    | 196|+void
+|    | 197|+Clock::Set (int t, int n)
+|    | 198|+{
+|    | 199|+    int m = 7 << n;
+|    | 200|+    for (int i = 0; i < 5; ++i)
+|    | 201|+      {
+|    | 202|+          next[i] |= ((disp[t] >> ((4 - i) * 3)) & 07) << n;
+|    | 203|+          mask |= (next[i] ^ older[i]) & m;
+|    | 204|+      }
+|    | 205|+    if (mask & m)
+|    | 206|+        mask |= m;
+| 189| 207| }
+| 190| 208| 
+| 191| 209| #endif // ENABLE_CLOCK
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/clock.cpp
+|    |++++| /app/src/screens/clock.cpp
+| 189| 189| }
+| 190| 190| 
+| 191| 191| #endif // ENABLE_CLOCK
+| 192|    |-
+
+src/screens/clock.cpp
+|  23| #include•"screens/clock.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/clock.h'
+
+src/screens/clock.cpp
+|  30| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/clock.cpp
+|  31| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist.h'
+
+src/screens/clock.cpp
+|  32| #include•"settings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'settings.h'
+
+src/screens/clock.cpp
+|  33| #include•"status.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'status.h'
+
+src/screens/clock.cpp
+|  34| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'statusbar.h'
+
+src/screens/clock.cpp
+|  35| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/clock.cpp
+|  36| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/clock.cpp
+|  42| Clock•*myClock;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myClock'
+
+src/screens/clock.cpp
+|  44| short•Clock::disp[11]•=
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Clock::disp'
+
+src/screens/clock.cpp
+|  51| long•Clock::older[6],•Clock::next[6],•Clock::newer[6],•Clock::mask;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Clock::older'
+
+src/screens/clock.cpp
+|  51| long•Clock::older[6],•Clock::next[6],•Clock::newer[6],•Clock::mask;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Clock::mask'
+
+src/screens/clock.cpp
+|  53| size_t•Clock::Width;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Clock::Width'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.cpp
+|    |++++| /app/src/curses/window.cpp
+|  31|  31| #include "utility/wide_string.h"
+|  32|  32| #include "window.h"
+|  33|  33| 
+|  34|    |-namespace {
+|  35|    |-
+|  36|    |-namespace rl {
+|  37|    |-
+|  38|    |-bool aborted;
+|  39|    |-
+|  40|    |-NC::Window *w;
+|  41|    |-size_t start_x;
+|  42|    |-size_t start_y;
+|  43|    |-size_t width;
+|  44|    |-bool encrypted;
+|  45|    |-const char *base;
+|  46|    |-
+|  47|    |-int read_key(FILE *)
+|  48|    |-{
+|  49|    |-	size_t x;
+|  50|    |-	bool done;
+|  51|    |-	int result;
+|  52|    |-	do
+|  53|    |-	{
+|  54|    |-		x = w->getX();
+|  55|    |-		if (w->runPromptHook(rl_line_buffer, &done))
+|  56|    |-		{
+|  57|    |-			// Do not end if readline is in one of its commands, e.g. searching
+|  58|    |-			// through history, as it doesn't actually make readline exit and it
+|  59|    |-			// becomes stuck in a loop.
+|  60|    |-			if (!RL_ISSTATE(RL_STATE_DISPATCHING) && done)
+|  61|    |-			{
+|  62|    |-				rl_done = 1;
+|  63|    |-				return EOF;
+|  64|    |-			}
+|  65|    |-			w->goToXY(x, start_y);
+|  66|    |-		}
+|  67|    |-		w->refresh();
+|  68|    |-		result = w->readKey();
+|  69|    |-		if (!w->FDCallbacksListEmpty())
+|  70|    |-		{
+|  71|    |-			w->goToXY(x, start_y);
+|  72|    |-			w->refresh();
+|  73|    |-		}
+|  74|    |-	}
+|  75|    |-	while (result == ERR);
+|  76|    |-	return result;
+|    |  34|+namespace
+|    |  35|+{
+|    |  36|+
+|    |  37|+    namespace rl
+|    |  38|+    {
+|    |  39|+
+|    |  40|+        bool aborted;
+|    |  41|+
+|    |  42|+          NC::Window * w;
+|    |  43|+        size_t start_x;
+|    |  44|+        size_t start_y;
+|    |  45|+        size_t width;
+|    |  46|+        bool encrypted;
+|    |  47|+        const char *base;
+|    |  48|+
+|    |  49|+        int read_key (FILE *)
+|    |  50|+        {
+|    |  51|+            size_t x;
+|    |  52|+            bool done;
+|    |  53|+            int result;
+|    |  54|+            do
+|    |  55|+              {
+|    |  56|+                  x = w->getX ();
+|    |  57|+                  if (w->runPromptHook (rl_line_buffer, &done))
+|    |  58|+                    {
+|    |  59|+                        // Do not end if readline is in one of its commands, e.g. searching
+|    |  60|+                        // through history, as it doesn't actually make readline exit and it
+|    |  61|+                        // becomes stuck in a loop.
+|    |  62|+                        if (!RL_ISSTATE (RL_STATE_DISPATCHING) && done)
+|    |  63|+                          {
+|    |  64|+                              rl_done = 1;
+|    |  65|+                              return EOF;
+|    |  66|+                          }
+|    |  67|+                        w->goToXY (x, start_y);
+|    |  68|+                    }
+|    |  69|+                  w->refresh ();
+|    |  70|+                  result = w->readKey ();
+|    |  71|+                  if (!w->FDCallbacksListEmpty ())
+|    |  72|+                    {
+|    |  73|+                        w->goToXY (x, start_y);
+|    |  74|+                        w->refresh ();
+|    |  75|+                    }
+|    |  76|+              }
+|    |  77|+            while (result == ERR);
+|    |  78|+            return result;
+|    |  79|+        }
+|    |  80|+
+|    |  81|+        void display_string ()
+|    |  82|+        {
+|    |  83|+            auto print_char =[](wchar_t wc) {
+|    |  84|+                if (encrypted)
+|    |  85|+                    *w << '*';
+|    |  86|+                else
+|    |  87|+                    *w << wc;
+|    |  88|+            };
+|    |  89|+            auto print_string =[](wchar_t * ws, size_t len) {
+|    |  90|+                if (encrypted)
+|    |  91|+                    for (size_t i = 0; i < len; ++i)
+|    |  92|+                        *w << '*';
+|    |  93|+                else
+|    |  94|+                    *w << ws;
+|    |  95|+            };
+|    |  96|+            auto narrow_to_wide =[](wchar_t * dest, const char *src, size_t n) {
+|    |  97|+                size_t result = 0;
+|    |  98|+                // convert the string and substitute invalid multibyte chars with dots.
+|    |  99|+                for (size_t i = 0; i < n;)
+|    | 100|+                  {
+|    | 101|+                      int ret = mbtowc (&dest[result], &src[i], n - i);
+|    | 102|+                      if (ret > 0)
+|    | 103|+                        {
+|    | 104|+                            i += ret;
+|    | 105|+                            ++result;
+|    | 106|+                        }
+|    | 107|+                      else if (ret == -1)
+|    | 108|+                        {
+|    | 109|+                            dest[result] = L'.';
+|    | 110|+                            ++i;
+|    | 111|+                            ++result;
+|    | 112|+                        }
+|    | 113|+                      else
+|    | 114|+                          throw std::
+|    | 115|+                              runtime_error
+|    | 116|+                              ("mbtowc: unexpected return value");
+|    | 117|+                  }
+|    | 118|+                return result;
+|    | 119|+            };
+|    | 120|+
+|    | 121|+            // copy the part of the string that is before the cursor to pre_pos
+|    | 122|+            char pt = rl_line_buffer[rl_point];
+|    | 123|+            rl_line_buffer[rl_point] = 0;
+|    | 124|+            wchar_t pre_pos[rl_point + 1];
+|    | 125|+            pre_pos[narrow_to_wide (pre_pos, rl_line_buffer, rl_point)] = 0;
+|    | 126|+            rl_line_buffer[rl_point] = pt;
+|    | 127|+
+|    | 128|+            int pos = wcswidth (pre_pos, rl_point);
+|    | 129|+            if (pos < 0)
+|    | 130|+                pos = rl_point;
+|    | 131|+
+|    | 132|+            // clear the area for the string
+|    | 133|+            mvwhline (w->raw (), start_y, start_x, ' ', width + 1);
+|    | 134|+
+|    | 135|+            w->goToXY (start_x, start_y);
+|    | 136|+            if (size_t (pos) <= width)
+|    | 137|+              {
+|    | 138|+                  // if the current position in the string is not bigger than allowed
+|    | 139|+                  // width, print the part of the string before cursor position...
+|    | 140|+
+|    | 141|+                  print_string (pre_pos, pos);
+|    | 142|+
+|    | 143|+                  // ...and then print the rest char-by-char until there is no more area
+|    | 144|+                  wchar_t post_pos[rl_end - rl_point + 1];
+|    | 145|+                  post_pos[narrow_to_wide
+|    | 146|+                           (post_pos, rl_line_buffer + rl_point,
+|    | 147|+                            rl_end - rl_point)] = 0;
+|    | 148|+
+|    | 149|+                  size_t cpos = pos;
+|    | 150|+                  for (wchar_t * c = post_pos; *c != 0; ++c)
+|    | 151|+                    {
+|    | 152|+                        int n = wcwidth (*c);
+|    | 153|+                        if (n < 0)
+|    | 154|+                          {
+|    | 155|+                              print_char (L'.');
+|    | 156|+                              ++cpos;
+|    | 157|+                          }
+|    | 158|+                        else
+|    | 159|+                          {
+|    | 160|+                              if (cpos + n > width)
+|    | 161|+                                  break;
+|    | 162|+                              cpos += n;
+|    | 163|+                              print_char (*c);
+|    | 164|+                          }
+|    | 165|+                    }
+|    | 166|+              }
+|    | 167|+            else
+|    | 168|+              {
+|    | 169|+                  // if the current position in the string is bigger than allowed
+|    | 170|+                  // width, we always keep the cursor at the end of the line (it
+|    | 171|+                  // would be nice to have more flexible scrolling, but for now
+|    | 172|+                  // let's stick to that) by cutting the beginning of the part
+|    | 173|+                  // of the string before the cursor until it fits the area.
+|    | 174|+
+|    | 175|+                  wchar_t *mod_pre_pos = pre_pos;
+|    | 176|+                  while (*mod_pre_pos != 0)
+|    | 177|+                    {
+|    | 178|+                        ++mod_pre_pos;
+|    | 179|+                        int n = wcwidth (*mod_pre_pos);
+|    | 180|+                        if (n < 0)
+|    | 181|+                            --pos;
+|    | 182|+                        else
+|    | 183|+                            pos -= n;
+|    | 184|+                        if (size_t (pos) <= width)
+|    | 185|+                            break;
+|    | 186|+                    }
+|    | 187|+                  print_string (mod_pre_pos, pos);
+|    | 188|+              }
+|    | 189|+            w->goToXY (start_x + pos, start_y);
+|    | 190|+        }
+|    | 191|+
+|    | 192|+        int add_base ()
+|    | 193|+        {
+|    | 194|+            rl_insert_text (base);
+|    | 195|+            return 0;
+|    | 196|+        }
+|    | 197|+
+|    | 198|+    }
+|    | 199|+
+|    | 200|+    int color_pair_counter;
+|    | 201|+    std::vector < int >color_pair_map;
+|    | 202|+
+|  77| 203| }
+|  78| 204| 
+|  79| 205| void display_string()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/window.cpp
+|    |++++| /app/src/curses/window.cpp
+|  76|  76| 	return result;
+|  77|  77| }
+|  78|  78| 
+|  79|    |-void display_string()
+|    |  79|+namespace NC
+|  80|  80| {
+|  81|    |-	auto print_char = [](wchar_t wc) {
+|  82|    |-		if (encrypted)
+|  83|    |-			*w << '*';
+|  84|    |-		else
+|  85|    |-			*w << wc;
+|  86|    |-	};
+|  87|    |-	auto print_string = [](wchar_t *ws, size_t len) {
+|  88|    |-		if (encrypted)
+|  89|    |-			for (size_t i = 0; i < len; ++i)
+|  90|    |-				*w << '*';
+|  91|    |-		else
+|  92|    |-			*w << ws;
+|  93|    |-	};
+|  94|    |-	auto narrow_to_wide = [](wchar_t *dest, const char *src, size_t n) {
+|  95|    |-		size_t result = 0;
+|  96|    |-		// convert the string and substitute invalid multibyte chars with dots.
+|  97|    |-		for (size_t i = 0; i < n;)
+|  98|    |-		{
+|  99|    |-			int ret = mbtowc(&dest[result], &src[i], n-i);
+| 100|    |-			if (ret > 0)
+| 101|    |-			{
+| 102|    |-				i += ret;
+| 103|    |-				++result;
+| 104|    |-			}
+| 105|    |-			else if (ret == -1)
+| 106|    |-			{
+| 107|    |-				dest[result] = L'.';
+| 108|    |-				++i;
+| 109|    |-				++result;
+| 110|    |-			}
+| 111|    |-			else
+| 112|    |-				throw std::runtime_error("mbtowc: unexpected return value");
+| 113|    |-		}
+| 114|    |-		return result;
+| 115|    |-	};
+| 116|    |-
+| 117|    |-	// copy the part of the string that is before the cursor to pre_pos
+| 118|    |-	char pt = rl_line_buffer[rl_point];
+| 119|    |-	rl_line_buffer[rl_point] = 0;
+| 120|    |-	wchar_t pre_pos[rl_point+1];
+| 121|    |-	pre_pos[narrow_to_wide(pre_pos, rl_line_buffer, rl_point)] = 0;
+| 122|    |-	rl_line_buffer[rl_point] = pt;
+| 123|    |-
+| 124|    |-	int pos = wcswidth(pre_pos, rl_point);
+| 125|    |-	if (pos < 0)
+| 126|    |-		pos = rl_point;
+| 127|    |-
+| 128|    |-	// clear the area for the string
+| 129|    |-	mvwhline(w->raw(), start_y, start_x, ' ', width+1);
+| 130|    |-
+| 131|    |-	w->goToXY(start_x, start_y);
+| 132|    |-	if (size_t(pos) <= width)
+| 133|    |-	{
+| 134|    |-		// if the current position in the string is not bigger than allowed
+| 135|    |-		// width, print the part of the string before cursor position...
+| 136|    |-
+| 137|    |-		print_string(pre_pos, pos);
+| 138|    |-
+| 139|    |-		// ...and then print the rest char-by-char until there is no more area
+| 140|    |-		wchar_t post_pos[rl_end-rl_point+1];
+| 141|    |-		post_pos[narrow_to_wide(post_pos, rl_line_buffer+rl_point, rl_end-rl_point)] = 0;
+| 142|    |-
+| 143|    |-		size_t cpos = pos;
+| 144|    |-		for (wchar_t *c = post_pos; *c != 0; ++c)
+| 145|    |-		{
+| 146|    |-			int n = wcwidth(*c);
+| 147|    |-			if (n < 0)
+| 148|    |-			{
+| 149|    |-				print_char(L'.');
+| 150|    |-				++cpos;
+| 151|    |-			}
+| 152|    |-			else
+| 153|    |-			{
+| 154|    |-				if (cpos+n > width)
+| 155|    |-					break;
+| 156|    |-				cpos += n;
+| 157|    |-				print_char(*c);
+| 158|    |-			}
+| 159|    |-		}
+| 160|    |-	}
+| 161|    |-	else
+| 162|    |-	{
+| 163|    |-		// if the current position in the string is bigger than allowed
+| 164|    |-		// width, we always keep the cursor at the end of the line (it
+| 165|    |-		// would be nice to have more flexible scrolling, but for now
+| 166|    |-		// let's stick to that) by cutting the beginning of the part
+| 167|    |-		// of the string before the cursor until it fits the area.
+| 168|    |-
+| 169|    |-		wchar_t *mod_pre_pos = pre_pos;
+| 170|    |-		while (*mod_pre_pos != 0)
+| 171|    |-		{
+| 172|    |-			++mod_pre_pos;
+| 173|    |-			int n = wcwidth(*mod_pre_pos);
+| 174|    |-			if (n < 0)
+| 175|    |-				--pos;
+| 176|    |-			else
+| 177|    |-				pos -= n;
+| 178|    |-			if (size_t(pos) <= width)
+| 179|    |-				break;
+| 180|    |-		}
+| 181|    |-		print_string(mod_pre_pos, pos);
+| 182|    |-	}
+| 183|    |-	w->goToXY(start_x+pos, start_y);
+| 184|    |-}
+| 185|    |-
+| 186|    |-int add_base()
+| 187|    |-{
+| 188|    |-	rl_insert_text(base);
+| 189|    |-	return 0;
+| 190|    |-}
+| 191|    |-
+| 192|    |-}
+| 193|    |-
+| 194|    |-int color_pair_counter;
+| 195|    |-std::vector<int> color_pair_map;
+| 196|    |-
+| 197|    |-}
+| 198|    |-
+| 199|    |-namespace NC {
+| 200|    |-
+| 201|    |-const short Color::transparent = -1;
+| 202|    |-const short Color::current = -2;
+| 203|    |-
+| 204|    |-Color Color::Default(0, 0, true, false);
+| 205|    |-Color Color::Black(COLOR_BLACK, Color::current);
+| 206|    |-Color Color::Red(COLOR_RED, Color::current);
+| 207|    |-Color Color::Green(COLOR_GREEN, Color::current);
+| 208|    |-Color Color::Yellow(COLOR_YELLOW, Color::current);
+| 209|    |-Color Color::Blue(COLOR_BLUE, Color::current);
+| 210|    |-Color Color::Magenta(COLOR_MAGENTA, Color::current);
+| 211|    |-Color Color::Cyan(COLOR_CYAN, Color::current);
+| 212|    |-Color Color::White(COLOR_WHITE, Color::current);
+| 213|    |-Color Color::End(0, 0, false, true);
+| 214|    |-
+| 215|    |-int Color::pairNumber() const
+| 216|    |-{
+| 217|    |-	// If colors are disabled, return default pair value.
+| 218|    |-	if (color_pair_map.empty())
+| 219|    |-		return 0;
+| 220|    |-
+| 221|    |-	int result = 0;
+| 222|    |-	if (isEnd())
+| 223|    |-		throw std::logic_error("'end' doesn't have a corresponding pair number");
+| 224|    |-	else if (!isDefault())
+| 225|    |-	{
+| 226|    |-		if (!currentBackground())
+| 227|    |-			result = (background() + 1) % COLORS;
+| 228|    |-		result *= 256;
+| 229|    |-		result += foreground() % COLORS;
+| 230|    |-
+| 231|    |-		assert(result < int(color_pair_map.size()));
+| 232|    |-
+| 233|    |-		// NCurses allows for a limited number of color pairs to be registered, so
+| 234|    |-		// in order to be able to support all the combinations we want to, we need
+| 235|    |-		// to dynamically register only pairs of colors we're actually using.
+| 236|    |-		if (!color_pair_map[result])
+| 237|    |-		{
+| 238|    |-			// Check if there are any unused pairs left and either register the one
+| 239|    |-			// that was requested or return a default one if there is no space left.
+| 240|    |-			if (color_pair_counter >= COLOR_PAIRS)
+| 241|    |-				result = 0;
+| 242|    |-			else
+| 243|    |-			{
+| 244|    |-				init_pair(color_pair_counter, foreground(), background());
+| 245|    |-				color_pair_map[result] = color_pair_counter;
+| 246|    |-				++color_pair_counter;
+| 247|    |-			}
+| 248|    |-		}
+| 249|    |-		result = color_pair_map[result];
+| 250|    |-	}
+| 251|    |-	return result;
+| 252|    |-}
+| 253|    |-
+| 254|    |-std::istream &operator>>(std::istream &is, Color &c)
+| 255|    |-{
+| 256|    |-	const short invalid_color_value = -1337;
+| 257|    |-	auto get_single_color = [](const std::string &s, bool background) {
+| 258|    |-		short result = invalid_color_value;
+| 259|    |-		if (s == "black")
+| 260|    |-			result = COLOR_BLACK;
+| 261|    |-		else if (s == "red")
+| 262|    |-			result = COLOR_RED;
+| 263|    |-		else if (s == "green")
+| 264|    |-			result = COLOR_GREEN;
+| 265|    |-		else if (s == "yellow")
+| 266|    |-			result = COLOR_YELLOW;
+| 267|    |-		else if (s == "blue")
+| 268|    |-			result = COLOR_BLUE;
+| 269|    |-		else if (s == "magenta")
+| 270|    |-			result = COLOR_MAGENTA;
+| 271|    |-		else if (s == "cyan")
+| 272|    |-			result = COLOR_CYAN;
+| 273|    |-		else if (s == "white")
+| 274|    |-			result = COLOR_WHITE;
+| 275|    |-		else if (background && s == "transparent")
+| 276|    |-			result = NC::Color::transparent;
+| 277|    |-		else if (background && s == "current")
+| 278|    |-			result = NC::Color::current;
+| 279|    |-		else if (std::all_of(s.begin(), s.end(), isdigit))
+| 280|    |-		{
+| 281|    |-			result = atoi(s.c_str());
+| 282|    |-			if (result < (background ? 0 : 1) || result > 256)
+| 283|    |-				result = invalid_color_value;
+| 284|    |-			else
+| 285|    |-				--result;
+| 286|    |-		}
+| 287|    |-		return result;
+| 288|    |-	};
+| 289|    |-
+| 290|    |-	auto get_color = [](std::istream &is_) {
+| 291|    |-		std::string result;
+| 292|    |-		while (!is_.eof() && isalnum(is_.peek()))
+| 293|    |-			result.push_back(is_.get());
+| 294|    |-		return result;
+| 295|    |-	};
+| 296|    |-
+| 297|    |-	std::string sc = get_color(is);
+| 298|    |-
+| 299|    |-	if (sc == "default")
+| 300|    |-		c = Color::Default;
+| 301|    |-	else if (sc == "end")
+| 302|    |-		c = Color::End;
+| 303|    |-	else
+| 304|    |-	{
+| 305|    |-		short fg = get_single_color(sc, false);
+| 306|    |-		if (fg == invalid_color_value)
+| 307|    |-			is.setstate(std::ios::failbit);
+| 308|    |-		// Check if there is background color
+| 309|    |-		else if (!is.eof() && is.peek() == '_')
+| 310|    |-		{
+| 311|    |-			is.get();
+| 312|    |-			sc = get_color(is);
+| 313|    |-			short bg = get_single_color(sc, true);
+| 314|    |-			if (bg == invalid_color_value)
+| 315|    |-				is.setstate(std::ios::failbit);
+| 316|    |-			else
+| 317|    |-				c = Color(fg, bg);
+| 318|    |-		}
+| 319|    |-		else
+| 320|    |-			c = Color(fg, NC::Color::current);
+| 321|    |-	}
+| 322|    |-	return is;
+| 323|    |-}
+| 324|    |-
+| 325|    |-NC::Format reverseFormat(NC::Format fmt)
+| 326|    |-{
+| 327|    |-	switch (fmt)
+| 328|    |-	{
+| 329|    |-	case NC::Format::Bold:
+| 330|    |-		return NC::Format::NoBold;
+| 331|    |-	case NC::Format::NoBold:
+| 332|    |-		return NC::Format::Bold;
+| 333|    |-	case NC::Format::Underline:
+| 334|    |-		return NC::Format::NoUnderline;
+| 335|    |-	case NC::Format::NoUnderline:
+| 336|    |-		return NC::Format::Underline;
+| 337|    |-	case NC::Format::Reverse:
+| 338|    |-		return NC::Format::NoReverse;
+| 339|    |-	case NC::Format::NoReverse:
+| 340|    |-		return NC::Format::Reverse;
+| 341|    |-	case NC::Format::AltCharset:
+| 342|    |-		return NC::Format::NoAltCharset;
+| 343|    |-	case NC::Format::NoAltCharset:
+| 344|    |-		return NC::Format::AltCharset;
+| 345|    |-	}
+| 346|    |-	// Unreachable, silence GCC.
+| 347|    |-	return fmt;
+| 348|    |-}
+| 349|    |-
+| 350|    |-namespace Mouse {
+| 351|    |-
+| 352|    |-namespace {
+| 353|    |-
+| 354|    |-bool supportEnabled = false;
+| 355|    |-
+| 356|    |-}
+| 357|    |-
+| 358|    |-void enable()
+| 359|    |-{
+| 360|    |-	if (!supportEnabled)
+| 361|    |-		return;
+| 362|    |-	// save old highlight mouse tracking
+| 363|    |-	std::printf("\e[?1001s");
+| 364|    |-	// enable mouse tracking
+| 365|    |-	std::printf("\e[?1000h");
+| 366|    |-	// try to enable extended (urxvt) mouse tracking
+| 367|    |-	std::printf("\e[?1015h");
+| 368|    |-	// send the above to the terminal immediately
+| 369|    |-	std::fflush(stdout);
+| 370|    |-}
+| 371|    |-
+| 372|    |-void disable()
+| 373|    |-{
+| 374|    |-	if (!supportEnabled)
+| 375|    |-		return;
+| 376|    |-	// disable extended (urxvt) mouse tracking
+| 377|    |-	std::printf("\e[?1015l");
+| 378|    |-	// disable mouse tracking
+| 379|    |-	std::printf("\e[?1000l");
+| 380|    |-	// restore old highlight mouse tracking
+| 381|    |-	std::printf("\e[?1001r");
+| 382|    |-	// send the above to the terminal immediately
+| 383|    |-	std::fflush(stdout);
+| 384|    |-}
+| 385|    |-
+| 386|    |-}
+| 387|    |-
+| 388|    |-void initScreen(bool enable_colors, bool enable_mouse)
+| 389|    |-{
+| 390|    |-	initscr();
+| 391|    |-	if (has_colors() && enable_colors)
+| 392|    |-	{
+| 393|    |-		start_color();
+| 394|    |-		use_default_colors();
+| 395|    |-		color_pair_map.resize(256 * 256, 0);
+| 396|    |-
+| 397|    |-		// Predefine pairs for colors with transparent background, all the other
+| 398|    |-		// ones will be dynamically registered in Color::pairNumber when they're
+| 399|    |-		// used.
+| 400|    |-		color_pair_counter = 1;
+| 401|    |-		for (int fg = 0; fg < COLORS; ++fg, ++color_pair_counter)
+| 402|    |-		{
+| 403|    |-			init_pair(color_pair_counter, fg, -1);
+| 404|    |-			color_pair_map[fg] = color_pair_counter;
+| 405|    |-		}
+| 406|    |-	}
+| 407|    |-	raw();
+| 408|    |-	nonl();
+| 409|    |-	noecho();
+| 410|    |-	timeout(0);
+| 411|    |-	curs_set(0);
+| 412|    |-
+| 413|    |-	// setup mouse
+| 414|    |-	Mouse::supportEnabled = enable_mouse;
+| 415|    |-	Mouse::enable();
+| 416|    |-
+| 417|    |-	// initialize readline (needed, otherwise we get segmentation
+| 418|    |-	// fault on SIGWINCH). also, initialize first as doing this
+| 419|    |-	// later erases keys bound with rl_bind_key for some users.
+| 420|    |-	rl_initialize();
+| 421|    |-	// disable autocompletion
+| 422|    |-	rl_attempted_completion_function = [](const char *, int, int) -> char ** {
+| 423|    |-		rl_attempted_completion_over = 1;
+| 424|    |-		return nullptr;
+| 425|    |-	};
+| 426|    |-	auto abort_prompt = [](int, int) -> int {
+| 427|    |-		rl::aborted = true;
+| 428|    |-		rl_done = 1;
+| 429|    |-		return 0;
+| 430|    |-	};
+| 431|    |-	// if ctrl-c or ctrl-g is pressed, abort the prompt
+| 432|    |-	rl_bind_key('\3', abort_prompt);
+| 433|    |-	rl_bind_key('\7', abort_prompt);
+| 434|    |-	// do not change the state of the terminal
+| 435|    |-	rl_prep_term_function = nullptr;
+| 436|    |-	rl_deprep_term_function = nullptr;
+| 437|    |-	// do not catch signals
+| 438|    |-	rl_catch_signals = 0;
+| 439|    |-	rl_catch_sigwinch = 0;
+| 440|    |-	// overwrite readline callbacks
+| 441|    |-	rl_getc_function = rl::read_key;
+| 442|    |-	rl_redisplay_function = rl::display_string;
+| 443|    |-	rl_startup_hook = rl::add_base;
+| 444|    |-}
+| 445|    |-
+| 446|    |-void destroyScreen()
+| 447|    |-{
+| 448|    |-	Mouse::disable();
+| 449|    |-	curs_set(1);
+| 450|    |-	endwin();
+| 451|    |-}
+| 452|    |-
+| 453|    |-Window::Window(size_t startx, size_t starty, size_t width, size_t height,
+| 454|    |-               std::string title, Color color, Border border)
+| 455|    |-	: m_window(nullptr),
+| 456|    |-	  m_start_x(startx),
+| 457|    |-	  m_start_y(starty),
+| 458|    |-	  m_width(width),
+| 459|    |-	  m_height(height),
+| 460|    |-	  m_window_timeout(-1),
+| 461|    |-	  m_border(std::move(border)),
+| 462|    |-	  m_prompt_hook(0),
+| 463|    |-	  m_title(std::move(title)),
+| 464|    |-	  m_escape_terminal_sequences(true),
+| 465|    |-	  m_bold_counter(0),
+| 466|    |-	  m_underline_counter(0),
+| 467|    |-	  m_reverse_counter(0),
+| 468|    |-	  m_alt_charset_counter(0)
+| 469|    |-{
+| 470|    |-	if (m_start_x > size_t(COLS)
+| 471|    |-	    ||  m_start_y > size_t(LINES)
+| 472|    |-	    ||  m_width+m_start_x > size_t(COLS)
+| 473|    |-	    ||  m_height+m_start_y > size_t(LINES))
+| 474|    |-		throw std::logic_error("constructed window doesn't fit into the terminal");
+| 475|    |-
+| 476|    |-	if (m_border)
+| 477|    |-	{
+| 478|    |-		++m_start_x;
+| 479|    |-		++m_start_y;
+| 480|    |-		m_width -= 2;
+| 481|    |-		m_height -= 2;
+| 482|    |-	}
+| 483|    |-	if (!m_title.empty())
+| 484|    |-	{
+| 485|    |-		m_start_y += 2;
+| 486|    |-		m_height -= 2;
+| 487|    |-	}
+| 488|    |-	
+| 489|    |-	m_window = newpad(m_height, m_width);
+| 490|    |-	wtimeout(m_window, 0);
+| 491|    |-
+| 492|    |-	setBaseColor(color);
+| 493|    |-	setColor(m_base_color);
+| 494|    |-}
+| 495|    |-
+| 496|    |-Window::Window(const Window &rhs)
+| 497|    |-: m_window(dupwin(rhs.m_window))
+| 498|    |-, m_start_x(rhs.m_start_x)
+| 499|    |-, m_start_y(rhs.m_start_y)
+| 500|    |-, m_width(rhs.m_width)
+| 501|    |-, m_height(rhs.m_height)
+| 502|    |-, m_window_timeout(rhs.m_window_timeout)
+| 503|    |-, m_color(rhs.m_color)
+| 504|    |-, m_base_color(rhs.m_base_color)
+| 505|    |-, m_border(rhs.m_border)
+| 506|    |-, m_prompt_hook(rhs.m_prompt_hook)
+| 507|    |-, m_title(rhs.m_title)
+| 508|    |-, m_color_stack(rhs.m_color_stack)
+| 509|    |-, m_input_queue(rhs.m_input_queue)
+| 510|    |-, m_fds(rhs.m_fds)
+| 511|    |-, m_escape_terminal_sequences(rhs.m_escape_terminal_sequences)
+| 512|    |-, m_bold_counter(rhs.m_bold_counter)
+| 513|    |-, m_underline_counter(rhs.m_underline_counter)
+| 514|    |-, m_reverse_counter(rhs.m_reverse_counter)
+| 515|    |-, m_alt_charset_counter(rhs.m_alt_charset_counter)
+| 516|    |-{
+| 517|    |-	setColor(m_color);
+| 518|    |-}
+| 519|    |-
+| 520|    |-Window::Window(Window &&rhs)
+| 521|    |-: m_window(rhs.m_window)
+| 522|    |-, m_start_x(rhs.m_start_x)
+| 523|    |-, m_start_y(rhs.m_start_y)
+| 524|    |-, m_width(rhs.m_width)
+| 525|    |-, m_height(rhs.m_height)
+| 526|    |-, m_window_timeout(rhs.m_window_timeout)
+| 527|    |-, m_color(rhs.m_color)
+| 528|    |-, m_base_color(rhs.m_base_color)
+| 529|    |-, m_border(rhs.m_border)
+| 530|    |-, m_prompt_hook(rhs.m_prompt_hook)
+| 531|    |-, m_title(std::move(rhs.m_title))
+| 532|    |-, m_color_stack(std::move(rhs.m_color_stack))
+| 533|    |-, m_input_queue(std::move(rhs.m_input_queue))
+| 534|    |-, m_fds(std::move(rhs.m_fds))
+| 535|    |-, m_escape_terminal_sequences(rhs.m_escape_terminal_sequences)
+| 536|    |-, m_bold_counter(rhs.m_bold_counter)
+| 537|    |-, m_underline_counter(rhs.m_underline_counter)
+| 538|    |-, m_reverse_counter(rhs.m_reverse_counter)
+| 539|    |-, m_alt_charset_counter(rhs.m_alt_charset_counter)
+| 540|    |-{
+| 541|    |-	rhs.m_window = nullptr;
+| 542|    |-}
+| 543|    |-
+| 544|    |-Window &Window::operator=(Window rhs)
+| 545|    |-{
+| 546|    |-	std::swap(m_window, rhs.m_window);
+| 547|    |-	std::swap(m_start_x, rhs.m_start_x);
+| 548|    |-	std::swap(m_start_y, rhs.m_start_y);
+| 549|    |-	std::swap(m_width, rhs.m_width);
+| 550|    |-	std::swap(m_height, rhs.m_height);
+| 551|    |-	std::swap(m_window_timeout, rhs.m_window_timeout);
+| 552|    |-	std::swap(m_color, rhs.m_color);
+| 553|    |-	std::swap(m_base_color, rhs.m_base_color);
+| 554|    |-	std::swap(m_border, rhs.m_border);
+| 555|    |-	std::swap(m_prompt_hook, rhs.m_prompt_hook);
+| 556|    |-	std::swap(m_title, rhs.m_title);
+| 557|    |-	std::swap(m_color_stack, rhs.m_color_stack);
+| 558|    |-	std::swap(m_input_queue, rhs.m_input_queue);
+| 559|    |-	std::swap(m_fds, rhs.m_fds);
+| 560|    |-	std::swap(m_escape_terminal_sequences, rhs.m_escape_terminal_sequences);
+| 561|    |-	std::swap(m_bold_counter, rhs.m_bold_counter);
+| 562|    |-	std::swap(m_underline_counter, rhs.m_underline_counter);
+| 563|    |-	std::swap(m_reverse_counter, rhs.m_reverse_counter);
+| 564|    |-	std::swap(m_alt_charset_counter, rhs.m_alt_charset_counter);
+| 565|    |-	return *this;
+| 566|    |-}
+| 567|    |-
+| 568|    |-Window::~Window()
+| 569|    |-{
+| 570|    |-	delwin(m_window);
+| 571|    |-}
+| 572|    |-
+| 573|    |-void Window::setColor(Color c)
+| 574|    |-{
+| 575|    |-	if (c.isDefault())
+| 576|    |-		c = m_base_color;
+| 577|    |-	if (c != Color::Default)
+| 578|    |-	{
+| 579|    |-		assert(!c.currentBackground());
+| 580|    |-		wcolor_set(m_window, c.pairNumber(), nullptr);
+| 581|    |-	}
+| 582|    |-	else
+| 583|    |-		wcolor_set(m_window, m_base_color.pairNumber(), nullptr);
+| 584|    |-	m_color = std::move(c);
+| 585|    |-}
+| 586|    |-
+| 587|    |-void Window::setBaseColor(const Color &color)
+| 588|    |-{
+| 589|    |-	if (color.currentBackground())
+| 590|    |-		m_base_color = Color(color.foreground(), Color::transparent);
+| 591|    |-	else
+| 592|    |-		m_base_color = color;
+| 593|    |-}
+| 594|    |-
+| 595|    |-void Window::setBorder(Border border)
+| 596|    |-{
+| 597|    |-	if (!border && m_border)
+| 598|    |-	{
+| 599|    |-		--m_start_x;
+| 600|    |-		--m_start_y;
+| 601|    |-		m_height += 2;
+| 602|    |-		m_width += 2;
+| 603|    |-		recreate(m_width, m_height);
+| 604|    |-	}
+| 605|    |-	else if (border && !m_border)
+| 606|    |-	{
+| 607|    |-		++m_start_x;
+| 608|    |-		++m_start_y;
+| 609|    |-		m_height -= 2;
+| 610|    |-		m_width -= 2;
+| 611|    |-		recreate(m_width, m_height);
+| 612|    |-	}
+| 613|    |-	m_border = border;
+| 614|    |-}
+| 615|    |-
+| 616|    |-void Window::setTitle(const std::string &new_title)
+| 617|    |-{
+| 618|    |-	if (!new_title.empty() && m_title.empty())
+| 619|    |-	{
+| 620|    |-		m_start_y += 2;
+| 621|    |-		m_height -= 2;
+| 622|    |-		recreate(m_width, m_height);
+| 623|    |-	}
+| 624|    |-	else if (new_title.empty() && !m_title.empty())
+| 625|    |-	{
+| 626|    |-		m_start_y -= 2;
+| 627|    |-		m_height += 2;
+| 628|    |-		recreate(m_width, m_height);
+| 629|    |-	}
+| 630|    |-	m_title = new_title;
+| 631|    |-}
+| 632|    |-
+| 633|    |-void Window::recreate(size_t width, size_t height)
+| 634|    |-{
+| 635|    |-	delwin(m_window);
+| 636|    |-	m_window = newpad(height, width);
+| 637|    |-	wtimeout(m_window, 0);
+| 638|    |-	setColor(m_color);
+| 639|    |-}
+| 640|    |-
+| 641|    |-void Window::moveTo(size_t new_x, size_t new_y)
+| 642|    |-{
+| 643|    |-	m_start_x = new_x;
+| 644|    |-	m_start_y = new_y;
+| 645|    |-	if (m_border)
+| 646|    |-	{
+| 647|    |-		++m_start_x;
+| 648|    |-		++m_start_y;
+| 649|    |-	}
+| 650|    |-	if (!m_title.empty())
+| 651|    |-		m_start_y += 2;
+| 652|    |-}
+| 653|    |-
+| 654|    |-void Window::adjustDimensions(size_t width, size_t height)
+| 655|    |-{
+| 656|    |-	if (m_border)
+| 657|    |-	{
+| 658|    |-		width -= 2;
+| 659|    |-		height -= 2;
+| 660|    |-	}
+| 661|    |-	if (!m_title.empty())
+| 662|    |-		height -= 2;
+| 663|    |-	m_height = height;
+| 664|    |-	m_width = width;
+| 665|    |-}
+| 666|    |-
+| 667|    |-void Window::resize(size_t new_width, size_t new_height)
+| 668|    |-{
+| 669|    |-	adjustDimensions(new_width, new_height);
+| 670|    |-	recreate(m_width, m_height);
+| 671|    |-}
+| 672|    |-
+| 673|    |-void Window::refreshBorder() const
+| 674|    |-{
+| 675|    |-	if (m_border)
+| 676|    |-	{
+| 677|    |-		size_t start_x = getStartX(), start_y = getStarty();
+| 678|    |-		size_t width = getWidth(), height = getHeight();
+| 679|    |-		color_set(m_border->pairNumber(), nullptr);
+| 680|    |-		attron(A_ALTCHARSET);
+| 681|    |-		// corners
+| 682|    |-		mvaddch(start_y, start_x, 'l');
+| 683|    |-		mvaddch(start_y, start_x+width-1, 'k');
+| 684|    |-		mvaddch(start_y+height-1, start_x, 'm');
+| 685|    |-		mvaddch(start_y+height-1, start_x+width-1, 'j');
+| 686|    |-		// lines
+| 687|    |-		mvhline(start_y, start_x+1, 'q', width-2);
+| 688|    |-		mvhline(start_y+height-1, start_x+1, 'q', width-2);
+| 689|    |-		mvvline(start_y+1, start_x, 'x', height-2);
+| 690|    |-		mvvline(start_y+1, start_x+width-1, 'x', height-2);
+| 691|    |-		if (!m_title.empty())
+| 692|    |-		{
+| 693|    |-			mvaddch(start_y+2, start_x, 't');
+| 694|    |-			mvaddch(start_y+2, start_x+width-1, 'u');
+| 695|    |-		}
+| 696|    |-		attroff(A_ALTCHARSET);
+| 697|    |-	}
+| 698|    |-	else
+| 699|    |-		color_set(m_base_color.pairNumber(), nullptr);
+| 700|    |-	if (!m_title.empty())
+| 701|    |-	{
+| 702|    |-		// clear title line
+| 703|    |-		mvhline(m_start_y-2, m_start_x, ' ', m_width);
+| 704|    |-		attron(A_BOLD);
+| 705|    |-		mvaddstr(m_start_y-2, m_start_x, m_title.c_str());
+| 706|    |-		attroff(A_BOLD);
+| 707|    |-		// add separator
+| 708|    |-		mvhline(m_start_y-1, m_start_x, 0, m_width);
+| 709|    |-	}
+| 710|    |-	standend();
+| 711|    |-	::refresh();
+| 712|    |-}
+| 713|    |-
+| 714|    |-void Window::display()
+| 715|    |-{
+| 716|    |-	refreshBorder();
+| 717|    |-	refresh();
+| 718|    |-}
+| 719|    |-
+| 720|    |-void Window::refresh()
+| 721|    |-{
+| 722|    |-	prefresh(m_window, 0, 0, m_start_y, m_start_x, m_start_y+m_height-1, m_start_x+m_width-1);
+| 723|    |-}
+| 724|    |-
+| 725|    |-void Window::clear()
+| 726|    |-{
+| 727|    |-	werase(m_window);
+| 728|    |-	setColor(m_base_color);
+| 729|    |-}
+| 730|    |-
+| 731|    |-void Window::bold(bool bold_state) const
+| 732|    |-{
+| 733|    |-	(bold_state ? wattron : wattroff)(m_window, A_BOLD);
+| 734|    |-}
+| 735|    |-
+| 736|    |-void Window::underline(bool underline_state) const
+| 737|    |-{
+| 738|    |-	(underline_state ? wattron : wattroff)(m_window, A_UNDERLINE);
+| 739|    |-}
+| 740|    |-
+| 741|    |-void Window::reverse(bool reverse_state) const
+| 742|    |-{
+| 743|    |-	(reverse_state ? wattron : wattroff)(m_window, A_REVERSE);
+| 744|    |-}
+| 745|    |-
+| 746|    |-void Window::altCharset(bool altcharset_state) const
+| 747|    |-{
+| 748|    |-	(altcharset_state ? wattron : wattroff)(m_window, A_ALTCHARSET);
+| 749|    |-}
+| 750|    |-
+| 751|    |-void Window::setTimeout(int timeout)
+| 752|    |-{
+| 753|    |-	m_window_timeout = timeout;
+| 754|    |-}
+| 755|    |-
+| 756|    |-void Window::addFDCallback(int fd, void (*callback)())
+| 757|    |-{
+| 758|    |-	m_fds.push_back(std::make_pair(fd, callback));
+| 759|    |-}
+| 760|    |-
+| 761|    |-void Window::clearFDCallbacksList()
+| 762|    |-{
+| 763|    |-	m_fds.clear();
+| 764|    |-}
+| 765|    |-
+| 766|    |-bool Window::FDCallbacksListEmpty() const
+| 767|    |-{
+| 768|    |-	return m_fds.empty();
+| 769|    |-}
+| 770|    |-
+| 771|    |-Key::Type Window::getInputChar(int key)
+| 772|    |-{
+| 773|    |-	if (!m_escape_terminal_sequences || key != Key::Escape)
+| 774|    |-		return key;
+| 775|    |-	auto define_mouse_event = [this](int type) {
+| 776|    |-		switch (type & ~28)
+| 777|    |-		{
+| 778|    |-		case 32:
+| 779|    |-			m_mouse_event.bstate = BUTTON1_PRESSED;
+| 780|    |-			break;
+| 781|    |-		case 33:
+| 782|    |-			m_mouse_event.bstate = BUTTON2_PRESSED;
+| 783|    |-			break;
+| 784|    |-		case 34:
+| 785|    |-			m_mouse_event.bstate = BUTTON3_PRESSED;
+| 786|    |-			break;
+| 787|    |-		case 96:
+| 788|    |-			m_mouse_event.bstate = BUTTON4_PRESSED;
+| 789|    |-			break;
+| 790|    |-		case 97:
+| 791|    |-			m_mouse_event.bstate = BUTTON5_PRESSED;
+| 792|    |-			break;
+| 793|    |-		default:
+| 794|    |-			return Key::None;
+| 795|    |-		}
+| 796|    |-		if (type & 4)
+| 797|    |-			m_mouse_event.bstate |= BUTTON_SHIFT;
+| 798|    |-		if (type & 8)
+| 799|    |-			m_mouse_event.bstate |= BUTTON_ALT;
+| 800|    |-		if (type & 16)
+| 801|    |-			m_mouse_event.bstate |= BUTTON_CTRL;
+| 802|    |-		if (m_mouse_event.x < 0 || m_mouse_event.x >= COLS)
+| 803|    |-			return Key::None;
+| 804|    |-		if (m_mouse_event.y < 0 || m_mouse_event.y >= LINES)
+| 805|    |-			return Key::None;
+| 806|    |-		return Key::Mouse;
+| 807|    |-	};
+| 808|    |-	auto get_xterm_modifier_key = [](int ch) {
+| 809|    |-		Key::Type modifier;
+| 810|    |-		switch (ch)
+| 811|    |-		{
+| 812|    |-		case '2':
+| 813|    |-			modifier = Key::Shift;
+| 814|    |-			break;
+| 815|    |-		case '3':
+| 816|    |-			modifier = Key::Alt;
+| 817|    |-			break;
+| 818|    |-		case '4':
+| 819|    |-			modifier = Key::Alt | Key::Shift;
+| 820|    |-			break;
+| 821|    |-		case '5':
+| 822|    |-			modifier = Key::Ctrl;
+| 823|    |-			break;
+| 824|    |-		case '6':
+| 825|    |-			modifier = Key::Ctrl | Key::Shift;
+| 826|    |-			break;
+| 827|    |-		case '7':
+| 828|    |-			modifier = Key::Alt | Key::Ctrl;
+| 829|    |-			break;
+| 830|    |-		case '8':
+| 831|    |-			modifier = Key::Alt | Key::Ctrl | Key::Shift;
+| 832|    |-			break;
+| 833|    |-		default:
+| 834|    |-			modifier = Key::None;
+| 835|    |-		}
+| 836|    |-		return modifier;
+| 837|    |-	};
+| 838|    |-	auto parse_number = [this](int &result) {
+| 839|    |-		int x;
+| 840|    |-		while (true)
+| 841|    |-		{
+| 842|    |-			x = wgetch(m_window);
+| 843|    |-			if (!isdigit(x))
+| 844|    |-				return x;
+| 845|    |-			result = result*10 + x - '0';
+| 846|    |-		}
+| 847|    |-	};
+| 848|    |-	key = wgetch(m_window);
+| 849|    |-	switch (key)
+| 850|    |-	{
+| 851|    |-	case '\t': // tty
+| 852|    |-		return Key::Shift | Key::Tab;
+| 853|    |-	case 'O':
+| 854|    |-		key = wgetch(m_window);
+| 855|    |-		switch (key)
+| 856|    |-		{
+| 857|    |-		// eterm
+| 858|    |-		case 'A':
+| 859|    |-			return Key::Up;
+| 860|    |-		case 'B':
+| 861|    |-			return Key::Down;
+| 862|    |-		case 'C':
+| 863|    |-			return Key::Right;
+| 864|    |-		case 'D':
+| 865|    |-			return Key::Left;
+| 866|    |-		// terminator
+| 867|    |-		case 'F':
+| 868|    |-			return Key::End;
+| 869|    |-		case 'H':
+| 870|    |-			return Key::Home;
+| 871|    |-		// rxvt
+| 872|    |-		case 'a':
+| 873|    |-			return Key::Ctrl | Key::Up;
+| 874|    |-		case 'b':
+| 875|    |-			return Key::Ctrl | Key::Down;
+| 876|    |-		case 'c':
+| 877|    |-			return Key::Ctrl | Key::Right;
+| 878|    |-		case 'd':
+| 879|    |-			return Key::Ctrl | Key::Left;
+| 880|    |-		// xterm
+| 881|    |-		case 'P':
+| 882|    |-			return Key::F1;
+| 883|    |-		case 'Q':
+| 884|    |-			return Key::F2;
+| 885|    |-		case 'R':
+| 886|    |-			return Key::F3;
+| 887|    |-		case 'S':
+| 888|    |-			return Key::F4;
+| 889|    |-		default:
+| 890|    |-			return Key::None;
+| 891|    |-		}
+| 892|    |-	case '[':
+| 893|    |-		key = wgetch(m_window);
+| 894|    |-		switch (key)
+| 895|    |-		{
+| 896|    |-		case 'a':
+| 897|    |-			return Key::Shift | Key::Up;
+| 898|    |-		case 'b':
+| 899|    |-			return Key::Shift | Key::Down;
+| 900|    |-		case 'c':
+| 901|    |-			return Key::Shift | Key::Right;
+| 902|    |-		case 'd':
+| 903|    |-			return Key::Shift | Key::Left;
+| 904|    |-		case 'A':
+| 905|    |-			return Key::Up;
+| 906|    |-		case 'B':
+| 907|    |-			return Key::Down;
+| 908|    |-		case 'C':
+| 909|    |-			return Key::Right;
+| 910|    |-		case 'D':
+| 911|    |-			return Key::Left;
+| 912|    |-		case 'F': // xterm
+| 913|    |-			return Key::End;
+| 914|    |-		case 'H': // xterm
+| 915|    |-			return Key::Home;
+| 916|    |-		case 'M': // standard mouse event
+| 917|    |-		{
+| 918|    |-			key = wgetch(m_window);
+| 919|    |-			int raw_x = wgetch(m_window);
+| 920|    |-			int raw_y = wgetch(m_window);
+| 921|    |-			// support coordinates up to 255
+| 922|    |-			m_mouse_event.x = (raw_x - 33) & 0xff;
+| 923|    |-			m_mouse_event.y = (raw_y - 33) & 0xff;
+| 924|    |-			return define_mouse_event(key);
+| 925|    |-		}
+| 926|    |-		case 'Z':
+| 927|    |-			return Key::Shift | Key::Tab;
+| 928|    |-		case '[': // F1 to F5 in tty
+| 929|    |-			key = wgetch(m_window);
+| 930|    |-			switch (key)
+| 931|    |-			{
+| 932|    |-			case 'A':
+| 933|    |-				return Key::F1;
+| 934|    |-			case 'B':
+| 935|    |-				return Key::F2;
+| 936|    |-			case 'C':
+| 937|    |-				return Key::F3;
+| 938|    |-			case 'D':
+| 939|    |-				return Key::F4;
+| 940|    |-			case 'E':
+| 941|    |-				return Key::F5;
+| 942|    |-			default:
+| 943|    |-				return Key::None;
+| 944|    |-			}
+| 945|    |-		case '1': case '2': case '3':
+| 946|    |-		case '4': case '5': case '6':
+| 947|    |-		case '7': case '8': case '9':
+| 948|    |-		{
+| 949|    |-			key -= '0';
+| 950|    |-			int delim = parse_number(key);
+| 951|    |-			if (key >= 2 && key <= 8)
+| 952|    |-			{
+| 953|    |-				Key::Type modifier;
+| 954|    |-				switch (delim)
+| 955|    |-				{
+| 956|    |-				case '~':
+| 957|    |-					modifier = Key::Null;
+| 958|    |-					break;
+| 959|    |-				case '^':
+| 960|    |-					modifier = Key::Ctrl;
+| 961|    |-					break;
+| 962|    |-				case '$':
+| 963|    |-					modifier = Key::Shift;
+| 964|    |-					break;
+| 965|    |-				case '@':
+| 966|    |-					modifier = Key::Ctrl | Key::Shift;
+| 967|    |-					break;
+| 968|    |-				case ';': // xterm insert/delete/page up/page down
+| 969|    |-				{
+| 970|    |-					int local_key = wgetch(m_window);
+| 971|    |-					modifier = get_xterm_modifier_key(local_key);
+| 972|    |-					local_key = wgetch(m_window);
+| 973|    |-					if (local_key != '~' || (key != 2 && key != 3 && key != 5 && key != 6))
+| 974|    |-						return Key::None;
+| 975|    |-					break;
+| 976|    |-				}
+| 977|    |-				default:
+| 978|    |-					return Key::None;
+| 979|    |-				}
+| 980|    |-				switch (key)
+| 981|    |-				{
+| 982|    |-				case 2:
+| 983|    |-					return modifier | Key::Insert;
+| 984|    |-				case 3:
+| 985|    |-					return modifier | Key::Delete;
+| 986|    |-				case 4:
+| 987|    |-					return modifier | Key::End;
+| 988|    |-				case 5:
+| 989|    |-					return modifier | Key::PageUp;
+| 990|    |-				case 6:
+| 991|    |-					return modifier | Key::PageDown;
+| 992|    |-				case 7:
+| 993|    |-					return modifier | Key::Home;
+| 994|    |-				case 8:
+| 995|    |-					return modifier | Key::End;
+| 996|    |-				default:
+| 997|    |-					std::cerr << "Unreachable code, aborting.\n";
+| 998|    |-					std::terminate();
+| 999|    |-				}
+|1000|    |-			}
+|1001|    |-			switch (delim)
+|1002|    |-			{
+|1003|    |-			case '~':
+|1004|    |-			{
+|1005|    |-				switch (key)
+|1006|    |-				{
+|1007|    |-				case 1: // tty
+|1008|    |-					return Key::Home;
+|1009|    |-				case 11:
+|1010|    |-					return Key::F1;
+|1011|    |-				case 12:
+|1012|    |-					return Key::F2;
+|1013|    |-				case 13:
+|1014|    |-					return Key::F3;
+|1015|    |-				case 14:
+|1016|    |-					return Key::F4;
+|1017|    |-				case 15:
+|1018|    |-					return Key::F5;
+|1019|    |-				case 17: // not a typo
+|1020|    |-					return Key::F6;
+|1021|    |-				case 18:
+|1022|    |-					return Key::F7;
+|1023|    |-				case 19:
+|1024|    |-					return Key::F8;
+|1025|    |-				case 20:
+|1026|    |-					return Key::F9;
+|1027|    |-				case 21:
+|1028|    |-					return Key::F10;
+|1029|    |-				case 23: // not a typo
+|1030|    |-					return Key::F11;
+|1031|    |-				case 24:
+|1032|    |-					return Key::F12;
+|1033|    |-				default:
+|1034|    |-					return Key::None;
+|1035|    |-				}
+|1036|    |-			}
+|1037|    |-			case ';':
+|1038|    |-				switch (key)
+|1039|    |-				{
+|1040|    |-				case 1: // xterm
+|1041|    |-				{
+|1042|    |-					key = wgetch(m_window);
+|1043|    |-					Key::Type modifier = get_xterm_modifier_key(key);
+|1044|    |-					if (modifier == Key::None)
+|1045|    |-						return Key::None;
+|1046|    |-					key = wgetch(m_window);
+|1047|    |-					switch (key)
+|1048|    |-					{
+|1049|    |-					case 'A':
+|1050|    |-						return modifier | Key::Up;
+|1051|    |-					case 'B':
+|1052|    |-						return modifier | Key::Down;
+|1053|    |-					case 'C':
+|1054|    |-						return modifier | Key::Right;
+|1055|    |-					case 'D':
+|1056|    |-						return modifier | Key::Left;
+|1057|    |-					case 'F':
+|1058|    |-						return modifier | Key::End;
+|1059|    |-					case 'H':
+|1060|    |-						return modifier | Key::Home;
+|1061|    |-					default:
+|1062|    |-						return Key::None;
+|1063|    |-					}
+|1064|    |-				}
+|1065|    |-				default: // urxvt mouse
+|1066|    |-					m_mouse_event.x = 0;
+|1067|    |-					delim = parse_number(m_mouse_event.x);
+|1068|    |-					if (delim != ';')
+|1069|    |-						return Key::None;
+|1070|    |-					m_mouse_event.y = 0;
+|1071|    |-					delim = parse_number(m_mouse_event.y);
+|1072|    |-					if (delim != 'M')
+|1073|    |-						return Key::None;
+|1074|    |-					--m_mouse_event.x;
+|1075|    |-					--m_mouse_event.y;
+|1076|    |-					return define_mouse_event(key);
+|1077|    |-				}
+|1078|    |-			default:
+|1079|    |-				return Key::None;
+|1080|    |-			}
+|1081|    |-		}
+|1082|    |-		default:
+|1083|    |-			return Key::None;
+|1084|    |-		}
+|1085|    |-	case ERR:
+|1086|    |-		return Key::Escape;
+|1087|    |-	default: // alt + something
+|1088|    |-	{
+|1089|    |-		auto key_prim = getInputChar(key);
+|1090|    |-		if (key_prim != Key::None)
+|1091|    |-			return Key::Alt | key_prim;
+|1092|    |-		return Key::None;
+|1093|    |-	}
+|1094|    |-	}
+|1095|    |-}
+|1096|    |-
+|1097|    |-Key::Type Window::readKey()
+|1098|    |-{
+|1099|    |-	Key::Type result;
+|1100|    |-	// if there are characters in input queue,
+|1101|    |-	// get them and return immediately.
+|1102|    |-	if (!m_input_queue.empty())
+|1103|    |-	{
+|1104|    |-		result = m_input_queue.front();
+|1105|    |-		m_input_queue.pop();
+|1106|    |-		return result;
+|1107|    |-	}
+|1108|    |-	
+|1109|    |-	fd_set fds_read;
+|1110|    |-	FD_ZERO(&fds_read);
+|1111|    |-	FD_SET(STDIN_FILENO, &fds_read);
+|1112|    |-	timeval timeout = { m_window_timeout/1000, (m_window_timeout%1000)*1000 };
+|1113|    |-	
+|1114|    |-	int fd_max = STDIN_FILENO;
+|1115|    |-	for (const auto &fd : m_fds)
+|1116|    |-	{
+|1117|    |-		if (fd.first > fd_max)
+|1118|    |-			fd_max = fd.first;
+|1119|    |-		FD_SET(fd.first, &fds_read);
+|1120|    |-	}
+|1121|    |-
+|1122|    |-	auto tv_addr = m_window_timeout < 0 ? nullptr : &timeout;
+|1123|    |-	int res = select(fd_max+1, &fds_read, nullptr, nullptr, tv_addr);
+|1124|    |-	if (res > 0)
+|1125|    |-	{
+|1126|    |-		if (FD_ISSET(STDIN_FILENO, &fds_read))
+|1127|    |-		{
+|1128|    |-			int key = wgetch(m_window);
+|1129|    |-			if (key == EOF)
+|1130|    |-				result = Key::EoF;
+|1131|    |-			else
+|1132|    |-				result = getInputChar(key);
+|1133|    |-		}
+|1134|    |-		else
+|1135|    |-			result = Key::None;
+|1136|    |-
+|1137|    |-		for (const auto &fd : m_fds)
+|1138|    |-			if (FD_ISSET(fd.first, &fds_read))
+|1139|    |-				fd.second();
+|1140|    |-	}
+|1141|    |-	else
+|1142|    |-		result = Key::None;
+|1143|    |-	return result;
+|1144|    |-}
+|1145|    |-
+|1146|    |-void Window::pushChar(const Key::Type ch)
+|1147|    |-{
+|1148|    |-	m_input_queue.push(ch);
+|1149|    |-}
+|1150|    |-
+|1151|    |-std::string Window::prompt(const std::string &base, size_t width, bool encrypted)
+|1152|    |-{
+|1153|    |-	std::string result;
+|1154|    |-
+|1155|    |-	rl::aborted = false;
+|1156|    |-	rl::w = this;
+|1157|    |-	getyx(m_window, rl::start_y, rl::start_x);
+|1158|    |-	rl::width = std::min(m_width-rl::start_x-1, width-1);
+|1159|    |-	rl::encrypted = encrypted;
+|1160|    |-	rl::base = base.c_str();
+|1161|    |-
+|1162|    |-	curs_set(1);
+|1163|    |-	Mouse::disable();
+|1164|    |-	m_escape_terminal_sequences = false;
+|1165|    |-	char *input = readline(nullptr);
+|1166|    |-	m_escape_terminal_sequences = true;
+|1167|    |-	Mouse::enable();
+|1168|    |-	curs_set(0);
+|1169|    |-	if (input != nullptr)
+|1170|    |-	{
+|    |  81|+
+|    |  82|+    const short Color::transparent = -1;
+|    |  83|+    const short Color::current = -2;
+|    |  84|+
+|    |  85|+    Color Color::Default (0, 0, true, false);
+|    |  86|+    Color Color::Black (COLOR_BLACK, Color::current);
+|    |  87|+    Color Color::Red (COLOR_RED, Color::current);
+|    |  88|+    Color Color::Green (COLOR_GREEN, Color::current);
+|    |  89|+    Color Color::Yellow (COLOR_YELLOW, Color::current);
+|    |  90|+    Color Color::Blue (COLOR_BLUE, Color::current);
+|    |  91|+    Color Color::Magenta (COLOR_MAGENTA, Color::current);
+|    |  92|+    Color Color::Cyan (COLOR_CYAN, Color::current);
+|    |  93|+    Color Color::White (COLOR_WHITE, Color::current);
+|    |  94|+    Color Color::End (0, 0, false, true);
+|    |  95|+
+|    |  96|+    int Color::pairNumber () const
+|    |  97|+    {
+|    |  98|+        // If colors are disabled, return default pair value.
+|    |  99|+        if (color_pair_map.empty ())
+|    | 100|+            return 0;
+|    | 101|+
+|    | 102|+        int result = 0;
+|    | 103|+        if (isEnd ())
+|    | 104|+            throw std::
+|    | 105|+                logic_error ("'end' doesn't have a corresponding pair number");
+|    | 106|+        else
+|    | 107|+    if (!isDefault ())
+|    | 108|+      {
+|    | 109|+          if (!currentBackground ())
+|    | 110|+              result = (background () + 1) % COLORS;
+|    | 111|+          result *= 256;
+|    | 112|+          result += foreground () % COLORS;
+|    | 113|+
+|    | 114|+          assert (result < int (color_pair_map.size ()));
+|    | 115|+
+|    | 116|+          // NCurses allows for a limited number of color pairs to be registered, so
+|    | 117|+          // in order to be able to support all the combinations we want to, we need
+|    | 118|+          // to dynamically register only pairs of colors we're actually using.
+|    | 119|+          if (!color_pair_map[result])
+|    | 120|+            {
+|    | 121|+                // Check if there are any unused pairs left and either register the one
+|    | 122|+                // that was requested or return a default one if there is no space left.
+|    | 123|+                if (color_pair_counter >= COLOR_PAIRS)
+|    | 124|+                    result = 0;
+|    | 125|+                else
+|    | 126|+                  {
+|    | 127|+                      init_pair (color_pair_counter, foreground (),
+|    | 128|+                                 background ());
+|    | 129|+                      color_pair_map[result] = color_pair_counter;
+|    | 130|+                      ++color_pair_counter;
+|    | 131|+                  }
+|    | 132|+            }
+|    | 133|+          result = color_pair_map[result];
+|    | 134|+      }
+|    | 135|+        return result;
+|    | 136|+    }
+|    | 137|+
+|    | 138|+    std::istream & operator>> (std::istream & is, Color & c)
+|    | 139|+    {
+|    | 140|+        const short invalid_color_value = -1337;
+|    | 141|+        auto get_single_color =[](const std::string & s, bool background) {
+|    | 142|+            short result = invalid_color_value;
+|    | 143|+            if (s == "black")
+|    | 144|+                result = COLOR_BLACK;
+|    | 145|+            else if (s == "red")
+|    | 146|+                result = COLOR_RED;
+|    | 147|+            else if (s == "green")
+|    | 148|+                result = COLOR_GREEN;
+|    | 149|+            else if (s == "yellow")
+|    | 150|+                result = COLOR_YELLOW;
+|    | 151|+            else if (s == "blue")
+|    | 152|+                result = COLOR_BLUE;
+|    | 153|+            else if (s == "magenta")
+|    | 154|+                result = COLOR_MAGENTA;
+|    | 155|+            else if (s == "cyan")
+|    | 156|+                result = COLOR_CYAN;
+|    | 157|+            else if (s == "white")
+|    | 158|+                result = COLOR_WHITE;
+|    | 159|+            else if (background && s == "transparent")
+|    | 160|+                result = NC::Color::transparent;
+|    | 161|+            else if (background && s == "current")
+|    | 162|+                result = NC::Color::current;
+|    | 163|+            else if (std::all_of (s.begin (), s.end (), isdigit))
+|    | 164|+              {
+|    | 165|+                  result = atoi (s.c_str ());
+|    | 166|+                  if (result < (background ? 0 : 1) || result > 256)
+|    | 167|+                      result = invalid_color_value;
+|    | 168|+                  else
+|    | 169|+                      --result;
+|    | 170|+              }
+|    | 171|+            return result;
+|    | 172|+        };
+|    | 173|+
+|    | 174|+        auto get_color =[](std::istream & is_) {
+|    | 175|+            std::string result;
+|    | 176|+            while (!is_.eof () && isalnum (is_.peek ()))
+|    | 177|+                result.push_back (is_.get ());
+|    | 178|+            return result;
+|    | 179|+        };
+|    | 180|+
+|    | 181|+        std::string sc = get_color (is);
+|    | 182|+
+|    | 183|+        if (sc == "default")
+|    | 184|+            c = Color::Default;
+|    | 185|+        else if (sc == "end")
+|    | 186|+            c = Color::End;
+|    | 187|+        else
+|    | 188|+          {
+|    | 189|+              short fg = get_single_color (sc, false);
+|    | 190|+              if (fg == invalid_color_value)
+|    | 191|+                  is.setstate (std::ios::failbit);
+|    | 192|+              // Check if there is background color
+|    | 193|+              else if (!is.eof () && is.peek () == '_')
+|    | 194|+                {
+|    | 195|+                    is.get ();
+|    | 196|+                    sc = get_color (is);
+|    | 197|+                    short bg = get_single_color (sc, true);
+|    | 198|+                    if (bg == invalid_color_value)
+|    | 199|+                        is.setstate (std::ios::failbit);
+|    | 200|+                    else
+|    | 201|+                        c = Color (fg, bg);
+|    | 202|+                }
+|    | 203|+              else
+|    | 204|+                  c = Color (fg, NC::Color::current);
+|    | 205|+          }
+|    | 206|+        return is;
+|    | 207|+    }
+|    | 208|+
+|    | 209|+    NC::Format reverseFormat (NC::Format fmt)
+|    | 210|+    {
+|    | 211|+        switch (fmt)
+|    | 212|+          {
+|    | 213|+          case NC::Format::Bold:
+|    | 214|+              return NC::Format::NoBold;
+|    | 215|+          case NC::Format::NoBold:
+|    | 216|+              return NC::Format::Bold;
+|    | 217|+          case NC::Format::Underline:
+|    | 218|+              return NC::Format::NoUnderline;
+|    | 219|+          case NC::Format::NoUnderline:
+|    | 220|+              return NC::Format::Underline;
+|    | 221|+          case NC::Format::Reverse:
+|    | 222|+              return NC::Format::NoReverse;
+|    | 223|+          case NC::Format::NoReverse:
+|    | 224|+              return NC::Format::Reverse;
+|    | 225|+          case NC::Format::AltCharset:
+|    | 226|+              return NC::Format::NoAltCharset;
+|    | 227|+          case NC::Format::NoAltCharset:
+|    | 228|+              return NC::Format::AltCharset;
+|    | 229|+          }
+|    | 230|+        // Unreachable, silence GCC.
+|    | 231|+        return fmt;
+|    | 232|+    }
+|    | 233|+
+|    | 234|+    namespace Mouse
+|    | 235|+    {
+|    | 236|+
+|    | 237|+        namespace
+|    | 238|+        {
+|    | 239|+
+|    | 240|+            bool supportEnabled = false;
+|    | 241|+
+|    | 242|+        }
+|    | 243|+
+|    | 244|+        void enable ()
+|    | 245|+        {
+|    | 246|+            if (!supportEnabled)
+|    | 247|+                return;
+|    | 248|+            // save old highlight mouse tracking
+|    | 249|+            std::printf ("\e[?1001s");
+|    | 250|+            // enable mouse tracking
+|    | 251|+            std::printf ("\e[?1000h");
+|    | 252|+            // try to enable extended (urxvt) mouse tracking
+|    | 253|+            std::printf ("\e[?1015h");
+|    | 254|+            // send the above to the terminal immediately
+|    | 255|+            std::fflush (stdout);
+|    | 256|+        }
+|    | 257|+
+|    | 258|+        void disable ()
+|    | 259|+        {
+|    | 260|+            if (!supportEnabled)
+|    | 261|+                return;
+|    | 262|+            // disable extended (urxvt) mouse tracking
+|    | 263|+            std::printf ("\e[?1015l");
+|    | 264|+            // disable mouse tracking
+|    | 265|+            std::printf ("\e[?1000l");
+|    | 266|+            // restore old highlight mouse tracking
+|    | 267|+            std::printf ("\e[?1001r");
+|    | 268|+            // send the above to the terminal immediately
+|    | 269|+            std::fflush (stdout);
+|    | 270|+        }
+|    | 271|+
+|    | 272|+    }
+|    | 273|+
+|    | 274|+    void initScreen (bool enable_colors, bool enable_mouse)
+|    | 275|+    {
+|    | 276|+        initscr ();
+|    | 277|+        if (has_colors () && enable_colors)
+|    | 278|+          {
+|    | 279|+              start_color ();
+|    | 280|+              use_default_colors ();
+|    | 281|+              color_pair_map.resize (256 * 256, 0);
+|    | 282|+
+|    | 283|+              // Predefine pairs for colors with transparent background, all the other
+|    | 284|+              // ones will be dynamically registered in Color::pairNumber when they're
+|    | 285|+              // used.
+|    | 286|+              color_pair_counter = 1;
+|    | 287|+              for (int fg = 0; fg < COLORS; ++fg, ++color_pair_counter)
+|    | 288|+                {
+|    | 289|+                    init_pair (color_pair_counter, fg, -1);
+|    | 290|+                    color_pair_map[fg] = color_pair_counter;
+|    | 291|+                }
+|    | 292|+          }
+|    | 293|+        raw ();
+|    | 294|+        nonl ();
+|    | 295|+        noecho ();
+|    | 296|+        timeout (0);
+|    | 297|+        curs_set (0);
+|    | 298|+
+|    | 299|+        // setup mouse
+|    | 300|+        Mouse::supportEnabled = enable_mouse;
+|    | 301|+        Mouse::enable ();
+|    | 302|+
+|    | 303|+        // initialize readline (needed, otherwise we get segmentation
+|    | 304|+        // fault on SIGWINCH). also, initialize first as doing this
+|    | 305|+        // later erases keys bound with rl_bind_key for some users.
+|    | 306|+        rl_initialize ();
+|    | 307|+        // disable autocompletion
+|    | 308|+        rl_attempted_completion_function =[](const char *, int, int)->char **
+|    | 309|+        {
+|    | 310|+            rl_attempted_completion_over = 1;
+|    | 311|+            return nullptr;
+|    | 312|+        };
+|    | 313|+        auto abort_prompt =[](int, int)->int {
+|    | 314|+            rl::aborted = true;
+|    | 315|+            rl_done = 1;
+|    | 316|+            return 0;
+|    | 317|+        };
+|    | 318|+        // if ctrl-c or ctrl-g is pressed, abort the prompt
+|    | 319|+        rl_bind_key ('\3', abort_prompt);
+|    | 320|+        rl_bind_key ('\7', abort_prompt);
+|    | 321|+        // do not change the state of the terminal
+|    | 322|+        rl_prep_term_function = nullptr;
+|    | 323|+        rl_deprep_term_function = nullptr;
+|    | 324|+        // do not catch signals
+|    | 325|+        rl_catch_signals = 0;
+|    | 326|+        rl_catch_sigwinch = 0;
+|    | 327|+        // overwrite readline callbacks
+|    | 328|+        rl_getc_function = rl::read_key;
+|    | 329|+        rl_redisplay_function = rl::display_string;
+|    | 330|+        rl_startup_hook = rl::add_base;
+|    | 331|+    }
+|    | 332|+
+|    | 333|+    void destroyScreen ()
+|    | 334|+    {
+|    | 335|+        Mouse::disable ();
+|    | 336|+        curs_set (1);
+|    | 337|+        endwin ();
+|    | 338|+    }
+|    | 339|+
+|    | 340|+  Window::Window (size_t startx, size_t starty, size_t width, size_t height, std::string title, Color color, Border border):m_window (nullptr),
+|    | 341|+        m_start_x (startx),
+|    | 342|+        m_start_y (starty),
+|    | 343|+        m_width (width),
+|    | 344|+        m_height (height),
+|    | 345|+        m_window_timeout (-1),
+|    | 346|+        m_border (std::move (border)),
+|    | 347|+        m_prompt_hook (0),
+|    | 348|+        m_title (std::move (title)),
+|    | 349|+        m_escape_terminal_sequences (true),
+|    | 350|+        m_bold_counter (0),
+|    | 351|+        m_underline_counter (0),
+|    | 352|+        m_reverse_counter (0), m_alt_charset_counter (0)
+|    | 353|+    {
+|    | 354|+        if (m_start_x > size_t (COLS)
+|    | 355|+            || m_start_y > size_t (LINES)
+|    | 356|+            || m_width + m_start_x > size_t (COLS)
+|    | 357|+            || m_height + m_start_y > size_t (LINES))
+|    | 358|+            throw std::
+|    | 359|+                logic_error
+|    | 360|+                ("constructed window doesn't fit into the terminal");
+|    | 361|+
+|    | 362|+        if (m_border)
+|    | 363|+          {
+|    | 364|+              ++m_start_x;
+|    | 365|+              ++m_start_y;
+|    | 366|+              m_width -= 2;
+|    | 367|+              m_height -= 2;
+|    | 368|+          }
+|    | 369|+        if (!m_title.empty ())
+|    | 370|+          {
+|    | 371|+              m_start_y += 2;
+|    | 372|+              m_height -= 2;
+|    | 373|+          }
+|    | 374|+
+|    | 375|+        m_window = newpad (m_height, m_width);
+|    | 376|+        wtimeout (m_window, 0);
+|    | 377|+
+|    | 378|+        setBaseColor (color);
+|    | 379|+        setColor (m_base_color);
+|    | 380|+    }
+|    | 381|+
+|    | 382|+    Window::Window (const Window & rhs):m_window (dupwin (rhs.m_window)),
+|    | 383|+        m_start_x (rhs.m_start_x), m_start_y (rhs.m_start_y),
+|    | 384|+        m_width (rhs.m_width), m_height (rhs.m_height),
+|    | 385|+        m_window_timeout (rhs.m_window_timeout), m_color (rhs.m_color),
+|    | 386|+        m_base_color (rhs.m_base_color), m_border (rhs.m_border),
+|    | 387|+        m_prompt_hook (rhs.m_prompt_hook), m_title (rhs.m_title),
+|    | 388|+        m_color_stack (rhs.m_color_stack), m_input_queue (rhs.m_input_queue),
+|    | 389|+        m_fds (rhs.m_fds),
+|    | 390|+        m_escape_terminal_sequences (rhs.m_escape_terminal_sequences),
+|    | 391|+        m_bold_counter (rhs.m_bold_counter),
+|    | 392|+        m_underline_counter (rhs.m_underline_counter),
+|    | 393|+        m_reverse_counter (rhs.m_reverse_counter),
+|    | 394|+        m_alt_charset_counter (rhs.m_alt_charset_counter)
+|    | 395|+    {
+|    | 396|+        setColor (m_color);
+|    | 397|+    }
+|    | 398|+
+|    | 399|+  Window::Window (Window && rhs):m_window (rhs.m_window), m_start_x (rhs.m_start_x),
+|    | 400|+        m_start_y (rhs.m_start_y), m_width (rhs.m_width),
+|    | 401|+        m_height (rhs.m_height), m_window_timeout (rhs.m_window_timeout),
+|    | 402|+        m_color (rhs.m_color), m_base_color (rhs.m_base_color),
+|    | 403|+        m_border (rhs.m_border), m_prompt_hook (rhs.m_prompt_hook),
+|    | 404|+        m_title (std::move (rhs.m_title)),
+|    | 405|+        m_color_stack (std::move (rhs.m_color_stack)),
+|    | 406|+        m_input_queue (std::move (rhs.m_input_queue)),
+|    | 407|+        m_fds (std::move (rhs.m_fds)),
+|    | 408|+        m_escape_terminal_sequences (rhs.m_escape_terminal_sequences),
+|    | 409|+        m_bold_counter (rhs.m_bold_counter),
+|    | 410|+        m_underline_counter (rhs.m_underline_counter),
+|    | 411|+        m_reverse_counter (rhs.m_reverse_counter),
+|    | 412|+        m_alt_charset_counter (rhs.m_alt_charset_counter)
+|    | 413|+    {
+|    | 414|+        rhs.m_window = nullptr;
+|    | 415|+    }
+|    | 416|+
+|    | 417|+    Window & Window::operator= (Window rhs)
+|    | 418|+    {
+|    | 419|+        std::swap (m_window, rhs.m_window);
+|    | 420|+        std::swap (m_start_x, rhs.m_start_x);
+|    | 421|+        std::swap (m_start_y, rhs.m_start_y);
+|    | 422|+        std::swap (m_width, rhs.m_width);
+|    | 423|+        std::swap (m_height, rhs.m_height);
+|    | 424|+        std::swap (m_window_timeout, rhs.m_window_timeout);
+|    | 425|+        std::swap (m_color, rhs.m_color);
+|    | 426|+        std::swap (m_base_color, rhs.m_base_color);
+|    | 427|+        std::swap (m_border, rhs.m_border);
+|    | 428|+        std::swap (m_prompt_hook, rhs.m_prompt_hook);
+|    | 429|+        std::swap (m_title, rhs.m_title);
+|    | 430|+        std::swap (m_color_stack, rhs.m_color_stack);
+|    | 431|+        std::swap (m_input_queue, rhs.m_input_queue);
+|    | 432|+        std::swap (m_fds, rhs.m_fds);
+|    | 433|+        std::swap (m_escape_terminal_sequences,
+|    | 434|+                   rhs.m_escape_terminal_sequences);
+|    | 435|+        std::swap (m_bold_counter, rhs.m_bold_counter);
+|    | 436|+        std::swap (m_underline_counter, rhs.m_underline_counter);
+|    | 437|+        std::swap (m_reverse_counter, rhs.m_reverse_counter);
+|    | 438|+        std::swap (m_alt_charset_counter, rhs.m_alt_charset_counter);
+|    | 439|+        return *this;
+|    | 440|+    }
+|    | 441|+
+|    | 442|+    Window::~Window ()
+|    | 443|+    {
+|    | 444|+        delwin (m_window);
+|    | 445|+    }
+|    | 446|+
+|    | 447|+    void Window::setColor (Color c)
+|    | 448|+    {
+|    | 449|+        if (c.isDefault ())
+|    | 450|+            c = m_base_color;
+|    | 451|+        if (c != Color::Default)
+|    | 452|+          {
+|    | 453|+              assert (!c.currentBackground ());
+|    | 454|+              wcolor_set (m_window, c.pairNumber (), nullptr);
+|    | 455|+          }
+|    | 456|+        else
+|    | 457|+            wcolor_set (m_window, m_base_color.pairNumber (), nullptr);
+|    | 458|+        m_color = std::move (c);
+|    | 459|+    }
+|    | 460|+
+|    | 461|+    void Window::setBaseColor (const Color & color)
+|    | 462|+    {
+|    | 463|+        if (color.currentBackground ())
+|    | 464|+            m_base_color = Color (color.foreground (), Color::transparent);
+|    | 465|+        else
+|    | 466|+            m_base_color = color;
+|    | 467|+    }
+|    | 468|+
+|    | 469|+    void Window::setBorder (Border border)
+|    | 470|+    {
+|    | 471|+        if (!border && m_border)
+|    | 472|+          {
+|    | 473|+              --m_start_x;
+|    | 474|+              --m_start_y;
+|    | 475|+              m_height += 2;
+|    | 476|+              m_width += 2;
+|    | 477|+              recreate (m_width, m_height);
+|    | 478|+          }
+|    | 479|+        else if (border && !m_border)
+|    | 480|+          {
+|    | 481|+              ++m_start_x;
+|    | 482|+              ++m_start_y;
+|    | 483|+              m_height -= 2;
+|    | 484|+              m_width -= 2;
+|    | 485|+              recreate (m_width, m_height);
+|    | 486|+          }
+|    | 487|+        m_border = border;
+|    | 488|+    }
+|    | 489|+
+|    | 490|+    void Window::setTitle (const std::string & new_title)
+|    | 491|+    {
+|    | 492|+        if (!new_title.empty () && m_title.empty ())
+|    | 493|+          {
+|    | 494|+              m_start_y += 2;
+|    | 495|+              m_height -= 2;
+|    | 496|+              recreate (m_width, m_height);
+|    | 497|+          }
+|    | 498|+        else if (new_title.empty () && !m_title.empty ())
+|    | 499|+          {
+|    | 500|+              m_start_y -= 2;
+|    | 501|+              m_height += 2;
+|    | 502|+              recreate (m_width, m_height);
+|    | 503|+          }
+|    | 504|+        m_title = new_title;
+|    | 505|+    }
+|    | 506|+
+|    | 507|+    void Window::recreate (size_t width, size_t height)
+|    | 508|+    {
+|    | 509|+        delwin (m_window);
+|    | 510|+        m_window = newpad (height, width);
+|    | 511|+        wtimeout (m_window, 0);
+|    | 512|+        setColor (m_color);
+|    | 513|+    }
+|    | 514|+
+|    | 515|+    void Window::moveTo (size_t new_x, size_t new_y)
+|    | 516|+    {
+|    | 517|+        m_start_x = new_x;
+|    | 518|+        m_start_y = new_y;
+|    | 519|+        if (m_border)
+|    | 520|+          {
+|    | 521|+              ++m_start_x;
+|    | 522|+              ++m_start_y;
+|    | 523|+          }
+|    | 524|+        if (!m_title.empty ())
+|    | 525|+            m_start_y += 2;
+|    | 526|+    }
+|    | 527|+
+|    | 528|+    void Window::adjustDimensions (size_t width, size_t height)
+|    | 529|+    {
+|    | 530|+        if (m_border)
+|    | 531|+          {
+|    | 532|+              width -= 2;
+|    | 533|+              height -= 2;
+|    | 534|+          }
+|    | 535|+        if (!m_title.empty ())
+|    | 536|+            height -= 2;
+|    | 537|+        m_height = height;
+|    | 538|+        m_width = width;
+|    | 539|+    }
+|    | 540|+
+|    | 541|+    void Window::resize (size_t new_width, size_t new_height)
+|    | 542|+    {
+|    | 543|+        adjustDimensions (new_width, new_height);
+|    | 544|+        recreate (m_width, m_height);
+|    | 545|+    }
+|    | 546|+
+|    | 547|+    void Window::refreshBorder () const
+|    | 548|+    {
+|    | 549|+        if (m_border)
+|    | 550|+          {
+|    | 551|+              size_t start_x = getStartX (), start_y = getStarty ();
+|    | 552|+              size_t width = getWidth (), height = getHeight ();
+|    | 553|+                color_set (m_border->pairNumber (), nullptr);
+|    | 554|+                attron (A_ALTCHARSET);
+|    | 555|+              // corners
+|    | 556|+                mvaddch (start_y, start_x, 'l');
+|    | 557|+                mvaddch (start_y, start_x + width - 1, 'k');
+|    | 558|+                mvaddch (start_y + height - 1, start_x, 'm');
+|    | 559|+                mvaddch (start_y + height - 1, start_x + width - 1, 'j');
+|    | 560|+              // lines
+|    | 561|+                mvhline (start_y, start_x + 1, 'q', width - 2);
+|    | 562|+                mvhline (start_y + height - 1, start_x + 1, 'q', width - 2);
+|    | 563|+                mvvline (start_y + 1, start_x, 'x', height - 2);
+|    | 564|+                mvvline (start_y + 1, start_x + width - 1, 'x', height - 2);
+|    | 565|+              if (!m_title.empty ())
+|    | 566|+                {
+|    | 567|+                    mvaddch (start_y + 2, start_x, 't');
+|    | 568|+                    mvaddch (start_y + 2, start_x + width - 1, 'u');
+|    | 569|+                }
+|    | 570|+              attroff (A_ALTCHARSET);
+|    | 571|+          }
+|    | 572|+        else
+|    | 573|+            color_set (m_base_color.pairNumber (), nullptr);
+|    | 574|+        if (!m_title.empty ())
+|    | 575|+          {
+|    | 576|+              // clear title line
+|    | 577|+              mvhline (m_start_y - 2, m_start_x, ' ', m_width);
+|    | 578|+              attron (A_BOLD);
+|    | 579|+              mvaddstr (m_start_y - 2, m_start_x, m_title.c_str ());
+|    | 580|+              attroff (A_BOLD);
+|    | 581|+              // add separator
+|    | 582|+              mvhline (m_start_y - 1, m_start_x, 0, m_width);
+|    | 583|+          }
+|    | 584|+        standend ();
+|    | 585|+        ::refresh ();
+|    | 586|+    }
+|    | 587|+
+|    | 588|+    void Window::display ()
+|    | 589|+    {
+|    | 590|+        refreshBorder ();
+|    | 591|+        refresh ();
+|    | 592|+    }
+|    | 593|+
+|    | 594|+    void Window::refresh ()
+|    | 595|+    {
+|    | 596|+        prefresh (m_window, 0, 0, m_start_y, m_start_x,
+|    | 597|+                  m_start_y + m_height - 1, m_start_x + m_width - 1);
+|    | 598|+    }
+|    | 599|+
+|    | 600|+    void Window::clear ()
+|    | 601|+    {
+|    | 602|+        werase (m_window);
+|    | 603|+        setColor (m_base_color);
+|    | 604|+    }
+|    | 605|+
+|    | 606|+    void Window::bold (bool bold_state) const
+|    | 607|+    {
+|    | 608|+        (bold_state ? wattron : wattroff) (m_window, A_BOLD);
+|    | 609|+    }
+|    | 610|+
+|    | 611|+    void Window::underline (bool underline_state) const
+|    | 612|+    {
+|    | 613|+        (underline_state ? wattron : wattroff) (m_window, A_UNDERLINE);
+|    | 614|+    }
+|    | 615|+
+|    | 616|+    void Window::reverse (bool reverse_state) const
+|    | 617|+    {
+|    | 618|+        (reverse_state ? wattron : wattroff) (m_window, A_REVERSE);
+|    | 619|+    }
+|    | 620|+
+|    | 621|+    void Window::altCharset (bool altcharset_state) const
+|    | 622|+    {
+|    | 623|+        (altcharset_state ? wattron : wattroff) (m_window, A_ALTCHARSET);
+|    | 624|+    }
+|    | 625|+
+|    | 626|+    void Window::setTimeout (int timeout)
+|    | 627|+    {
+|    | 628|+        m_window_timeout = timeout;
+|    | 629|+    }
+|    | 630|+
+|    | 631|+    void Window::addFDCallback (int fd, void (*callback) ())
+|    | 632|+    {
+|    | 633|+        m_fds.push_back (std::make_pair (fd, callback));
+|    | 634|+    }
+|    | 635|+
+|    | 636|+    void Window::clearFDCallbacksList ()
+|    | 637|+    {
+|    | 638|+        m_fds.clear ();
+|    | 639|+    }
+|    | 640|+
+|    | 641|+    bool Window::FDCallbacksListEmpty () const
+|    | 642|+    {
+|    | 643|+        return m_fds.empty ();
+|    | 644|+    }
+|    | 645|+
+|    | 646|+    Key::Type Window::getInputChar (int key)
+|    | 647|+    {
+|    | 648|+        if (!m_escape_terminal_sequences || key != Key::Escape)
+|    | 649|+            return key;
+|    | 650|+        auto define_mouse_event =[this] (int type) {
+|    | 651|+            switch (type & ~28)
+|    | 652|+              {
+|    | 653|+              case 32:
+|    | 654|+              m_mouse_event.bstate = BUTTON1_PRESSED; break; case 33:
+|    | 655|+              m_mouse_event.bstate = BUTTON2_PRESSED; break; case 34:
+|    | 656|+              m_mouse_event.bstate = BUTTON3_PRESSED; break; case 96:
+|    | 657|+              m_mouse_event.bstate = BUTTON4_PRESSED; break; case 97:
+|    | 658|+              m_mouse_event.bstate = BUTTON5_PRESSED; break; default:
+|    | 659|+               return Key::None;}
+|    | 660|+               if (type & 4)
+|    | 661|+               m_mouse_event.bstate |= BUTTON_SHIFT;
+|    | 662|+               if (type & 8)
+|    | 663|+               m_mouse_event.bstate |= BUTTON_ALT;
+|    | 664|+               if (type & 16)
+|    | 665|+               m_mouse_event.bstate |= BUTTON_CTRL;
+|    | 666|+               if (m_mouse_event.x < 0 || m_mouse_event.x >= COLS)
+|    | 667|+               return Key::None;
+|    | 668|+               if (m_mouse_event.y < 0 || m_mouse_event.y >= LINES)
+|    | 669|+               return Key::None;
+|    | 670|+               return Key::Mouse;}; auto get_xterm_modifier_key =[](int ch)
+|    | 671|+               {
+|    | 672|+               Key::Type modifier; switch (ch)
+|    | 673|+               {
+|    | 674|+case '2':
+|    | 675|+modifier = Key::Shift; break; case '3':
+|    | 676|+modifier = Key::Alt; break; case '4':
+|    | 677|+modifier = Key::Alt | Key::Shift; break; case '5':
+|    | 678|+modifier = Key::Ctrl; break; case '6':
+|    | 679|+modifier = Key::Ctrl | Key::Shift; break; case '7':
+|    | 680|+modifier = Key::Alt | Key::Ctrl; break; case '8':
+|    | 681|+modifier = Key::Alt | Key::Ctrl | Key::Shift; break; default:
+|    | 682|+               modifier = Key::None;}
+|    | 683|+               return modifier;}; auto parse_number =[this] (int &result)
+|    | 684|+               {
+|    | 685|+               int x; while (true)
+|    | 686|+               {
+|    | 687|+               x = wgetch (m_window);
+|    | 688|+               if (!isdigit (x)) return x; result = result * 10 + x - '0';}
+|    | 689|+               }; key = wgetch (m_window); switch (key)
+|    | 690|+               {
+|    | 691|+case '\t':                     // tty
+|    | 692|+return Key::Shift | Key::Tab; case 'O':
+|    | 693|+               key = wgetch (m_window); switch (key)
+|    | 694|+               {
+|    | 695|+               // eterm
+|    | 696|+case 'A':
+|    | 697|+return Key::Up; case 'B':
+|    | 698|+return Key::Down; case 'C':
+|    | 699|+return Key::Right; case 'D':
+|    | 700|+               return Key::Left;
+|    | 701|+               // terminator
+|    | 702|+case 'F':
+|    | 703|+return Key::End; case 'H':
+|    | 704|+               return Key::Home;
+|    | 705|+               // rxvt
+|    | 706|+case 'a':
+|    | 707|+return Key::Ctrl | Key::Up; case 'b':
+|    | 708|+return Key::Ctrl | Key::Down; case 'c':
+|    | 709|+return Key::Ctrl | Key::Right; case 'd':
+|    | 710|+               return Key::Ctrl | Key::Left;
+|    | 711|+               // xterm
+|    | 712|+case 'P':
+|    | 713|+return Key::F1; case 'Q':
+|    | 714|+return Key::F2; case 'R':
+|    | 715|+return Key::F3; case 'S':
+|    | 716|+return Key::F4; default:
+|    | 717|+               return Key::None;}
+|    | 718|+case '[':
+|    | 719|+               key = wgetch (m_window); switch (key)
+|    | 720|+               {
+|    | 721|+case 'a':
+|    | 722|+return Key::Shift | Key::Up; case 'b':
+|    | 723|+return Key::Shift | Key::Down; case 'c':
+|    | 724|+return Key::Shift | Key::Right; case 'd':
+|    | 725|+return Key::Shift | Key::Left; case 'A':
+|    | 726|+return Key::Up; case 'B':
+|    | 727|+return Key::Down; case 'C':
+|    | 728|+return Key::Right; case 'D':
+|    | 729|+return Key::Left; case 'F':    // xterm
+|    | 730|+return Key::End; case 'H':     // xterm
+|    | 731|+return Key::Home; case 'M':    // standard mouse event
+|    | 732|+               {
+|    | 733|+               key = wgetch (m_window);
+|    | 734|+               int raw_x = wgetch (m_window); int raw_y = wgetch (m_window);
+|    | 735|+               // support coordinates up to 255
+|    | 736|+               m_mouse_event.x = (raw_x - 33) & 0xff;
+|    | 737|+               m_mouse_event.y = (raw_y - 33) & 0xff;
+|    | 738|+               return define_mouse_event (key);}
+|    | 739|+case 'Z':
+|    | 740|+return Key::Shift | Key::Tab; case '[':    // F1 to F5 in tty
+|    | 741|+               key = wgetch (m_window); switch (key)
+|    | 742|+               {
+|    | 743|+case 'A':
+|    | 744|+return Key::F1; case 'B':
+|    | 745|+return Key::F2; case 'C':
+|    | 746|+return Key::F3; case 'D':
+|    | 747|+return Key::F4; case 'E':
+|    | 748|+return Key::F5; default:
+|    | 749|+               return Key::None;}
+|    | 750|+case '1':
+|    | 751|+case '2':
+|    | 752|+case '3':
+|    | 753|+case '4':
+|    | 754|+case '5':
+|    | 755|+case '6':
+|    | 756|+case '7':
+|    | 757|+case '8':
+|    | 758|+case '9':
+|    | 759|+               {
+|    | 760|+               key -= '0';
+|    | 761|+               int delim = parse_number (key); if (key >= 2 && key <= 8)
+|    | 762|+               {
+|    | 763|+               Key::Type modifier; switch (delim)
+|    | 764|+               {
+|    | 765|+case '~':
+|    | 766|+modifier = Key::Null; break; case '^':
+|    | 767|+modifier = Key::Ctrl; break; case '$':
+|    | 768|+modifier = Key::Shift; break; case '@':
+|    | 769|+modifier = Key::Ctrl | Key::Shift; break; case ';':    // xterm insert/delete/page up/page down
+|    | 770|+               {
+|    | 771|+               int local_key = wgetch (m_window);
+|    | 772|+               modifier = get_xterm_modifier_key (local_key);
+|    | 773|+               local_key = wgetch (m_window);
+|    | 774|+               if (local_key != '~'
+|    | 775|+                   || (key != 2 && key != 3 && key != 5
+|    | 776|+                       && key != 6)) return Key::None; break;}
+|    | 777|+default:
+|    | 778|+               return Key::None;}
+|    | 779|+               switch (key)
+|    | 780|+               {
+|    | 781|+case 2:
+|    | 782|+return modifier | Key::Insert; case 3:
+|    | 783|+return modifier | Key::Delete; case 4:
+|    | 784|+return modifier | Key::End; case 5:
+|    | 785|+return modifier | Key::PageUp; case 6:
+|    | 786|+return modifier | Key::PageDown; case 7:
+|    | 787|+return modifier | Key::Home; case 8:
+|    | 788|+return modifier | Key::End; default:
+|    | 789|+               std::cerr << "Unreachable code, aborting.\n"; std::terminate ();}
+|    | 790|+               }
+|    | 791|+               switch (delim)
+|    | 792|+               {
+|    | 793|+case '~':
+|    | 794|+               {
+|    | 795|+               switch (key)
+|    | 796|+               {
+|    | 797|+case 1:                        // tty
+|    | 798|+return Key::Home; case 11:
+|    | 799|+return Key::F1; case 12:
+|    | 800|+return Key::F2; case 13:
+|    | 801|+return Key::F3; case 14:
+|    | 802|+return Key::F4; case 15:
+|    | 803|+return Key::F5; case 17:       // not a typo
+|    | 804|+return Key::F6; case 18:
+|    | 805|+return Key::F7; case 19:
+|    | 806|+return Key::F8; case 20:
+|    | 807|+return Key::F9; case 21:
+|    | 808|+return Key::F10; case 23:      // not a typo
+|    | 809|+return Key::F11; case 24:
+|    | 810|+return Key::F12; default:
+|    | 811|+               return Key::None;}
+|    | 812|+               }
+|    | 813|+case ';':
+|    | 814|+               switch (key)
+|    | 815|+               {
+|    | 816|+case 1:                        // xterm
+|    | 817|+               {
+|    | 818|+               key = wgetch (m_window);
+|    | 819|+               Key::Type modifier = get_xterm_modifier_key (key);
+|    | 820|+               if (modifier == Key::None)
+|    | 821|+               return Key::None; key = wgetch (m_window); switch (key)
+|    | 822|+               {
+|    | 823|+case 'A':
+|    | 824|+return modifier | Key::Up; case 'B':
+|    | 825|+return modifier | Key::Down; case 'C':
+|    | 826|+return modifier | Key::Right; case 'D':
+|    | 827|+return modifier | Key::Left; case 'F':
+|    | 828|+return modifier | Key::End; case 'H':
+|    | 829|+return modifier | Key::Home; default:
+|    | 830|+               return Key::None;}
+|    | 831|+               }
+|    | 832|+default:                       // urxvt mouse
+|    | 833|+               m_mouse_event.x = 0;
+|    | 834|+               delim = parse_number (m_mouse_event.x);
+|    | 835|+               if (delim != ';')
+|    | 836|+               return Key::None;
+|    | 837|+               m_mouse_event.y = 0;
+|    | 838|+               delim = parse_number (m_mouse_event.y);
+|    | 839|+               if (delim != 'M')
+|    | 840|+               return Key::None;
+|    | 841|+               --m_mouse_event.x;
+|    | 842|+               --m_mouse_event.y; return define_mouse_event (key);}
+|    | 843|+default:
+|    | 844|+               return Key::None;}
+|    | 845|+               }
+|    | 846|+default:
+|    | 847|+               return Key::None;}
+|    | 848|+case ERR:
+|    | 849|+return Key::Escape; default:   // alt + something
+|    | 850|+               {
+|    | 851|+               auto key_prim = getInputChar (key);
+|    | 852|+               if (key_prim != Key::None)
+|    | 853|+               return Key::Alt | key_prim; return Key::None;}
+|    | 854|+               }
+|    | 855|+               }
+|    | 856|+
+|    | 857|+               Key::Type Window::readKey ()
+|    | 858|+               {
+|    | 859|+               Key::Type result;
+|    | 860|+               // if there are characters in input queue,
+|    | 861|+               // get them and return immediately.
+|    | 862|+               if (!m_input_queue.empty ())
+|    | 863|+               {
+|    | 864|+               result = m_input_queue.front ();
+|    | 865|+               m_input_queue.pop (); return result;}
+|    | 866|+
+|    | 867|+               fd_set fds_read;
+|    | 868|+               FD_ZERO (&fds_read);
+|    | 869|+               FD_SET (STDIN_FILENO, &fds_read); timeval timeout =
+|    | 870|+               {
+|    | 871|+      m_window_timeout / 1000, (m_window_timeout % 1000) * 1000}; int fd_max = STDIN_FILENO; for (const auto & fd:m_fds)
+|    | 872|+               {
+|    | 873|+               if (fd.first > fd_max)
+|    | 874|+               fd_max = fd.first; FD_SET (fd.first, &fds_read);}
+|    | 875|+
+|    | 876|+               auto tv_addr = m_window_timeout < 0 ? nullptr : &timeout;
+|    | 877|+               int res =
+|    | 878|+               select (fd_max + 1, &fds_read, nullptr, nullptr, tv_addr);
+|    | 879|+               if (res > 0)
+|    | 880|+               {
+|    | 881|+               if (FD_ISSET (STDIN_FILENO, &fds_read))
+|    | 882|+               {
+|    | 883|+               int key = wgetch (m_window); if (key == EOF) result = Key::EoF;
+|    | 884|+               else
+|    | 885|+               result = getInputChar (key);}
+|    | 886|+               else
+|    | 887|+      result = Key::None; for (const auto & fd:m_fds)
+|    | 888|+               if (FD_ISSET (fd.first, &fds_read))
+|    | 889|+               fd.second ();}
+|    | 890|+               else
+|    | 891|+               result = Key::None; return result;}
+|    | 892|+
+|    | 893|+               void Window::pushChar (const Key::Type ch)
+|    | 894|+               {
+|    | 895|+               m_input_queue.push (ch);}
+|    | 896|+
+|    | 897|+               std::string Window::prompt (const std::string & base,
+|    | 898|+                                           size_t width, bool encrypted)
+|    | 899|+               {
+|    | 900|+               std::string result;
+|    | 901|+               rl::aborted = false;
+|    | 902|+               rl::w = this;
+|    | 903|+               getyx (m_window, rl::start_y, rl::start_x);
+|    | 904|+               rl::width = std::min (m_width - rl::start_x - 1, width - 1);
+|    | 905|+               rl::encrypted = encrypted;
+|    | 906|+               rl::base = base.c_str ();
+|    | 907|+               curs_set (1);
+|    | 908|+               Mouse::disable ();
+|    | 909|+               m_escape_terminal_sequences = false;
+|    | 910|+               char *input = readline (nullptr);
+|    | 911|+               m_escape_terminal_sequences = true;
+|    | 912|+               Mouse::enable (); curs_set (0); if (input != nullptr)
+|    | 913|+               {
+|1171| 914| #ifdef HAVE_READLINE_HISTORY_H
+|1172|    |-		if (!encrypted && input[0] != 0)
+|1173|    |-			add_history(input);
+|    | 915|+               if (!encrypted && input[0] != 0) add_history (input);
+|1174| 916| #endif // HAVE_READLINE_HISTORY_H
+|1175|    |-		result = input;
+|1176|    |-		free(input);
+|1177|    |-	}
+|1178|    |-
+|1179|    |-	if (rl::aborted)
+|1180|    |-		throw PromptAborted(std::move(result));
+|1181|    |-
+|1182|    |-	return result;
+|1183|    |-}
+|1184|    |-
+|1185|    |-void Window::goToXY(int x, int y)
+|1186|    |-{
+|1187|    |-	wmove(m_window, y, x);
+|1188|    |-}
+|1189|    |-
+|1190|    |-int Window::getX()
+|1191|    |-{
+|1192|    |-	return getcurx(m_window);
+|1193|    |-}
+|1194|    |-
+|1195|    |-int Window::getY()
+|1196|    |-{
+|1197|    |-	return getcury(m_window);
+|1198|    |-}
+|1199|    |-
+|1200|    |-bool Window::hasCoords(int &x, int &y)
+|1201|    |-{
+|1202|    |-	return wmouse_trafo(m_window, &y, &x, 0);
+|1203|    |-}
+|1204|    |-
+|1205|    |-bool Window::runPromptHook(const char *arg, bool *done) const
+|1206|    |-{
+|1207|    |-	if (m_prompt_hook)
+|1208|    |-	{
+|1209|    |-		bool continue_ = m_prompt_hook(arg);
+|1210|    |-		if (done != nullptr)
+|1211|    |-			*done = !continue_;
+|1212|    |-		return true;
+|1213|    |-	}
+|1214|    |-	else
+|1215|    |-		return false;
+|1216|    |-}
+|1217|    |-
+|1218|    |-size_t Window::getWidth() const
+|1219|    |-{
+|1220|    |-	if (m_border)
+|1221|    |-		return m_width+2;
+|1222|    |-	else
+|1223|    |-		return m_width;
+|1224|    |-}
+|1225|    |-
+|1226|    |-size_t Window::getHeight() const
+|1227|    |-{
+|1228|    |-	size_t height = m_height;
+|1229|    |-	if (m_border)
+|1230|    |-		height += 2;
+|1231|    |-	if (!m_title.empty())
+|1232|    |-		height += 2;
+|1233|    |-	return height;
+|1234|    |-}
+|1235|    |-
+|1236|    |-size_t Window::getStartX() const
+|1237|    |-{
+|1238|    |-	if (m_border)
+|1239|    |-		return m_start_x-1;
+|1240|    |-	else
+|1241|    |-		return m_start_x;
+|1242|    |-}
+|1243|    |-
+|1244|    |-size_t Window::getStarty() const
+|1245|    |-{
+|1246|    |-	size_t starty = m_start_y;
+|1247|    |-	if (m_border)
+|1248|    |-		--starty;
+|1249|    |-	if (!m_title.empty())
+|1250|    |-		starty -= 2;
+|1251|    |-	return starty;
+|1252|    |-}
+|1253|    |-
+|1254|    |-const std::string &Window::getTitle() const
+|1255|    |-{
+|1256|    |-	return m_title;
+|1257|    |-}
+|1258|    |-
+|1259|    |-const Color &Window::getColor() const
+|1260|    |-{
+|1261|    |-	return m_color;
+|1262|    |-}
+|1263|    |-
+|1264|    |-const Border &Window::getBorder() const
+|1265|    |-{
+|1266|    |-	return m_border;
+|1267|    |-}
+|1268|    |-
+|1269|    |-int Window::getTimeout() const
+|1270|    |-{
+|1271|    |-	return m_window_timeout;
+|1272|    |-}
+|1273|    |-
+|1274|    |-const MEVENT &Window::getMouseEvent()
+|1275|    |-{
+|1276|    |-	return m_mouse_event;
+|1277|    |-}
+|1278|    |-
+|1279|    |-void Window::scroll(Scroll where)
+|1280|    |-{
+|1281|    |-	idlok(m_window, 1);
+|1282|    |-	scrollok(m_window, 1);
+|1283|    |-	switch (where)
+|1284|    |-	{
+|1285|    |-		case Scroll::Up:
+|1286|    |-			wscrl(m_window, 1);
+|1287|    |-			break;
+|1288|    |-		case Scroll::Down:
+|1289|    |-			wscrl(m_window, -1);
+|1290|    |-			break;
+|1291|    |-		case Scroll::PageUp:
+|1292|    |-			wscrl(m_window, m_width);
+|1293|    |-			break;
+|1294|    |-		case Scroll::PageDown:
+|1295|    |-			wscrl(m_window, -m_width);
+|1296|    |-			break;
+|1297|    |-		default:
+|1298|    |-			break;
+|1299|    |-	}
+|1300|    |-	idlok(m_window, 0);
+|1301|    |-	scrollok(m_window, 0);
+|1302|    |-}
+|1303|    |-
+|1304|    |-
+|1305|    |-Window &Window::operator<<(const Color &c)
+|1306|    |-{
+|1307|    |-	if (c.isDefault())
+|1308|    |-	{
+|1309|    |-		while (!m_color_stack.empty())
+|1310|    |-			m_color_stack.pop();
+|1311|    |-		setColor(m_base_color);
+|1312|    |-	}
+|1313|    |-	else if (c.isEnd())
+|1314|    |-	{
+|1315|    |-		if (!m_color_stack.empty())
+|1316|    |-			m_color_stack.pop();
+|1317|    |-		if (!m_color_stack.empty())
+|1318|    |-			setColor(m_color_stack.top());
+|1319|    |-		else
+|1320|    |-			setColor(m_base_color);
+|1321|    |-	}
+|1322|    |-	else
+|1323|    |-	{
+|1324|    |-		if (c.currentBackground())
+|1325|    |-		{
+|1326|    |-			short background = m_color.isDefault()
+|1327|    |-				? Color::transparent
+|1328|    |-				: m_color.background();
+|1329|    |-			Color cc = Color(c.foreground(), background);
+|1330|    |-			setColor(cc);
+|1331|    |-			m_color_stack.push(cc);
+|1332|    |-		}
+|1333|    |-		else
+|1334|    |-		{
+|1335|    |-			setColor(c);
+|1336|    |-			m_color_stack.push(c);
+|1337|    |-		}
+|1338|    |-	}
+|1339|    |-	return *this;
+|1340|    |-}
+|1341|    |-
+|1342|    |-Window &Window::operator<<(Format format)
+|1343|    |-{
+|1344|    |-	auto increase_flag = [](Window &w, int &flag, auto set) {
+|1345|    |-		++flag;
+|1346|    |-		(w.*set)(true);
+|1347|    |-	};
+|1348|    |-	auto decrease_flag = [](Window &w, int &flag, auto set) {
+|1349|    |-		if (flag > 0)
+|1350|    |-		{
+|1351|    |-			--flag;
+|1352|    |-			if (flag == 0)
+|1353|    |-				(w.*set)(false);
+|1354|    |-		}
+|1355|    |-	};
+|1356|    |-	switch (format)
+|1357|    |-	{
+|1358|    |-		case Format::Bold:
+|1359|    |-			increase_flag(*this, m_bold_counter, &Window::bold);
+|1360|    |-			break;
+|1361|    |-		case Format::NoBold:
+|1362|    |-			decrease_flag(*this, m_bold_counter, &Window::bold);
+|1363|    |-			break;
+|1364|    |-		case Format::Underline:
+|1365|    |-			increase_flag(*this, m_underline_counter, &Window::underline);
+|1366|    |-			break;
+|1367|    |-		case Format::NoUnderline:
+|1368|    |-			decrease_flag(*this, m_underline_counter, &Window::underline);
+|1369|    |-			break;
+|1370|    |-		case Format::Reverse:
+|1371|    |-			increase_flag(*this, m_reverse_counter, &Window::reverse);
+|1372|    |-			break;
+|1373|    |-		case Format::NoReverse:
+|1374|    |-			decrease_flag(*this, m_reverse_counter, &Window::reverse);
+|1375|    |-			break;
+|1376|    |-		case Format::AltCharset:
+|1377|    |-			increase_flag(*this, m_alt_charset_counter, &Window::altCharset);
+|1378|    |-			break;
+|1379|    |-		case Format::NoAltCharset:
+|1380|    |-			decrease_flag(*this, m_alt_charset_counter, &Window::altCharset);
+|1381|    |-			break;
+|1382|    |-	}
+|1383|    |-	return *this;
+|1384|    |-}
+|1385|    |-
+|1386|    |-Window &Window::operator<<(TermManip tm)
+|1387|    |-{
+|1388|    |-	switch (tm)
+|1389|    |-	{
+|1390|    |-		case TermManip::ClearToEOL:
+|1391|    |-		{
+|1392|    |-			auto x = getX(), y = getY();
+|1393|    |-			mvwhline(m_window, y, x, ' ', m_width-x);
+|1394|    |-			goToXY(x, y);
+|1395|    |-		}
+|1396|    |-		break;
+|1397|    |-	}
+|1398|    |-	return *this;
+|1399|    |-}
+|1400|    |-
+|1401|    |-Window &Window::operator<<(const XY &coords)
+|1402|    |-{
+|1403|    |-	goToXY(coords.x, coords.y);
+|1404|    |-	return *this;
+|1405|    |-}
+|1406|    |-
+|1407|    |-Window &Window::operator<<(const char *s)
+|1408|    |-{
+|1409|    |-	waddstr(m_window, s);
+|1410|    |-	return *this;
+|1411|    |-}
+|1412|    |-
+|1413|    |-Window &Window::operator<<(char c)
+|1414|    |-{
+|1415|    |-	// Might cause problem similar to
+|1416|    |-	// https://github.com/arybczak/ncmpcpp/issues/21, enable for testing as the
+|1417|    |-	// code in the ticket supposed to be culprit was rewritten.
+|1418|    |-	waddnstr(m_window, &c, 1);
+|1419|    |-	//wprintw(m_window, "%c", c);
+|1420|    |-	return *this;
+|1421|    |-}
+|1422|    |-
+|1423|    |-Window &Window::operator<<(const wchar_t *ws)
+|1424|    |-{
+|1425|    |-	waddwstr(m_window, ws);
+|1426|    |-	return *this;
+|1427|    |-}
+|1428|    |-
+|1429|    |-Window &Window::operator<<(wchar_t wc)
+|1430|    |-{
+|1431|    |-	waddnwstr(m_window, &wc, 1);
+|1432|    |-	return *this;
+|1433|    |-}
+|1434|    |-
+|1435|    |-Window &Window::operator<<(int i)
+|1436|    |-{
+|1437|    |-	wprintw(m_window, "%d", i);
+|1438|    |-	return *this;
+|1439|    |-}
+|1440|    |-
+|1441|    |-Window &Window::operator<<(double d)
+|1442|    |-{
+|1443|    |-	wprintw(m_window, "%f", d);
+|1444|    |-	return *this;
+|1445|    |-}
+|1446|    |-
+|1447|    |-Window &Window::operator<<(const std::string &s)
+|1448|    |-{
+|1449|    |-	waddnstr(m_window, s.c_str(), s.length());
+|1450|    |-	return *this;
+|1451|    |-}
+|1452|    |-
+|1453|    |-Window &Window::operator<<(const std::wstring &ws)
+|1454|    |-{
+|1455|    |-	waddnwstr(m_window, ws.c_str(), ws.length());
+|1456|    |-	return *this;
+|1457|    |-}
+|1458|    |-
+|1459|    |-Window &Window::operator<<(size_t s)
+|1460|    |-{
+|1461|    |-	wprintw(m_window, "%zu", s);
+|1462|    |-	return *this;
+|1463|    |-}
+|1464|    |-
+|1465|    |-}
+|    | 917|+               result = input; free (input);}
+|    | 918|+
+|    | 919|+               if (rl::aborted)
+|    | 920|+               throw PromptAborted (std::move (result)); return result;}
+|    | 921|+
+|    | 922|+               void Window::goToXY (int x, int y)
+|    | 923|+               {
+|    | 924|+               wmove (m_window, y, x);}
+|    | 925|+
+|    | 926|+               int Window::getX ()
+|    | 927|+               {
+|    | 928|+               return getcurx (m_window);}
+|    | 929|+
+|    | 930|+               int Window::getY ()
+|    | 931|+               {
+|    | 932|+               return getcury (m_window);}
+|    | 933|+
+|    | 934|+               bool Window::hasCoords (int &x, int &y)
+|    | 935|+               {
+|    | 936|+               return wmouse_trafo (m_window, &y, &x, 0);}
+|    | 937|+
+|    | 938|+               bool Window::runPromptHook (const char *arg, bool * done) const
+|    | 939|+               {
+|    | 940|+               if (m_prompt_hook)
+|    | 941|+               {
+|    | 942|+               bool continue_ = m_prompt_hook (arg);
+|    | 943|+               if (done != nullptr) * done = !continue_; return true;}
+|    | 944|+               else
+|    | 945|+               return false;}
+|    | 946|+
+|    | 947|+               size_t Window::getWidth ()const
+|    | 948|+               {
+|    | 949|+               if (m_border) return m_width + 2;
+|    | 950|+               else
+|    | 951|+               return m_width;}
+|    | 952|+
+|    | 953|+               size_t Window::getHeight ()const
+|    | 954|+               {
+|    | 955|+               size_t height = m_height;
+|    | 956|+               if (m_border)
+|    | 957|+               height += 2; if (!m_title.empty ())height += 2; return height;}
+|    | 958|+
+|    | 959|+               size_t Window::getStartX ()const
+|    | 960|+               {
+|    | 961|+               if (m_border) return m_start_x - 1;
+|    | 962|+               else
+|    | 963|+               return m_start_x;}
+|    | 964|+
+|    | 965|+               size_t Window::getStarty ()const
+|    | 966|+               {
+|    | 967|+               size_t starty = m_start_y;
+|    | 968|+               if (m_border)-- starty;
+|    | 969|+               if (!m_title.empty ())starty -= 2; return starty;}
+|    | 970|+
+|    | 971|+               const std::string & Window::getTitle ()const
+|    | 972|+               {
+|    | 973|+               return m_title;}
+|    | 974|+
+|    | 975|+               const Color & Window::getColor ()const
+|    | 976|+               {
+|    | 977|+               return m_color;}
+|    | 978|+
+|    | 979|+               const Border & Window::getBorder ()const
+|    | 980|+               {
+|    | 981|+               return m_border;}
+|    | 982|+
+|    | 983|+               int Window::getTimeout ()const
+|    | 984|+               {
+|    | 985|+               return m_window_timeout;}
+|    | 986|+
+|    | 987|+               const MEVENT & Window::getMouseEvent ()
+|    | 988|+               {
+|    | 989|+               return m_mouse_event;}
+|    | 990|+
+|    | 991|+               void Window::scroll (Scroll where)
+|    | 992|+               {
+|    | 993|+               idlok (m_window, 1); scrollok (m_window, 1); switch (where)
+|    | 994|+               {
+|    | 995|+case Scroll::Up:
+|    | 996|+wscrl (m_window, 1); break; case Scroll::Down:
+|    | 997|+wscrl (m_window, -1); break; case Scroll::PageUp:
+|    | 998|+wscrl (m_window, m_width); break; case Scroll::PageDown:
+|    | 999|+wscrl (m_window, -m_width); break; default:
+|    |1000|+               break;}
+|    |1001|+               idlok (m_window, 0); scrollok (m_window, 0);}
+|    |1002|+
+|    |1003|+               Window & Window::operator<< (const Color & c)
+|    |1004|+               {
+|    |1005|+               if (c.isDefault ())
+|    |1006|+               {
+|    |1007|+               while (!m_color_stack.empty ())m_color_stack.pop ();
+|    |1008|+               setColor (m_base_color);}
+|    |1009|+               else
+|    |1010|+               if (c.isEnd ())
+|    |1011|+               {
+|    |1012|+               if (!m_color_stack.empty ())m_color_stack.pop ();
+|    |1013|+               if (!m_color_stack.empty ())setColor (m_color_stack.top ());
+|    |1014|+               else
+|    |1015|+               setColor (m_base_color);}
+|    |1016|+               else
+|    |1017|+               {
+|    |1018|+               if (c.currentBackground ())
+|    |1019|+               {
+|    |1020|+               short background = m_color.isDefault ()? Color::transparent
+|    |1021|+               : m_color.background ();
+|    |1022|+               Color cc = Color (c.foreground (), background);
+|    |1023|+               setColor (cc); m_color_stack.push (cc);}
+|    |1024|+               else
+|    |1025|+               {
+|    |1026|+               setColor (c); m_color_stack.push (c);}
+|    |1027|+               }
+|    |1028|+               return *this;}
+|    |1029|+
+|    |1030|+               Window & Window::operator<< (Format format)
+|    |1031|+               {
+|    |1032|+               auto increase_flag =[](Window & w, int &flag, auto set)
+|    |1033|+               {
+|    |1034|+               ++flag;
+|    |1035|+               (w.*set) (true);};
+|    |1036|+               auto decrease_flag =[](Window & w, int &flag, auto set)
+|    |1037|+               {
+|    |1038|+               if (flag > 0)
+|    |1039|+               {
+|    |1040|+               --flag; if (flag == 0) (w.*set) (false);}
+|    |1041|+               }; switch (format)
+|    |1042|+               {
+|    |1043|+case Format::Bold:
+|    |1044|+increase_flag (*this, m_bold_counter, &Window::bold); break; case Format::NoBold:
+|    |1045|+decrease_flag (*this, m_bold_counter, &Window::bold); break; case Format::Underline:
+|    |1046|+increase_flag (*this, m_underline_counter, &Window::underline); break; case Format::NoUnderline:
+|    |1047|+decrease_flag (*this, m_underline_counter, &Window::underline); break; case Format::Reverse:
+|    |1048|+increase_flag (*this, m_reverse_counter, &Window::reverse); break; case Format::NoReverse:
+|    |1049|+decrease_flag (*this, m_reverse_counter, &Window::reverse); break; case Format::AltCharset:
+|    |1050|+increase_flag (*this, m_alt_charset_counter, &Window::altCharset); break; case Format::NoAltCharset:
+|    |1051|+               decrease_flag (*this, m_alt_charset_counter,
+|    |1052|+                              &Window::altCharset); break;}
+|    |1053|+               return *this;}
+|    |1054|+
+|    |1055|+               Window & Window::operator<< (TermManip tm)
+|    |1056|+               {
+|    |1057|+               switch (tm)
+|    |1058|+               {
+|    |1059|+case TermManip::ClearToEOL:
+|    |1060|+               {
+|    |1061|+               auto x = getX (), y = getY ();
+|    |1062|+               mvwhline (m_window, y, x, ' ', m_width - x); goToXY (x, y);}
+|    |1063|+               break;}
+|    |1064|+               return *this;}
+|    |1065|+
+|    |1066|+               Window & Window::operator<< (const XY & coords)
+|    |1067|+               {
+|    |1068|+               goToXY (coords.x, coords.y); return *this;}
+|    |1069|+
+|    |1070|+               Window & Window::operator<< (const char *s)
+|    |1071|+               {
+|    |1072|+               waddstr (m_window, s); return *this;}
+|    |1073|+
+|    |1074|+               Window & Window::operator<< (char c)
+|    |1075|+               {
+|    |1076|+               // Might cause problem similar to
+|    |1077|+               // https://github.com/arybczak/ncmpcpp/issues/21, enable for testing as the
+|    |1078|+               // code in the ticket supposed to be culprit was rewritten.
+|    |1079|+               waddnstr (m_window, &c, 1);
+|    |1080|+               //wprintw(m_window, "%c", c);
+|    |1081|+               return *this;}
+|    |1082|+
+|    |1083|+               Window & Window::operator<< (const wchar_t * ws)
+|    |1084|+               {
+|    |1085|+               waddwstr (m_window, ws); return *this;}
+|    |1086|+
+|    |1087|+               Window & Window::operator<< (wchar_t wc)
+|    |1088|+               {
+|    |1089|+               waddnwstr (m_window, &wc, 1); return *this;}
+|    |1090|+
+|    |1091|+               Window & Window::operator<< (int i)
+|    |1092|+               {
+|    |1093|+               wprintw (m_window, "%d", i); return *this;}
+|    |1094|+
+|    |1095|+               Window & Window::operator<< (double d)
+|    |1096|+               {
+|    |1097|+               wprintw (m_window, "%f", d); return *this;}
+|    |1098|+
+|    |1099|+               Window & Window::operator<< (const std::string & s)
+|    |1100|+               {
+|    |1101|+               waddnstr (m_window, s.c_str (), s.length ()); return *this;}
+|    |1102|+
+|    |1103|+               Window & Window::operator<< (const std::wstring & ws)
+|    |1104|+               {
+|    |1105|+               waddnwstr (m_window, ws.c_str (), ws.length ()); return *this;}
+|    |1106|+
+|    |1107|+               Window & Window::operator<< (size_t s)
+|    |1108|+               {
+|    |1109|+               wprintw (m_window, "%zu", s); return *this;}
+|    |1110|+
+|    |1111|+               }
+
+src/curses/window.cpp
+|  29| #include•"utility/readline.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/readline.h'
+
+src/curses/window.cpp
+|  30| #include•"utility/string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/string.h'
+
+src/curses/window.cpp
+|  31| #include•"utility/wide_string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/wide_string.h'
+
+src/curses/window.cpp
+|  38| bool•aborted;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'aborted'
+
+src/curses/window.cpp
+|  40| NC::Window•*w;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'w'
+
+src/curses/window.cpp
+|  41| size_t•start_x;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'start_x'
+
+src/curses/window.cpp
+|  42| size_t•start_y;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'start_y'
+
+src/curses/window.cpp
+|  43| size_t•width;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'width'
+
+src/curses/window.cpp
+|  44| bool•encrypted;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'encrypted'
+
+src/curses/window.cpp
+| 194| int•color_pair_counter;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'color_pair_counter'
+
+src/curses/window.cpp
+| 195| std::vector<int>•color_pair_map;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'color_pair_map'
+
+src/curses/window.cpp
+| 354| bool•supportEnabled•=•false;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'supportEnabled'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/clock.h
+|    |++++| /app/src/screens/clock.h
+|  29|  29| #include "interfaces.h"
+|  30|  30| #include "screens/screen.h"
+|  31|  31| 
+|  32|    |-struct Clock: Screen<NC::Window>, Tabbable
+|    |  32|+struct Clock:Screen <
+|    |  33|+    NC::Window >,
+|    |  34|+    Tabbable
+|  33|  35| {
+|  34|    |-	Clock();
+|  35|    |-	
+|  36|    |-	virtual void resize() override;
+|  37|    |-	virtual void switchTo() override;
+|  38|    |-	
+|  39|    |-	virtual std::wstring title() override;
+|  40|    |-	virtual ScreenType type() override { return ScreenType::Clock; }
+|  41|    |-	
+|  42|    |-	virtual void update() override;
+|  43|    |-	virtual void scroll(NC::Scroll) override { }
+|  44|    |-	
+|  45|    |-	virtual void mouseButtonPressed(MEVENT) override { }
+|  46|    |-	
+|  47|    |-	virtual bool isLockable() override { return false; }
+|  48|    |-	virtual bool isMergable() override { return true; }
+|  49|    |-	
+|  50|    |-private:
+|  51|    |-	NC::Window m_pane;
+|  52|    |-	
+|  53|    |-	static void Prepare();
+|  54|    |-	static void Set(int, int);
+|  55|    |-	
+|  56|    |-	static short disp[11];
+|  57|    |-	static long older[6], next[6], newer[6], mask;
+|  58|    |-	
+|  59|    |-	static size_t Width;
+|  60|    |-	static const size_t Height;
+|    |  36|+    Clock ();
+|    |  37|+
+|    |  38|+    virtual void
+|    |  39|+    resize ()
+|    |  40|+        override;
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+
+|    |  45|+    virtual
+|    |  46|+        std::wstring
+|    |  47|+    title ()
+|    |  48|+        override;
+|    |  49|+    virtual ScreenType
+|    |  50|+    type ()
+|    |  51|+        override
+|    |  52|+    {
+|    |  53|+        return ScreenType::Clock;
+|    |  54|+    }
+|    |  55|+
+|    |  56|+    virtual void
+|    |  57|+    update ()
+|    |  58|+        override;
+|    |  59|+    virtual void
+|    |  60|+    scroll (NC::Scroll)
+|    |  61|+        override
+|    |  62|+    {
+|    |  63|+    }
+|    |  64|+
+|    |  65|+    virtual void
+|    |  66|+    mouseButtonPressed (MEVENT)
+|    |  67|+        override
+|    |  68|+    {
+|    |  69|+    }
+|    |  70|+
+|    |  71|+    virtual bool
+|    |  72|+    isLockable ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+        return false;
+|    |  76|+    }
+|    |  77|+    virtual bool
+|    |  78|+    isMergable ()
+|    |  79|+        override
+|    |  80|+    {
+|    |  81|+        return true;
+|    |  82|+    }
+|    |  83|+
+|    |  84|+  private:
+|    |  85|+    NC::Window m_pane;
+|    |  86|+
+|    |  87|+    static void
+|    |  88|+    Prepare ();
+|    |  89|+    static void
+|    |  90|+    Set (int, int);
+|    |  91|+
+|    |  92|+    static short
+|    |  93|+        disp[11];
+|    |  94|+    static long
+|    |  95|+        older[6],
+|    |  96|+        next[6],
+|    |  97|+        newer[6],
+|    |  98|+        mask;
+|    |  99|+
+|    | 100|+    static size_t
+|    | 101|+        Width;
+|    | 102|+    static const size_t
+|    | 103|+        Height;
+|  61| 104| };
+|  62| 105| 
+|  63| 106| extern Clock *myClock;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/clock.h
+|    |++++| /app/src/screens/clock.h
+|  60|  60| 	static const size_t Height;
+|  61|  61| };
+|  62|  62| 
+|  63|    |-extern Clock *myClock;
+|    |  63|+extern Clock *
+|    |  64|+    myClock;
+|  64|  65| 
+|  65|  66| #endif // ENABLE_CLOCK
+|  66|  67| 
+
+src/screens/clock.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/clock.h
+|  28| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+
+src/screens/clock.h
+|  29| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/clock.h
+|  30| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/clock.h
+|  56| »   static•short•disp[11];
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'disp'
+
+src/screens/clock.h
+|  57| »   static•long•older[6],•next[6],•newer[6],•mask;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'older'
+
+src/screens/clock.h
+|  57| »   static•long•older[6],•next[6],•newer[6],•mask;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'mask'
+
+src/screens/clock.h
+|  59| »   static•size_t•Width;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Width'
+
+src/screens/clock.h
+|  63| extern•Clock•*myClock;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myClock'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  24|  24| #include "curses/window.h"
+|  25|  25| #include "curses/strbuffer.h"
+|  26|  26| 
+|  27|    |-namespace NC {
+|    |  27|+namespace NC
+|    |  28|+{
+|  28|  29| 
+|  29|  30| /// Scrollpad is specialized window that holds large portions of text and
+|  30|  31| /// supports scrolling if the amount of it is bigger than the window area.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  28|  28| 
+|  29|  29| /// Scrollpad is specialized window that holds large portions of text and
+|  30|  30| /// supports scrolling if the amount of it is bigger than the window area.
+|  31|    |-struct Scrollpad: public Window
+|  32|    |-{
+|  33|    |-	Scrollpad() { }
+|  34|    |-	
+|  35|    |-	Scrollpad(size_t startx, size_t starty, size_t width, size_t height,
+|  36|    |-	          const std::string &title, Color color, Border border);
+|  37|    |-	
+|  38|    |-	// override a few Window functions
+|  39|    |-	virtual void refresh() override;
+|  40|    |-	virtual void scroll(Scroll where) override;
+|  41|    |-	virtual void resize(size_t new_width, size_t new_height) override;
+|  42|    |-	virtual void clear() override;
+|  43|    |-	
+|  44|    |-	const std::string &buffer();
+|  45|    |-	
+|  46|    |-	void flush();
+|  47|    |-	void reset();
+|  48|    |-	
+|  49|    |-	bool setProperties(const Color &begin, const std::string &s, const Color &end,
+|  50|    |-	                   size_t flags, size_t id = -2);
+|  51|    |-	bool setProperties(const Format &begin, const std::string &s, const Format &end,
+|  52|    |-	                   size_t flags, size_t id = -2);
+|  53|    |-	bool setProperties(const FormattedColor &fc, const std::string &s,
+|  54|    |-	                   size_t flags, size_t id = -2);
+|  55|    |-	void removeProperties(size_t id = -2);
+|  56|    |-	
+|  57|    |-	Scrollpad &operator<<(int n) { return write(n); }
+|  58|    |-	Scrollpad &operator<<(long int n) { return write(n); }
+|  59|    |-	Scrollpad &operator<<(unsigned int n) { return write(n); }
+|  60|    |-	Scrollpad &operator<<(unsigned long int n) { return write(n); }
+|  61|    |-	Scrollpad &operator<<(char c) { return write(c); }
+|  62|    |-	Scrollpad &operator<<(const char *s) { return write(s); }
+|  63|    |-	Scrollpad &operator<<(const std::string &s) { return write(s); }
+|  64|    |-	Scrollpad &operator<<(Color color) { return write(color); }
+|  65|    |-	Scrollpad &operator<<(Format format) { return write(format); }
+|    |  31|+    struct Scrollpad:public Window
+|    |  32|+    {
+|    |  33|+        Scrollpad ()
+|    |  34|+        {
+|    |  35|+        }
+|  66|  36| 
+|  67|    |-private:
+|  68|    |-	template <typename ItemT>
+|  69|    |-	Scrollpad &write(ItemT &&item)
+|  70|    |-	{
+|  71|    |-		m_buffer << std::forward<ItemT>(item);
+|  72|    |-		return *this;
+|  73|    |-	}
+|    |  37|+        Scrollpad (size_t startx, size_t starty, size_t width, size_t height,
+|    |  38|+                   const std::string & title, Color color, Border border);
+|  74|  39| 
+|  75|    |-	Buffer m_buffer;
+|  76|    |-	
+|  77|    |-	size_t m_beginning;
+|  78|    |-	size_t m_real_height;
+|  79|    |-};
+|    |  40|+        // override a few Window functions
+|    |  41|+        virtual void refresh () override;
+|    |  42|+        virtual void scroll (Scroll where) override;
+|    |  43|+        virtual void resize (size_t new_width, size_t new_height) override;
+|    |  44|+        virtual void clear () override;
+|    |  45|+
+|    |  46|+        const std::string & buffer ();
+|    |  47|+
+|    |  48|+        void flush ();
+|    |  49|+        void reset ();
+|    |  50|+
+|    |  51|+        bool setProperties (const Color & begin, const std::string & s,
+|    |  52|+                            const Color & end, size_t flags, size_t id = -2);
+|    |  53|+        bool setProperties (const Format & begin, const std::string & s,
+|    |  54|+                            const Format & end, size_t flags, size_t id = -2);
+|    |  55|+        bool setProperties (const FormattedColor & fc, const std::string & s,
+|    |  56|+                            size_t flags, size_t id = -2);
+|    |  57|+        void removeProperties (size_t id = -2);
+|    |  58|+
+|    |  59|+          Scrollpad & operator<< (int n)
+|    |  60|+        {
+|    |  61|+            return write (n);
+|    |  62|+        }
+|    |  63|+        Scrollpad & operator<< (long int n)
+|    |  64|+        {
+|    |  65|+            return write (n);
+|    |  66|+        }
+|    |  67|+        Scrollpad & operator<< (unsigned int n)
+|    |  68|+        {
+|    |  69|+            return write (n);
+|    |  70|+        }
+|    |  71|+        Scrollpad & operator<< (unsigned long int n)
+|    |  72|+        {
+|    |  73|+            return write (n);
+|    |  74|+        }
+|    |  75|+        Scrollpad & operator<< (char c)
+|    |  76|+        {
+|    |  77|+            return write (c);
+|    |  78|+        }
+|    |  79|+        Scrollpad & operator<< (const char *s)
+|    |  80|+        {
+|    |  81|+            return write (s);
+|    |  82|+        }
+|    |  83|+        Scrollpad & operator<< (const std::string & s)
+|    |  84|+        {
+|    |  85|+            return write (s);
+|    |  86|+        }
+|    |  87|+        Scrollpad & operator<< (Color color)
+|    |  88|+        {
+|    |  89|+            return write (color);
+|    |  90|+        }
+|    |  91|+        Scrollpad & operator<< (Format format)
+|    |  92|+        {
+|    |  93|+            return write (format);
+|    |  94|+        }
+|    |  95|+
+|    |  96|+      private:
+|    |  97|+        template < typename ItemT > Scrollpad & write (ItemT && item)
+|    |  98|+        {
+|    |  99|+            m_buffer << std::forward < ItemT > (item);
+|    | 100|+            return *this;
+|    | 101|+        }
+|    | 102|+
+|    | 103|+        Buffer m_buffer;
+|    | 104|+
+|    | 105|+        size_t m_beginning;
+|    | 106|+        size_t m_real_height;
+|    | 107|+    };
+|  80| 108| 
+|  81| 109| }
+|  82| 110| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/scrollpad.h
+|    |++++| /app/src/curses/scrollpad.h
+|  81|  81| }
+|  82|  82| 
+|  83|  83| #endif // NCMPCPP_SCROLLPAD_H
+|  84|    |-
+
+src/curses/scrollpad.h
+|  24| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+
+src/curses/scrollpad.h
+|  25| #include•"curses/strbuffer.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/strbuffer.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.cpp
+|    |++++| /app/src/screens/song_info.cpp
+|  32|  32| # include <boost/lexical_cast.hpp>
+|  33|  33| #endif // HAVE_TAGLIB_H
+|  34|  34| 
+|  35|    |-using Global::MainHeight;
+|  36|    |-using Global::MainStartY;
+|    |  35|+using
+|    |  36|+    Global::MainHeight;
+|    |  37|+using
+|    |  38|+    Global::MainStartY;
+|  37|  39| 
+|  38|    |-SongInfo *mySongInfo;
+|    |  40|+SongInfo *
+|    |  41|+    mySongInfo;
+|  39|  42| 
+|  40|    |-const SongInfo::Metadata SongInfo::Tags[] =
+|  41|    |-{
+|  42|    |- { "Title",        &MPD::Song::getTitle,       &MPD::MutableSong::setTitle       },
+|  43|    |- { "Artist",       &MPD::Song::getArtist,      &MPD::MutableSong::setArtist      },
+|  44|    |- { "Album Artist", &MPD::Song::getAlbumArtist, &MPD::MutableSong::setAlbumArtist },
+|  45|    |- { "Album",        &MPD::Song::getAlbum,       &MPD::MutableSong::setAlbum       },
+|  46|    |- { "Date",         &MPD::Song::getDate,        &MPD::MutableSong::setDate        },
+|  47|    |- { "Track",        &MPD::Song::getTrack,       &MPD::MutableSong::setTrack       },
+|  48|    |- { "Genre",        &MPD::Song::getGenre,       &MPD::MutableSong::setGenre       },
+|  49|    |- { "Composer",     &MPD::Song::getComposer,    &MPD::MutableSong::setComposer    },
+|  50|    |- { "Performer",    &MPD::Song::getPerformer,   &MPD::MutableSong::setPerformer   },
+|  51|    |- { "Disc",         &MPD::Song::getDisc,        &MPD::MutableSong::setDisc        },
+|  52|    |- { "Comment",      &MPD::Song::getComment,     &MPD::MutableSong::setComment     },
+|  53|    |- { 0,              0,                          0                                 }
+|    |  43|+const
+|    |  44|+    SongInfo::Metadata
+|    |  45|+    SongInfo::Tags[] = {
+|    |  46|+    {"Title", &MPD::Song::getTitle, &MPD::MutableSong::setTitle},
+|    |  47|+    {"Artist", &MPD::Song::getArtist, &MPD::MutableSong::setArtist},
+|    |  48|+    {"Album Artist", &MPD::Song::getAlbumArtist,
+|    |  49|+     &MPD::MutableSong::setAlbumArtist},
+|    |  50|+    {"Album", &MPD::Song::getAlbum, &MPD::MutableSong::setAlbum},
+|    |  51|+    {"Date", &MPD::Song::getDate, &MPD::MutableSong::setDate},
+|    |  52|+    {"Track", &MPD::Song::getTrack, &MPD::MutableSong::setTrack},
+|    |  53|+    {"Genre", &MPD::Song::getGenre, &MPD::MutableSong::setGenre},
+|    |  54|+    {"Composer", &MPD::Song::getComposer, &MPD::MutableSong::setComposer},
+|    |  55|+    {"Performer", &MPD::Song::getPerformer, &MPD::MutableSong::setPerformer},
+|    |  56|+    {"Disc", &MPD::Song::getDisc, &MPD::MutableSong::setDisc},
+|    |  57|+    {"Comment", &MPD::Song::getComment, &MPD::MutableSong::setComment},
+|    |  58|+    {0, 0, 0}
+|  54|  59| };
+|  55|  60| 
+|  56|  61| SongInfo::SongInfo()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.cpp
+|    |++++| /app/src/screens/song_info.cpp
+|  53|  53|  { 0,              0,                          0                                 }
+|  54|  54| };
+|  55|  55| 
+|  56|    |-SongInfo::SongInfo()
+|  57|    |-: Screen(NC::Scrollpad(0, MainStartY, COLS, MainHeight, "", Config.main_color, NC::Border()))
+|  58|    |-{ }
+|  59|    |-
+|  60|    |-void SongInfo::resize()
+|    |  56|+SongInfo::SongInfo ():Screen (NC::
+|    |  57|+        Scrollpad (0, MainStartY, COLS, MainHeight, "", Config.main_color,
+|    |  58|+                   NC::Border ()))
+|  61|  59| {
+|  62|    |-	size_t x_offset, width;
+|  63|    |-	getWindowResizeParams(x_offset, width);
+|  64|    |-	w.resize(width, MainHeight);
+|  65|    |-	w.moveTo(x_offset, MainStartY);
+|  66|    |-	hasToBeResized = 0;
+|  67|  60| }
+|  68|  61| 
+|  69|  62| std::wstring SongInfo::title()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.cpp
+|    |++++| /app/src/screens/song_info.cpp
+|  66|  66| 	hasToBeResized = 0;
+|  67|  67| }
+|  68|  68| 
+|  69|    |-std::wstring SongInfo::title()
+|    |  69|+void
+|    |  70|+SongInfo::resize ()
+|  70|  71| {
+|  71|    |-	return L"Song info";
+|    |  72|+    size_t x_offset, width;
+|    |  73|+    getWindowResizeParams (x_offset, width);
+|    |  74|+    w.resize (width, MainHeight);
+|    |  75|+    w.moveTo (x_offset, MainStartY);
+|    |  76|+    hasToBeResized = 0;
+|  72|  77| }
+|  73|  78| 
+|  74|  79| void SongInfo::switchTo()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.cpp
+|    |++++| /app/src/screens/song_info.cpp
+|  71|  71| 	return L"Song info";
+|  72|  72| }
+|  73|  73| 
+|  74|    |-void SongInfo::switchTo()
+|    |  74|+std::wstring SongInfo::title ()
+|  75|  75| {
+|  76|    |-	using Global::myScreen;
+|  77|    |-	if (myScreen != this)
+|  78|    |-	{
+|  79|    |-		auto s = currentSong(myScreen);
+|  80|    |-		if (!s)
+|  81|    |-			return;
+|  82|    |-		SwitchTo::execute(this);
+|  83|    |-		w.clear();
+|  84|    |-		w.reset();
+|  85|    |-		PrepareSong(*s);
+|  86|    |-		w.flush();
+|  87|    |-		// redraw header after we're done with the file, since reading it from disk
+|  88|    |-		// takes a bit of time and having header updated before content of a window
+|  89|    |-		// is displayed doesn't look nice.
+|  90|    |-		drawHeader();
+|  91|    |-	}
+|  92|    |-	else
+|  93|    |-		switchToPreviousScreen();
+|    |  76|+    return L"Song info";
+|  94|  77| }
+|  95|  78| 
+|  96|  79| void SongInfo::PrepareSong(const MPD::Song &s)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.cpp
+|    |++++| /app/src/screens/song_info.cpp
+|  93|  93| 		switchToPreviousScreen();
+|  94|  94| }
+|  95|  95| 
+|  96|    |-void SongInfo::PrepareSong(const MPD::Song &s)
+|    |  96|+void
+|    |  97|+SongInfo::switchTo ()
+|  97|  98| {
+|  98|    |-	auto print_key_value = [this](const char *key, const auto &value) {
+|  99|    |-		w << NC::Format::Bold
+| 100|    |-		  << Config.color1
+| 101|    |-		  << key
+| 102|    |-		  << ":"
+| 103|    |-		  << NC::FormattedColor::End<>(Config.color1)
+| 104|    |-		  << NC::Format::NoBold
+| 105|    |-		  << " "
+| 106|    |-		  << Config.color2
+| 107|    |-		  << value
+| 108|    |-		  << NC::FormattedColor::End<>(Config.color2)
+| 109|    |-		  << "\n";
+| 110|    |-	};
+|    |  99|+    using Global::myScreen;
+|    | 100|+    if (myScreen != this)
+|    | 101|+      {
+|    | 102|+          auto s = currentSong (myScreen);
+|    | 103|+          if (!s)
+|    | 104|+              return;
+|    | 105|+          SwitchTo::execute (this);
+|    | 106|+          w.clear ();
+|    | 107|+          w.reset ();
+|    | 108|+          PrepareSong (*s);
+|    | 109|+          w.flush ();
+|    | 110|+          // redraw header after we're done with the file, since reading it from disk
+|    | 111|+          // takes a bit of time and having header updated before content of a window
+|    | 112|+          // is displayed doesn't look nice.
+|    | 113|+          drawHeader ();
+|    | 114|+      }
+|    | 115|+    else
+|    | 116|+        switchToPreviousScreen ();
+|    | 117|+}
+| 111| 118| 
+| 112|    |-	print_key_value("Filename", s.getName());
+| 113|    |-	print_key_value("Directory", ShowTag(s.getDirectory()));
+| 114|    |-	w << "\n";
+| 115|    |-	print_key_value("Length", s.getLength());
+|    | 119|+void
+|    | 120|+SongInfo::PrepareSong (const MPD::Song & s)
+|    | 121|+{
+|    | 122|+    auto print_key_value =[this] (const char *key, const auto & value) {
+|    | 123|+        w << NC::Format::Bold
+|    | 124|+            << Config.color1
+|    | 125|+            << key
+|    | 126|+            << ":"
+|    | 127|+            << NC::FormattedColor::End <> (Config.color1)
+|    | 128|+            << NC::Format::NoBold
+|    | 129|+            << " "
+|    | 130|+            << Config.color2
+|    | 131|+            << value << NC::FormattedColor::End <> (Config.color2) << "\n";
+|    | 132|+    };
+|    | 133|+
+|    | 134|+    print_key_value ("Filename", s.getName ());
+|    | 135|+    print_key_value ("Directory", ShowTag (s.getDirectory ()));
+|    | 136|+    w << "\n";
+|    | 137|+    print_key_value ("Length", s.getLength ());
+| 116| 138| 
+| 117| 139| #	ifdef HAVE_TAGLIB_H
+| 118| 140| 	if (!Config.mpd_music_dir.empty() && !s.isStream())
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/song_info.cpp
+|    |++++| /app/src/screens/song_info.cpp
+| 115| 115| 	print_key_value("Length", s.getLength());
+| 116| 116| 
+| 117| 117| #	ifdef HAVE_TAGLIB_H
+| 118|    |-	if (!Config.mpd_music_dir.empty() && !s.isStream())
+| 119|    |-	{
+| 120|    |-		std::string path_to_file;
+| 121|    |-		if (s.isFromDatabase())
+| 122|    |-			path_to_file += Config.mpd_music_dir;
+| 123|    |-		path_to_file += s.getURI();
+| 124|    |-		TagLib::FileRef f(path_to_file.c_str());
+| 125|    |-		if (!f.isNull())
+| 126|    |-		{
+| 127|    |-			print_key_value(
+| 128|    |-				"Bitrate",
+| 129|    |-				boost::lexical_cast<std::string>(f.audioProperties()->bitrate()) + " kbps");
+| 130|    |-			print_key_value(
+| 131|    |-				"Sample rate",
+| 132|    |-				boost::lexical_cast<std::string>(f.audioProperties()->sampleRate()) + " Hz");
+| 133|    |-			print_key_value("Channels", channelsToString(f.audioProperties()->channels()));
+| 134|    |-			
+| 135|    |-			auto rginfo = Tags::readReplayGain(f.file());
+| 136|    |-			if (!rginfo.empty())
+| 137|    |-			{
+| 138|    |-				w << "\n";
+| 139|    |-				print_key_value("Reference loudness", rginfo.referenceLoudness());
+| 140|    |-				print_key_value("Track gain", rginfo.trackGain());
+| 141|    |-				print_key_value("Track peak", rginfo.trackPeak());
+| 142|    |-				print_key_value("Album gain", rginfo.albumGain());
+| 143|    |-				print_key_value("Album peak", rginfo.albumPeak());
+| 144|    |-			}
+| 145|    |-		}
+| 146|    |-	}
+|    | 118|+    if (!Config.mpd_music_dir.empty () && !s.isStream ())
+|    | 119|+      {
+|    | 120|+          std::string path_to_file;
+|    | 121|+          if (s.isFromDatabase ())
+|    | 122|+              path_to_file += Config.mpd_music_dir;
+|    | 123|+          path_to_file += s.getURI ();
+|    | 124|+          TagLib::FileRef f (path_to_file.c_str ());
+|    | 125|+          if (!f.isNull ())
+|    | 126|+            {
+|    | 127|+                print_key_value ("Bitrate",
+|    | 128|+                                 boost::lexical_cast < std::string >
+|    | 129|+                                 (f.audioProperties ()->bitrate ()) + " kbps");
+|    | 130|+                print_key_value ("Sample rate",
+|    | 131|+                                 boost::lexical_cast < std::string >
+|    | 132|+                                 (f.audioProperties ()->sampleRate ()) +
+|    | 133|+                                 " Hz");
+|    | 134|+                print_key_value ("Channels",
+|    | 135|+                                 channelsToString (f.audioProperties ()->
+|    | 136|+                                                   channels ()));
+|    | 137|+
+|    | 138|+                auto rginfo = Tags::readReplayGain (f.file ());
+|    | 139|+                if (!rginfo.empty ())
+|    | 140|+                  {
+|    | 141|+                      w << "\n";
+|    | 142|+                      print_key_value ("Reference loudness",
+|    | 143|+                                       rginfo.referenceLoudness ());
+|    | 144|+                      print_key_value ("Track gain", rginfo.trackGain ());
+|    | 145|+                      print_key_value ("Track peak", rginfo.trackPeak ());
+|    | 146|+                      print_key_value ("Album gain", rginfo.albumGain ());
+|    | 147|+                      print_key_value ("Album peak", rginfo.albumPeak ());
+|    | 148|+                  }
+|    | 149|+            }
+|    | 150|+      }
+| 147| 151| #	endif // HAVE_TAGLIB_H
+| 148|    |-	w << NC::Color::Default;
+| 149|    |-	
+| 150|    |-	for (const Metadata *m = Tags; m->Name; ++m)
+| 151|    |-	{
+| 152|    |-		w << NC::Format::Bold << "\n" << m->Name << ":" << NC::Format::NoBold << " ";
+| 153|    |-		ShowTag(w, s.getTags(m->Get));
+| 154|    |-	}
+|    | 152|+    w << NC::Color::Default;
+|    | 153|+
+|    | 154|+    for (const Metadata * m = Tags; m->Name; ++m)
+|    | 155|+      {
+|    | 156|+          w << NC::Format::Bold << "\n" << m->
+|    | 157|+              Name << ":" << NC::Format::NoBold << " ";
+|    | 158|+          ShowTag (w, s.getTags (m->Get));
+|    | 159|+      }
+| 155| 160| }
+
+src/screens/song_info.cpp
+|  21| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/song_info.cpp
+|  22| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/song_info.cpp
+|  23| #include•"screens/song_info.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/song_info.h'
+
+src/screens/song_info.cpp
+|  24| #include•"screens/tag_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/tag_editor.h'
+
+src/screens/song_info.cpp
+|  25| #include•"tags.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'tags.h'
+
+src/screens/song_info.cpp
+|  26| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/song_info.cpp
+|  27| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/song_info.cpp
+|  30| #•include•"fileref.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'fileref.h'
+
+src/screens/song_info.cpp
+|  31| #•include•"tag.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'tag.h'
+
+src/screens/song_info.cpp
+|  38| SongInfo•*mySongInfo;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'mySongInfo'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  22|  22| #include "screens/song_info.h"
+|  23|  23| #include "utility/functional.h"
+|  24|  24| 
+|  25|    |-SongIterator SongMenu::currentS()
+|    |  25|+SongIterator
+|    |  26|+SongMenu::currentS ()
+|  26|  27| {
+|  27|    |-	return makeSongIterator(current());
+|    |  28|+    return makeSongIterator (current ());
+|  28|  29| }
+|  29|  30| 
+|  30|  31| ConstSongIterator SongMenu::currentS() const
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  27|  27| 	return makeSongIterator(current());
+|  28|  28| }
+|  29|  29| 
+|  30|    |-ConstSongIterator SongMenu::currentS() const
+|    |  30|+ConstSongIterator
+|    |  31|+SongMenu::currentS () const const
+|  31|  32| {
+|  32|    |-	return makeConstSongIterator(current());
+|    |  33|+    return makeConstSongIterator (current ());
+|  33|  34| }
+|  34|  35| 
+|  35|  36| SongIterator SongMenu::beginS()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  32|  32| 	return makeConstSongIterator(current());
+|  33|  33| }
+|  34|  34| 
+|  35|    |-SongIterator SongMenu::beginS()
+|    |  35|+SongIterator
+|    |  36|+SongMenu::beginS ()
+|  36|  37| {
+|  37|    |-	return makeSongIterator(begin());
+|    |  38|+    return makeSongIterator (begin ());
+|  38|  39| }
+|  39|  40| 
+|  40|  41| ConstSongIterator SongMenu::beginS() const
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  37|  37| 	return makeSongIterator(begin());
+|  38|  38| }
+|  39|  39| 
+|  40|    |-ConstSongIterator SongMenu::beginS() const
+|    |  40|+ConstSongIterator
+|    |  41|+SongMenu::beginS () const const
+|  41|  42| {
+|  42|    |-	return makeConstSongIterator(begin());
+|    |  43|+    return makeConstSongIterator (begin ());
+|  43|  44| }
+|  44|  45| 
+|  45|  46| SongIterator SongMenu::endS()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  42|  42| 	return makeConstSongIterator(begin());
+|  43|  43| }
+|  44|  44| 
+|  45|    |-SongIterator SongMenu::endS()
+|    |  45|+SongIterator
+|    |  46|+SongMenu::endS ()
+|  46|  47| {
+|  47|    |-	return makeSongIterator(end());
+|    |  48|+    return makeSongIterator (end ());
+|  48|  49| }
+|  49|  50| 
+|  50|  51| ConstSongIterator SongMenu::endS() const
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  47|  47| 	return makeSongIterator(end());
+|  48|  48| }
+|  49|  49| 
+|  50|    |-ConstSongIterator SongMenu::endS() const
+|    |  50|+ConstSongIterator
+|    |  51|+SongMenu::endS () const const
+|  51|  52| {
+|  52|    |-	return makeConstSongIterator(end());
+|    |  53|+    return makeConstSongIterator (end ());
+|  53|  54| }
+|  54|  55| 
+|  55|  56| std::vector<MPD::Song> SongMenu::getSelectedSongs()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.cpp
+|    |++++| /app/src/song_list.cpp
+|  52|  52| 	return makeConstSongIterator(end());
+|  53|  53| }
+|  54|  54| 
+|  55|    |-std::vector<MPD::Song> SongMenu::getSelectedSongs()
+|    |  55|+std::vector < MPD::Song > SongMenu::getSelectedSongs ()
+|  56|  56| {
+|  57|    |-	std::vector<MPD::Song> result;
+|  58|    |-	for (auto it = begin(); it != end(); ++it)
+|  59|    |-		if (it->isSelected())
+|  60|    |-			result.push_back(it->value());
+|  61|    |-	if (result.empty() && !empty())
+|  62|    |-		result.push_back(current()->value());
+|  63|    |-	return result;
+|    |  57|+    std::vector < MPD::Song > result;
+|    |  58|+    for (auto it = begin (); it != end (); ++it)
+|    |  59|+        if (it->isSelected ())
+|    |  60|+            result.push_back (it->value ());
+|    |  61|+    if (result.empty () && !empty ())
+|    |  62|+        result.push_back (current ()->value ());
+|    |  63|+    return result;
+|  64|  64| }
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/storage_kind.h
+|    |++++| /app/src/utility/storage_kind.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_STORAGE_KIND_H
+|  22|  22| #define NCMPCPP_UTILITY_STORAGE_KIND_H
+|  23|  23| 
+|  24|    |-enum class StorageKind { Reference, Value };
+|    |  24|+enum class StorageKind
+|    |  25|+{ Reference, Value };
+|  25|  26| 
+|  26|  27| #endif // NCMPCPP_UTILITY_VALUE_TYPE_H
+
+src/utility/storage_kind.h
+|  24| enum•class•StorageKind•{•Reference,•Value•};
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format.h
+|    |++++| /app/src/format.h
+|  26|  26| #include "curses/menu.h"
+|  27|  27| #include "song.h"
+|  28|  28| 
+|  29|    |-namespace Format {
+|    |  29|+namespace Format
+|    |  30|+{
+|  30|  31| 
+|  31|    |-namespace Flags {
+|  32|    |-const unsigned None = 0;
+|  33|    |-const unsigned Color = 1;
+|  34|    |-const unsigned Format = 2;
+|  35|    |-const unsigned OutputSwitch = 4;
+|  36|    |-const unsigned Tag = 8;
+|  37|    |-const unsigned All = Color | Format | OutputSwitch | Tag;
+|  38|    |-}
+|    |  32|+    namespace Flags
+|    |  33|+    {
+|    |  34|+        const unsigned None = 0;
+|    |  35|+        const unsigned Color = 1;
+|    |  36|+        const unsigned Format = 2;
+|    |  37|+        const unsigned OutputSwitch = 4;
+|    |  38|+        const unsigned Tag = 8;
+|    |  39|+        const unsigned All = Color | Format | OutputSwitch | Tag;
+|    |  40|+    }
+|  39|  41| 
+|  40|    |-enum class ListType { Group, FirstOf, AST };
+|    |  42|+    enum class ListType
+|    |  43|+    { Group, FirstOf, AST };
+|  41|  44| 
+|  42|    |-template <ListType, typename> struct List;
+|  43|    |-template <typename CharT> using Group = List<ListType::Group, CharT>;
+|  44|    |-template <typename CharT> using FirstOf = List<ListType::FirstOf, CharT>;
+|  45|    |-template <typename CharT> using AST = List<ListType::AST, CharT>;
+|    |  45|+      template < ListType, typename > struct List;
+|    |  46|+      template < typename CharT > using Group =
+|    |  47|+        List < ListType::Group, CharT >;
+|    |  48|+      template < typename CharT > using FirstOf =
+|    |  49|+        List < ListType::FirstOf, CharT >;
+|    |  50|+      template < typename CharT > using AST = List < ListType::AST, CharT >;
+|  46|  51| 
+|  47|    |-struct OutputSwitch { };
+|    |  52|+    struct OutputSwitch
+|    |  53|+    {
+|    |  54|+    };
+|  48|  55| 
+|  49|    |-struct SongTag
+|  50|    |-{
+|  51|    |-	SongTag(MPD::Song::GetFunction function_, unsigned delimiter_ = 0)
+|  52|    |-	: m_function(function_), m_delimiter(delimiter_)
+|  53|    |-	{ }
+|    |  56|+    struct SongTag
+|    |  57|+    {
+|    |  58|+      SongTag (MPD::Song::GetFunction function_, unsigned delimiter_ = 0):m_function (function_),
+|    |  59|+            m_delimiter
+|    |  60|+            (delimiter_)
+|    |  61|+        {
+|    |  62|+        }
+|  54|  63| 
+|  55|    |-	MPD::Song::GetFunction function() const { return m_function; }
+|  56|    |-	unsigned delimiter() const { return m_delimiter; }
+|    |  64|+        MPD::Song::GetFunction function () const
+|    |  65|+        {
+|    |  66|+            return m_function;
+|    |  67|+        }
+|    |  68|+        unsigned delimiter () const
+|    |  69|+        {
+|    |  70|+            return m_delimiter;
+|    |  71|+        }
+|  57|  72| 
+|  58|    |-private:
+|  59|    |-	MPD::Song::GetFunction m_function;
+|  60|    |-	unsigned m_delimiter;
+|  61|    |-};
+|    |  73|+      private:
+|    |  74|+          MPD::Song::GetFunction m_function;
+|    |  75|+        unsigned m_delimiter;
+|    |  76|+    };
+|  62|  77| 
+|  63|    |-inline bool operator==(const SongTag &lhs, const SongTag &rhs) {
+|  64|    |-	return lhs.function() == rhs.function()
+|  65|    |-		&& lhs.delimiter() == rhs.delimiter();
+|  66|    |-}
+|  67|    |-inline bool operator!=(const SongTag &lhs, const SongTag &rhs) {
+|  68|    |-	return !(lhs == rhs);
+|  69|    |-}
+|    |  78|+    inline bool operator== (const SongTag & lhs, const SongTag & rhs)
+|    |  79|+    {
+|    |  80|+        return lhs.function () == rhs.function ()
+|    |  81|+            && lhs.delimiter () == rhs.delimiter ();
+|    |  82|+    }
+|    |  83|+    inline bool operator!= (const SongTag & lhs, const SongTag & rhs)
+|    |  84|+    {
+|    |  85|+        return !(lhs == rhs);
+|    |  86|+    }
+|  70|  87| 
+|  71|    |-template <typename CharT>
+|  72|    |-using TagVector = std::vector<
+|  73|    |-	std::pair<
+|  74|    |-		boost::optional<SongTag>,
+|  75|    |-		std::basic_string<CharT>
+|  76|    |-		>
+|  77|    |-	>;
+|    |  88|+    template < typename CharT >
+|    |  89|+        using TagVector = std::vector <
+|    |  90|+        std::pair <
+|    |  91|+        boost::optional < SongTag >, std::basic_string < CharT > >>;
+|  78|  92| 
+|  79|    |-enum class Result { Empty, Missing, Ok };
+|    |  93|+    enum class Result
+|    |  94|+    { Empty, Missing, Ok };
+|  80|  95| 
+|  81|    |-template <typename CharT>
+|  82|    |-using Expression = boost::variant<
+|  83|    |-	std::basic_string<CharT>,
+|  84|    |-	NC::Color,
+|  85|    |-	NC::Format,
+|  86|    |-	OutputSwitch,
+|  87|    |-	SongTag,
+|  88|    |-	boost::recursive_wrapper<FirstOf<CharT>>,
+|  89|    |-	boost::recursive_wrapper<Group<CharT>>
+|  90|    |->;
+|    |  96|+    template < typename CharT >
+|    |  97|+        using Expression = boost::variant <
+|    |  98|+        std::basic_string < CharT >,
+|    |  99|+        NC::Color,
+|    | 100|+        NC::Format,
+|    | 101|+        OutputSwitch,
+|    | 102|+        SongTag,
+|    | 103|+        boost::recursive_wrapper < FirstOf < CharT >>,
+|    | 104|+        boost::recursive_wrapper < Group < CharT >> >;
+|  91| 105| 
+|  92|    |-template <ListType Type, typename CharT>
+|  93|    |-struct List
+|  94|    |-{
+|  95|    |-	typedef std::vector<Expression<CharT>> Base;
+|    | 106|+    template < ListType Type, typename CharT > struct List
+|    | 107|+    {
+|    | 108|+        typedef std::vector < Expression < CharT >> Base;
+|  96| 109| 
+|  97|    |-	List() { }
+|  98|    |-	List(Base &&base_)
+|  99|    |-	: m_base(std::move(base_))
+| 100|    |-	{ }
+|    | 110|+          List ()
+|    | 111|+        {
+|    | 112|+        }
+|    | 113|+        List (Base && base_):m_base (std::move (base_))
+|    | 114|+        {
+|    | 115|+        }
+| 101| 116| 
+| 102|    |-	Base &base() { return m_base; }
+| 103|    |-	const Base &base() const { return m_base; }
+|    | 117|+        Base & base ()
+|    | 118|+        {
+|    | 119|+            return m_base;
+|    | 120|+        }
+|    | 121|+        const Base & base () const
+|    | 122|+        {
+|    | 123|+            return m_base;
+|    | 124|+        }
+| 104| 125| 
+| 105|    |-private:
+| 106|    |-	Base m_base;
+| 107|    |-};
+|    | 126|+      private:
+|    | 127|+          Base m_base;
+|    | 128|+    };
+| 108| 129| 
+| 109|    |-template <typename CharT, typename VisitorT>
+| 110|    |-void visit(VisitorT &visitor, const AST<CharT> &ast);
+|    | 130|+    template < typename CharT, typename VisitorT >
+|    | 131|+        void visit (VisitorT & visitor, const AST < CharT > &ast);
+| 111| 132| 
+| 112|    |-template <typename CharT, typename ItemT>
+| 113|    |-void print(const AST<CharT> &ast, NC::Menu<ItemT> &menu, const MPD::Song *song,
+| 114|    |-           NC::BasicBuffer<CharT> *buffer, const unsigned flags = Flags::All);
+|    | 133|+    template < typename CharT, typename ItemT >
+|    | 134|+        void print (const AST < CharT > &ast, NC::Menu < ItemT > &menu,
+|    | 135|+                    const MPD::Song * song, NC::BasicBuffer < CharT > *buffer,
+|    | 136|+                    const unsigned flags = Flags::All);
+| 115| 137| 
+| 116|    |-template <typename CharT>
+| 117|    |-void print(const AST<CharT> &ast, NC::BasicBuffer<CharT> &buffer,
+| 118|    |-           const MPD::Song *song, const unsigned flags = Flags::All);
+|    | 138|+    template < typename CharT >
+|    | 139|+        void print (const AST < CharT > &ast,
+|    | 140|+                    NC::BasicBuffer < CharT > &buffer, const MPD::Song * song,
+|    | 141|+                    const unsigned flags = Flags::All);
+| 119| 142| 
+| 120|    |-template <typename CharT>
+| 121|    |-std::basic_string<CharT> stringify(const AST<CharT> &ast, const MPD::Song *song);
+|    | 143|+    template < typename CharT >
+|    | 144|+        std::basic_string < CharT > stringify (const AST < CharT > &ast,
+|    | 145|+                                               const MPD::Song * song);
+| 122| 146| 
+| 123|    |-template <typename CharT>
+| 124|    |-TagVector<CharT> flatten(const AST<CharT> &ast, const MPD::Song &song);
+|    | 147|+    template < typename CharT >
+|    | 148|+        TagVector < CharT > flatten (const AST < CharT > &ast,
+|    | 149|+                                     const MPD::Song & song);
+| 125| 150| 
+| 126|    |-AST<char> parse(const std::string &s, const unsigned flags = Flags::All);
+| 127|    |-AST<wchar_t> parse(const std::wstring &ws, const unsigned flags = Flags::All);
+|    | 151|+    AST < char >parse (const std::string & s, const unsigned flags =
+|    | 152|+                       Flags::All);
+|    | 153|+    AST < wchar_t > parse (const std::wstring & ws, const unsigned flags =
+|    | 154|+                           Flags::All);
+| 128| 155| 
+| 129| 156| }
+| 130| 157| 
+
+src/format.h
+|  26| #include•"curses/menu.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'curses/menu.h' does not need to be #included; use a forward declaration instead
+
+src/format.h
+|  40| enum•class•ListType•{•Group,•FirstOf,•AST•};
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.h
+|    |++++| /app/src/helpers.h
+|  32|  32| #include "utility/type_conversions.h"
+|  33|  33| #include "utility/wide_string.h"
+|  34|  34| 
+|  35|    |-enum ReapplyFilter { Yes, No };
+|  36|    |-
+|  37|    |-template <typename ItemT>
+|  38|    |-struct ScopedUnfilteredMenu
+|  39|    |-{
+|  40|    |-	ScopedUnfilteredMenu(ReapplyFilter reapply_filter, NC::Menu<ItemT> &menu)
+|  41|    |-		: m_refresh(false), m_reapply_filter(reapply_filter), m_menu(menu)
+|  42|    |-	{
+|  43|    |-		m_is_filtered = m_menu.isFiltered();
+|  44|    |-		if (m_is_filtered)
+|  45|    |-			m_menu.showAllItems();
+|  46|    |-	}
+|  47|    |-
+|  48|    |-	~ScopedUnfilteredMenu()
+|  49|    |-	{
+|  50|    |-		if (m_is_filtered)
+|  51|    |-		{
+|  52|    |-			switch (m_reapply_filter)
+|  53|    |-			{
+|  54|    |-			case ReapplyFilter::Yes:
+|  55|    |-				m_menu.reapplyFilter();
+|  56|    |-				break;
+|  57|    |-			case ReapplyFilter::No:
+|  58|    |-				m_menu.showFilteredItems();
+|  59|    |-				break;
+|  60|    |-			}
+|  61|    |-		}
+|  62|    |-		if (m_refresh)
+|  63|    |-			m_menu.refresh();
+|  64|    |-	}
+|  65|    |-
+|  66|    |-	void set(ReapplyFilter reapply_filter, bool refresh)
+|  67|    |-	{
+|  68|    |-		m_reapply_filter = reapply_filter;
+|  69|    |-		m_refresh = refresh;
+|  70|    |-	}
+|  71|    |-
+|  72|    |-private:
+|  73|    |-	bool m_is_filtered;
+|  74|    |-	bool m_refresh;
+|  75|    |-	ReapplyFilter m_reapply_filter;
+|  76|    |-	NC::Menu<ItemT> &m_menu;
+|    |  35|+enum ReapplyFilter
+|    |  36|+{ Yes, No };
+|    |  37|+
+|    |  38|+template < typename ItemT > struct ScopedUnfilteredMenu
+|    |  39|+{
+|    |  40|+    ScopedUnfilteredMenu (ReapplyFilter reapply_filter,
+|    |  41|+                          NC::Menu < ItemT > &menu):m_refresh (false),
+|    |  42|+        m_reapply_filter (reapply_filter), m_menu (menu)
+|    |  43|+    {
+|    |  44|+        m_is_filtered = m_menu.isFiltered ();
+|    |  45|+        if (m_is_filtered)
+|    |  46|+            m_menu.showAllItems ();
+|    |  47|+    }
+|    |  48|+
+|    |  49|+     ~ScopedUnfilteredMenu ()
+|    |  50|+    {
+|    |  51|+        if (m_is_filtered)
+|    |  52|+          {
+|    |  53|+              switch (m_reapply_filter)
+|    |  54|+                {
+|    |  55|+                case ReapplyFilter::Yes:
+|    |  56|+                    m_menu.reapplyFilter ();
+|    |  57|+                    break;
+|    |  58|+                case ReapplyFilter::No:
+|    |  59|+                    m_menu.showFilteredItems ();
+|    |  60|+                    break;
+|    |  61|+                }
+|    |  62|+          }
+|    |  63|+        if (m_refresh)
+|    |  64|+            m_menu.refresh ();
+|    |  65|+    }
+|    |  66|+
+|    |  67|+    void set (ReapplyFilter reapply_filter, bool refresh)
+|    |  68|+    {
+|    |  69|+        m_reapply_filter = reapply_filter;
+|    |  70|+        m_refresh = refresh;
+|    |  71|+    }
+|    |  72|+
+|    |  73|+  private:
+|    |  74|+    bool m_is_filtered;
+|    |  75|+    bool m_refresh;
+|    |  76|+    ReapplyFilter m_reapply_filter;
+|    |  77|+    NC::Menu < ItemT > &m_menu;
+|  77|  78| };
+|  78|  79| 
+|  79|  80| template <typename Iterator, typename PredicateT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.h
+|    |++++| /app/src/helpers.h
+|  76|  76| 	NC::Menu<ItemT> &m_menu;
+|  77|  77| };
+|  78|  78| 
+|  79|    |-template <typename Iterator, typename PredicateT>
+|  80|    |-Iterator wrappedSearch(Iterator begin, Iterator current, Iterator end,
+|  81|    |-                       const PredicateT &pred, bool wrap, bool skip_current)
+|  82|    |-{
+|  83|    |-	if (begin == end)
+|  84|    |-	{
+|  85|    |-		assert(current == end);
+|  86|    |-		return begin;
+|  87|    |-	}
+|  88|    |-	if (skip_current)
+|  89|    |-		++current;
+|  90|    |-	auto it = std::find_if(current, end, pred);
+|  91|    |-	if (it == end && wrap)
+|  92|    |-	{
+|  93|    |-		it = std::find_if(begin, current, pred);
+|  94|    |-		if (it == current)
+|  95|    |-			it = end;
+|  96|    |-	}
+|  97|    |-	return it;
+|  98|    |-}
+|  99|    |-
+| 100|    |-template <typename ItemT, typename PredicateT>
+| 101|    |-bool search(NC::Menu<ItemT> &m, const PredicateT &pred,
+| 102|    |-                  SearchDirection direction, bool wrap, bool skip_current)
+| 103|    |-{
+| 104|    |-	bool result = false;
+| 105|    |-	if (pred.defined())
+| 106|    |-	{
+| 107|    |-		switch (direction)
+| 108|    |-		{
+| 109|    |-			case SearchDirection::Backward:
+| 110|    |-			{
+| 111|    |-				auto it = wrappedSearch(m.rbegin(), m.rcurrent(), m.rend(),
+| 112|    |-					pred, wrap, skip_current
+| 113|    |-				);
+| 114|    |-				if (it != m.rend())
+| 115|    |-				{
+| 116|    |-					m.highlight(it.base()-m.begin()-1);
+| 117|    |-					result = true;
+| 118|    |-				}
+| 119|    |-				break;
+| 120|    |-			}
+| 121|    |-			case SearchDirection::Forward:
+| 122|    |-			{
+| 123|    |-				auto it = wrappedSearch(m.begin(), m.current(), m.end(),
+| 124|    |-					pred, wrap, skip_current
+| 125|    |-				);
+| 126|    |-				if (it != m.end())
+| 127|    |-				{
+| 128|    |-					m.highlight(it-m.begin());
+| 129|    |-					result = true;
+| 130|    |-				}
+| 131|    |-			}
+| 132|    |-		}
+| 133|    |-	}
+| 134|    |-	return result;
+| 135|    |-}
+| 136|    |-
+| 137|    |-template <typename Iterator>
+| 138|    |-bool hasSelected(Iterator first, Iterator last)
+| 139|    |-{
+| 140|    |-	for (; first != last; ++first)
+| 141|    |-		if (first->isSelected())
+| 142|    |-			return true;
+| 143|    |-	return false;
+| 144|    |-}
+| 145|    |-
+| 146|    |-template <typename Iterator>
+| 147|    |-std::vector<Iterator> getSelected(Iterator first, Iterator last)
+| 148|    |-{
+| 149|    |-	std::vector<Iterator> result;
+| 150|    |-	for (; first != last; ++first)
+| 151|    |-		if (first->isSelected())
+| 152|    |-			result.push_back(first);
+| 153|    |-	return result;
+|    |  79|+template < typename Iterator, typename PredicateT >
+|    |  80|+    Iterator wrappedSearch (Iterator begin, Iterator current, Iterator end,
+|    |  81|+                            const PredicateT & pred, bool wrap,
+|    |  82|+                            bool skip_current)
+|    |  83|+{
+|    |  84|+    if (begin == end)
+|    |  85|+      {
+|    |  86|+          assert (current == end);
+|    |  87|+          return begin;
+|    |  88|+      }
+|    |  89|+    if (skip_current)
+|    |  90|+        ++current;
+|    |  91|+    auto it = std::find_if (current, end, pred);
+|    |  92|+    if (it == end && wrap)
+|    |  93|+      {
+|    |  94|+          it = std::find_if (begin, current, pred);
+|    |  95|+          if (it == current)
+|    |  96|+              it = end;
+|    |  97|+      }
+|    |  98|+    return it;
+|    |  99|+}
+|    | 100|+
+|    | 101|+template < typename ItemT, typename PredicateT >
+|    | 102|+    bool search (NC::Menu < ItemT > &m, const PredicateT & pred,
+|    | 103|+                 SearchDirection direction, bool wrap, bool skip_current)
+|    | 104|+{
+|    | 105|+    bool result = false;
+|    | 106|+    if (pred.defined ())
+|    | 107|+      {
+|    | 108|+          switch (direction)
+|    | 109|+            {
+|    | 110|+            case SearchDirection::Backward:
+|    | 111|+                {
+|    | 112|+                    auto it =
+|    | 113|+                        wrappedSearch (m.rbegin (), m.rcurrent (), m.rend (),
+|    | 114|+                                       pred, wrap, skip_current);
+|    | 115|+                    if (it != m.rend ())
+|    | 116|+                      {
+|    | 117|+                          m.highlight (it.base () - m.begin () - 1);
+|    | 118|+                          result = true;
+|    | 119|+                      }
+|    | 120|+                    break;
+|    | 121|+                }
+|    | 122|+            case SearchDirection::Forward:
+|    | 123|+                {
+|    | 124|+                    auto it =
+|    | 125|+                        wrappedSearch (m.begin (), m.current (), m.end (),
+|    | 126|+                                       pred, wrap, skip_current);
+|    | 127|+                    if (it != m.end ())
+|    | 128|+                      {
+|    | 129|+                          m.highlight (it - m.begin ());
+|    | 130|+                          result = true;
+|    | 131|+                      }
+|    | 132|+                }
+|    | 133|+            }
+|    | 134|+      }
+|    | 135|+    return result;
+|    | 136|+}
+|    | 137|+
+|    | 138|+template < typename Iterator > bool hasSelected (Iterator first, Iterator last)
+|    | 139|+{
+|    | 140|+    for (; first != last; ++first)
+|    | 141|+        if (first->isSelected ())
+|    | 142|+            return true;
+|    | 143|+    return false;
+|    | 144|+}
+|    | 145|+
+|    | 146|+template < typename Iterator >
+|    | 147|+    std::vector < Iterator > getSelected (Iterator first, Iterator last)
+|    | 148|+{
+|    | 149|+    std::vector < Iterator > result;
+|    | 150|+    for (; first != last; ++first)
+|    | 151|+        if (first->isSelected ())
+|    | 152|+            result.push_back (first);
+|    | 153|+    return result;
+| 154| 154| }
+| 155| 155| 
+| 156| 156| /// @return true if range that begins and ends with selected items was
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.h
+|    |++++| /app/src/helpers.h
+| 156| 156| /// @return true if range that begins and ends with selected items was
+| 157| 157| /// found, false when there is no selected items (in which case first
+| 158| 158| /// == last).
+| 159|    |-template <typename Iterator>
+| 160|    |-bool findRange(Iterator &first, Iterator &last)
+| 161|    |-{
+| 162|    |-	for (; first != last; ++first)
+| 163|    |-	{
+| 164|    |-		if (first->isSelected())
+| 165|    |-			break;
+| 166|    |-	}
+| 167|    |-	if (first == last)
+| 168|    |-		return false;
+| 169|    |-	--last;
+| 170|    |-	for (; first != last; --last)
+| 171|    |-	{
+| 172|    |-		if (last->isSelected())
+| 173|    |-			break;
+| 174|    |-	}
+| 175|    |-	++last;
+| 176|    |-	return true;
+|    | 159|+template < typename Iterator >
+|    | 160|+    bool findRange (Iterator & first, Iterator & last)
+|    | 161|+{
+|    | 162|+    for (; first != last; ++first)
+|    | 163|+      {
+|    | 164|+          if (first->isSelected ())
+|    | 165|+              break;
+|    | 166|+      }
+|    | 167|+    if (first == last)
+|    | 168|+        return false;
+|    | 169|+    --last;
+|    | 170|+    for (; first != last; --last)
+|    | 171|+      {
+|    | 172|+          if (last->isSelected ())
+|    | 173|+              break;
+|    | 174|+      }
+|    | 175|+    ++last;
+|    | 176|+    return true;
+| 177| 177| }
+| 178| 178| 
+| 179| 179| /// @return true if fully selected range was found or no selected
+
+src/helpers.h
+|  24| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'interfaces.h' does not need to be #included
+
+src/helpers.h
+|  26| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'screens/playlist.h' does not need to be #included
+
+src/helpers.h
+|  27| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'screens/screen.h' does not need to be #included; use a forward declaration instead
+
+src/helpers.h
+|  28| #include•"settings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'settings.h' does not need to be #included
+
+src/helpers.h
+|  30| #include•"status.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'status.h' does not need to be #included
+
+src/helpers.h
+|  32| #include•"utility/type_conversions.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'utility/type_conversions.h' does not need to be #included
+
+src/helpers.h
+|  33| #include•"utility/wide_string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'utility/wide_string.h' does not need to be #included
+
+src/helpers.h
+|  27| #include•"screens/screen.h"
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  25|  25| #include <utility>
+|  26|  26| 
+|  27|  27| /// Map over the first element in range satisfying the predicate.
+|  28|    |-template <typename InputIterator, typename PredicateT, typename MapT>
+|  29|    |-InputIterator find_map_first(InputIterator first, InputIterator last, PredicateT &&p, MapT &&f)
+|    |  28|+template < typename InputIterator, typename PredicateT, typename MapT >
+|    |  29|+    InputIterator find_map_first (InputIterator first, InputIterator last,
+|    |  30|+                                  PredicateT && p, MapT && f)
+|  30|  31| {
+|  31|    |-	auto it = std::find(first, last, std::forward<PredicateT>(p));
+|  32|    |-	if (it != last)
+|  33|    |-		f(*it);
+|  34|    |-	return it;
+|    |  32|+    auto it = std::find (first, last, std::forward < PredicateT > (p));
+|    |  33|+    if (it != last)
+|    |  34|+        f (*it);
+|    |  35|+    return it;
+|  35|  36| }
+|  36|  37| 
+|  37|  38| /// Map over all elements in range satisfying the predicate.
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  35|  35| }
+|  36|  36| 
+|  37|  37| /// Map over all elements in range satisfying the predicate.
+|  38|    |-template <typename InputIterator, typename PredicateT, typename MapT>
+|  39|    |-void find_map_all(InputIterator first, InputIterator last, PredicateT &&p, MapT &&f)
+|    |  38|+template < typename InputIterator, typename PredicateT, typename MapT > void
+|    |  39|+find_map_all (InputIterator first, InputIterator last, PredicateT && p, MapT
+|    |  40|+              && f)
+|  40|  41| {
+|  41|    |-	InputIterator it = first;
+|  42|    |-	do
+|  43|    |-		it = find_map_first(it, last, p, f);
+|  44|    |-	while (it != last);
+|    |  42|+    InputIterator it = first;
+|    |  43|+    do
+|    |  44|+        it = find_map_first (it, last, p, f);
+|    |  45|+    while (it != last);
+|  45|  46| }
+|  46|  47| 
+|  47|  48| // convert string to appropriate type
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  45|  45| }
+|  46|  46| 
+|  47|  47| // convert string to appropriate type
+|  48|    |-template <typename TargetT, typename SourceT>
+|  49|    |-struct convertString
+|    |  48|+template < typename TargetT, typename SourceT > struct convertString
+|  50|  49| {
+|  51|    |-	static std::basic_string<TargetT> apply(const std::basic_string<SourceT> &s)
+|  52|    |-	{
+|  53|    |-		return boost::locale::conv::utf_to_utf<TargetT>(s);
+|  54|    |-	}
+|    |  50|+    static std::basic_string < TargetT > apply (const std::basic_string <
+|    |  51|+                                                SourceT > &s)
+|    |  52|+    {
+|    |  53|+        return boost::locale::conv::utf_to_utf < TargetT > (s);
+|    |  54|+    }
+|  55|  55| };
+|  56|    |-template <typename TargetT>
+|  57|    |-struct convertString<TargetT, TargetT>
+|    |  56|+template < typename TargetT > struct convertString <TargetT, TargetT >
+|  58|  57| {
+|  59|    |-	static const std::basic_string<TargetT> &apply(const std::basic_string<TargetT> &s)
+|  60|    |-	{
+|  61|    |-		return s;
+|  62|    |-	}
+|    |  58|+    static const std::basic_string < TargetT >
+|    |  59|+        &apply (const std::basic_string < TargetT > &s)
+|    |  60|+    {
+|    |  61|+        return s;
+|    |  62|+    }
+|  63|  63| };
+|  64|  64| 
+|  65|  65| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/functional.h
+|    |++++| /app/src/utility/functional.h
+|  62|  62| 	}
+|  63|  63| };
+|  64|  64| 
+|  65|    |-
+|  66|  65| #endif // NCMPCPP_UTILITY_FUNCTIONAL_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/lastfm_service.h
+|    |++++| /app/src/lastfm_service.h
+|  28|  28| 
+|  29|  29| #include "curses/scrollpad.h"
+|  30|  30| 
+|  31|    |-namespace LastFm {
+|    |  31|+namespace LastFm
+|    |  32|+{
+|  32|  33| 
+|  33|    |-struct Service
+|  34|    |-{
+|  35|    |-	typedef std::map<std::string, std::string> Arguments;
+|  36|    |-	typedef std::pair<bool, std::string> Result;
+|  37|    |-	
+|  38|    |-	Service(Arguments args) : m_arguments(args) { }
+|    |  34|+    struct Service
+|    |  35|+    {
+|    |  36|+        typedef std::map < std::string, std::string > Arguments;
+|    |  37|+        typedef std::pair < bool, std::string > Result;
+|  39|  38| 
+|  40|    |-	virtual const char *name() = 0;
+|  41|    |-	virtual Result fetch();
+|  42|    |-	
+|  43|    |-	virtual void beautifyOutput(NC::Scrollpad &w) = 0;
+|  44|    |-	
+|  45|    |-protected:
+|  46|    |-	virtual bool argumentsOk() = 0;
+|  47|    |-	virtual bool actionFailed(const std::string &data);
+|  48|    |-	
+|  49|    |-	virtual Result processData(const std::string &data) = 0;
+|  50|    |-	
+|  51|    |-	virtual const char *methodName() = 0;
+|  52|    |-	
+|  53|    |-	Arguments m_arguments;
+|  54|    |-};
+|    |  39|+          Service (Arguments args):m_arguments (args)
+|    |  40|+        {
+|    |  41|+        }
+|  55|  42| 
+|  56|    |-struct ArtistInfo : public Service
+|  57|    |-{
+|  58|    |-	ArtistInfo(std::string artist, std::string lang)
+|  59|    |-	: Service({{"artist", artist}, {"lang", lang}}) { }
+|  60|    |-	
+|  61|    |-	virtual const char *name() { return "Artist info"; }
+|  62|    |-	
+|  63|    |-	virtual void beautifyOutput(NC::Scrollpad &w);
+|  64|    |-	
+|  65|    |-	bool operator==(const ArtistInfo &ai) const { return m_arguments == ai.m_arguments; }
+|  66|    |-	
+|  67|    |-protected:
+|  68|    |-	virtual bool argumentsOk();
+|  69|    |-	virtual Result processData(const std::string &data);
+|  70|    |-	
+|  71|    |-	virtual const char *methodName() { return "artist.getinfo"; }
+|  72|    |-};
+|    |  43|+        virtual const char *name () = 0;
+|    |  44|+        virtual Result fetch ();
+|    |  45|+
+|    |  46|+        virtual void beautifyOutput (NC::Scrollpad & w) = 0;
+|    |  47|+
+|    |  48|+      protected:
+|    |  49|+          virtual bool argumentsOk () = 0;
+|    |  50|+        virtual bool actionFailed (const std::string & data);
+|    |  51|+
+|    |  52|+        virtual Result processData (const std::string & data) = 0;
+|    |  53|+
+|    |  54|+        virtual const char *methodName () = 0;
+|    |  55|+
+|    |  56|+        Arguments m_arguments;
+|    |  57|+    };
+|    |  58|+
+|    |  59|+    struct ArtistInfo:public Service
+|    |  60|+    {
+|    |  61|+        ArtistInfo (std::string artist, std::string lang):Service (
+|    |  62|+                                                                      {
+|    |  63|+                                                                      {
+|    |  64|+                                                                      "artist",
+|    |  65|+                                                                      artist},
+|    |  66|+                                                                      {
+|    |  67|+                                                                      "lang",
+|    |  68|+                                                                      lang}})
+|    |  69|+        {
+|    |  70|+        }
+|    |  71|+
+|    |  72|+        virtual const char *name ()
+|    |  73|+        {
+|    |  74|+            return "Artist info";
+|    |  75|+        }
+|    |  76|+
+|    |  77|+        virtual void beautifyOutput (NC::Scrollpad & w);
+|    |  78|+
+|    |  79|+        bool operator== (const ArtistInfo & ai) const
+|    |  80|+        {
+|    |  81|+            return m_arguments == ai.m_arguments;
+|    |  82|+        }
+|    |  83|+
+|    |  84|+      protected:
+|    |  85|+          virtual bool argumentsOk ();
+|    |  86|+        virtual Result processData (const std::string & data);
+|    |  87|+
+|    |  88|+        virtual const char *methodName ()
+|    |  89|+        {
+|    |  90|+            return "artist.getinfo";
+|    |  91|+        }
+|    |  92|+    };
+|  73|  93| 
+|  74|  94| }
+|  75|  95| 
+
+src/lastfm_service.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/lastfm_service.h
+|  29| #include•"curses/scrollpad.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'curses/scrollpad.h' does not need to be #included; use a forward declaration instead
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/title.h
+|    |++++| /app/src/title.h
+|  23|  23| 
+|  24|  24| #include "curses/window.h"
+|  25|  25| 
+|  26|    |-void windowTitle(const std::string &title);
+|    |  26|+void windowTitle (const std::string & title);
+|  27|  27| 
+|  28|    |-void drawHeader();
+|    |  28|+void drawHeader ();
+|  29|  29| 
+|  30|  30| #endif // NCMPCPP_TITLE_H
+
+src/title.h
+|  24| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'curses/window.h' does not need to be #included
+
+src/title.h
+| 196| The line belonging to the following result cannot be printed because it refers to a line that doesn't seem to exist in the given file.
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.h
+|    |++++| /app/src/screens/lastfm.h
+|  31|  31| #include "screens/screen.h"
+|  32|  32| #include "utility/wide_string.h"
+|  33|  33| 
+|  34|    |-struct Lastfm: Screen<NC::Scrollpad>, Tabbable
+|    |  34|+struct Lastfm:Screen <
+|    |  35|+    NC::Scrollpad >,
+|    |  36|+    Tabbable
+|  35|  37| {
+|  36|    |-	Lastfm();
+|  37|    |-	
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	
+|  41|    |-	virtual std::wstring title() override;
+|  42|    |-	virtual ScreenType type() override { return ScreenType::Lastfm; }
+|  43|    |-	
+|  44|    |-	virtual void update() override;
+|  45|    |-	
+|  46|    |-	virtual bool isLockable() override { return true; }
+|  47|    |-	virtual bool isMergable() override { return true; }
+|  48|    |-	
+|  49|    |-	template <typename ServiceT>
+|  50|    |-	void queueJob(ServiceT *service)
+|  51|    |-	{
+|  52|    |-		auto old_service = dynamic_cast<ServiceT *>(m_service.get());
+|  53|    |-		// if the same service and arguments were used, leave old info
+|  54|    |-		if (old_service != nullptr && *old_service == *service)
+|  55|    |-			return;
+|    |  38|+    Lastfm ();
+|  56|  39| 
+|  57|    |-		m_service = std::shared_ptr<ServiceT>(service);
+|  58|    |-		m_worker = boost::async(
+|  59|    |-			boost::launch::async,
+|  60|    |-			std::bind(&LastFm::Service::fetch, m_service));
+|    |  40|+    virtual void
+|    |  41|+    switchTo ()
+|    |  42|+        override;
+|    |  43|+    virtual void
+|    |  44|+    resize ()
+|    |  45|+        override;
+|  61|  46| 
+|  62|    |-		w.clear();
+|  63|    |-		w << "Fetching information...";
+|  64|    |-		m_refresh_window = true;
+|  65|    |-		m_title = ToWString(m_service->name());
+|  66|    |-	}
+|    |  47|+    virtual
+|    |  48|+        std::wstring
+|    |  49|+    title ()
+|    |  50|+        override;
+|    |  51|+    virtual ScreenType
+|    |  52|+    type ()
+|    |  53|+        override
+|    |  54|+    {
+|    |  55|+        return ScreenType::Lastfm;
+|    |  56|+    }
+|  67|  57| 
+|  68|    |-private:
+|  69|    |-	std::wstring m_title;
+|  70|    |-	bool m_refresh_window;
+|  71|    |-	
+|  72|    |-	std::shared_ptr<LastFm::Service> m_service;
+|  73|    |-	boost::BOOST_THREAD_FUTURE<LastFm::Service::Result> m_worker;
+|    |  58|+    virtual void
+|    |  59|+    update ()
+|    |  60|+        override;
+|    |  61|+
+|    |  62|+    virtual bool
+|    |  63|+    isLockable ()
+|    |  64|+        override
+|    |  65|+    {
+|    |  66|+        return true;
+|    |  67|+    }
+|    |  68|+    virtual bool
+|    |  69|+    isMergable ()
+|    |  70|+        override
+|    |  71|+    {
+|    |  72|+        return true;
+|    |  73|+    }
+|    |  74|+
+|    |  75|+    template < typename ServiceT > void
+|    |  76|+    queueJob (ServiceT * service)
+|    |  77|+    {
+|    |  78|+        auto
+|    |  79|+            old_service = dynamic_cast < ServiceT * >(m_service.get ());
+|    |  80|+        // if the same service and arguments were used, leave old info
+|    |  81|+        if (old_service != nullptr && *old_service == *service)
+|    |  82|+            return;
+|    |  83|+
+|    |  84|+        m_service = std::shared_ptr < ServiceT > (service);
+|    |  85|+        m_worker = boost::async (boost::launch::async,
+|    |  86|+                                 std::bind (&LastFm::Service::fetch,
+|    |  87|+                                            m_service));
+|    |  88|+
+|    |  89|+        w.clear ();
+|    |  90|+        w << "Fetching information...";
+|    |  91|+        m_refresh_window = true;
+|    |  92|+        m_title = ToWString (m_service->name ());
+|    |  93|+    }
+|    |  94|+
+|    |  95|+  private:
+|    |  96|+    std::wstring m_title;
+|    |  97|+    bool
+|    |  98|+        m_refresh_window;
+|    |  99|+
+|    | 100|+    std::shared_ptr < LastFm::Service > m_service;
+|    | 101|+    boost::BOOST_THREAD_FUTURE < LastFm::Service::Result > m_worker;
+|  74| 102| };
+|  75| 103| 
+|  76| 104| extern Lastfm *myLastfm;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.h
+|    |++++| /app/src/screens/lastfm.h
+|  73|  73| 	boost::BOOST_THREAD_FUTURE<LastFm::Service::Result> m_worker;
+|  74|  74| };
+|  75|  75| 
+|  76|    |-extern Lastfm *myLastfm;
+|    |  76|+extern Lastfm *
+|    |  77|+    myLastfm;
+|  77|  78| 
+|  78|  79| #endif // NCMPCPP_LASTFM_H
+
+src/screens/lastfm.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/lastfm.h
+|  29| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/lastfm.h
+|  30| #include•"lastfm_service.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'lastfm_service.h'
+
+src/screens/lastfm.h
+|  31| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/lastfm.h
+|  32| #include•"utility/wide_string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/wide_string.h'
+
+src/screens/lastfm.h
+|  76| extern•Lastfm•*myLastfm;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myLastfm'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.cpp
+|    |++++| /app/src/utility/option_parser.cpp
+|  35|  35| 
+|  36|  36| #include "utility/option_parser.h"
+|  37|  37| 
+|  38|    |-bool yes_no(const std::string &v)
+|    |  38|+bool
+|    |  39|+yes_no (const std::string & v)
+|  39|  40| {
+|  40|    |-	if (v == "yes")
+|  41|    |-		return true;
+|  42|    |-	else if (v == "no")
+|  43|    |-		return false;
+|  44|    |-	else
+|  45|    |-		invalid_value(v);
+|    |  41|+    if (v == "yes")
+|    |  42|+        return true;
+|    |  43|+    else if (v == "no")
+|    |  44|+        return false;
+|    |  45|+    else
+|    |  46|+        invalid_value (v);
+|  46|  47| }
+|  47|  48| 
+|  48|  49| ////////////////////////////////////////////////////////////////////////////////
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.cpp
+|    |++++| /app/src/utility/option_parser.cpp
+|  47|  47| 
+|  48|  48| ////////////////////////////////////////////////////////////////////////////////
+|  49|  49| 
+|  50|    |-bool option_parser::run(std::istream &is, bool ignore_errors)
+|    |  50|+bool
+|    |  51|+option_parser::run (std::istream & is, bool ignore_errors)
+|  51|  52| {
+|  52|    |-	// quoted value. leftmost and rightmost quotation marks are the delimiters.
+|  53|    |-	boost::regex quoted("(\\w+)\\h*=\\h*\"(.*)\"[^\"]*");
+|  54|    |-	// unquoted value. whitespaces get trimmed.
+|  55|    |-	boost::regex unquoted("(\\w+)\\h*=\\h*(.*?)\\h*");
+|  56|    |-	boost::smatch match;
+|  57|    |-	std::string line;
+|  58|    |-	while (std::getline(is, line))
+|  59|    |-	{
+|  60|    |-		if (boost::regex_match(line, match, quoted)
+|  61|    |-		||  boost::regex_match(line, match, unquoted))
+|  62|    |-		{
+|  63|    |-			std::string option = match[1];
+|  64|    |-			auto it = m_parsers.find(option);
+|  65|    |-			if (it != m_parsers.end())
+|  66|    |-			{
+|  67|    |-				try
+|  68|    |-				{
+|  69|    |-					it->second.parse(match[2]);
+|  70|    |-				}
+|  71|    |-				catch (std::exception &e)
+|  72|    |-				{
+|  73|    |-					std::cerr << "Error while processing option \"" << option
+|  74|    |-					          << "\": " << e.what() << "\n";
+|  75|    |-					if (!ignore_errors)
+|  76|    |-						return false;
+|  77|    |-				}
+|  78|    |-			}
+|  79|    |-			else
+|  80|    |-			{
+|  81|    |-				std::cerr << "Unknown option: " << option << "\n";
+|  82|    |-				if (!ignore_errors)
+|  83|    |-					return false;
+|  84|    |-			}
+|  85|    |-		}
+|  86|    |-	}
+|  87|    |-	return true;
+|    |  53|+    // quoted value. leftmost and rightmost quotation marks are the delimiters.
+|    |  54|+    boost::regex quoted ("(\\w+)\\h*=\\h*\"(.*)\"[^\"]*");
+|    |  55|+    // unquoted value. whitespaces get trimmed.
+|    |  56|+    boost::regex unquoted ("(\\w+)\\h*=\\h*(.*?)\\h*");
+|    |  57|+    boost::smatch match;
+|    |  58|+    std::string line;
+|    |  59|+    while (std::getline (is, line))
+|    |  60|+      {
+|    |  61|+          if (boost::regex_match (line, match, quoted)
+|    |  62|+              || boost::regex_match (line, match, unquoted))
+|    |  63|+            {
+|    |  64|+                std::string option = match[1];
+|    |  65|+                auto it = m_parsers.find (option);
+|    |  66|+                if (it != m_parsers.end ())
+|    |  67|+                  {
+|    |  68|+                      try
+|    |  69|+                      {
+|    |  70|+                          it->second.parse (match[2]);
+|    |  71|+                      }
+|    |  72|+                      catch (std::exception & e)
+|    |  73|+                      {
+|    |  74|+                          std::
+|    |  75|+                              cerr << "Error while processing option \"" <<
+|    |  76|+                              option << "\": " << e.what () << "\n";
+|    |  77|+                          if (!ignore_errors)
+|    |  78|+                              return false;
+|    |  79|+                      }
+|    |  80|+                  }
+|    |  81|+                else
+|    |  82|+                  {
+|    |  83|+                      std::cerr << "Unknown option: " << option << "\n";
+|    |  84|+                      if (!ignore_errors)
+|    |  85|+                          return false;
+|    |  86|+                  }
+|    |  87|+            }
+|    |  88|+      }
+|    |  89|+    return true;
+|  88|  90| }
+|  89|  91| 
+|  90|  92| bool option_parser::initialize_undefined(bool ignore_errors)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/option_parser.cpp
+|    |++++| /app/src/utility/option_parser.cpp
+|  87|  87| 	return true;
+|  88|  88| }
+|  89|  89| 
+|  90|    |-bool option_parser::initialize_undefined(bool ignore_errors)
+|    |  90|+bool
+|    |  91|+option_parser::initialize_undefined (bool ignore_errors)
+|  91|  92| {
+|  92|    |-	for (auto &pp : m_parsers)
+|  93|    |-	{
+|  94|    |-		auto &p = pp.second;
+|  95|    |-		if (!p.used())
+|  96|    |-		{
+|  97|    |-			try
+|  98|    |-			{
+|  99|    |-				p.parse_default();
+| 100|    |-			}
+| 101|    |-			catch (std::exception &e)
+| 102|    |-			{
+| 103|    |-				std::cerr << "Error while initializing option \"" << pp.first
+| 104|    |-				          << "\": " << e.what() << "\n";
+| 105|    |-				if (ignore_errors)
+| 106|    |-					return false;
+| 107|    |-			}
+| 108|    |-		}
+| 109|    |-	}
+| 110|    |-	return true;
+|    |  93|+  for (auto & pp:m_parsers)
+|    |  94|+      {
+|    |  95|+          auto & p = pp.second;
+|    |  96|+          if (!p.used ())
+|    |  97|+            {
+|    |  98|+                try
+|    |  99|+                {
+|    | 100|+                    p.parse_default ();
+|    | 101|+                }
+|    | 102|+                catch (std::exception & e)
+|    | 103|+                {
+|    | 104|+                    std::cerr << "Error while initializing option \"" << pp.
+|    | 105|+                        first << "\": " << e.what () << "\n";
+|    | 106|+                    if (ignore_errors)
+|    | 107|+                        return false;
+|    | 108|+                }
+|    | 109|+            }
+|    | 110|+      }
+|    | 111|+    return true;
+| 111| 112| }
+
+src/utility/option_parser.cpp
+|  36| #include•"utility/option_parser.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/option_parser.h'
+
+src/utility/option_parser.cpp
+|  38| bool•yes_no(const•std::string•&v)
+|    | [NORMAL] CPPCleanBear:
+|    | 'yes_no' not found in any directly #included header
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+|  28|  28| #include "screens/screen.h"
+|  29|  29| #include "song_list.h"
+|  30|  30| 
+|  31|    |-struct MediaLibrary: Screen<NC::Window *>, Filterable, HasColumns, HasSongs, Searchable, Tabbable
+|    |  31|+struct MediaLibrary:Screen <
+|    |  32|+NC::Window * >,
+|    |  33|+    Filterable,
+|    |  34|+    HasColumns,
+|    |  35|+    HasSongs,
+|    |  36|+    Searchable,
+|    |  37|+    Tabbable
+|  32|  38| {
+|  33|    |-	MediaLibrary();
+|  34|    |-	
+|  35|    |-	virtual void switchTo() override;
+|  36|    |-	virtual void resize() override;
+|  37|    |-	
+|  38|    |-	virtual std::wstring title() override;
+|  39|    |-	virtual ScreenType type() override { return ScreenType::MediaLibrary; }
+|  40|    |-	
+|  41|    |-	virtual void refresh() override;
+|  42|    |-	virtual void update() override;
+|  43|    |-	
+|  44|    |-	virtual int windowTimeout() override;
+|  45|    |-
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// Searchable implementation
+|  52|    |-	virtual bool allowsSearching() override;
+|  53|    |-	virtual const std::string &searchConstraint() override;
+|  54|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  55|    |-	virtual void clearSearchConstraint() override;
+|  56|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|  57|    |-
+|  58|    |-	// Filterable implementation
+|  59|    |-	virtual bool allowsFiltering() override;
+|  60|    |-	virtual std::string currentFilter() override;
+|  61|    |-	virtual void applyFilter(const std::string &filter) override;
+|  62|    |-
+|  63|    |-	// HasSongs implementation
+|  64|    |-	virtual bool itemAvailable() override;
+|  65|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  66|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  67|    |-	
+|  68|    |-	// HasColumns implementation
+|  69|    |-	virtual bool previousColumnAvailable() override;
+|  70|    |-	virtual void previousColumn() override;
+|  71|    |-	
+|  72|    |-	virtual bool nextColumnAvailable() override;
+|  73|    |-	virtual void nextColumn() override;
+|  74|    |-	
+|  75|    |-	// other members
+|  76|    |-	void updateTimer();
+|  77|    |-	void toggleColumnsMode();
+|  78|    |-	int columns();
+|  79|    |-	void locateSong(const MPD::Song &s);
+|  80|    |-	void toggleSortMode();
+|  81|    |-	
+|  82|    |-	void requestTagsUpdate() { m_tags_update_request = true; }
+|  83|    |-	void requestAlbumsUpdate() { m_albums_update_request = true; }
+|  84|    |-	void requestSongsUpdate() { m_songs_update_request = true; }
+|  85|    |-	
+|  86|    |-	struct PrimaryTag
+|  87|    |-	{
+|  88|    |-		PrimaryTag() : m_mtime(0) { }
+|  89|    |-		PrimaryTag(std::string tag_, time_t mtime_)
+|  90|    |-		: m_tag(std::move(tag_)), m_mtime(mtime_) { }
+|  91|    |-		
+|  92|    |-		const std::string &tag() const { return m_tag; }
+|  93|    |-		time_t mtime() const { return m_mtime; }
+|  94|    |-		
+|  95|    |-	private:
+|  96|    |-		std::string m_tag;
+|  97|    |-		time_t m_mtime;
+|  98|    |-	};
+|  99|    |-	
+| 100|    |-	struct Album
+| 101|    |-	{
+| 102|    |-		Album(std::string tag_, std::string album_, std::string date_, time_t mtime_)
+| 103|    |-		: m_tag(std::move(tag_)), m_album(std::move(album_))
+| 104|    |-		, m_date(std::move(date_)), m_mtime(mtime_) { }
+| 105|    |-		
+| 106|    |-		const std::string &tag() const { return m_tag; }
+| 107|    |-		const std::string &album() const { return m_album; }
+| 108|    |-		const std::string &date() const { return m_date; }
+| 109|    |-		time_t mtime() const { return m_mtime; }
+| 110|    |-		
+| 111|    |-	private:
+| 112|    |-		std::string m_tag;
+| 113|    |-		std::string m_album;
+| 114|    |-		std::string m_date;
+| 115|    |-		time_t m_mtime;
+| 116|    |-	};
+| 117|    |-	
+| 118|    |-	struct AlbumEntry
+| 119|    |-	{
+| 120|    |-		AlbumEntry() : m_all_tracks_entry(false), m_album("", "", "", 0) { }
+| 121|    |-		explicit AlbumEntry(Album album_) : m_all_tracks_entry(false), m_album(album_) { }
+| 122|    |-		
+| 123|    |-		const Album &entry() const { return m_album; }
+| 124|    |-		bool isAllTracksEntry() const { return m_all_tracks_entry; }
+| 125|    |-		
+| 126|    |-		static AlbumEntry mkAllTracksEntry(std::string tag) {
+| 127|    |-			auto result = AlbumEntry(Album(tag, "", "", 0));
+| 128|    |-			result.m_all_tracks_entry = true;
+| 129|    |-			return result;
+| 130|    |-		}
+| 131|    |-		
+| 132|    |-	private:
+| 133|    |-		bool m_all_tracks_entry;
+| 134|    |-		Album m_album;
+| 135|    |-	};
+| 136|    |-	
+| 137|    |-	NC::Menu<PrimaryTag> Tags;
+| 138|    |-	NC::Menu<AlbumEntry> Albums;
+| 139|    |-	SongMenu Songs;
+| 140|    |-	
+| 141|    |-private:
+| 142|    |-	bool m_tags_update_request;
+| 143|    |-	bool m_albums_update_request;
+| 144|    |-	bool m_songs_update_request;
+| 145|    |-
+| 146|    |-	boost::posix_time::ptime m_timer;
+| 147|    |-
+| 148|    |-	const int m_window_timeout;
+| 149|    |-	const boost::posix_time::time_duration m_fetching_delay;
+| 150|    |-
+| 151|    |-	Regex::Filter<PrimaryTag> m_tags_search_predicate;
+| 152|    |-	Regex::ItemFilter<AlbumEntry> m_albums_search_predicate;
+| 153|    |-	Regex::Filter<MPD::Song> m_songs_search_predicate;
+|    |  39|+    MediaLibrary ();
+|    |  40|+
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|    |  47|+
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::MediaLibrary;
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    virtual void
+|    |  60|+    refresh ()
+|    |  61|+        override;
+|    |  62|+    virtual void
+|    |  63|+    update ()
+|    |  64|+        override;
+|    |  65|+
+|    |  66|+    virtual int
+|    |  67|+    windowTimeout ()
+|    |  68|+        override;
+|    |  69|+
+|    |  70|+    virtual void
+|    |  71|+    mouseButtonPressed (MEVENT me)
+|    |  72|+        override;
+|    |  73|+
+|    |  74|+    virtual bool
+|    |  75|+    isLockable ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return true;
+|    |  79|+    }
+|    |  80|+    virtual bool
+|    |  81|+    isMergable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|    |  86|+
+|    |  87|+    // Searchable implementation
+|    |  88|+    virtual bool
+|    |  89|+    allowsSearching ()
+|    |  90|+        override;
+|    |  91|+    virtual const
+|    |  92|+        std::string &
+|    |  93|+    searchConstraint ()
+|    |  94|+        override;
+|    |  95|+    virtual void
+|    |  96|+    setSearchConstraint (const std::string & constraint)
+|    |  97|+        override;
+|    |  98|+    virtual void
+|    |  99|+    clearSearchConstraint ()
+|    | 100|+        override;
+|    | 101|+    virtual bool
+|    | 102|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 103|+        override;
+|    | 104|+
+|    | 105|+    // Filterable implementation
+|    | 106|+    virtual bool
+|    | 107|+    allowsFiltering ()
+|    | 108|+        override;
+|    | 109|+    virtual
+|    | 110|+        std::string
+|    | 111|+    currentFilter ()
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    applyFilter (const std::string & filter)
+|    | 115|+        override;
+|    | 116|+
+|    | 117|+    // HasSongs implementation
+|    | 118|+    virtual bool
+|    | 119|+    itemAvailable ()
+|    | 120|+        override;
+|    | 121|+    virtual bool
+|    | 122|+    addItemToPlaylist (bool play)
+|    | 123|+        override;
+|    | 124|+    virtual
+|    | 125|+        std::vector <
+|    | 126|+        MPD::Song >
+|    | 127|+    getSelectedSongs ()
+|    | 128|+        override;
+|    | 129|+
+|    | 130|+    // HasColumns implementation
+|    | 131|+    virtual bool
+|    | 132|+    previousColumnAvailable ()
+|    | 133|+        override;
+|    | 134|+    virtual void
+|    | 135|+    previousColumn ()
+|    | 136|+        override;
+|    | 137|+
+|    | 138|+    virtual bool
+|    | 139|+    nextColumnAvailable ()
+|    | 140|+        override;
+|    | 141|+    virtual void
+|    | 142|+    nextColumn ()
+|    | 143|+        override;
+|    | 144|+
+|    | 145|+    // other members
+|    | 146|+    void
+|    | 147|+    updateTimer ();
+|    | 148|+    void
+|    | 149|+    toggleColumnsMode ();
+|    | 150|+    int
+|    | 151|+    columns ();
+|    | 152|+    void
+|    | 153|+    locateSong (const MPD::Song & s);
+|    | 154|+    void
+|    | 155|+    toggleSortMode ();
+|    | 156|+
+|    | 157|+    void
+|    | 158|+    requestTagsUpdate ()
+|    | 159|+    {
+|    | 160|+        m_tags_update_request = true;
+|    | 161|+    }
+|    | 162|+    void
+|    | 163|+    requestAlbumsUpdate ()
+|    | 164|+    {
+|    | 165|+        m_albums_update_request = true;
+|    | 166|+    }
+|    | 167|+    void
+|    | 168|+    requestSongsUpdate ()
+|    | 169|+    {
+|    | 170|+        m_songs_update_request = true;
+|    | 171|+    }
+|    | 172|+
+|    | 173|+    struct PrimaryTag
+|    | 174|+    {
+|    | 175|+        PrimaryTag ():
+|    | 176|+        m_mtime (0)
+|    | 177|+        {
+|    | 178|+        }
+|    | 179|+        PrimaryTag (std::string tag_, time_t mtime_):
+|    | 180|+        m_tag (std::move (tag_)),
+|    | 181|+        m_mtime (mtime_)
+|    | 182|+        {
+|    | 183|+        }
+|    | 184|+
+|    | 185|+        const
+|    | 186|+            std::string &
+|    | 187|+        tag () const
+|    | 188|+        {
+|    | 189|+            return
+|    | 190|+                m_tag;
+|    | 191|+        }
+|    | 192|+        time_t
+|    | 193|+        mtime () const
+|    | 194|+        {
+|    | 195|+            return
+|    | 196|+                m_mtime;
+|    | 197|+        }
+|    | 198|+
+|    | 199|+      private:
+|    | 200|+        std::string
+|    | 201|+            m_tag;
+|    | 202|+        time_t
+|    | 203|+            m_mtime;
+|    | 204|+    };
+|    | 205|+
+|    | 206|+    struct Album
+|    | 207|+    {
+|    | 208|+        Album (std::string tag_, std::string album_, std::string date_,
+|    | 209|+               time_t mtime_):
+|    | 210|+        m_tag (std::move (tag_)),
+|    | 211|+        m_album (std::move (album_)),
+|    | 212|+        m_date (std::move (date_)),
+|    | 213|+        m_mtime (mtime_)
+|    | 214|+        {
+|    | 215|+        }
+|    | 216|+
+|    | 217|+        const
+|    | 218|+            std::string &
+|    | 219|+        tag () const
+|    | 220|+        {
+|    | 221|+            return
+|    | 222|+                m_tag;
+|    | 223|+        }
+|    | 224|+        const
+|    | 225|+            std::string &
+|    | 226|+        album () const
+|    | 227|+        {
+|    | 228|+            return
+|    | 229|+                m_album;
+|    | 230|+        }
+|    | 231|+        const
+|    | 232|+            std::string &
+|    | 233|+        date () const
+|    | 234|+        {
+|    | 235|+            return
+|    | 236|+                m_date;
+|    | 237|+        }
+|    | 238|+        time_t
+|    | 239|+        mtime () const
+|    | 240|+        {
+|    | 241|+            return
+|    | 242|+                m_mtime;
+|    | 243|+        }
+|    | 244|+
+|    | 245|+      private:
+|    | 246|+        std::string
+|    | 247|+            m_tag;
+|    | 248|+        std::string m_album;
+|    | 249|+        std::string m_date;
+|    | 250|+        time_t
+|    | 251|+            m_mtime;
+|    | 252|+    };
+|    | 253|+
+|    | 254|+    struct AlbumEntry
+|    | 255|+    {
+|    | 256|+        AlbumEntry ():
+|    | 257|+        m_all_tracks_entry (false),
+|    | 258|+        m_album ("", "", "", 0)
+|    | 259|+        {
+|    | 260|+        }
+|    | 261|+        explicit
+|    | 262|+        AlbumEntry (Album album_):
+|    | 263|+        m_all_tracks_entry (false),
+|    | 264|+        m_album (album_)
+|    | 265|+        {
+|    | 266|+        }
+|    | 267|+
+|    | 268|+        const
+|    | 269|+            Album &
+|    | 270|+        entry () const
+|    | 271|+        {
+|    | 272|+            return
+|    | 273|+                m_album;
+|    | 274|+        }
+|    | 275|+        bool
+|    | 276|+        isAllTracksEntry () const
+|    | 277|+        {
+|    | 278|+            return
+|    | 279|+                m_all_tracks_entry;
+|    | 280|+        }
+|    | 281|+
+|    | 282|+        static AlbumEntry
+|    | 283|+        mkAllTracksEntry (std::string tag)
+|    | 284|+        {
+|    | 285|+            auto
+|    | 286|+                result = AlbumEntry (Album (tag, "", "", 0));
+|    | 287|+            result.m_all_tracks_entry = true;
+|    | 288|+            return result;
+|    | 289|+        }
+|    | 290|+
+|    | 291|+      private:
+|    | 292|+        bool m_all_tracks_entry;
+|    | 293|+        Album
+|    | 294|+            m_album;
+|    | 295|+    };
+|    | 296|+
+|    | 297|+    NC::Menu < PrimaryTag > Tags;
+|    | 298|+    NC::Menu < AlbumEntry > Albums;
+|    | 299|+    SongMenu
+|    | 300|+        Songs;
+|    | 301|+
+|    | 302|+  private:
+|    | 303|+    bool m_tags_update_request;
+|    | 304|+    bool
+|    | 305|+        m_albums_update_request;
+|    | 306|+    bool
+|    | 307|+        m_songs_update_request;
+|    | 308|+
+|    | 309|+    boost::posix_time::ptime m_timer;
+|    | 310|+
+|    | 311|+    const int
+|    | 312|+        m_window_timeout;
+|    | 313|+    const
+|    | 314|+        boost::posix_time::time_duration
+|    | 315|+        m_fetching_delay;
+|    | 316|+
+|    | 317|+    Regex::Filter < PrimaryTag > m_tags_search_predicate;
+|    | 318|+    Regex::ItemFilter < AlbumEntry > m_albums_search_predicate;
+|    | 319|+    Regex::Filter < MPD::Song > m_songs_search_predicate;
+| 154| 320| 
+| 155| 321| };
+| 156| 322| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+| 154| 154| 
+| 155| 155| };
+| 156| 156| 
+| 157|    |-extern MediaLibrary *myLibrary;
+|    | 157|+extern MediaLibrary *
+|    | 158|+    myLibrary;
+| 158| 159| 
+| 159| 160| #endif // NCMPCPP_MEDIA_LIBRARY_H
+| 160| 161| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/media_library.h
+|    |++++| /app/src/screens/media_library.h
+| 157| 157| extern MediaLibrary *myLibrary;
+| 158| 158| 
+| 159| 159| #endif // NCMPCPP_MEDIA_LIBRARY_H
+| 160|    |-
+
+src/screens/media_library.h
+|  26| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/media_library.h
+|  27| #include•"regex_filter.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'regex_filter.h'
+
+src/screens/media_library.h
+|  28| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/media_library.h
+|  29| #include•"song_list.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song_list.h'
+
+src/screens/media_library.h
+| 157| extern•MediaLibrary•*myLibrary;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myLibrary'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.h
+|    |++++| /app/src/screens/playlist_editor.h
+|  28|  28| #include "screens/screen.h"
+|  29|  29| #include "song_list.h"
+|  30|  30| 
+|  31|    |-struct PlaylistEditor: Screen<NC::Window *>, Filterable, HasColumns, HasSongs, Searchable, Tabbable
+|    |  31|+struct PlaylistEditor:Screen <
+|    |  32|+NC::Window * >,
+|    |  33|+    Filterable,
+|    |  34|+    HasColumns,
+|    |  35|+    HasSongs,
+|    |  36|+    Searchable,
+|    |  37|+    Tabbable
+|  32|  38| {
+|  33|    |-	PlaylistEditor();
+|  34|    |-	
+|  35|    |-	virtual void switchTo() override;
+|  36|    |-	virtual void resize() override;
+|  37|    |-	
+|  38|    |-	virtual std::wstring title() override;
+|  39|    |-	virtual ScreenType type() override { return ScreenType::PlaylistEditor; }
+|  40|    |-	
+|  41|    |-	virtual void refresh() override;
+|  42|    |-	virtual void update() override;
+|  43|    |-	
+|  44|    |-	virtual int windowTimeout() override;
+|    |  39|+    PlaylistEditor ();
+|  45|  40| 
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// Searchable implementation
+|  52|    |-	virtual bool allowsSearching() override;
+|  53|    |-	virtual const std::string &searchConstraint() override;
+|  54|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  55|    |-	virtual void clearSearchConstraint() override;
+|  56|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|  57|  47| 
+|  58|    |-	// Filterable implementation
+|  59|    |-	virtual bool allowsFiltering() override;
+|  60|    |-	virtual std::string currentFilter() override;
+|  61|    |-	virtual void applyFilter(const std::string &filter) override;
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::PlaylistEditor;
+|    |  57|+    }
+|  62|  58| 
+|  63|    |-	// HasSongs implementation
+|  64|    |-	virtual bool itemAvailable() override;
+|  65|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  66|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  67|    |-	
+|  68|    |-	// HasColumns implementation
+|  69|    |-	virtual bool previousColumnAvailable() override;
+|  70|    |-	virtual void previousColumn() override;
+|  71|    |-	
+|  72|    |-	virtual bool nextColumnAvailable() override;
+|  73|    |-	virtual void nextColumn() override;
+|  74|    |-	
+|  75|    |-	// private members
+|  76|    |-	void updateTimer();
+|    |  59|+    virtual void
+|    |  60|+    refresh ()
+|    |  61|+        override;
+|    |  62|+    virtual void
+|    |  63|+    update ()
+|    |  64|+        override;
+|  77|  65| 
+|  78|    |-	void requestPlaylistsUpdate() { m_playlists_update_requested = true; }
+|  79|    |-	void requestContentUpdate() { m_content_update_requested = true; }
+|  80|    |-	
+|  81|    |-	void locatePlaylist(const MPD::Playlist &playlist);
+|  82|    |-	void locateSong(const MPD::Song &s);
+|    |  66|+    virtual int
+|    |  67|+    windowTimeout ()
+|    |  68|+        override;
+|  83|  69| 
+|  84|    |-	NC::Menu<MPD::Playlist> Playlists;
+|  85|    |-	SongMenu Content;
+|  86|    |-	
+|  87|    |-private:
+|  88|    |-	bool m_playlists_update_requested;
+|  89|    |-	bool m_content_update_requested;
+|    |  70|+    virtual void
+|    |  71|+    mouseButtonPressed (MEVENT me)
+|    |  72|+        override;
+|  90|  73| 
+|  91|    |-	boost::posix_time::ptime m_timer;
+|    |  74|+    virtual bool
+|    |  75|+    isLockable ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return true;
+|    |  79|+    }
+|    |  80|+    virtual bool
+|    |  81|+    isMergable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|  92|  86| 
+|  93|    |-	const int m_window_timeout;
+|  94|    |-	const boost::posix_time::time_duration m_fetching_delay;
+|    |  87|+    // Searchable implementation
+|    |  88|+    virtual bool
+|    |  89|+    allowsSearching ()
+|    |  90|+        override;
+|    |  91|+    virtual const
+|    |  92|+        std::string &
+|    |  93|+    searchConstraint ()
+|    |  94|+        override;
+|    |  95|+    virtual void
+|    |  96|+    setSearchConstraint (const std::string & constraint)
+|    |  97|+        override;
+|    |  98|+    virtual void
+|    |  99|+    clearSearchConstraint ()
+|    | 100|+        override;
+|    | 101|+    virtual bool
+|    | 102|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 103|+        override;
+|  95| 104| 
+|  96|    |-	Regex::Filter<MPD::Playlist> m_playlists_search_predicate;
+|  97|    |-	Regex::Filter<MPD::Song> m_content_search_predicate;
+|    | 105|+    // Filterable implementation
+|    | 106|+    virtual bool
+|    | 107|+    allowsFiltering ()
+|    | 108|+        override;
+|    | 109|+    virtual
+|    | 110|+        std::string
+|    | 111|+    currentFilter ()
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    applyFilter (const std::string & filter)
+|    | 115|+        override;
+|    | 116|+
+|    | 117|+    // HasSongs implementation
+|    | 118|+    virtual bool
+|    | 119|+    itemAvailable ()
+|    | 120|+        override;
+|    | 121|+    virtual bool
+|    | 122|+    addItemToPlaylist (bool play)
+|    | 123|+        override;
+|    | 124|+    virtual
+|    | 125|+        std::vector <
+|    | 126|+        MPD::Song >
+|    | 127|+    getSelectedSongs ()
+|    | 128|+        override;
+|    | 129|+
+|    | 130|+    // HasColumns implementation
+|    | 131|+    virtual bool
+|    | 132|+    previousColumnAvailable ()
+|    | 133|+        override;
+|    | 134|+    virtual void
+|    | 135|+    previousColumn ()
+|    | 136|+        override;
+|    | 137|+
+|    | 138|+    virtual bool
+|    | 139|+    nextColumnAvailable ()
+|    | 140|+        override;
+|    | 141|+    virtual void
+|    | 142|+    nextColumn ()
+|    | 143|+        override;
+|    | 144|+
+|    | 145|+    // private members
+|    | 146|+    void
+|    | 147|+    updateTimer ();
+|    | 148|+
+|    | 149|+    void
+|    | 150|+    requestPlaylistsUpdate ()
+|    | 151|+    {
+|    | 152|+        m_playlists_update_requested = true;
+|    | 153|+    }
+|    | 154|+    void
+|    | 155|+    requestContentUpdate ()
+|    | 156|+    {
+|    | 157|+        m_content_update_requested = true;
+|    | 158|+    }
+|    | 159|+
+|    | 160|+    void
+|    | 161|+    locatePlaylist (const MPD::Playlist & playlist);
+|    | 162|+    void
+|    | 163|+    locateSong (const MPD::Song & s);
+|    | 164|+
+|    | 165|+    NC::Menu < MPD::Playlist > Playlists;
+|    | 166|+    SongMenu
+|    | 167|+        Content;
+|    | 168|+
+|    | 169|+  private:
+|    | 170|+    bool m_playlists_update_requested;
+|    | 171|+    bool
+|    | 172|+        m_content_update_requested;
+|    | 173|+
+|    | 174|+    boost::posix_time::ptime m_timer;
+|    | 175|+
+|    | 176|+    const int
+|    | 177|+        m_window_timeout;
+|    | 178|+    const
+|    | 179|+        boost::posix_time::time_duration
+|    | 180|+        m_fetching_delay;
+|    | 181|+
+|    | 182|+    Regex::Filter < MPD::Playlist > m_playlists_search_predicate;
+|    | 183|+    Regex::Filter < MPD::Song > m_content_search_predicate;
+|  98| 184| };
+|  99| 185| 
+| 100| 186| extern PlaylistEditor *myPlaylistEditor;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.h
+|    |++++| /app/src/screens/playlist_editor.h
+|  97|  97| 	Regex::Filter<MPD::Song> m_content_search_predicate;
+|  98|  98| };
+|  99|  99| 
+| 100|    |-extern PlaylistEditor *myPlaylistEditor;
+|    | 100|+extern PlaylistEditor *
+|    | 101|+    myPlaylistEditor;
+| 101| 102| 
+| 102| 103| #endif // NCMPCPP_PLAYLIST_EDITOR_H
+| 103| 104| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.h
+|    |++++| /app/src/screens/playlist_editor.h
+| 100| 100| extern PlaylistEditor *myPlaylistEditor;
+| 101| 101| 
+| 102| 102| #endif // NCMPCPP_PLAYLIST_EDITOR_H
+| 103|    |-
+
+src/screens/playlist_editor.h
+|  26| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/playlist_editor.h
+|  27| #include•"regex_filter.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'regex_filter.h'
+
+src/screens/playlist_editor.h
+|  28| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/playlist_editor.h
+|  29| #include•"song_list.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song_list.h'
+
+src/screens/playlist_editor.h
+| 100| extern•PlaylistEditor•*myPlaylistEditor;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myPlaylistEditor'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lyrics.cpp
+|    |++++| /app/src/screens/lyrics.cpp
+|  43|  43| #include "screens/screen_switcher.h"
+|  44|  44| #include "utility/string.h"
+|  45|  45| 
+|  46|    |-using Global::MainHeight;
+|  47|    |-using Global::MainStartY;
+|  48|    |-
+|  49|    |-Lyrics *myLyrics;
+|  50|    |-
+|  51|    |-namespace {
+|  52|    |-
+|  53|    |-std::string removeExtension(std::string filename)
+|    |  46|+using
+|    |  47|+    Global::MainHeight;
+|    |  48|+using
+|    |  49|+    Global::MainStartY;
+|    |  50|+
+|    |  51|+Lyrics *
+|    |  52|+    myLyrics;
+|    |  53|+
+|    |  54|+namespace
+|  54|  55| {
+|  55|    |-	size_t dot = filename.rfind('.');
+|  56|    |-	if (dot != std::string::npos)
+|  57|    |-		filename.resize(dot);
+|  58|    |-	return filename;
+|  59|    |-}
+|  60|    |-
+|  61|    |-std::string lyricsFilename(const MPD::Song &s)
+|  62|    |-{
+|  63|    |-	std::string filename;
+|  64|    |-	if (Config.store_lyrics_in_song_dir && !s.isStream())
+|  65|    |-	{
+|  66|    |-		if (s.isFromDatabase())
+|  67|    |-			filename = Config.mpd_music_dir + "/";
+|  68|    |-		filename += removeExtension(s.getURI());
+|  69|    |-		removeExtension(filename);
+|  70|    |-	}
+|  71|    |-	else
+|  72|    |-	{
+|  73|    |-		std::string artist = s.getArtist();
+|  74|    |-		std::string title  = s.getTitle();
+|  75|    |-		if (artist.empty() || title.empty())
+|  76|    |-			filename = removeExtension(s.getName());
+|  77|    |-		else
+|  78|    |-			filename = artist + " - " + title;
+|  79|    |-		removeInvalidCharsFromFilename(filename, Config.generate_win32_compatible_filenames);
+|  80|    |-		filename = Config.lyrics_directory + "/" + filename;
+|  81|    |-	}
+|  82|    |-	filename += ".txt";
+|  83|    |-	return filename;
+|  84|    |-}
+|  85|    |-
+|  86|    |-bool loadLyrics(NC::Scrollpad &w, const std::string &filename)
+|  87|    |-{
+|  88|    |-	std::ifstream input(filename);
+|  89|    |-	if (input.is_open())
+|  90|    |-	{
+|  91|    |-		std::string line;
+|  92|    |-		bool first_line = true;
+|  93|    |-		while (std::getline(input, line))
+|  94|    |-		{
+|  95|    |-			// Remove carriage returns as they mess up the display.
+|  96|    |-			boost::remove_erase(line, '\r');
+|  97|    |-			if (!first_line)
+|  98|    |-				w << '\n';
+|  99|    |-			w << Charset::utf8ToLocale(line);
+| 100|    |-			first_line = false;
+| 101|    |-		}
+| 102|    |-		return true;
+| 103|    |-	}
+| 104|    |-	else
+| 105|    |-		return false;
+| 106|    |-}
+| 107|    |-
+| 108|    |-bool saveLyrics(const std::string &filename, const std::string &lyrics)
+| 109|    |-{
+| 110|    |-	std::ofstream output(filename);
+| 111|    |-	if (output.is_open())
+| 112|    |-	{
+| 113|    |-		output << lyrics;
+| 114|    |-		output.close();
+| 115|    |-		return true;
+| 116|    |-	}
+| 117|    |-	else
+| 118|    |-		return false;
+| 119|    |-}
+| 120|    |-
+| 121|    |-boost::optional<std::string> downloadLyrics(
+| 122|    |-	const MPD::Song &s,
+| 123|    |-	std::shared_ptr<Shared<NC::Buffer>> shared_buffer,
+| 124|    |-	std::shared_ptr<std::atomic<bool>> download_stopper,
+| 125|    |-	LyricsFetcher *current_fetcher)
+| 126|    |-{
+| 127|    |-	std::string s_artist = s.getArtist();
+| 128|    |-	std::string s_title  = s.getTitle();
+| 129|    |-	// If artist or title is empty, use filename. This should give reasonable
+| 130|    |-	// results for google search based lyrics fetchers.
+| 131|    |-	if (s_artist.empty() || s_title.empty())
+| 132|    |-	{
+| 133|    |-		s_artist.clear();
+| 134|    |-		s_title = s.getName();
+| 135|    |-		// Get rid of underscores to improve search results.
+| 136|    |-		std::replace_if(s_title.begin(), s_title.end(), boost::is_any_of("-_"), ' ');
+| 137|    |-		size_t dot = s_title.rfind('.');
+| 138|    |-		if (dot != std::string::npos)
+| 139|    |-			s_title.resize(dot);
+| 140|    |-	}
+| 141|    |-
+| 142|    |-	auto fetch_lyrics = [&](auto &fetcher_) {
+| 143|    |-		{
+| 144|    |-			if (shared_buffer)
+| 145|    |-			{
+| 146|    |-				auto buf = shared_buffer->acquire();
+| 147|    |-				*buf << "Fetching lyrics from "
+| 148|    |-				     << NC::Format::Bold
+| 149|    |-				     << fetcher_->name()
+| 150|    |-				     << NC::Format::NoBold << "... ";
+| 151|    |-			}
+| 152|    |-		}
+| 153|    |-		auto result_ = fetcher_->fetch(s_artist, s_title);
+| 154|    |-		if (result_.first == false)
+| 155|    |-		{
+| 156|    |-			if (shared_buffer)
+| 157|    |-			{
+| 158|    |-				auto buf = shared_buffer->acquire();
+| 159|    |-				*buf << NC::Color::Red
+| 160|    |-				     << result_.second
+| 161|    |-				     << NC::Color::End
+| 162|    |-				     << '\n';
+| 163|    |-			}
+| 164|    |-		}
+| 165|    |-		return result_;
+| 166|    |-	};
+| 167|    |-
+| 168|    |-	LyricsFetcher::Result fetcher_result;
+| 169|    |-	if (current_fetcher == nullptr)
+| 170|    |-	{
+| 171|    |-		for (auto &fetcher : Config.lyrics_fetchers)
+| 172|    |-		{
+| 173|    |-			if (download_stopper && download_stopper->load())
+| 174|    |-				return boost::none;
+| 175|    |-			fetcher_result = fetch_lyrics(fetcher);
+| 176|    |-			if (fetcher_result.first)
+| 177|    |-				break;
+| 178|    |-		}
+| 179|    |-	}
+| 180|    |-	else
+| 181|    |-		fetcher_result = fetch_lyrics(current_fetcher);
+| 182|    |-
+| 183|    |-	boost::optional<std::string> result;
+| 184|    |-	if (fetcher_result.first)
+| 185|    |-		result = std::move(fetcher_result.second);
+| 186|    |-	return result;
+| 187|    |-}
+| 188|    |-
+| 189|    |-}
+| 190|    |-
+| 191|    |-Lyrics::Lyrics()
+| 192|    |-	: Screen(NC::Scrollpad(0, MainStartY, COLS, MainHeight, "", Config.main_color, NC::Border()))
+| 193|    |-	, m_refresh_window(false)
+| 194|    |-	, m_scroll_begin(0)
+| 195|    |-	, m_fetcher(nullptr)
+| 196|    |-{ }
+| 197|    |-
+| 198|    |-void Lyrics::resize()
+| 199|    |-{
+| 200|    |-	size_t x_offset, width;
+| 201|    |-	getWindowResizeParams(x_offset, width);
+| 202|    |-	w.resize(width, MainHeight);
+| 203|    |-	w.moveTo(x_offset, MainStartY);
+| 204|    |-	hasToBeResized = 0;
+| 205|    |-}
+| 206|    |-
+| 207|    |-void Lyrics::update()
+| 208|    |-{
+| 209|    |-	if (m_worker.valid())
+| 210|    |-	{
+| 211|    |-		auto buffer = m_shared_buffer->acquire();
+| 212|    |-		if (!buffer->empty())
+| 213|    |-		{
+| 214|    |-			w << *buffer;
+| 215|    |-			buffer->clear();
+| 216|    |-			m_refresh_window = true;
+| 217|    |-		}
+| 218|    |-
+| 219|    |-		if (m_worker.is_ready())
+| 220|    |-		{
+| 221|    |-			auto lyrics = m_worker.get();
+| 222|    |-			if (lyrics)
+| 223|    |-			{
+| 224|    |-				w.clear();
+| 225|    |-				w << Charset::utf8ToLocale(*lyrics);
+| 226|    |-				std::string filename = lyricsFilename(m_song);
+| 227|    |-				if (!saveLyrics(filename, *lyrics))
+| 228|    |-					Statusbar::printf("Couldn't save lyrics as \"%1%\": %2%",
+| 229|    |-					                  filename, strerror(errno));
+| 230|    |-			}
+| 231|    |-			else
+| 232|    |-				w << "\nLyrics were not found.\n";
+| 233|    |-			clearWorker();
+| 234|    |-			m_refresh_window = true;
+| 235|    |-		}
+| 236|    |-	}
+| 237|    |-
+| 238|    |-	if (m_refresh_window)
+| 239|    |-	{
+| 240|    |-		m_refresh_window = false;
+| 241|    |-		w.flush();
+| 242|    |-		w.refresh();
+| 243|    |-	}
+| 244|    |-}
+| 245|    |-
+| 246|    |-void Lyrics::switchTo()
+| 247|    |-{
+| 248|    |-	using Global::myScreen;
+| 249|    |-	if (myScreen != this)
+| 250|    |-	{
+| 251|    |-		SwitchTo::execute(this);
+| 252|    |-		m_scroll_begin = 0;
+| 253|    |-		drawHeader();
+| 254|    |-	}
+| 255|    |-	else
+| 256|    |-		switchToPreviousScreen();
+| 257|    |-}
+| 258|    |-
+| 259|    |-std::wstring Lyrics::title()
+| 260|    |-{
+| 261|    |-	std::wstring result = L"Lyrics";
+| 262|    |-	if (!m_song.empty())
+| 263|    |-	{
+| 264|    |-		result += L": ";
+| 265|    |-		result += Scroller(
+| 266|    |-			Format::stringify<wchar_t>(Format::parse(L"{%a - %t}|{%f}"), &m_song),
+| 267|    |-			m_scroll_begin,
+| 268|    |-			COLS - result.length() - (Config.design == Design::Alternative
+| 269|    |-			                          ? 2
+| 270|    |-			                          : Global::VolumeState.length()));
+| 271|    |-	}
+| 272|    |-	return result;
+| 273|    |-}
+| 274|    |-
+| 275|    |-void Lyrics::fetch(const MPD::Song &s)
+| 276|    |-{
+| 277|    |-	if (!m_worker.valid() || s != m_song)
+| 278|    |-	{
+| 279|    |-		stopDownload();
+| 280|    |-		w.clear();
+| 281|    |-		m_song = s;
+| 282|    |-		if (loadLyrics(w, lyricsFilename(m_song)))
+| 283|    |-		{
+| 284|    |-			clearWorker();
+| 285|    |-			m_refresh_window = true;
+| 286|    |-		}
+| 287|    |-		else
+| 288|    |-		{
+| 289|    |-			m_download_stopper = std::make_shared<std::atomic<bool>>(false);
+| 290|    |-			m_shared_buffer = std::make_shared<Shared<NC::Buffer>>();
+| 291|    |-			m_worker = boost::async(
+| 292|    |-				boost::launch::async,
+| 293|    |-				std::bind(downloadLyrics,
+| 294|    |-				          m_song, m_shared_buffer, m_download_stopper, m_fetcher));
+| 295|    |-		}
+| 296|    |-	}
+| 297|    |-}
+| 298|    |-
+| 299|    |-void Lyrics::refetchCurrent()
+| 300|    |-{
+| 301|    |-	std::string filename = lyricsFilename(m_song);
+| 302|    |-	if (std::remove(filename.c_str()) == -1 && errno != ENOENT)
+| 303|    |-	{
+| 304|    |-		const char msg[] = "Couldn't remove \"%1%\": %2%";
+| 305|    |-		Statusbar::printf(msg, wideShorten(filename, COLS - const_strlen(msg) - 25),
+| 306|    |-		                  strerror(errno));
+| 307|    |-	}
+| 308|    |-	else
+| 309|    |-	{
+| 310|    |-		clearWorker();
+| 311|    |-		fetch(m_song);
+| 312|    |-	}
+| 313|    |-}
+| 314|    |-
+| 315|    |-void Lyrics::edit()
+| 316|    |-{
+| 317|    |-	if (Config.external_editor.empty())
+| 318|    |-	{
+| 319|    |-		Statusbar::print("external_editor variable has to be set in configuration file");
+| 320|    |-		return;
+| 321|    |-	}
+| 322|    |-
+| 323|    |-	Statusbar::print("Opening lyrics in external editor...");
+| 324|    |-
+| 325|    |-	GNUC_UNUSED int res;
+| 326|    |-	std::string command;
+| 327|    |-	std::string filename = lyricsFilename(m_song);
+| 328|    |-	if (Config.use_console_editor)
+| 329|    |-	{
+| 330|    |-		command = "/bin/sh -c \"" + Config.external_editor + " \\\"" + filename + "\\\"\"";
+| 331|    |-		res = system(command.c_str());
+| 332|    |-		fetch(m_song);
+| 333|    |-		// Reset ncurses state to refresh the screen.
+| 334|    |-		endwin();
+| 335|    |-		initscr();
+| 336|    |-		curs_set(0);
+| 337|    |-	}
+| 338|    |-	else
+| 339|    |-	{
+| 340|    |-		command = "nohup " + Config.external_editor
+| 341|    |-			+ " \"" + filename + "\" > /dev/null 2>&1 &";
+| 342|    |-		res = system(command.c_str());
+| 343|    |-	}
+| 344|    |-}
+| 345|    |-
+| 346|    |-void Lyrics::toggleFetcher()
+| 347|    |-{
+| 348|    |-	if (m_fetcher != nullptr)
+| 349|    |-	{
+| 350|    |-		auto fetcher = std::find_if(Config.lyrics_fetchers.begin(),
+| 351|    |-		                            Config.lyrics_fetchers.end(),
+| 352|    |-		                            [this](auto &f) { return f.get() == m_fetcher; });
+| 353|    |-		assert(fetcher != Config.lyrics_fetchers.end());
+| 354|    |-		++fetcher;
+| 355|    |-		if (fetcher != Config.lyrics_fetchers.end())
+| 356|    |-			m_fetcher = fetcher->get();
+| 357|    |-		else
+| 358|    |-			m_fetcher = nullptr;
+| 359|    |-	}
+| 360|    |-	else
+| 361|    |-	{
+| 362|    |-		assert(!Config.lyrics_fetchers.empty());
+| 363|    |-		m_fetcher = Config.lyrics_fetchers[0].get();
+| 364|    |-	}
+| 365|    |-
+| 366|    |-	if (m_fetcher != nullptr)
+| 367|    |-		Statusbar::printf("Using lyrics fetcher: %s", m_fetcher->name());
+| 368|    |-	else
+| 369|    |-		Statusbar::print("Using all lyrics fetchers");
+| 370|    |-}
+| 371|    |-
+| 372|    |-void Lyrics::fetchInBackground(const MPD::Song &s, bool notify_)
+| 373|    |-{
+| 374|    |-	auto consumer_impl = [this] {
+| 375|    |-		std::string lyrics_file;
+| 376|    |-		while (true)
+| 377|    |-		{
+| 378|    |-			ConsumerState::Song cs;
+| 379|    |-			{
+| 380|    |-				auto consumer = m_consumer_state.acquire();
+| 381|    |-				assert(consumer->running);
+| 382|    |-				if (consumer->songs.empty())
+| 383|    |-				{
+| 384|    |-					consumer->running = false;
+| 385|    |-					break;
+| 386|    |-				}
+| 387|    |-				lyrics_file = lyricsFilename(consumer->songs.front().song());
+| 388|    |-				if (!boost::filesystem::exists(lyrics_file))
+| 389|    |-				{
+| 390|    |-					cs = consumer->songs.front();
+| 391|    |-					if (cs.notify())
+| 392|    |-					{
+| 393|    |-						consumer->message = "Fetching lyrics for \""
+| 394|    |-							+ Format::stringify<char>(Config.song_status_format, &cs.song())
+| 395|    |-							+ "\"...";
+| 396|    |-					}
+| 397|    |-				}
+| 398|    |-				consumer->songs.pop();
+| 399|    |-			}
+| 400|    |-			if (!cs.song().empty())
+| 401|    |-			{
+| 402|    |-				auto lyrics = downloadLyrics(cs.song(), nullptr, nullptr, m_fetcher);
+| 403|    |-				if (lyrics)
+| 404|    |-					saveLyrics(lyrics_file, *lyrics);
+| 405|    |-			}
+| 406|    |-		}
+| 407|    |-	};
+| 408|    |-
+| 409|    |-	auto consumer = m_consumer_state.acquire();
+| 410|    |-	consumer->songs.emplace(s, notify_);
+| 411|    |-	// Start the consumer if it's not running.
+| 412|    |-	if (!consumer->running)
+| 413|    |-	{
+| 414|    |-		std::thread t(consumer_impl);
+| 415|    |-		t.detach();
+| 416|    |-		consumer->running = true;
+| 417|    |-	}
+| 418|    |-}
+| 419|    |-
+| 420|    |-boost::optional<std::string> Lyrics::tryTakeConsumerMessage()
+| 421|    |-{
+| 422|    |-	boost::optional<std::string> result;
+| 423|    |-	auto consumer = m_consumer_state.acquire();
+| 424|    |-	if (consumer->message)
+| 425|    |-	{
+| 426|    |-		result = std::move(consumer->message);
+| 427|    |-		consumer->message = boost::none;
+| 428|    |-	}
+| 429|    |-	return result;
+| 430|    |-}
+| 431|    |-
+| 432|    |-void Lyrics::clearWorker()
+| 433|    |-{
+| 434|    |-	m_shared_buffer.reset();
+| 435|    |-	m_worker = boost::BOOST_THREAD_FUTURE<boost::optional<std::string>>();
+| 436|    |-}
+| 437|    |-
+| 438|    |-void Lyrics::stopDownload()
+| 439|    |-{
+| 440|    |-	if (m_download_stopper)
+| 441|    |-		m_download_stopper->store(true);
+| 442|    |-}
+|    |  56|+
+|    |  57|+    std::string removeExtension (std::string filename)
+|    |  58|+    {
+|    |  59|+        size_t
+|    |  60|+            dot = filename.rfind ('.');
+|    |  61|+        if (dot != std::string::npos)
+|    |  62|+            filename.resize (dot);
+|    |  63|+        return filename;
+|    |  64|+    }
+|    |  65|+
+|    |  66|+    std::string lyricsFilename (const MPD::Song & s)
+|    |  67|+    {
+|    |  68|+        std::string filename;
+|    |  69|+        if (Config.store_lyrics_in_song_dir && !s.isStream ())
+|    |  70|+          {
+|    |  71|+              if (s.isFromDatabase ())
+|    |  72|+                  filename = Config.mpd_music_dir + "/";
+|    |  73|+              filename += removeExtension (s.getURI ());
+|    |  74|+              removeExtension (filename);
+|    |  75|+          }
+|    |  76|+        else
+|    |  77|+          {
+|    |  78|+              std::string artist = s.getArtist ();
+|    |  79|+              std::string title = s.getTitle ();
+|    |  80|+              if (artist.empty () || title.empty ())
+|    |  81|+                  filename = removeExtension (s.getName ());
+|    |  82|+              else
+|    |  83|+                  filename = artist + " - " + title;
+|    |  84|+              removeInvalidCharsFromFilename (filename,
+|    |  85|+                                              Config.
+|    |  86|+                                              generate_win32_compatible_filenames);
+|    |  87|+              filename = Config.lyrics_directory + "/" + filename;
+|    |  88|+          }
+|    |  89|+        filename += ".txt";
+|    |  90|+        return filename;
+|    |  91|+    }
+|    |  92|+
+|    |  93|+    bool
+|    |  94|+    loadLyrics (NC::Scrollpad & w, const std::string & filename)
+|    |  95|+    {
+|    |  96|+        std::ifstream input (filename);
+|    |  97|+        if (input.is_open ())
+|    |  98|+          {
+|    |  99|+              std::string line;
+|    | 100|+              bool
+|    | 101|+                  first_line = true;
+|    | 102|+              while (std::getline (input, line))
+|    | 103|+                {
+|    | 104|+                    // Remove carriage returns as they mess up the display.
+|    | 105|+                    boost::remove_erase (line, '\r');
+|    | 106|+                    if (!first_line)
+|    | 107|+                        w << '\n';
+|    | 108|+                    w << Charset::utf8ToLocale (line);
+|    | 109|+                    first_line = false;
+|    | 110|+                }
+|    | 111|+              return true;
+|    | 112|+          }
+|    | 113|+        else
+|    | 114|+            return false;
+|    | 115|+    }
+|    | 116|+
+|    | 117|+    bool
+|    | 118|+    saveLyrics (const std::string & filename, const std::string & lyrics)
+|    | 119|+    {
+|    | 120|+        std::ofstream output (filename);
+|    | 121|+        if (output.is_open ())
+|    | 122|+          {
+|    | 123|+              output << lyrics;
+|    | 124|+              output.close ();
+|    | 125|+              return true;
+|    | 126|+          }
+|    | 127|+        else
+|    | 128|+            return false;
+|    | 129|+    }
+|    | 130|+
+|    | 131|+    boost::optional < std::string > downloadLyrics (const MPD::Song & s,
+|    | 132|+                                                    std::shared_ptr < Shared <
+|    | 133|+                                                    NC::
+|    | 134|+                                                    Buffer >> shared_buffer,
+|    | 135|+                                                    std::shared_ptr <
+|    | 136|+                                                    std::atomic <
+|    | 137|+                                                    bool >> download_stopper,
+|    | 138|+                                                    LyricsFetcher *
+|    | 139|+                                                    current_fetcher)
+|    | 140|+    {
+|    | 141|+        std::string s_artist = s.getArtist ();
+|    | 142|+        std::string s_title = s.getTitle ();
+|    | 143|+        // If artist or title is empty, use filename. This should give reasonable
+|    | 144|+        // results for google search based lyrics fetchers.
+|    | 145|+        if (s_artist.empty () || s_title.empty ())
+|    | 146|+          {
+|    | 147|+              s_artist.clear ();
+|    | 148|+              s_title = s.getName ();
+|    | 149|+              // Get rid of underscores to improve search results.
+|    | 150|+              std::replace_if (s_title.begin (), s_title.end (),
+|    | 151|+                               boost::is_any_of ("-_"), ' ');
+|    | 152|+              size_t
+|    | 153|+                  dot = s_title.rfind ('.');
+|    | 154|+              if (dot != std::string::npos)
+|    | 155|+                  s_title.resize (dot);
+|    | 156|+          }
+|    | 157|+
+|    | 158|+        auto
+|    | 159|+            fetch_lyrics =[&](auto & fetcher_) {
+|    | 160|+            {
+|    | 161|+             if (shared_buffer) {
+|    | 162|+                                 auto buf = shared_buffer->acquire ();
+|    | 163|+                                 *buf << "Fetching lyrics from "
+|    | 164|+                                 << NC::Format::Bold
+|    | 165|+                                 << fetcher_->name ()
+|    | 166|+                                 << NC::Format::NoBold << "... ";}
+|    | 167|+                                 }
+|    | 168|+                                 auto result_ =
+|    | 169|+                                 fetcher_->fetch (s_artist, s_title);
+|    | 170|+                                 if (result_.first == false)
+|    | 171|+                                 {
+|    | 172|+                                 if (shared_buffer)
+|    | 173|+                                 {
+|    | 174|+                                 auto buf = shared_buffer->acquire ();
+|    | 175|+                                 *buf << NC::Color::Red
+|    | 176|+                                 << result_.second << NC::Color::End << '\n';}
+|    | 177|+                                 }
+|    | 178|+                                 return result_;};
+|    | 179|+                                 LyricsFetcher::Result fetcher_result;
+|    | 180|+                                 if (current_fetcher == nullptr)
+|    | 181|+                                 {
+|    | 182|+          for (auto & fetcher:  Config.
+|    | 183|+                                      lyrics_fetchers)
+|    | 184|+                                 {
+|    | 185|+                                 if (download_stopper
+|    | 186|+                                     && download_stopper->
+|    | 187|+                                     load ())return boost::none;
+|    | 188|+                                 fetcher_result = fetch_lyrics (fetcher);
+|    | 189|+                                 if (fetcher_result.first) break;}
+|    | 190|+                                 }
+|    | 191|+                                 else
+|    | 192|+                                 fetcher_result =
+|    | 193|+                                 fetch_lyrics (current_fetcher);
+|    | 194|+                                 boost::optional < std::string > result;
+|    | 195|+                                 if (fetcher_result.first) result =
+|    | 196|+                                 std::move (fetcher_result.second);
+|    | 197|+                                 return result;}
+|    | 198|+
+|    | 199|+                                 }
+|    | 200|+
+|    | 201|+Lyrics::Lyrics ():              Screen (NC::
+|    | 202|+                                         Scrollpad (0, MainStartY, COLS,
+|    | 203|+                                                    MainHeight, "",
+|    | 204|+                                                    Config.main_color,
+|    | 205|+                                                    NC::Border ())),
+|    | 206|+                                 m_refresh_window (false), m_scroll_begin (0),
+|    | 207|+                                 m_fetcher (nullptr)
+|    | 208|+                                 {
+|    | 209|+                                 }
+|    | 210|+
+|    | 211|+                                 void Lyrics::resize ()
+|    | 212|+                                 {
+|    | 213|+                                 size_t x_offset, width;
+|    | 214|+                                 getWindowResizeParams (x_offset, width);
+|    | 215|+                                 w.resize (width, MainHeight);
+|    | 216|+                                 w.moveTo (x_offset, MainStartY);
+|    | 217|+                                 hasToBeResized = 0;}
+|    | 218|+
+|    | 219|+                                 void Lyrics::update ()
+|    | 220|+                                 {
+|    | 221|+                                 if (m_worker.valid ())
+|    | 222|+                                 {
+|    | 223|+                                 auto buffer = m_shared_buffer->acquire ();
+|    | 224|+                                 if (!buffer->empty ())
+|    | 225|+                                 {
+|    | 226|+                                 w << *buffer;
+|    | 227|+                                 buffer->clear (); m_refresh_window = true;}
+|    | 228|+
+|    | 229|+                                 if (m_worker.is_ready ())
+|    | 230|+                                 {
+|    | 231|+                                 auto lyrics = m_worker.get (); if (lyrics)
+|    | 232|+                                 {
+|    | 233|+                                 w.clear ();
+|    | 234|+                                 w << Charset::utf8ToLocale (*lyrics);
+|    | 235|+                                 std::string filename =
+|    | 236|+                                 lyricsFilename (m_song);
+|    | 237|+                                 if (!saveLyrics (filename, *lyrics))
+|    | 238|+                                 Statusbar::
+|    | 239|+                                 printf
+|    | 240|+                                 ("Couldn't save lyrics as \"%1%\": %2%",
+|    | 241|+                                  filename, strerror (errno));}
+|    | 242|+                                 else
+|    | 243|+                                 w << "\nLyrics were not found.\n";
+|    | 244|+                                 clearWorker (); m_refresh_window = true;}
+|    | 245|+                                 }
+|    | 246|+
+|    | 247|+                                 if (m_refresh_window)
+|    | 248|+                                 {
+|    | 249|+                                 m_refresh_window = false;
+|    | 250|+                                 w.flush (); w.refresh ();}
+|    | 251|+                                 }
+|    | 252|+
+|    | 253|+                                 void Lyrics::switchTo ()
+|    | 254|+                                 {
+|    | 255|+                                 using Global::myScreen; if (myScreen != this)
+|    | 256|+                                 {
+|    | 257|+                                 SwitchTo::execute (this);
+|    | 258|+                                 m_scroll_begin = 0; drawHeader ();}
+|    | 259|+                                 else
+|    | 260|+                                 switchToPreviousScreen ();}
+|    | 261|+
+|    | 262|+                                 std::wstring Lyrics::title ()
+|    | 263|+                                 {
+|    | 264|+                                 std::wstring result = L"Lyrics";
+|    | 265|+                                 if (!m_song.empty ())
+|    | 266|+                                 {
+|    | 267|+                                 result += L": ";
+|    | 268|+                                 result +=
+|    | 269|+                                 Scroller (Format::stringify < wchar_t >
+|    | 270|+                                           (Format::parse (L"{%a - %t}|{%f}"),
+|    | 271|+                                            &m_song), m_scroll_begin,
+|    | 272|+                                           COLS - result.length () -
+|    | 273|+                                           (Config.design ==
+|    | 274|+                                            Design::Alternative ? 2 : Global::
+|    | 275|+                                            VolumeState.length ()));}
+|    | 276|+                                 return result;}
+|    | 277|+
+|    | 278|+                                 void Lyrics::fetch (const MPD::Song & s)
+|    | 279|+                                 {
+|    | 280|+                                 if (!m_worker.valid () || s != m_song)
+|    | 281|+                                 {
+|    | 282|+                                 stopDownload ();
+|    | 283|+                                 w.clear ();
+|    | 284|+                                 m_song = s;
+|    | 285|+                                 if (loadLyrics (w, lyricsFilename (m_song)))
+|    | 286|+                                 {
+|    | 287|+                                 clearWorker (); m_refresh_window = true;}
+|    | 288|+                                 else
+|    | 289|+                                 {
+|    | 290|+                                 m_download_stopper =
+|    | 291|+                                 std::make_shared < std::atomic <
+|    | 292|+                                 bool >> (false);
+|    | 293|+                                 m_shared_buffer =
+|    | 294|+                                 std::make_shared < Shared < NC::Buffer >> ();
+|    | 295|+                                 m_worker =
+|    | 296|+                                 boost::async (boost::launch::async,
+|    | 297|+                                               std::bind (downloadLyrics,
+|    | 298|+                                                          m_song,
+|    | 299|+                                                          m_shared_buffer,
+|    | 300|+                                                          m_download_stopper,
+|    | 301|+                                                          m_fetcher));}
+|    | 302|+                                 }
+|    | 303|+                                 }
+|    | 304|+
+|    | 305|+                                 void Lyrics::refetchCurrent ()
+|    | 306|+                                 {
+|    | 307|+                                 std::string filename =
+|    | 308|+                                 lyricsFilename (m_song);
+|    | 309|+                                 if (std::remove (filename.c_str ()) == -1
+|    | 310|+                                     && errno != ENOENT)
+|    | 311|+                                 {
+|    | 312|+                                 const char msg[] =
+|    | 313|+                                 "Couldn't remove \"%1%\": %2%";
+|    | 314|+                                 Statusbar::printf (msg,
+|    | 315|+                                                    wideShorten (filename,
+|    | 316|+                                                                 COLS -
+|    | 317|+                                                                 const_strlen
+|    | 318|+                                                                 (msg) - 25),
+|    | 319|+                                                    strerror (errno));}
+|    | 320|+                                 else
+|    | 321|+                                 {
+|    | 322|+                                 clearWorker (); fetch (m_song);}
+|    | 323|+                                 }
+|    | 324|+
+|    | 325|+                                 void Lyrics::edit ()
+|    | 326|+                                 {
+|    | 327|+                                 if (Config.external_editor.empty ())
+|    | 328|+                                 {
+|    | 329|+                                 Statusbar::
+|    | 330|+                                 print
+|    | 331|+                                 ("external_editor variable has to be set in configuration file");
+|    | 332|+                                 return;}
+|    | 333|+
+|    | 334|+                                 Statusbar::
+|    | 335|+                                 print
+|    | 336|+                                 ("Opening lyrics in external editor...");
+|    | 337|+                                 GNUC_UNUSED int res; std::string command;
+|    | 338|+                                 std::string filename =
+|    | 339|+                                 lyricsFilename (m_song);
+|    | 340|+                                 if (Config.use_console_editor)
+|    | 341|+                                 {
+|    | 342|+                                 command =
+|    | 343|+                                 "/bin/sh -c \"" + Config.external_editor +
+|    | 344|+                                 " \\\"" + filename + "\\\"\"";
+|    | 345|+                                 res = system (command.c_str ());
+|    | 346|+                                 fetch (m_song);
+|    | 347|+                                 // Reset ncurses state to refresh the screen.
+|    | 348|+                                 endwin (); initscr (); curs_set (0);}
+|    | 349|+                                 else
+|    | 350|+                                 {
+|    | 351|+                                 command = "nohup " + Config.external_editor
+|    | 352|+                                 + " \"" + filename + "\" > /dev/null 2>&1 &";
+|    | 353|+                                 res = system (command.c_str ());}
+|    | 354|+                                 }
+|    | 355|+
+|    | 356|+                                 void Lyrics::toggleFetcher ()
+|    | 357|+                                 {
+|    | 358|+                                 if (m_fetcher != nullptr)
+|    | 359|+                                 {
+|    | 360|+                                 auto fetcher =
+|    | 361|+                                 std::find_if (Config.lyrics_fetchers.begin (),
+|    | 362|+                                               Config.lyrics_fetchers.end (),
+|    | 363|+                                               [this] (auto & f)
+|    | 364|+                                               {
+|    | 365|+                                               return f.get () == m_fetcher;}
+|    | 366|+                                 );
+|    | 367|+                                 assert (fetcher !=
+|    | 368|+                                         Config.lyrics_fetchers.end ());
+|    | 369|+                                 ++fetcher;
+|    | 370|+                                 if (fetcher !=
+|    | 371|+                                     Config.lyrics_fetchers.end ())m_fetcher =
+|    | 372|+                                 fetcher->get ();
+|    | 373|+                                 else
+|    | 374|+                                 m_fetcher = nullptr;}
+|    | 375|+                                 else
+|    | 376|+                                 {
+|    | 377|+                                 assert (!Config.lyrics_fetchers.empty ());
+|    | 378|+                                 m_fetcher = Config.lyrics_fetchers[0].get ();}
+|    | 379|+
+|    | 380|+                                 if (m_fetcher != nullptr)
+|    | 381|+                                 Statusbar::printf ("Using lyrics fetcher: %s",
+|    | 382|+                                                    m_fetcher->name ());
+|    | 383|+                                 else
+|    | 384|+                                 Statusbar::
+|    | 385|+                                 print ("Using all lyrics fetchers");}
+|    | 386|+
+|    | 387|+                                 void Lyrics::fetchInBackground (const MPD::
+|    | 388|+                                                                 Song & s,
+|    | 389|+                                                                 bool notify_)
+|    | 390|+                                 {
+|    | 391|+                                 auto consumer_impl =[this]
+|    | 392|+                                 {
+|    | 393|+                                 std::string lyrics_file; while (true)
+|    | 394|+                                 {
+|    | 395|+                                 ConsumerState::Song cs;
+|    | 396|+                                 {
+|    | 397|+                                 auto consumer = m_consumer_state.acquire ();
+|    | 398|+                                 assert (consumer->running);
+|    | 399|+                                 if (consumer->songs.empty ())
+|    | 400|+                                 {
+|    | 401|+                                 consumer->running = false; break;}
+|    | 402|+                                 lyrics_file =
+|    | 403|+                                 lyricsFilename (consumer->songs.front ().
+|    | 404|+                                                 song ());
+|    | 405|+                                 if (!boost::filesystem::exists (lyrics_file))
+|    | 406|+                                 {
+|    | 407|+                                 cs = consumer->songs.front ();
+|    | 408|+                                 if (cs.notify ())
+|    | 409|+                                 {
+|    | 410|+                                 consumer->message = "Fetching lyrics for \""
+|    | 411|+                                 + Format::stringify <
+|    | 412|+                                 char >(Config.song_status_format,
+|    | 413|+                                        &cs.song ()) + "\"...";}
+|    | 414|+                                 }
+|    | 415|+                                 consumer->songs.pop ();}
+|    | 416|+                                 if (!cs.song ().empty ())
+|    | 417|+                                 {
+|    | 418|+                                 auto lyrics =
+|    | 419|+                                 downloadLyrics (cs.song (), nullptr, nullptr,
+|    | 420|+                                                 m_fetcher);
+|    | 421|+                                 if (lyrics) saveLyrics (lyrics_file,
+|    | 422|+                                                         *lyrics);}
+|    | 423|+                                 }
+|    | 424|+                                 };
+|    | 425|+                                 auto consumer = m_consumer_state.acquire ();
+|    | 426|+                                 consumer->songs.emplace (s, notify_);
+|    | 427|+                                 // Start the consumer if it's not running.
+|    | 428|+                                 if (!consumer->running)
+|    | 429|+                                 {
+|    | 430|+                                 std::thread t (consumer_impl);
+|    | 431|+                                 t.detach (); consumer->running = true;}
+|    | 432|+                                 }
+|    | 433|+
+|    | 434|+                                 boost::optional < std::string >
+|    | 435|+                                 Lyrics::tryTakeConsumerMessage ()
+|    | 436|+                                 {
+|    | 437|+                                 boost::optional < std::string > result;
+|    | 438|+                                 auto consumer = m_consumer_state.acquire ();
+|    | 439|+                                 if (consumer->message)
+|    | 440|+                                 {
+|    | 441|+                                 result = std::move (consumer->message);
+|    | 442|+                                 consumer->message = boost::none;}
+|    | 443|+                                 return result;}
+|    | 444|+
+|    | 445|+                                 void Lyrics::clearWorker ()
+|    | 446|+                                 {
+|    | 447|+                                 m_shared_buffer.reset ();
+|    | 448|+                                 m_worker =
+|    | 449|+                                 boost::BOOST_THREAD_FUTURE < boost::optional <
+|    | 450|+                                 std::string >> ();}
+|    | 451|+
+|    | 452|+                                 void Lyrics::stopDownload ()
+|    | 453|+                                 {
+|    | 454|+                                 if (m_download_stopper)
+|    | 455|+                                 m_download_stopper->store (true);}
+
+src/screens/lyrics.cpp
+|  30| #include•"curses/scrollpad.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/scrollpad.h'
+
+src/screens/lyrics.cpp
+|  31| #include•"screens/browser.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/browser.h'
+
+src/screens/lyrics.cpp
+|  32| #include•"charset.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'charset.h'
+
+src/screens/lyrics.cpp
+|  33| #include•"curl_handle.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curl_handle.h'
+
+src/screens/lyrics.cpp
+|  34| #include•"format_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'format_impl.h'
+
+src/screens/lyrics.cpp
+|  35| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/lyrics.cpp
+|  36| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/lyrics.cpp
+|  37| #include•"screens/lyrics.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/lyrics.h'
+
+src/screens/lyrics.cpp
+|  38| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist.h'
+
+src/screens/lyrics.cpp
+|  39| #include•"settings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'settings.h'
+
+src/screens/lyrics.cpp
+|  40| #include•"song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song.h'
+
+src/screens/lyrics.cpp
+|  41| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'statusbar.h'
+
+src/screens/lyrics.cpp
+|  42| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/lyrics.cpp
+|  43| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/lyrics.cpp
+|  44| #include•"utility/string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/string.h'
+
+src/screens/lyrics.cpp
+|  49| Lyrics•*myLyrics;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myLyrics'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+|  37|  37| #include "title.h"
+|  38|  38| #include "screens/screen_switcher.h"
+|  39|  39| 
+|  40|    |-using Global::MainHeight;
+|  41|    |-using Global::MainStartY;
+|  42|    |-
+|  43|    |-namespace ph = std::placeholders;
+|  44|    |-
+|  45|    |-SearchEngine *mySearcher;
+|  46|    |-
+|  47|    |-namespace {
+|    |  40|+using
+|    |  41|+    Global::MainHeight;
+|    |  42|+using
+|    |  43|+    Global::MainStartY;
+|    |  44|+
+|    |  45|+namespace
+|    |  46|+    ph = std::placeholders;
+|    |  47|+
+|    |  48|+SearchEngine *
+|    |  49|+    mySearcher;
+|    |  50|+
+|    |  51|+namespace
+|    |  52|+{
+|  48|  53| 
+|  49|  54| /*const std::array<const std::string, 11> constraintsNames = {{
+|  50|  55| 	"Any",
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+|  73|  73| 	const size_t reset = search+1;
+|  74|  74| }*/
+|  75|  75| 
+|  76|    |-std::string SEItemToString(const SEItem &ei);
+|  77|    |-bool SEItemEntryMatcher(const Regex::Regex &rx,
+|  78|    |-                        const NC::Menu<SEItem>::Item &item,
+|  79|    |-                        bool filter);
+|  80|    |-
+|  81|    |-}
+|  82|    |-
+|  83|    |-template <>
+|  84|    |-struct SongPropertiesExtractor<SEItem>
+|  85|    |-{
+|  86|    |-	template <typename ItemT>
+|  87|    |-	auto &operator()(ItemT &item) const
+|  88|    |-	{
+|  89|    |-		auto s = !item.isSeparator() && item.value().isSong()
+|  90|    |-			? &item.value().song()
+|  91|    |-			: nullptr;
+|  92|    |-		return m_cache.assign(&item.properties(), s);
+|  93|    |-	}
+|  94|    |-
+|  95|    |-private:
+|  96|    |-	mutable SongProperties m_cache;
+|    |  76|+    std::string SEItemToString (const SEItem & ei);
+|    |  77|+    bool
+|    |  78|+    SEItemEntryMatcher (const Regex::Regex & rx,
+|    |  79|+                        const NC::Menu < SEItem >::Item & item, bool filter);
+|    |  80|+
+|    |  81|+}
+|    |  82|+
+|    |  83|+template <> struct SongPropertiesExtractor <
+|    |  84|+    SEItem >
+|    |  85|+{
+|    |  86|+    template <
+|    |  87|+        typename
+|    |  88|+        ItemT >
+|    |  89|+        auto &
+|    |  90|+    operator () (ItemT & item) const
+|    |  91|+    {
+|    |  92|+        auto
+|    |  93|+            s = !item.isSeparator ()
+|    |  94|+            && item.value ().isSong ()? &item.value ().song () : nullptr;
+|    |  95|+        return
+|    |  96|+            m_cache.
+|    |  97|+        assign (&item.properties (), s);
+|    |  98|+    }
+|    |  99|+
+|    | 100|+  private:
+|    | 101|+    mutable
+|    | 102|+        SongProperties
+|    | 103|+        m_cache;
+|  97| 104| };
+|  98| 105| 
+|  99| 106| SongIterator SearchEngineWindow::currentS()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+|  96|  96| 	mutable SongProperties m_cache;
+|  97|  97| };
+|  98|  98| 
+|  99|    |-SongIterator SearchEngineWindow::currentS()
+| 100|    |-{
+| 101|    |-	return makeSongIterator(current());
+| 102|    |-}
+| 103|    |-
+| 104|    |-ConstSongIterator SearchEngineWindow::currentS() const
+| 105|    |-{
+| 106|    |-	return makeConstSongIterator(current());
+| 107|    |-}
+| 108|    |-
+| 109|    |-SongIterator SearchEngineWindow::beginS()
+| 110|    |-{
+| 111|    |-	return makeSongIterator(begin());
+| 112|    |-}
+| 113|    |-
+| 114|    |-ConstSongIterator SearchEngineWindow::beginS() const
+| 115|    |-{
+| 116|    |-	return makeConstSongIterator(begin());
+| 117|    |-}
+| 118|    |-
+| 119|    |-SongIterator SearchEngineWindow::endS()
+| 120|    |-{
+| 121|    |-	return makeSongIterator(end());
+| 122|    |-}
+| 123|    |-
+| 124|    |-ConstSongIterator SearchEngineWindow::endS() const
+| 125|    |-{
+| 126|    |-	return makeConstSongIterator(end());
+| 127|    |-}
+| 128|    |-
+| 129|    |-std::vector<MPD::Song> SearchEngineWindow::getSelectedSongs()
+| 130|    |-{
+| 131|    |-	std::vector<MPD::Song> result;
+| 132|    |-	for (auto &item : *this)
+| 133|    |-	{
+| 134|    |-		if (item.isSelected())
+| 135|    |-		{
+| 136|    |-			assert(item.value().isSong());
+| 137|    |-			result.push_back(item.value().song());
+| 138|    |-		}
+| 139|    |-	}
+| 140|    |-	// If no item is selected, add the current one if it's a song.
+| 141|    |-	if (result.empty() && !empty() && current()->value().isSong())
+| 142|    |-		result.push_back(current()->value().song());
+| 143|    |-	return result;
+|    |  99|+SongIterator
+|    | 100|+SearchEngineWindow::currentS ()
+|    | 101|+{
+|    | 102|+    return makeSongIterator (current ());
+|    | 103|+}
+|    | 104|+
+|    | 105|+ConstSongIterator
+|    | 106|+SearchEngineWindow::currentS () const const
+|    | 107|+{
+|    | 108|+    return makeConstSongIterator (current ());
+|    | 109|+}
+|    | 110|+
+|    | 111|+SongIterator
+|    | 112|+SearchEngineWindow::beginS ()
+|    | 113|+{
+|    | 114|+    return makeSongIterator (begin ());
+|    | 115|+}
+|    | 116|+
+|    | 117|+ConstSongIterator
+|    | 118|+SearchEngineWindow::beginS () const const
+|    | 119|+{
+|    | 120|+    return makeConstSongIterator (begin ());
+|    | 121|+}
+|    | 122|+
+|    | 123|+SongIterator
+|    | 124|+SearchEngineWindow::endS ()
+|    | 125|+{
+|    | 126|+    return makeSongIterator (end ());
+|    | 127|+}
+|    | 128|+
+|    | 129|+ConstSongIterator
+|    | 130|+SearchEngineWindow::endS () const const
+|    | 131|+{
+|    | 132|+    return makeConstSongIterator (end ());
+|    | 133|+}
+|    | 134|+
+|    | 135|+std::vector < MPD::Song > SearchEngineWindow::getSelectedSongs ()
+|    | 136|+{
+|    | 137|+    std::vector < MPD::Song > result;
+|    | 138|+  for (auto & item:*this)
+|    | 139|+      {
+|    | 140|+          if (item.isSelected ())
+|    | 141|+            {
+|    | 142|+                assert (item.value ().isSong ());
+|    | 143|+                result.push_back (item.value ().song ());
+|    | 144|+            }
+|    | 145|+      }
+|    | 146|+    // If no item is selected, add the current one if it's a song.
+|    | 147|+    if (result.empty () && !empty () && current ()->value ().isSong ())
+|    | 148|+        result.push_back (current ()->value ().song ());
+|    | 149|+    return result;
+| 144| 150| }
+| 145| 151| 
+| 146| 152| /**********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 145| 145| 
+| 146| 146| /**********************************************************************/
+| 147| 147| 
+| 148|    |-const char *SearchEngine::ConstraintsNames[] =
+| 149|    |-{
+| 150|    |-	"Any",
+| 151|    |-	"Artist",
+| 152|    |-	"Album Artist",
+| 153|    |-	"Title",
+| 154|    |-	"Album",
+| 155|    |-	"Filename",
+| 156|    |-	"Composer",
+| 157|    |-	"Performer",
+| 158|    |-	"Genre",
+| 159|    |-	"Date",
+| 160|    |-	"Comment"
+|    | 148|+const char *
+|    | 149|+    SearchEngine::ConstraintsNames[] = {
+|    | 150|+    "Any",
+|    | 151|+    "Artist",
+|    | 152|+    "Album Artist",
+|    | 153|+    "Title",
+|    | 154|+    "Album",
+|    | 155|+    "Filename",
+|    | 156|+    "Composer",
+|    | 157|+    "Performer",
+|    | 158|+    "Genre",
+|    | 159|+    "Date",
+|    | 160|+    "Comment"
+| 161| 161| };
+| 162| 162| 
+| 163| 163| const char *SearchEngine::SearchModes[] =
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 160| 160| 	"Comment"
+| 161| 161| };
+| 162| 162| 
+| 163|    |-const char *SearchEngine::SearchModes[] =
+| 164|    |-{
+| 165|    |-	"Match if tag contains searched phrase (no regexes)",
+| 166|    |-	"Match if tag contains searched phrase (regexes supported)",
+| 167|    |-	"Match only if both values are the same",
+| 168|    |-	0
+|    | 163|+const char *
+|    | 164|+    SearchEngine::SearchModes[] = {
+|    | 165|+    "Match if tag contains searched phrase (no regexes)",
+|    | 166|+    "Match if tag contains searched phrase (regexes supported)",
+|    | 167|+    "Match only if both values are the same",
+|    | 168|+    0
+| 169| 169| };
+| 170| 170| 
+| 171| 171| size_t SearchEngine::StaticOptions = 20;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 168| 168| 	0
+| 169| 169| };
+| 170| 170| 
+| 171|    |-size_t SearchEngine::StaticOptions = 20;
+| 172|    |-size_t SearchEngine::ResetButton = 16;
+| 173|    |-size_t SearchEngine::SearchButton = 15;
+| 174|    |-
+| 175|    |-SearchEngine::SearchEngine()
+| 176|    |-: Screen(NC::Menu<SEItem>(0, MainStartY, COLS, MainHeight, "", Config.main_color, NC::Border()))
+| 177|    |-{
+| 178|    |-	setHighlightFixes(w);
+| 179|    |-	w.cyclicScrolling(Config.use_cyclic_scrolling);
+| 180|    |-	w.centeredCursor(Config.centered_cursor);
+| 181|    |-	w.setItemDisplayer(std::bind(Display::SEItems, ph::_1, std::cref(w)));
+| 182|    |-	w.setSelectedPrefix(Config.selected_item_prefix);
+| 183|    |-	w.setSelectedSuffix(Config.selected_item_suffix);
+| 184|    |-	SearchMode = &SearchModes[Config.search_engine_default_search_mode];
+| 185|    |-}
+| 186|    |-
+| 187|    |-void SearchEngine::resize()
+| 188|    |-{
+| 189|    |-	size_t x_offset, width;
+| 190|    |-	getWindowResizeParams(x_offset, width);
+| 191|    |-	w.resize(width, MainHeight);
+| 192|    |-	w.moveTo(x_offset, MainStartY);
+| 193|    |-	switch (Config.search_engine_display_mode)
+| 194|    |-	{
+| 195|    |-		case DisplayMode::Columns:
+| 196|    |-			if (Config.titles_visibility)
+| 197|    |-			{
+| 198|    |-				w.setTitle(Display::Columns(w.getWidth()));
+| 199|    |-				break;
+| 200|    |-			}
+| 201|    |-		case DisplayMode::Classic:
+| 202|    |-			w.setTitle("");
+| 203|    |-	}
+| 204|    |-	hasToBeResized = 0;
+| 205|    |-}
+| 206|    |-
+| 207|    |-void SearchEngine::switchTo()
+| 208|    |-{
+| 209|    |-	SwitchTo::execute(this);
+| 210|    |-	if (w.empty())
+| 211|    |-		Prepare();
+| 212|    |-	drawHeader();
+| 213|    |-}
+| 214|    |-
+| 215|    |-std::wstring SearchEngine::title()
+| 216|    |-{
+| 217|    |-	return L"Search engine";
+| 218|    |-}
+| 219|    |-
+| 220|    |-void SearchEngine::mouseButtonPressed(MEVENT me)
+| 221|    |-{
+| 222|    |-	if (w.empty() || !w.hasCoords(me.x, me.y) || size_t(me.y) >= w.size())
+| 223|    |-		return;
+| 224|    |-	if (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED))
+| 225|    |-	{
+| 226|    |-		if (!w.Goto(me.y))
+| 227|    |-			return;
+| 228|    |-		w.refresh();
+| 229|    |-		if ((me.bstate & BUTTON3_PRESSED)
+| 230|    |-		    && w.choice() < StaticOptions)
+| 231|    |-			runAction();
+| 232|    |-		else if (w.choice() >= StaticOptions)
+| 233|    |-		{
+| 234|    |-			bool play = me.bstate & BUTTON3_PRESSED;
+| 235|    |-			addItemToPlaylist(play);
+| 236|    |-		}
+| 237|    |-	}
+| 238|    |-	else
+| 239|    |-		Screen<WindowType>::mouseButtonPressed(me);
+|    | 171|+size_t
+|    | 172|+    SearchEngine::StaticOptions = 20;
+|    | 173|+size_t
+|    | 174|+    SearchEngine::ResetButton = 16;
+|    | 175|+size_t
+|    | 176|+    SearchEngine::SearchButton = 15;
+|    | 177|+
+|    | 178|+SearchEngine::SearchEngine ():Screen (NC::Menu < SEItem >
+|    | 179|+        (0, MainStartY, COLS, MainHeight, "", Config.main_color,
+|    | 180|+         NC::Border ()))
+|    | 181|+{
+|    | 182|+    setHighlightFixes (w);
+|    | 183|+    w.cyclicScrolling (Config.use_cyclic_scrolling);
+|    | 184|+    w.centeredCursor (Config.centered_cursor);
+|    | 185|+    w.setItemDisplayer (std::bind (Display::SEItems, ph::_1, std::cref (w)));
+|    | 186|+    w.setSelectedPrefix (Config.selected_item_prefix);
+|    | 187|+    w.setSelectedSuffix (Config.selected_item_suffix);
+|    | 188|+    SearchMode = &SearchModes[Config.search_engine_default_search_mode];
+|    | 189|+}
+|    | 190|+
+|    | 191|+void
+|    | 192|+SearchEngine::resize ()
+|    | 193|+{
+|    | 194|+    size_t x_offset, width;
+|    | 195|+    getWindowResizeParams (x_offset, width);
+|    | 196|+    w.resize (width, MainHeight);
+|    | 197|+    w.moveTo (x_offset, MainStartY);
+|    | 198|+    switch (Config.search_engine_display_mode)
+|    | 199|+      {
+|    | 200|+      case DisplayMode::Columns:
+|    | 201|+          if (Config.titles_visibility)
+|    | 202|+            {
+|    | 203|+                w.setTitle (Display::Columns (w.getWidth ()));
+|    | 204|+                break;
+|    | 205|+            }
+|    | 206|+      case DisplayMode::Classic:
+|    | 207|+          w.setTitle ("");
+|    | 208|+      }
+|    | 209|+    hasToBeResized = 0;
+|    | 210|+}
+|    | 211|+
+|    | 212|+void
+|    | 213|+SearchEngine::switchTo ()
+|    | 214|+{
+|    | 215|+    SwitchTo::execute (this);
+|    | 216|+    if (w.empty ())
+|    | 217|+        Prepare ();
+|    | 218|+    drawHeader ();
+|    | 219|+}
+|    | 220|+
+|    | 221|+std::wstring SearchEngine::title ()
+|    | 222|+{
+|    | 223|+    return L"Search engine";
+|    | 224|+}
+|    | 225|+
+|    | 226|+void
+|    | 227|+SearchEngine::mouseButtonPressed (MEVENT me)
+|    | 228|+{
+|    | 229|+    if (w.empty () || !w.hasCoords (me.x, me.y) || size_t (me.y) >= w.size ())
+|    | 230|+        return;
+|    | 231|+    if (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED))
+|    | 232|+      {
+|    | 233|+          if (!w.Goto (me.y))
+|    | 234|+              return;
+|    | 235|+          w.refresh ();
+|    | 236|+          if ((me.bstate & BUTTON3_PRESSED) && w.choice () < StaticOptions)
+|    | 237|+              runAction ();
+|    | 238|+          else if (w.choice () >= StaticOptions)
+|    | 239|+            {
+|    | 240|+                bool play = me.bstate & BUTTON3_PRESSED;
+|    | 241|+                addItemToPlaylist (play);
+|    | 242|+            }
+|    | 243|+      }
+|    | 244|+    else
+|    | 245|+        Screen < WindowType >::mouseButtonPressed (me);
+| 240| 246| }
+| 241| 247| 
+| 242| 248| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 241| 241| 
+| 242| 242| /***********************************************************************/
+| 243| 243| 
+| 244|    |-bool SearchEngine::allowsSearching()
+| 245|    |-{
+| 246|    |-	return w.rbegin()->value().isSong();
+| 247|    |-}
+| 248|    |-
+| 249|    |-const std::string &SearchEngine::searchConstraint()
+| 250|    |-{
+| 251|    |-	return m_search_predicate.constraint();
+| 252|    |-}
+| 253|    |-
+| 254|    |-void SearchEngine::setSearchConstraint(const std::string &constraint)
+| 255|    |-{
+| 256|    |-	m_search_predicate = Regex::ItemFilter<SEItem>(
+| 257|    |-		constraint,
+| 258|    |-		Config.regex_type,
+| 259|    |-		std::bind(SEItemEntryMatcher, ph::_1, ph::_2, false));
+| 260|    |-}
+| 261|    |-
+| 262|    |-void SearchEngine::clearSearchConstraint()
+| 263|    |-{
+| 264|    |-	m_search_predicate.clear();
+| 265|    |-}
+| 266|    |-
+| 267|    |-bool SearchEngine::search(SearchDirection direction, bool wrap, bool skip_current)
+| 268|    |-{
+| 269|    |-	return ::search(w, m_search_predicate, direction, wrap, skip_current);
+|    | 244|+bool
+|    | 245|+SearchEngine::allowsSearching ()
+|    | 246|+{
+|    | 247|+    return w.rbegin ()->value ().isSong ();
+|    | 248|+}
+|    | 249|+
+|    | 250|+const
+|    | 251|+    std::string &
+|    | 252|+SearchEngine::searchConstraint ()
+|    | 253|+{
+|    | 254|+    return m_search_predicate.constraint ();
+|    | 255|+}
+|    | 256|+
+|    | 257|+void
+|    | 258|+SearchEngine::setSearchConstraint (const std::string & constraint)
+|    | 259|+{
+|    | 260|+    m_search_predicate = Regex::ItemFilter < SEItem > (constraint,
+|    | 261|+                                                       Config.regex_type,
+|    | 262|+                                                       std::
+|    | 263|+                                                       bind
+|    | 264|+                                                       (SEItemEntryMatcher,
+|    | 265|+                                                        ph::_1, ph::_2,
+|    | 266|+                                                        false));
+|    | 267|+}
+|    | 268|+
+|    | 269|+void
+|    | 270|+SearchEngine::clearSearchConstraint ()
+|    | 271|+{
+|    | 272|+    m_search_predicate.clear ();
+|    | 273|+}
+|    | 274|+
+|    | 275|+bool
+|    | 276|+SearchEngine::search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 277|+{
+|    | 278|+    return::search (w, m_search_predicate, direction, wrap, skip_current);
+| 270| 279| }
+| 271| 280| 
+| 272| 281| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 271| 271| 
+| 272| 272| /***********************************************************************/
+| 273| 273| 
+| 274|    |-bool SearchEngine::allowsFiltering()
+| 275|    |-{
+| 276|    |-	return allowsSearching();
+| 277|    |-}
+| 278|    |-
+| 279|    |-std::string SearchEngine::currentFilter()
+| 280|    |-{
+| 281|    |-	std::string result;
+| 282|    |-	if (auto pred = w.filterPredicate<Regex::ItemFilter<SEItem>>())
+| 283|    |-		result = pred->constraint();
+| 284|    |-	return result;
+| 285|    |-}
+| 286|    |-
+| 287|    |-void SearchEngine::applyFilter(const std::string &constraint)
+| 288|    |-{
+| 289|    |-	if (!constraint.empty())
+| 290|    |-	{
+| 291|    |-		w.applyFilter(Regex::ItemFilter<SEItem>(
+| 292|    |-			              constraint,
+| 293|    |-			              Config.regex_type,
+| 294|    |-			              std::bind(SEItemEntryMatcher, ph::_1, ph::_2, true)));
+| 295|    |-	}
+| 296|    |-	else
+| 297|    |-		w.clearFilter();
+|    | 274|+bool
+|    | 275|+SearchEngine::allowsFiltering ()
+|    | 276|+{
+|    | 277|+    return allowsSearching ();
+|    | 278|+}
+|    | 279|+
+|    | 280|+std::string SearchEngine::currentFilter ()
+|    | 281|+{
+|    | 282|+    std::string result;
+|    | 283|+    if (auto pred = w.filterPredicate < Regex::ItemFilter < SEItem >> ())
+|    | 284|+        result = pred->constraint ();
+|    | 285|+    return result;
+|    | 286|+}
+|    | 287|+
+|    | 288|+void
+|    | 289|+SearchEngine::applyFilter (const std::string & constraint)
+|    | 290|+{
+|    | 291|+    if (!constraint.empty ())
+|    | 292|+      {
+|    | 293|+          w.applyFilter (Regex::ItemFilter < SEItem > (constraint,
+|    | 294|+                                                       Config.regex_type,
+|    | 295|+                                                       std::
+|    | 296|+                                                       bind
+|    | 297|+                                                       (SEItemEntryMatcher,
+|    | 298|+                                                        ph::_1, ph::_2,
+|    | 299|+                                                        true)));
+|    | 300|+      }
+|    | 301|+    else
+|    | 302|+        w.clearFilter ();
+| 298| 303| }
+| 299| 304| 
+| 300| 305| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 299| 299| 
+| 300| 300| /***********************************************************************/
+| 301| 301| 
+| 302|    |-bool SearchEngine::actionRunnable()
+| 303|    |-{
+| 304|    |-	return !w.empty() && !w.current()->value().isSong();
+| 305|    |-}
+| 306|    |-
+| 307|    |-void SearchEngine::runAction()
+| 308|    |-{
+| 309|    |-	size_t option = w.choice();
+| 310|    |-	if (option > ConstraintsNumber && option < SearchButton)
+| 311|    |-		w.current()->value().buffer().clear();
+| 312|    |-
+| 313|    |-	if (option < ConstraintsNumber)
+| 314|    |-	{
+| 315|    |-		Statusbar::ScopedLock slock;
+| 316|    |-		std::string constraint = ConstraintsNames[option];
+| 317|    |-		Statusbar::put() << NC::Format::Bold << constraint << NC::Format::NoBold << ": ";
+| 318|    |-		itsConstraints[option] = Global::wFooter->prompt(itsConstraints[option]);
+| 319|    |-		w.current()->value().buffer().clear();
+| 320|    |-		constraint.resize(13, ' ');
+| 321|    |-		w.current()->value().buffer() << NC::Format::Bold << constraint << NC::Format::NoBold << ": ";
+| 322|    |-		ShowTag(w.current()->value().buffer(), itsConstraints[option]);
+| 323|    |-	}
+| 324|    |-	else if (option == ConstraintsNumber+1)
+| 325|    |-	{
+| 326|    |-		Config.search_in_db = !Config.search_in_db;
+| 327|    |-		w.current()->value().buffer() << NC::Format::Bold << "Search in:" << NC::Format::NoBold << ' ' << (Config.search_in_db ? "Database" : "Current playlist");
+| 328|    |-	}
+| 329|    |-	else if (option == ConstraintsNumber+2)
+| 330|    |-	{
+| 331|    |-		if (!*++SearchMode)
+| 332|    |-			SearchMode = &SearchModes[0];
+| 333|    |-		w.current()->value().buffer() << NC::Format::Bold << "Search mode:" << NC::Format::NoBold << ' ' << *SearchMode;
+| 334|    |-	}
+| 335|    |-	else if (option == SearchButton)
+| 336|    |-	{
+| 337|    |-		w.clearFilter();
+| 338|    |-		Statusbar::print("Searching...");
+| 339|    |-		if (w.size() > StaticOptions)
+| 340|    |-			Prepare();
+| 341|    |-		Search();
+| 342|    |-		if (w.rbegin()->value().isSong())
+| 343|    |-		{
+| 344|    |-			if (Config.search_engine_display_mode == DisplayMode::Columns)
+| 345|    |-				w.setTitle(Config.titles_visibility ? Display::Columns(w.getWidth()) : "");
+| 346|    |-			size_t found = w.size()-SearchEngine::StaticOptions;
+| 347|    |-			found += 3; // don't count options inserted below
+| 348|    |-			w.insertSeparator(ResetButton+1);
+| 349|    |-			w.insertItem(ResetButton+2, SEItem(), NC::List::Properties::Inactive);
+| 350|    |-			w.at(ResetButton+2).value().mkBuffer()
+| 351|    |-				<< NC::Format::Bold
+| 352|    |-				<< Config.color1
+| 353|    |-				<< "Search results: "
+| 354|    |-				<< NC::FormattedColor::End<>(Config.color1)
+| 355|    |-				<< Config.color2
+| 356|    |-				<< "Found " << found << (found > 1 ? " songs" : " song")
+| 357|    |-				<< NC::FormattedColor::End<>(Config.color2)
+| 358|    |-				<< NC::Format::NoBold;
+| 359|    |-			w.insertSeparator(ResetButton+3);
+| 360|    |-				Statusbar::print("Searching finished");
+| 361|    |-			if (Config.block_search_constraints_change)
+| 362|    |-				for (size_t i = 0; i < StaticOptions-4; ++i)
+| 363|    |-					w.at(i).setInactive(true);
+| 364|    |-			w.scroll(NC::Scroll::Down);
+| 365|    |-			w.scroll(NC::Scroll::Down);
+| 366|    |-		}
+| 367|    |-		else
+| 368|    |-			Statusbar::print("No results found");
+| 369|    |-	}
+| 370|    |-	else if (option == ResetButton)
+| 371|    |-	{
+| 372|    |-		reset();
+| 373|    |-	}
+| 374|    |-	else
+| 375|    |-		addSongToPlaylist(w.current()->value().song(), true);
+|    | 302|+bool
+|    | 303|+SearchEngine::actionRunnable ()
+|    | 304|+{
+|    | 305|+    return !w.empty () && !w.current ()->value ().isSong ();
+|    | 306|+}
+|    | 307|+
+|    | 308|+void
+|    | 309|+SearchEngine::runAction ()
+|    | 310|+{
+|    | 311|+    size_t option = w.choice ();
+|    | 312|+    if (option > ConstraintsNumber && option < SearchButton)
+|    | 313|+        w.current ()->value ().buffer ().clear ();
+|    | 314|+
+|    | 315|+    if (option < ConstraintsNumber)
+|    | 316|+      {
+|    | 317|+          Statusbar::ScopedLock slock;
+|    | 318|+          std::string constraint = ConstraintsNames[option];
+|    | 319|+          Statusbar::put () << NC::Format::Bold << constraint << NC::Format::
+|    | 320|+              NoBold << ": ";
+|    | 321|+          itsConstraints[option] =
+|    | 322|+              Global::wFooter->prompt (itsConstraints[option]);
+|    | 323|+          w.current ()->value ().buffer ().clear ();
+|    | 324|+          constraint.resize (13, ' ');
+|    | 325|+          w.current ()->value ().
+|    | 326|+              buffer () << NC::Format::Bold << constraint << NC::Format::
+|    | 327|+              NoBold << ": ";
+|    | 328|+          ShowTag (w.current ()->value ().buffer (), itsConstraints[option]);
+|    | 329|+      }
+|    | 330|+    else if (option == ConstraintsNumber + 1)
+|    | 331|+      {
+|    | 332|+          Config.search_in_db = !Config.search_in_db;
+|    | 333|+          w.current ()->value ().
+|    | 334|+              buffer () << NC::Format::Bold << "Search in:" << NC::Format::
+|    | 335|+              NoBold << ' ' << (Config.
+|    | 336|+                                search_in_db ? "Database" :
+|    | 337|+                                "Current playlist");
+|    | 338|+      }
+|    | 339|+    else if (option == ConstraintsNumber + 2)
+|    | 340|+      {
+|    | 341|+          if (!*++SearchMode)
+|    | 342|+              SearchMode = &SearchModes[0];
+|    | 343|+          w.current ()->value ().
+|    | 344|+              buffer () << NC::Format::Bold << "Search mode:" << NC::Format::
+|    | 345|+              NoBold << ' ' << *SearchMode;
+|    | 346|+      }
+|    | 347|+    else if (option == SearchButton)
+|    | 348|+      {
+|    | 349|+          w.clearFilter ();
+|    | 350|+          Statusbar::print ("Searching...");
+|    | 351|+          if (w.size () > StaticOptions)
+|    | 352|+              Prepare ();
+|    | 353|+          Search ();
+|    | 354|+          if (w.rbegin ()->value ().isSong ())
+|    | 355|+            {
+|    | 356|+                if (Config.search_engine_display_mode == DisplayMode::Columns)
+|    | 357|+                    w.setTitle (Config.
+|    | 358|+                                titles_visibility ? Display::Columns (w.
+|    | 359|+                                                                      getWidth
+|    | 360|+                                                                      ()) :
+|    | 361|+                                "");
+|    | 362|+                size_t found = w.size () - SearchEngine::StaticOptions;
+|    | 363|+                found += 3;     // don't count options inserted below
+|    | 364|+                w.insertSeparator (ResetButton + 1);
+|    | 365|+                w.insertItem (ResetButton + 2, SEItem (),
+|    | 366|+                              NC::List::Properties::Inactive);
+|    | 367|+                w.at (ResetButton +
+|    | 368|+                      2).value ().mkBuffer () << NC::Format::Bold << Config.
+|    | 369|+                    color1 << "Search results: " << NC::FormattedColor::
+|    | 370|+                    End <> (Config.color1) << Config.
+|    | 371|+                    color2 << "Found " << found << (found >
+|    | 372|+                                                    1 ? " songs" : " song") <<
+|    | 373|+                    NC::FormattedColor::End <> (Config.
+|    | 374|+                                                color2) << NC::Format::NoBold;
+|    | 375|+                w.insertSeparator (ResetButton + 3);
+|    | 376|+                Statusbar::print ("Searching finished");
+|    | 377|+                if (Config.block_search_constraints_change)
+|    | 378|+                    for (size_t i = 0; i < StaticOptions - 4; ++i)
+|    | 379|+                        w.at (i).setInactive (true);
+|    | 380|+                w.scroll (NC::Scroll::Down);
+|    | 381|+                w.scroll (NC::Scroll::Down);
+|    | 382|+            }
+|    | 383|+          else
+|    | 384|+              Statusbar::print ("No results found");
+|    | 385|+      }
+|    | 386|+    else if (option == ResetButton)
+|    | 387|+      {
+|    | 388|+          reset ();
+|    | 389|+      }
+|    | 390|+    else
+|    | 391|+        addSongToPlaylist (w.current ()->value ().song (), true);
+| 376| 392| }
+| 377| 393| 
+| 378| 394| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 377| 377| 
+| 378| 378| /***********************************************************************/
+| 379| 379| 
+| 380|    |-bool SearchEngine::itemAvailable()
+| 381|    |-{
+| 382|    |-	return !w.empty() && w.current()->value().isSong();
+| 383|    |-}
+| 384|    |-
+| 385|    |-bool SearchEngine::addItemToPlaylist(bool play)
+| 386|    |-{
+| 387|    |-	return addSongToPlaylist(w.current()->value().song(), play);
+| 388|    |-}
+| 389|    |-
+| 390|    |-std::vector<MPD::Song> SearchEngine::getSelectedSongs()
+| 391|    |-{
+| 392|    |-	return w.getSelectedSongs();
+|    | 380|+bool
+|    | 381|+SearchEngine::itemAvailable ()
+|    | 382|+{
+|    | 383|+    return !w.empty () && w.current ()->value ().isSong ();
+|    | 384|+}
+|    | 385|+
+|    | 386|+bool
+|    | 387|+SearchEngine::addItemToPlaylist (bool play)
+|    | 388|+{
+|    | 389|+    return addSongToPlaylist (w.current ()->value ().song (), play);
+|    | 390|+}
+|    | 391|+
+|    | 392|+std::vector < MPD::Song > SearchEngine::getSelectedSongs ()
+|    | 393|+{
+|    | 394|+    return w.getSelectedSongs ();
+| 393| 395| }
+| 394| 396| 
+| 395| 397| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/search_engine.cpp
+|    |++++| /app/src/screens/search_engine.cpp
+| 394| 394| 
+| 395| 395| /***********************************************************************/
+| 396| 396| 
+| 397|    |-void SearchEngine::Prepare()
+| 398|    |-{
+| 399|    |-	w.setTitle("");
+| 400|    |-	w.clear();
+| 401|    |-	w.resizeList(StaticOptions-3);
+| 402|    |-
+| 403|    |-	for (auto &item : w)
+| 404|    |-		item.setSelectable(false);
+| 405|    |-	
+| 406|    |-	w.at(ConstraintsNumber).setSeparator(true);
+| 407|    |-	w.at(SearchButton-1).setSeparator(true);
+| 408|    |-	
+| 409|    |-	for (size_t i = 0; i < ConstraintsNumber; ++i)
+| 410|    |-	{
+| 411|    |-		std::string constraint = ConstraintsNames[i];
+| 412|    |-		constraint.resize(13, ' ');
+| 413|    |-		w[i].value().mkBuffer() << NC::Format::Bold << constraint << NC::Format::NoBold << ": ";
+| 414|    |-		ShowTag(w[i].value().buffer(), itsConstraints[i]);
+| 415|    |-	}
+| 416|    |-	
+| 417|    |-	w.at(ConstraintsNumber+1).value().mkBuffer() << NC::Format::Bold << "Search in:" << NC::Format::NoBold << ' ' << (Config.search_in_db ? "Database" : "Current playlist");
+| 418|    |-	w.at(ConstraintsNumber+2).value().mkBuffer() << NC::Format::Bold << "Search mode:" << NC::Format::NoBold << ' ' << *SearchMode;
+| 419|    |-	
+| 420|    |-	w.at(SearchButton).value().mkBuffer() << "Search";
+| 421|    |-	w.at(ResetButton).value().mkBuffer() << "Reset";
+| 422|    |-}
+| 423|    |-
+| 424|    |-void SearchEngine::reset()
+| 425|    |-{
+| 426|    |-	for (size_t i = 0; i < ConstraintsNumber; ++i)
+| 427|    |-		itsConstraints[i].clear();
+| 428|    |-	w.reset();
+| 429|    |-	Prepare();
+| 430|    |-	Statusbar::print("Search state reset");
+| 431|    |-}
+| 432|    |-
+| 433|    |-void SearchEngine::Search()
+| 434|    |-{
+| 435|    |-	bool constraints_empty = 1;
+| 436|    |-	for (size_t i = 0; i < ConstraintsNumber; ++i)
+| 437|    |-	{
+| 438|    |-		if (!itsConstraints[i].empty())
+| 439|    |-		{
+| 440|    |-			constraints_empty = 0;
+| 441|    |-			break;
+| 442|    |-		}
+| 443|    |-	}
+| 444|    |-	if (constraints_empty)
+| 445|    |-		return;
+| 446|    |-	
+| 447|    |-	if (Config.search_in_db && (SearchMode == &SearchModes[0] || SearchMode == &SearchModes[2])) // use built-in mpd searching
+| 448|    |-	{
+| 449|    |-		Mpd.StartSearch(SearchMode == &SearchModes[2]);
+| 450|    |-		if (!itsConstraints[0].empty())
+| 451|    |-			Mpd.AddSearchAny(itsConstraints[0]);
+| 452|    |-		if (!itsConstraints[1].empty())
+| 453|    |-			Mpd.AddSearch(MPD_TAG_ARTIST, itsConstraints[1]);
+| 454|    |-		if (!itsConstraints[2].empty())
+| 455|    |-			Mpd.AddSearch(MPD_TAG_ALBUM_ARTIST, itsConstraints[2]);
+| 456|    |-		if (!itsConstraints[3].empty())
+| 457|    |-			Mpd.AddSearch(MPD_TAG_TITLE, itsConstraints[3]);
+| 458|    |-		if (!itsConstraints[4].empty())
+| 459|    |-			Mpd.AddSearch(MPD_TAG_ALBUM, itsConstraints[4]);
+| 460|    |-		if (!itsConstraints[5].empty())
+| 461|    |-			Mpd.AddSearchURI(itsConstraints[5]);
+| 462|    |-		if (!itsConstraints[6].empty())
+| 463|    |-			Mpd.AddSearch(MPD_TAG_COMPOSER, itsConstraints[6]);
+| 464|    |-		if (!itsConstraints[7].empty())
+| 465|    |-			Mpd.AddSearch(MPD_TAG_PERFORMER, itsConstraints[7]);
+| 466|    |-		if (!itsConstraints[8].empty())
+| 467|    |-			Mpd.AddSearch(MPD_TAG_GENRE, itsConstraints[8]);
+| 468|    |-		if (!itsConstraints[9].empty())
+| 469|    |-			Mpd.AddSearch(MPD_TAG_DATE, itsConstraints[9]);
+| 470|    |-		if (!itsConstraints[10].empty())
+| 471|    |-			Mpd.AddSearch(MPD_TAG_COMMENT, itsConstraints[10]);
+| 472|    |-		for (MPD::SongIterator s = Mpd.CommitSearchSongs(), end; s != end; ++s)
+| 473|    |-			w.addItem(std::move(*s));
+| 474|    |-		return;
+| 475|    |-	}
+| 476|    |-
+| 477|    |-	Regex::Regex rx[ConstraintsNumber];
+| 478|    |-	if (SearchMode != &SearchModes[2]) // match to pattern
+| 479|    |-	{
+| 480|    |-		for (size_t i = 0; i < ConstraintsNumber; ++i)
+| 481|    |-		{
+| 482|    |-			if (!itsConstraints[i].empty())
+| 483|    |-			{
+| 484|    |-				try
+| 485|    |-				{
+| 486|    |-					rx[i] = Regex::make(itsConstraints[i], Config.regex_type);
+| 487|    |-				}
+| 488|    |-				catch (boost::bad_expression &) { }
+| 489|    |-			}
+| 490|    |-		}
+| 491|    |-	}
+| 492|    |-
+| 493|    |-	typedef boost::range_detail::any_iterator<
+| 494|    |-		const MPD::Song,
+| 495|    |-		boost::single_pass_traversal_tag,
+| 496|    |-		const MPD::Song &,
+| 497|    |-		std::ptrdiff_t
+| 498|    |-	> input_song_iterator;
+| 499|    |-	input_song_iterator s, end;
+| 500|    |-	if (Config.search_in_db)
+| 501|    |-	{
+| 502|    |-		s = input_song_iterator(getDatabaseIterator(Mpd));
+| 503|    |-		end = input_song_iterator(MPD::SongIterator());
+| 504|    |-	}
+| 505|    |-	else
+| 506|    |-	{
+| 507|    |-		s = input_song_iterator(myPlaylist->main().beginV());
+| 508|    |-		end = input_song_iterator(myPlaylist->main().endV());
+| 509|    |-	}
+| 510|    |-
+| 511|    |-	LocaleStringComparison cmp(std::locale(), Config.ignore_leading_the);
+| 512|    |-	for (; s != end; ++s)
+| 513|    |-	{
+| 514|    |-		bool any_found = true, found = true;
+| 515|    |-
+| 516|    |-		if (SearchMode != &SearchModes[2]) // match to pattern
+| 517|    |-		{
+| 518|    |-			if (!rx[0].empty())
+| 519|    |-				any_found =
+| 520|    |-					   Regex::search(s->getArtist(), rx[0], Config.ignore_diacritics)
+| 521|    |-					|| Regex::search(s->getAlbumArtist(), rx[0], Config.ignore_diacritics)
+| 522|    |-					|| Regex::search(s->getTitle(), rx[0], Config.ignore_diacritics)
+| 523|    |-					|| Regex::search(s->getAlbum(), rx[0], Config.ignore_diacritics)
+| 524|    |-					|| Regex::search(s->getName(), rx[0], Config.ignore_diacritics)
+| 525|    |-					|| Regex::search(s->getComposer(), rx[0], Config.ignore_diacritics)
+| 526|    |-					|| Regex::search(s->getPerformer(), rx[0], Config.ignore_diacritics)
+| 527|    |-					|| Regex::search(s->getGenre(), rx[0], Config.ignore_diacritics)
+| 528|    |-					|| Regex::search(s->getDate(), rx[0], Config.ignore_diacritics)
+| 529|    |-					|| Regex::search(s->getComment(), rx[0], Config.ignore_diacritics);
+| 530|    |-			if (found && !rx[1].empty())
+| 531|    |-				found = Regex::search(s->getArtist(), rx[1], Config.ignore_diacritics);
+| 532|    |-			if (found && !rx[2].empty())
+| 533|    |-				found = Regex::search(s->getAlbumArtist(), rx[2], Config.ignore_diacritics);
+| 534|    |-			if (found && !rx[3].empty())
+| 535|    |-				found = Regex::search(s->getTitle(), rx[3], Config.ignore_diacritics);
+| 536|    |-			if (found && !rx[4].empty())
+| 537|    |-				found = Regex::search(s->getAlbum(), rx[4], Config.ignore_diacritics);
+| 538|    |-			if (found && !rx[5].empty())
+| 539|    |-				found = Regex::search(s->getName(), rx[5], Config.ignore_diacritics);
+| 540|    |-			if (found && !rx[6].empty())
+| 541|    |-				found = Regex::search(s->getComposer(), rx[6], Config.ignore_diacritics);
+| 542|    |-			if (found && !rx[7].empty())
+| 543|    |-				found = Regex::search(s->getPerformer(), rx[7], Config.ignore_diacritics);
+| 544|    |-			if (found && !rx[8].empty())
+| 545|    |-				found = Regex::search(s->getGenre(), rx[8], Config.ignore_diacritics);
+| 546|    |-			if (found && !rx[9].empty())
+| 547|    |-				found = Regex::search(s->getDate(), rx[9], Config.ignore_diacritics);
+| 548|    |-			if (found && !rx[10].empty())
+| 549|    |-				found = Regex::search(s->getComment(), rx[10], Config.ignore_diacritics);
+| 550|    |-		}
+| 551|    |-		else // match only if values are equal
+| 552|    |-		{
+| 553|    |-			if (!itsConstraints[0].empty())
+| 554|    |-				any_found =
+| 555|    |-				   !cmp(s->getArtist(), itsConstraints[0])
+| 556|    |-				|| !cmp(s->getAlbumArtist(), itsConstraints[0])
+| 557|    |-				|| !cmp(s->getTitle(), itsConstraints[0])
+| 558|    |-				|| !cmp(s->getAlbum(), itsConstraints[0])
+| 559|    |-				|| !cmp(s->getName(), itsConstraints[0])
+| 560|    |-				|| !cmp(s->getComposer(), itsConstraints[0])
+| 561|    |-				|| !cmp(s->getPerformer(), itsConstraints[0])
+| 562|    |-				|| !cmp(s->getGenre(), itsConstraints[0])
+| 563|    |-				|| !cmp(s->getDate(), itsConstraints[0])
+| 564|    |-				|| !cmp(s->getComment(), itsConstraints[0]);
+| 565|    |-			
+| 566|    |-			if (found && !itsConstraints[1].empty())
+| 567|    |-				found = !cmp(s->getArtist(), itsConstraints[1]);
+| 568|    |-			if (found && !itsConstraints[2].empty())
+| 569|    |-				found = !cmp(s->getAlbumArtist(), itsConstraints[2]);
+| 570|    |-			if (found && !itsConstraints[3].empty())
+| 571|    |-				found = !cmp(s->getTitle(), itsConstraints[3]);
+| 572|    |-			if (found && !itsConstraints[4].empty())
+| 573|    |-				found = !cmp(s->getAlbum(), itsConstraints[4]);
+| 574|    |-			if (found && !itsConstraints[5].empty())
+| 575|    |-				found = !cmp(s->getName(), itsConstraints[5]);
+| 576|    |-			if (found && !itsConstraints[6].empty())
+| 577|    |-				found = !cmp(s->getComposer(), itsConstraints[6]);
+| 578|    |-			if (found && !itsConstraints[7].empty())
+| 579|    |-				found = !cmp(s->getPerformer(), itsConstraints[7]);
+| 580|    |-			if (found && !itsConstraints[8].empty())
+| 581|    |-				found = !cmp(s->getGenre(), itsConstraints[8]);
+| 582|    |-			if (found && !itsConstraints[9].empty())
+| 583|    |-				found = !cmp(s->getDate(), itsConstraints[9]);
+| 584|    |-			if (found && !itsConstraints[10].empty())
+| 585|    |-				found = !cmp(s->getComment(), itsConstraints[10]);
+| 586|    |-		}
+| 587|    |-		
+| 588|    |-		if (any_found && found)
+| 589|    |-			w.addItem(*s);
+| 590|    |-	}
+| 591|    |-}
+| 592|    |-
+| 593|    |-namespace {
+| 594|    |-
+| 595|    |-std::string SEItemToString(const SEItem &ei)
+| 596|    |-{
+| 597|    |-	std::string result;
+| 598|    |-	if (ei.isSong())
+| 599|    |-	{
+| 600|    |-		switch (Config.search_engine_display_mode)
+| 601|    |-		{
+| 602|    |-			case DisplayMode::Classic:
+| 603|    |-				result = Format::stringify<char>(Config.song_list_format, &ei.song());
+| 604|    |-				break;
+| 605|    |-			case DisplayMode::Columns:
+| 606|    |-				result = Format::stringify<char>(Config.song_columns_mode_format, &ei.song());
+| 607|    |-				break;
+| 608|    |-		}
+| 609|    |-	}
+| 610|    |-	else
+| 611|    |-		result = ei.buffer().str();
+| 612|    |-	return result;
+| 613|    |-}
+| 614|    |-
+| 615|    |-bool SEItemEntryMatcher(const Regex::Regex &rx, const NC::Menu<SEItem>::Item &item, bool filter)
+| 616|    |-{
+| 617|    |-	if (item.isSeparator() || !item.value().isSong())
+| 618|    |-		return filter;
+| 619|    |-	return Regex::search(SEItemToString(item.value()), rx, Config.ignore_diacritics);
+| 620|    |-}
+| 621|    |-
+| 622|    |-}
+|    | 397|+void
+|    | 398|+SearchEngine::Prepare ()
+|    | 399|+{
+|    | 400|+    w.setTitle ("");
+|    | 401|+    w.clear ();
+|    | 402|+    w.resizeList (StaticOptions - 3);
+|    | 403|+
+|    | 404|+  for (auto & item:w)
+|    | 405|+        item.setSelectable (false);
+|    | 406|+
+|    | 407|+    w.at (ConstraintsNumber).setSeparator (true);
+|    | 408|+    w.at (SearchButton - 1).setSeparator (true);
+|    | 409|+
+|    | 410|+    for (size_t i = 0; i < ConstraintsNumber; ++i)
+|    | 411|+      {
+|    | 412|+          std::string constraint = ConstraintsNames[i];
+|    | 413|+          constraint.resize (13, ' ');
+|    | 414|+          w[i].value ().
+|    | 415|+              mkBuffer () << NC::Format::Bold << constraint << NC::Format::
+|    | 416|+              NoBold << ": ";
+|    | 417|+          ShowTag (w[i].value ().buffer (), itsConstraints[i]);
+|    | 418|+      }
+|    | 419|+
+|    | 420|+    w.at (ConstraintsNumber +
+|    | 421|+          1).value ().
+|    | 422|+        mkBuffer () << NC::Format::Bold << "Search in:" << NC::Format::
+|    | 423|+        NoBold << ' ' << (Config.
+|    | 424|+                          search_in_db ? "Database" : "Current playlist");
+|    | 425|+    w.at (ConstraintsNumber +
+|    | 426|+          2).value ().
+|    | 427|+        mkBuffer () << NC::Format::Bold << "Search mode:" << NC::Format::
+|    | 428|+        NoBold << ' ' << *SearchMode;
+|    | 429|+
+|    | 430|+    w.at (SearchButton).value ().mkBuffer () << "Search";
+|    | 431|+    w.at (ResetButton).value ().mkBuffer () << "Reset";
+|    | 432|+}
+|    | 433|+
+|    | 434|+void
+|    | 435|+SearchEngine::reset ()
+|    | 436|+{
+|    | 437|+    for (size_t i = 0; i < ConstraintsNumber; ++i)
+|    | 438|+        itsConstraints[i].clear ();
+|    | 439|+    w.reset ();
+|    | 440|+    Prepare ();
+|    | 441|+    Statusbar::print ("Search state reset");
+|    | 442|+}
+|    | 443|+
+|    | 444|+void
+|    | 445|+SearchEngine::Search ()
+|    | 446|+{
+|    | 447|+    bool constraints_empty = 1;
+|    | 448|+    for (size_t i = 0; i < ConstraintsNumber; ++i)
+|    | 449|+      {
+|    | 450|+          if (!itsConstraints[i].empty ())
+|    | 451|+            {
+|    | 452|+                constraints_empty = 0;
+|    | 453|+                break;
+|    | 454|+            }
+|    | 455|+      }
+|    | 456|+    if (constraints_empty)
+|    | 457|+        return;
+|    | 458|+
+|    | 459|+    if (Config.search_in_db && (SearchMode == &SearchModes[0] || SearchMode == &SearchModes[2]))    // use built-in mpd searching
+|    | 460|+      {
+|    | 461|+          Mpd.StartSearch (SearchMode == &SearchModes[2]);
+|    | 462|+          if (!itsConstraints[0].empty ())
+|    | 463|+              Mpd.AddSearchAny (itsConstraints[0]);
+|    | 464|+          if (!itsConstraints[1].empty ())
+|    | 465|+              Mpd.AddSearch (MPD_TAG_ARTIST, itsConstraints[1]);
+|    | 466|+          if (!itsConstraints[2].empty ())
+|    | 467|+              Mpd.AddSearch (MPD_TAG_ALBUM_ARTIST, itsConstraints[2]);
+|    | 468|+          if (!itsConstraints[3].empty ())
+|    | 469|+              Mpd.AddSearch (MPD_TAG_TITLE, itsConstraints[3]);
+|    | 470|+          if (!itsConstraints[4].empty ())
+|    | 471|+              Mpd.AddSearch (MPD_TAG_ALBUM, itsConstraints[4]);
+|    | 472|+          if (!itsConstraints[5].empty ())
+|    | 473|+              Mpd.AddSearchURI (itsConstraints[5]);
+|    | 474|+          if (!itsConstraints[6].empty ())
+|    | 475|+              Mpd.AddSearch (MPD_TAG_COMPOSER, itsConstraints[6]);
+|    | 476|+          if (!itsConstraints[7].empty ())
+|    | 477|+              Mpd.AddSearch (MPD_TAG_PERFORMER, itsConstraints[7]);
+|    | 478|+          if (!itsConstraints[8].empty ())
+|    | 479|+              Mpd.AddSearch (MPD_TAG_GENRE, itsConstraints[8]);
+|    | 480|+          if (!itsConstraints[9].empty ())
+|    | 481|+              Mpd.AddSearch (MPD_TAG_DATE, itsConstraints[9]);
+|    | 482|+          if (!itsConstraints[10].empty ())
+|    | 483|+              Mpd.AddSearch (MPD_TAG_COMMENT, itsConstraints[10]);
+|    | 484|+          for (MPD::SongIterator s = Mpd.CommitSearchSongs (), end; s != end;
+|    | 485|+               ++s)
+|    | 486|+              w.addItem (std::move (*s));
+|    | 487|+          return;
+|    | 488|+      }
+|    | 489|+
+|    | 490|+    Regex::Regex rx[ConstraintsNumber];
+|    | 491|+    if (SearchMode != &SearchModes[2])  // match to pattern
+|    | 492|+      {
+|    | 493|+          for (size_t i = 0; i < ConstraintsNumber; ++i)
+|    | 494|+            {
+|    | 495|+                if (!itsConstraints[i].empty ())
+|    | 496|+                  {
+|    | 497|+                      try
+|    | 498|+                      {
+|    | 499|+                          rx[i] =
+|    | 500|+                              Regex::make (itsConstraints[i],
+|    | 501|+                                           Config.regex_type);
+|    | 502|+                      }
+|    | 503|+                      catch (boost::bad_expression &)
+|    | 504|+                      {
+|    | 505|+                      }
+|    | 506|+                  }
+|    | 507|+            }
+|    | 508|+      }
+|    | 509|+
+|    | 510|+    typedef boost::range_detail::any_iterator <
+|    | 511|+        const MPD::Song,
+|    | 512|+        boost::single_pass_traversal_tag,
+|    | 513|+        const MPD::Song &, std::ptrdiff_t > input_song_iterator;
+|    | 514|+    input_song_iterator s, end;
+|    | 515|+    if (Config.search_in_db)
+|    | 516|+      {
+|    | 517|+          s = input_song_iterator (getDatabaseIterator (Mpd));
+|    | 518|+          end = input_song_iterator (MPD::SongIterator ());
+|    | 519|+      }
+|    | 520|+    else
+|    | 521|+      {
+|    | 522|+          s = input_song_iterator (myPlaylist->main ().beginV ());
+|    | 523|+          end = input_song_iterator (myPlaylist->main ().endV ());
+|    | 524|+      }
+|    | 525|+
+|    | 526|+    LocaleStringComparison cmp (std::locale (), Config.ignore_leading_the);
+|    | 527|+    for (; s != end; ++s)
+|    | 528|+      {
+|    | 529|+          bool any_found = true, found = true;
+|    | 530|+
+|    | 531|+          if (SearchMode != &SearchModes[2])    // match to pattern
+|    | 532|+            {
+|    | 533|+                if (!rx[0].empty ())
+|    | 534|+                    any_found =
+|    | 535|+                        Regex::search (s->getArtist (), rx[0],
+|    | 536|+                                       Config.ignore_diacritics)
+|    | 537|+                        || Regex::search (s->getAlbumArtist (), rx[0],
+|    | 538|+                                          Config.ignore_diacritics)
+|    | 539|+                        || Regex::search (s->getTitle (), rx[0],
+|    | 540|+                                          Config.ignore_diacritics)
+|    | 541|+                        || Regex::search (s->getAlbum (), rx[0],
+|    | 542|+                                          Config.ignore_diacritics)
+|    | 543|+                        || Regex::search (s->getName (), rx[0],
+|    | 544|+                                          Config.ignore_diacritics)
+|    | 545|+                        || Regex::search (s->getComposer (), rx[0],
+|    | 546|+                                          Config.ignore_diacritics)
+|    | 547|+                        || Regex::search (s->getPerformer (), rx[0],
+|    | 548|+                                          Config.ignore_diacritics)
+|    | 549|+                        || Regex::search (s->getGenre (), rx[0],
+|    | 550|+                                          Config.ignore_diacritics)
+|    | 551|+                        || Regex::search (s->getDate (), rx[0],
+|    | 552|+                                          Config.ignore_diacritics)
+|    | 553|+                        || Regex::search (s->getComment (), rx[0],
+|    | 554|+                                          Config.ignore_diacritics);
+|    | 555|+                if (found && !rx[1].empty ())
+|    | 556|+                    found =
+|    | 557|+                        Regex::search (s->getArtist (), rx[1],
+|    | 558|+                                       Config.ignore_diacritics);
+|    | 559|+                if (found && !rx[2].empty ())
+|    | 560|+                    found =
+|    | 561|+                        Regex::search (s->getAlbumArtist (), rx[2],
+|    | 562|+                                       Config.ignore_diacritics);
+|    | 563|+                if (found && !rx[3].empty ())
+|    | 564|+                    found =
+|    | 565|+                        Regex::search (s->getTitle (), rx[3],
+|    | 566|+                                       Config.ignore_diacritics);
+|    | 567|+                if (found && !rx[4].empty ())
+|    | 568|+                    found =
+|    | 569|+                        Regex::search (s->getAlbum (), rx[4],
+|    | 570|+                                       Config.ignore_diacritics);
+|    | 571|+                if (found && !rx[5].empty ())
+|    | 572|+                    found =
+|    | 573|+                        Regex::search (s->getName (), rx[5],
+|    | 574|+                                       Config.ignore_diacritics);
+|    | 575|+                if (found && !rx[6].empty ())
+|    | 576|+                    found =
+|    | 577|+                        Regex::search (s->getComposer (), rx[6],
+|    | 578|+                                       Config.ignore_diacritics);
+|    | 579|+                if (found && !rx[7].empty ())
+|    | 580|+                    found =
+|    | 581|+                        Regex::search (s->getPerformer (), rx[7],
+|    | 582|+                                       Config.ignore_diacritics);
+|    | 583|+                if (found && !rx[8].empty ())
+|    | 584|+                    found =
+|    | 585|+                        Regex::search (s->getGenre (), rx[8],
+|    | 586|+                                       Config.ignore_diacritics);
+|    | 587|+                if (found && !rx[9].empty ())
+|    | 588|+                    found =
+|    | 589|+                        Regex::search (s->getDate (), rx[9],
+|    | 590|+                                       Config.ignore_diacritics);
+|    | 591|+                if (found && !rx[10].empty ())
+|    | 592|+                    found =
+|    | 593|+                        Regex::search (s->getComment (), rx[10],
+|    | 594|+                                       Config.ignore_diacritics);
+|    | 595|+            }
+|    | 596|+          else                  // match only if values are equal
+|    | 597|+            {
+|    | 598|+                if (!itsConstraints[0].empty ())
+|    | 599|+                    any_found =
+|    | 600|+                        !cmp (s->getArtist (), itsConstraints[0])
+|    | 601|+                        || !cmp (s->getAlbumArtist (), itsConstraints[0])
+|    | 602|+                        || !cmp (s->getTitle (), itsConstraints[0])
+|    | 603|+                        || !cmp (s->getAlbum (), itsConstraints[0])
+|    | 604|+                        || !cmp (s->getName (), itsConstraints[0])
+|    | 605|+                        || !cmp (s->getComposer (), itsConstraints[0])
+|    | 606|+                        || !cmp (s->getPerformer (), itsConstraints[0])
+|    | 607|+                        || !cmp (s->getGenre (), itsConstraints[0])
+|    | 608|+                        || !cmp (s->getDate (), itsConstraints[0])
+|    | 609|+                        || !cmp (s->getComment (), itsConstraints[0]);
+|    | 610|+
+|    | 611|+                if (found && !itsConstraints[1].empty ())
+|    | 612|+                    found = !cmp (s->getArtist (), itsConstraints[1]);
+|    | 613|+                if (found && !itsConstraints[2].empty ())
+|    | 614|+                    found = !cmp (s->getAlbumArtist (), itsConstraints[2]);
+|    | 615|+                if (found && !itsConstraints[3].empty ())
+|    | 616|+                    found = !cmp (s->getTitle (), itsConstraints[3]);
+|    | 617|+                if (found && !itsConstraints[4].empty ())
+|    | 618|+                    found = !cmp (s->getAlbum (), itsConstraints[4]);
+|    | 619|+                if (found && !itsConstraints[5].empty ())
+|    | 620|+                    found = !cmp (s->getName (), itsConstraints[5]);
+|    | 621|+                if (found && !itsConstraints[6].empty ())
+|    | 622|+                    found = !cmp (s->getComposer (), itsConstraints[6]);
+|    | 623|+                if (found && !itsConstraints[7].empty ())
+|    | 624|+                    found = !cmp (s->getPerformer (), itsConstraints[7]);
+|    | 625|+                if (found && !itsConstraints[8].empty ())
+|    | 626|+                    found = !cmp (s->getGenre (), itsConstraints[8]);
+|    | 627|+                if (found && !itsConstraints[9].empty ())
+|    | 628|+                    found = !cmp (s->getDate (), itsConstraints[9]);
+|    | 629|+                if (found && !itsConstraints[10].empty ())
+|    | 630|+                    found = !cmp (s->getComment (), itsConstraints[10]);
+|    | 631|+            }
+|    | 632|+
+|    | 633|+          if (any_found && found)
+|    | 634|+              w.addItem (*s);
+|    | 635|+      }
+|    | 636|+}
+|    | 637|+
+|    | 638|+namespace
+|    | 639|+{
+|    | 640|+
+|    | 641|+    std::string SEItemToString (const SEItem & ei)
+|    | 642|+    {
+|    | 643|+        std::string result;
+|    | 644|+        if (ei.isSong ())
+|    | 645|+          {
+|    | 646|+              switch (Config.search_engine_display_mode)
+|    | 647|+                {
+|    | 648|+                case DisplayMode::Classic:
+|    | 649|+                    result =
+|    | 650|+                        Format::stringify < char >(Config.song_list_format,
+|    | 651|+                                                   &ei.song ());
+|    | 652|+                    break;
+|    | 653|+                case DisplayMode::Columns:
+|    | 654|+                    result =
+|    | 655|+                        Format::stringify <
+|    | 656|+                        char >(Config.song_columns_mode_format, &ei.song ());
+|    | 657|+                    break;
+|    | 658|+                }
+|    | 659|+          }
+|    | 660|+        else
+|    | 661|+            result = ei.buffer ().str ();
+|    | 662|+        return result;
+|    | 663|+    }
+|    | 664|+
+|    | 665|+    bool SEItemEntryMatcher (const Regex::Regex & rx,
+|    | 666|+                             const NC::Menu < SEItem >::Item & item,
+|    | 667|+                             bool filter)
+|    | 668|+    {
+|    | 669|+        if (item.isSeparator () || !item.value ().isSong ())
+|    | 670|+            return filter;
+|    | 671|+        return Regex::search (SEItemToString (item.value ()), rx,
+|    | 672|+                              Config.ignore_diacritics);
+|    | 673|+    }
+|    | 674|+
+|    | 675|+}
+
+src/screens/search_engine.cpp
+|  25| #include•"curses/menu_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/menu_impl.h'
+
+src/screens/search_engine.cpp
+|  26| #include•"display.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'display.h'
+
+src/screens/search_engine.cpp
+|  27| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/search_engine.cpp
+|  28| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/search_engine.cpp
+|  29| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist.h'
+
+src/screens/search_engine.cpp
+|  30| #include•"screens/search_engine.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/search_engine.h'
+
+src/screens/search_engine.cpp
+|  31| #include•"settings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'settings.h'
+
+src/screens/search_engine.cpp
+|  32| #include•"status.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'status.h'
+
+src/screens/search_engine.cpp
+|  33| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'statusbar.h'
+
+src/screens/search_engine.cpp
+|  34| #include•"format_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'format_impl.h'
+
+src/screens/search_engine.cpp
+|  35| #include•"helpers/song_iterator_maker.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers/song_iterator_maker.h'
+
+src/screens/search_engine.cpp
+|  36| #include•"utility/comparators.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/comparators.h'
+
+src/screens/search_engine.cpp
+|  37| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/search_engine.cpp
+|  38| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/search_engine.cpp
+|  45| SearchEngine•*mySearcher;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'mySearcher'
+
+src/screens/search_engine.cpp
+| 171| size_t•SearchEngine::StaticOptions•=•20;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'SearchEngine::StaticOptions'
+
+src/screens/search_engine.cpp
+| 172| size_t•SearchEngine::ResetButton•=•16;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'SearchEngine::ResetButton'
+
+src/screens/search_engine.cpp
+| 173| size_t•SearchEngine::SearchButton•=•15;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'SearchEngine::SearchButton'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/settings.h
+|    |++++| /app/src/settings.h
+|  37|  37| 
+|  38|  38| struct Column
+|  39|  39| {
+|  40|    |-	Column() : stretch_limit(-1), right_alignment(0), display_empty_tag(1) { }
+|  41|    |-
+|  42|    |-	std::wstring name;
+|  43|    |-	std::string type;
+|  44|    |-	int width;
+|  45|    |-	int stretch_limit;
+|  46|    |-	NC::Color color;
+|  47|    |-	bool fixed;
+|  48|    |-	bool right_alignment;
+|  49|    |-	bool display_empty_tag;
+|    |  40|+    Column ():stretch_limit (-1), right_alignment (0), display_empty_tag (1)
+|    |  41|+    {
+|    |  42|+    }
+|    |  43|+
+|    |  44|+    std::wstring name;
+|    |  45|+    std::string type;
+|    |  46|+    int width;
+|    |  47|+    int stretch_limit;
+|    |  48|+    NC::Color color;
+|    |  49|+    bool fixed;
+|    |  50|+    bool right_alignment;
+|    |  51|+    bool display_empty_tag;
+|  50|  52| };
+|  51|  53| 
+|  52|  54| struct Configuration
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/settings.h
+|    |++++| /app/src/settings.h
+|  51|  51| 
+|  52|  52| struct Configuration
+|  53|  53| {
+|  54|    |-	Configuration()
+|  55|    |-	: playlist_disable_highlight_delay(0), visualizer_sync_interval(0)
+|  56|    |-	{ }
+|  57|    |-
+|  58|    |-	bool read(const std::vector<std::string> &config_paths, bool ignore_errors);
+|  59|    |-
+|  60|    |-	std::string ncmpcpp_directory;
+|  61|    |-	std::string lyrics_directory;
+|  62|    |-
+|  63|    |-	std::string mpd_music_dir;
+|  64|    |-	std::string visualizer_fifo_path;
+|  65|    |-	std::string visualizer_output_name;
+|  66|    |-	std::string empty_tag;
+|  67|    |-
+|  68|    |-	Format::AST<char> song_list_format;
+|  69|    |-	Format::AST<char> song_window_title_format;
+|  70|    |-	Format::AST<char> song_library_format;
+|  71|    |-	Format::AST<char> song_columns_mode_format;
+|  72|    |-	Format::AST<char> browser_sort_format;
+|  73|    |-	Format::AST<char> song_status_format;
+|  74|    |-	Format::AST<wchar_t> song_status_wformat;
+|  75|    |-	Format::AST<wchar_t> new_header_first_line;
+|  76|    |-	Format::AST<wchar_t> new_header_second_line;
+|  77|    |-
+|  78|    |-	std::string external_editor;
+|  79|    |-	std::string system_encoding;
+|  80|    |-	std::string execute_on_song_change;
+|  81|    |-	std::string execute_on_player_state_change;
+|  82|    |-	std::string lastfm_preferred_language;
+|  83|    |-	std::wstring progressbar;
+|  84|    |-	std::wstring visualizer_chars;
+|  85|    |-
+|  86|    |-	std::string pattern;
+|  87|    |-
+|  88|    |-	std::vector<Column> columns;
+|  89|    |-
+|  90|    |-	DisplayMode playlist_display_mode;
+|  91|    |-	DisplayMode browser_display_mode;
+|  92|    |-	DisplayMode search_engine_display_mode;
+|  93|    |-	DisplayMode playlist_editor_display_mode;
+|  94|    |-
+|  95|    |-	NC::Buffer browser_playlist_prefix;
+|  96|    |-	NC::Buffer selected_item_prefix;
+|  97|    |-	NC::Buffer selected_item_suffix;
+|  98|    |-	NC::Buffer now_playing_prefix;
+|  99|    |-	NC::Buffer now_playing_suffix;
+| 100|    |-	NC::Buffer modified_item_prefix;
+| 101|    |-	NC::Buffer current_item_prefix;
+| 102|    |-	NC::Buffer current_item_suffix;
+| 103|    |-	NC::Buffer current_item_inactive_column_prefix;
+| 104|    |-	NC::Buffer current_item_inactive_column_suffix;
+| 105|    |-
+| 106|    |-	NC::Color header_color;
+| 107|    |-	NC::Color main_color;
+| 108|    |-	NC::Color statusbar_color;
+| 109|    |-
+| 110|    |-	NC::FormattedColor color1;
+| 111|    |-	NC::FormattedColor color2;
+| 112|    |-	NC::FormattedColor empty_tags_color;
+| 113|    |-	NC::FormattedColor volume_color;
+| 114|    |-	NC::FormattedColor state_line_color;
+| 115|    |-	NC::FormattedColor state_flags_color;
+| 116|    |-	NC::FormattedColor progressbar_color;
+| 117|    |-	NC::FormattedColor progressbar_elapsed_color;
+| 118|    |-	NC::FormattedColor player_state_color;
+| 119|    |-	NC::FormattedColor statusbar_time_color;
+| 120|    |-	NC::FormattedColor alternative_ui_separator_color;
+| 121|    |-
+| 122|    |-	std::vector<NC::FormattedColor> visualizer_colors;
+| 123|    |-	VisualizerType visualizer_type;
+| 124|    |-
+| 125|    |-	NC::Border window_border;
+| 126|    |-	NC::Border active_window_border;
+| 127|    |-
+| 128|    |-	Design design;
+| 129|    |-
+| 130|    |-	SpaceAddMode space_add_mode;
+| 131|    |-
+| 132|    |-	mpd_tag_type media_lib_primary_tag;
+| 133|    |-
+| 134|    |-	bool colors_enabled;
+| 135|    |-	bool playlist_show_mpd_host;
+| 136|    |-	bool playlist_show_remaining_time;
+| 137|    |-	bool playlist_shorten_total_times;
+| 138|    |-	bool playlist_separate_albums;
+| 139|    |-	bool set_window_title;
+| 140|    |-	bool header_visibility;
+| 141|    |-	bool header_text_scrolling;
+| 142|    |-	bool statusbar_visibility;
+| 143|    |-	bool titles_visibility;
+| 144|    |-	bool centered_cursor;
+| 145|    |-	bool screen_switcher_previous;
+| 146|    |-	bool autocenter_mode;
+| 147|    |-	bool wrapped_search;
+| 148|    |-	bool incremental_seeking;
+| 149|    |-	bool now_playing_lyrics;
+| 150|    |-	bool fetch_lyrics_in_background;
+| 151|    |-	bool local_browser_show_hidden_files;
+| 152|    |-	bool search_in_db;
+| 153|    |-	bool jump_to_now_playing_song_at_start;
+| 154|    |-	bool clock_display_seconds;
+| 155|    |-	bool display_volume_level;
+| 156|    |-	bool display_bitrate;
+| 157|    |-	bool display_remaining_time;
+| 158|    |-	bool ignore_leading_the;
+| 159|    |-	bool ignore_diacritics;
+| 160|    |-	bool block_search_constraints_change;
+| 161|    |-	bool use_console_editor;
+| 162|    |-	bool use_cyclic_scrolling;
+| 163|    |-	bool ask_before_clearing_playlists;
+| 164|    |-	bool ask_before_shuffling_playlists;
+| 165|    |-	bool mouse_support;
+| 166|    |-	bool mouse_list_scroll_whole_page;
+| 167|    |-	bool visualizer_in_stereo;
+| 168|    |-	bool data_fetching_delay;
+| 169|    |-	bool media_library_sort_by_mtime;
+| 170|    |-	bool tag_editor_extended_numeration;
+| 171|    |-	bool discard_colors_if_item_is_selected;
+| 172|    |-	bool store_lyrics_in_song_dir;
+| 173|    |-	bool generate_win32_compatible_filenames;
+| 174|    |-	bool ask_for_locked_screen_width_part;
+| 175|    |-	bool allow_for_physical_item_deletion;
+| 176|    |-	bool media_library_albums_split_by_date;
+| 177|    |-	bool startup_slave_screen_focus;
+| 178|    |-
+| 179|    |-	unsigned mpd_connection_timeout;
+| 180|    |-	unsigned crossfade_time;
+| 181|    |-	unsigned seek_time;
+| 182|    |-	unsigned volume_change_step;
+| 183|    |-	unsigned message_delay_time;
+| 184|    |-	unsigned lyrics_db;
+| 185|    |-	unsigned lines_scrolled;
+| 186|    |-	unsigned search_engine_default_search_mode;
+| 187|    |-
+| 188|    |-	boost::regex::flag_type regex_type;
+| 189|    |-
+| 190|    |-	boost::posix_time::seconds playlist_disable_highlight_delay;
+| 191|    |-	boost::posix_time::seconds visualizer_sync_interval;
+| 192|    |-
+| 193|    |-	double locked_screen_width_part;
+| 194|    |-
+| 195|    |-	size_t selected_item_prefix_length;
+| 196|    |-	size_t selected_item_suffix_length;
+| 197|    |-	size_t now_playing_prefix_length;
+| 198|    |-	size_t now_playing_suffix_length;
+| 199|    |-	size_t current_item_prefix_length;
+| 200|    |-	size_t current_item_suffix_length;
+| 201|    |-	size_t current_item_inactive_column_prefix_length;
+| 202|    |-	size_t current_item_inactive_column_suffix_length;
+| 203|    |-
+| 204|    |-	ScreenType startup_screen_type;
+| 205|    |-	boost::optional<ScreenType> startup_slave_screen_type;
+| 206|    |-	std::vector<ScreenType> screen_sequence;
+| 207|    |-
+| 208|    |-	SortMode browser_sort_mode;
+| 209|    |-
+| 210|    |-	LyricsFetchers lyrics_fetchers;
+|    |  54|+    Configuration ():playlist_disable_highlight_delay (0),
+|    |  55|+        visualizer_sync_interval (0)
+|    |  56|+    {
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    bool read (const std::vector < std::string > &config_paths,
+|    |  60|+               bool ignore_errors);
+|    |  61|+
+|    |  62|+    std::string ncmpcpp_directory;
+|    |  63|+    std::string lyrics_directory;
+|    |  64|+
+|    |  65|+    std::string mpd_music_dir;
+|    |  66|+    std::string visualizer_fifo_path;
+|    |  67|+    std::string visualizer_output_name;
+|    |  68|+    std::string empty_tag;
+|    |  69|+
+|    |  70|+    Format::AST < char >song_list_format;
+|    |  71|+    Format::AST < char >song_window_title_format;
+|    |  72|+    Format::AST < char >song_library_format;
+|    |  73|+    Format::AST < char >song_columns_mode_format;
+|    |  74|+    Format::AST < char >browser_sort_format;
+|    |  75|+    Format::AST < char >song_status_format;
+|    |  76|+    Format::AST < wchar_t > song_status_wformat;
+|    |  77|+    Format::AST < wchar_t > new_header_first_line;
+|    |  78|+    Format::AST < wchar_t > new_header_second_line;
+|    |  79|+
+|    |  80|+    std::string external_editor;
+|    |  81|+    std::string system_encoding;
+|    |  82|+    std::string execute_on_song_change;
+|    |  83|+    std::string execute_on_player_state_change;
+|    |  84|+    std::string lastfm_preferred_language;
+|    |  85|+    std::wstring progressbar;
+|    |  86|+    std::wstring visualizer_chars;
+|    |  87|+
+|    |  88|+    std::string pattern;
+|    |  89|+
+|    |  90|+    std::vector < Column > columns;
+|    |  91|+
+|    |  92|+    DisplayMode playlist_display_mode;
+|    |  93|+    DisplayMode browser_display_mode;
+|    |  94|+    DisplayMode search_engine_display_mode;
+|    |  95|+    DisplayMode playlist_editor_display_mode;
+|    |  96|+
+|    |  97|+    NC::Buffer browser_playlist_prefix;
+|    |  98|+    NC::Buffer selected_item_prefix;
+|    |  99|+    NC::Buffer selected_item_suffix;
+|    | 100|+    NC::Buffer now_playing_prefix;
+|    | 101|+    NC::Buffer now_playing_suffix;
+|    | 102|+    NC::Buffer modified_item_prefix;
+|    | 103|+    NC::Buffer current_item_prefix;
+|    | 104|+    NC::Buffer current_item_suffix;
+|    | 105|+    NC::Buffer current_item_inactive_column_prefix;
+|    | 106|+    NC::Buffer current_item_inactive_column_suffix;
+|    | 107|+
+|    | 108|+    NC::Color header_color;
+|    | 109|+    NC::Color main_color;
+|    | 110|+    NC::Color statusbar_color;
+|    | 111|+
+|    | 112|+    NC::FormattedColor color1;
+|    | 113|+    NC::FormattedColor color2;
+|    | 114|+    NC::FormattedColor empty_tags_color;
+|    | 115|+    NC::FormattedColor volume_color;
+|    | 116|+    NC::FormattedColor state_line_color;
+|    | 117|+    NC::FormattedColor state_flags_color;
+|    | 118|+    NC::FormattedColor progressbar_color;
+|    | 119|+    NC::FormattedColor progressbar_elapsed_color;
+|    | 120|+    NC::FormattedColor player_state_color;
+|    | 121|+    NC::FormattedColor statusbar_time_color;
+|    | 122|+    NC::FormattedColor alternative_ui_separator_color;
+|    | 123|+
+|    | 124|+    std::vector < NC::FormattedColor > visualizer_colors;
+|    | 125|+    VisualizerType visualizer_type;
+|    | 126|+
+|    | 127|+    NC::Border window_border;
+|    | 128|+    NC::Border active_window_border;
+|    | 129|+
+|    | 130|+    Design design;
+|    | 131|+
+|    | 132|+    SpaceAddMode space_add_mode;
+|    | 133|+
+|    | 134|+    mpd_tag_type media_lib_primary_tag;
+|    | 135|+
+|    | 136|+    bool colors_enabled;
+|    | 137|+    bool playlist_show_mpd_host;
+|    | 138|+    bool playlist_show_remaining_time;
+|    | 139|+    bool playlist_shorten_total_times;
+|    | 140|+    bool playlist_separate_albums;
+|    | 141|+    bool set_window_title;
+|    | 142|+    bool header_visibility;
+|    | 143|+    bool header_text_scrolling;
+|    | 144|+    bool statusbar_visibility;
+|    | 145|+    bool titles_visibility;
+|    | 146|+    bool centered_cursor;
+|    | 147|+    bool screen_switcher_previous;
+|    | 148|+    bool autocenter_mode;
+|    | 149|+    bool wrapped_search;
+|    | 150|+    bool incremental_seeking;
+|    | 151|+    bool now_playing_lyrics;
+|    | 152|+    bool fetch_lyrics_in_background;
+|    | 153|+    bool local_browser_show_hidden_files;
+|    | 154|+    bool search_in_db;
+|    | 155|+    bool jump_to_now_playing_song_at_start;
+|    | 156|+    bool clock_display_seconds;
+|    | 157|+    bool display_volume_level;
+|    | 158|+    bool display_bitrate;
+|    | 159|+    bool display_remaining_time;
+|    | 160|+    bool ignore_leading_the;
+|    | 161|+    bool ignore_diacritics;
+|    | 162|+    bool block_search_constraints_change;
+|    | 163|+    bool use_console_editor;
+|    | 164|+    bool use_cyclic_scrolling;
+|    | 165|+    bool ask_before_clearing_playlists;
+|    | 166|+    bool ask_before_shuffling_playlists;
+|    | 167|+    bool mouse_support;
+|    | 168|+    bool mouse_list_scroll_whole_page;
+|    | 169|+    bool visualizer_in_stereo;
+|    | 170|+    bool data_fetching_delay;
+|    | 171|+    bool media_library_sort_by_mtime;
+|    | 172|+    bool tag_editor_extended_numeration;
+|    | 173|+    bool discard_colors_if_item_is_selected;
+|    | 174|+    bool store_lyrics_in_song_dir;
+|    | 175|+    bool generate_win32_compatible_filenames;
+|    | 176|+    bool ask_for_locked_screen_width_part;
+|    | 177|+    bool allow_for_physical_item_deletion;
+|    | 178|+    bool media_library_albums_split_by_date;
+|    | 179|+    bool startup_slave_screen_focus;
+|    | 180|+
+|    | 181|+    unsigned mpd_connection_timeout;
+|    | 182|+    unsigned crossfade_time;
+|    | 183|+    unsigned seek_time;
+|    | 184|+    unsigned volume_change_step;
+|    | 185|+    unsigned message_delay_time;
+|    | 186|+    unsigned lyrics_db;
+|    | 187|+    unsigned lines_scrolled;
+|    | 188|+    unsigned search_engine_default_search_mode;
+|    | 189|+
+|    | 190|+    boost::regex::flag_type regex_type;
+|    | 191|+
+|    | 192|+    boost::posix_time::seconds playlist_disable_highlight_delay;
+|    | 193|+    boost::posix_time::seconds visualizer_sync_interval;
+|    | 194|+
+|    | 195|+    double locked_screen_width_part;
+|    | 196|+
+|    | 197|+    size_t selected_item_prefix_length;
+|    | 198|+    size_t selected_item_suffix_length;
+|    | 199|+    size_t now_playing_prefix_length;
+|    | 200|+    size_t now_playing_suffix_length;
+|    | 201|+    size_t current_item_prefix_length;
+|    | 202|+    size_t current_item_suffix_length;
+|    | 203|+    size_t current_item_inactive_column_prefix_length;
+|    | 204|+    size_t current_item_inactive_column_suffix_length;
+|    | 205|+
+|    | 206|+    ScreenType startup_screen_type;
+|    | 207|+    boost::optional < ScreenType > startup_slave_screen_type;
+|    | 208|+    std::vector < ScreenType > screen_sequence;
+|    | 209|+
+|    | 210|+    SortMode browser_sort_mode;
+|    | 211|+
+|    | 212|+    LyricsFetchers lyrics_fetchers;
+| 211| 213| };
+| 212| 214| 
+| 213| 215| extern Configuration Config;
+
+src/settings.h
+|  34| #include•"format.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'format.h' does not need to be #included
+
+src/settings.h
+| 213| extern•Configuration•Config;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Config'
+
+src/settings.h
+|  27| #include•<cassert>
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.cpp
+|    |++++| /app/src/status.cpp
+|  43|  43| #include "title.h"
+|  44|  44| #include "utility/string.h"
+|  45|  45| 
+|  46|    |-using Global::myScreen;
+|  47|    |-
+|  48|    |-using Global::wFooter;
+|  49|    |-using Global::wHeader;
+|  50|    |-
+|  51|    |-using Global::Timer;
+|  52|    |-using Global::VolumeState;
+|  53|    |-
+|  54|    |-namespace {
+|  55|    |-
+|  56|    |-boost::posix_time::ptime past = boost::posix_time::from_time_t(0);
+|  57|    |-
+|  58|    |-size_t playing_song_scroll_begin = 0;
+|  59|    |-size_t first_line_scroll_begin = 0;
+|  60|    |-size_t second_line_scroll_begin = 0;
+|  61|    |-
+|  62|    |-bool m_status_initialized;
+|  63|    |-
+|  64|    |-char m_consume;
+|  65|    |-char m_crossfade;
+|  66|    |-char m_db_updating;
+|  67|    |-char m_repeat;
+|  68|    |-char m_random;
+|  69|    |-char m_single;
+|  70|    |-
+|  71|    |-int m_current_song_id;
+|  72|    |-int m_current_song_pos;
+|  73|    |-unsigned m_elapsed_time;
+|  74|    |-unsigned m_kbps;
+|  75|    |-MPD::PlayerState m_player_state;
+|  76|    |-unsigned m_playlist_version;
+|  77|    |-unsigned m_playlist_length;
+|  78|    |-unsigned m_total_time;
+|  79|    |-int m_volume;
+|  80|    |-
+|  81|    |-void drawTitle(const MPD::Song &np)
+|  82|    |-{
+|  83|    |-	assert(!np.empty());
+|  84|    |-	windowTitle(Format::stringify<char>(Config.song_window_title_format, &np));
+|  85|    |-}
+|  86|    |-
+|  87|    |-std::string playerStateToString(MPD::PlayerState ps)
+|  88|    |-{
+|  89|    |-	std::string result;
+|  90|    |-	switch (ps)
+|  91|    |-	{
+|  92|    |-		case MPD::psUnknown:
+|  93|    |-			switch (Config.design)
+|  94|    |-			{
+|  95|    |-				case Design::Alternative:
+|  96|    |-					result = "[unknown]";
+|  97|    |-					break;
+|  98|    |-				case Design::Classic:
+|  99|    |-					break;
+| 100|    |-			}
+| 101|    |-			break;
+| 102|    |-		case MPD::psPlay:
+| 103|    |-			switch (Config.design)
+| 104|    |-			{
+| 105|    |-				case Design::Alternative:
+| 106|    |-					result = "[playing]";
+| 107|    |-					break;
+| 108|    |-				case Design::Classic:
+| 109|    |-					result = "Playing:";
+| 110|    |-					break;
+| 111|    |-			}
+| 112|    |-			break;
+| 113|    |-		case MPD::psPause:
+| 114|    |-			switch (Config.design)
+| 115|    |-			{
+| 116|    |-				case Design::Alternative:
+| 117|    |-					result = "[paused]";
+| 118|    |-					break;
+| 119|    |-				case Design::Classic:
+| 120|    |-					result = "Paused:";
+| 121|    |-					break;
+| 122|    |-			}
+| 123|    |-			break;
+| 124|    |-		case MPD::psStop:
+| 125|    |-			switch (Config.design)
+| 126|    |-			{
+| 127|    |-				case Design::Alternative:
+| 128|    |-					result = "[stopped]";
+| 129|    |-					break;
+| 130|    |-				case Design::Classic:
+| 131|    |-					break;
+| 132|    |-			}
+| 133|    |-			break;
+| 134|    |-	}
+| 135|    |-	return result;
+| 136|    |-}
+| 137|    |-
+| 138|    |-void initialize_status()
+| 139|    |-{
+| 140|    |-	// get full info about new connection
+| 141|    |-	Status::update(-1);
+| 142|    |-
+| 143|    |-	if (Config.jump_to_now_playing_song_at_start)
+| 144|    |-	{
+| 145|    |-		int curr_pos = Status::State::currentSongPosition();
+| 146|    |-		if  (curr_pos >= 0)
+| 147|    |-		{
+| 148|    |-			myPlaylist->main().highlight(curr_pos);
+| 149|    |-			if (isVisible(myPlaylist))
+| 150|    |-				myPlaylist->refresh();
+| 151|    |-		}
+| 152|    |-	}
+| 153|    |-
+| 154|    |-	// Set TCP_NODELAY on the tcp socket as we are using write-write-read pattern
+| 155|    |-	// a lot (noidle - write, command - write, then read the result of command),
+| 156|    |-	// which kills the performance.
+| 157|    |-	int flag = 1;
+| 158|    |-	setsockopt(Mpd.GetFD(), IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));
+| 159|    |-
+| 160|    |-	myBrowser->fetchSupportedExtensions();
+|    |  46|+using
+|    |  47|+    Global::myScreen;
+|    |  48|+
+|    |  49|+using
+|    |  50|+    Global::wFooter;
+|    |  51|+using
+|    |  52|+    Global::wHeader;
+|    |  53|+
+|    |  54|+using
+|    |  55|+    Global::Timer;
+|    |  56|+using
+|    |  57|+    Global::VolumeState;
+|    |  58|+
+|    |  59|+namespace
+|    |  60|+{
+|    |  61|+
+|    |  62|+    boost::posix_time::ptime past = boost::posix_time::from_time_t (0);
+|    |  63|+
+|    |  64|+    size_t
+|    |  65|+        playing_song_scroll_begin = 0;
+|    |  66|+    size_t
+|    |  67|+        first_line_scroll_begin = 0;
+|    |  68|+    size_t
+|    |  69|+        second_line_scroll_begin = 0;
+|    |  70|+
+|    |  71|+    bool
+|    |  72|+        m_status_initialized;
+|    |  73|+
+|    |  74|+    char
+|    |  75|+        m_consume;
+|    |  76|+    char
+|    |  77|+        m_crossfade;
+|    |  78|+    char
+|    |  79|+        m_db_updating;
+|    |  80|+    char
+|    |  81|+        m_repeat;
+|    |  82|+    char
+|    |  83|+        m_random;
+|    |  84|+    char
+|    |  85|+        m_single;
+|    |  86|+
+|    |  87|+    int
+|    |  88|+        m_current_song_id;
+|    |  89|+    int
+|    |  90|+        m_current_song_pos;
+|    |  91|+    unsigned
+|    |  92|+        m_elapsed_time;
+|    |  93|+    unsigned
+|    |  94|+        m_kbps;
+|    |  95|+    MPD::PlayerState m_player_state;
+|    |  96|+    unsigned
+|    |  97|+        m_playlist_version;
+|    |  98|+    unsigned
+|    |  99|+        m_playlist_length;
+|    | 100|+    unsigned
+|    | 101|+        m_total_time;
+|    | 102|+    int
+|    | 103|+        m_volume;
+|    | 104|+
+|    | 105|+    void
+|    | 106|+    drawTitle (const MPD::Song & np)
+|    | 107|+    {
+|    | 108|+        assert (!np.empty ());
+|    | 109|+        windowTitle (Format::stringify <
+|    | 110|+                     char >(Config.song_window_title_format, &np));
+|    | 111|+    }
+|    | 112|+
+|    | 113|+    std::string playerStateToString (MPD::PlayerState ps)
+|    | 114|+    {
+|    | 115|+        std::string result;
+|    | 116|+        switch (ps)
+|    | 117|+          {
+|    | 118|+          case MPD::psUnknown:
+|    | 119|+              switch (Config.design)
+|    | 120|+                {
+|    | 121|+                case Design::Alternative:
+|    | 122|+                    result = "[unknown]";
+|    | 123|+                    break;
+|    | 124|+                case Design::Classic:
+|    | 125|+                    break;
+|    | 126|+                }
+|    | 127|+              break;
+|    | 128|+          case MPD::psPlay:
+|    | 129|+              switch (Config.design)
+|    | 130|+                {
+|    | 131|+                case Design::Alternative:
+|    | 132|+                    result = "[playing]";
+|    | 133|+                    break;
+|    | 134|+                case Design::Classic:
+|    | 135|+                    result = "Playing:";
+|    | 136|+                    break;
+|    | 137|+                }
+|    | 138|+              break;
+|    | 139|+          case MPD::psPause:
+|    | 140|+              switch (Config.design)
+|    | 141|+                {
+|    | 142|+                case Design::Alternative:
+|    | 143|+                    result = "[paused]";
+|    | 144|+                    break;
+|    | 145|+                case Design::Classic:
+|    | 146|+                    result = "Paused:";
+|    | 147|+                    break;
+|    | 148|+                }
+|    | 149|+              break;
+|    | 150|+          case MPD::psStop:
+|    | 151|+              switch (Config.design)
+|    | 152|+                {
+|    | 153|+                case Design::Alternative:
+|    | 154|+                    result = "[stopped]";
+|    | 155|+                    break;
+|    | 156|+                case Design::Classic:
+|    | 157|+                    break;
+|    | 158|+                }
+|    | 159|+              break;
+|    | 160|+          }
+|    | 161|+        return result;
+|    | 162|+    }
+|    | 163|+
+|    | 164|+    void
+|    | 165|+    initialize_status ()
+|    | 166|+    {
+|    | 167|+        // get full info about new connection
+|    | 168|+        Status::update (-1);
+|    | 169|+
+|    | 170|+        if (Config.jump_to_now_playing_song_at_start)
+|    | 171|+          {
+|    | 172|+              int
+|    | 173|+                  curr_pos = Status::State::currentSongPosition ();
+|    | 174|+              if (curr_pos >= 0)
+|    | 175|+                {
+|    | 176|+                    myPlaylist->main ().highlight (curr_pos);
+|    | 177|+                    if (isVisible (myPlaylist))
+|    | 178|+                        myPlaylist->refresh ();
+|    | 179|+                }
+|    | 180|+          }
+|    | 181|+
+|    | 182|+        // Set TCP_NODELAY on the tcp socket as we are using write-write-read pattern
+|    | 183|+        // a lot (noidle - write, command - write, then read the result of command),
+|    | 184|+        // which kills the performance.
+|    | 185|+        int
+|    | 186|+            flag = 1;
+|    | 187|+        setsockopt (Mpd.GetFD (), IPPROTO_TCP, TCP_NODELAY, &flag,
+|    | 188|+                    sizeof (flag));
+|    | 189|+
+|    | 190|+        myBrowser->fetchSupportedExtensions ();
+| 161| 191| #	ifdef ENABLE_OUTPUTS
+| 162|    |-	myOutputs->fetchList();
+|    | 192|+        myOutputs->fetchList ();
+| 163| 193| #	endif // ENABLE_OUTPUTS
+| 164| 194| #	ifdef ENABLE_VISUALIZER
+| 165| 195| 	myVisualizer->ResetFD();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.cpp
+|    |++++| /app/src/status.cpp
+| 162| 162| 	myOutputs->fetchList();
+| 163| 163| #	endif // ENABLE_OUTPUTS
+| 164| 164| #	ifdef ENABLE_VISUALIZER
+| 165|    |-	myVisualizer->ResetFD();
+| 166|    |-	myVisualizer->SetFD();
+| 167|    |-	myVisualizer->FindOutputID();
+|    | 165|+        myVisualizer->ResetFD ();
+|    | 166|+        myVisualizer->SetFD ();
+|    | 167|+        myVisualizer->FindOutputID ();
+| 168| 168| #	endif // ENABLE_VISUALIZER
+| 169| 169| 
+| 170| 170| 	m_status_initialized = true;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.cpp
+|    |++++| /app/src/status.cpp
+| 167| 167| 	myVisualizer->FindOutputID();
+| 168| 168| #	endif // ENABLE_VISUALIZER
+| 169| 169| 
+| 170|    |-	m_status_initialized = true;
+| 171|    |-	wFooter->addFDCallback(Mpd.GetFD(), Statusbar::Helpers::mpd);
+| 172|    |-	Statusbar::printf("Connected to %1%", Mpd.GetHostname());
+| 173|    |-}
+|    | 170|+        m_status_initialized = true;
+|    | 171|+        wFooter->addFDCallback (Mpd.GetFD (), Statusbar::Helpers::mpd);
+|    | 172|+        Statusbar::printf ("Connected to %1%", Mpd.GetHostname ());
+|    | 173|+    }
+| 174| 174| 
+| 175| 175| }
+| 176| 176| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.cpp
+|    |++++| /app/src/status.cpp
+| 176| 176| 
+| 177| 177| /*************************************************************************/
+| 178| 178| 
+| 179|    |-void Status::handleClientError(MPD::ClientError &e)
+| 180|    |-{
+| 181|    |-	if (!e.clearable())
+| 182|    |-		Mpd.Disconnect();
+| 183|    |-	Statusbar::printf("ncmpcpp: %1%", e.what());
+| 184|    |-}
+| 185|    |-
+| 186|    |-void Status::handleServerError(MPD::ServerError &e)
+| 187|    |-{
+| 188|    |-	Statusbar::printf("MPD: %1%", e.what());
+| 189|    |-	if (e.code() == MPD_SERVER_ERROR_PERMISSION)
+| 190|    |-	{
+| 191|    |-		NC::Window::ScopedPromptHook helper(*wFooter, nullptr);
+| 192|    |-		Statusbar::put() << "Password: ";
+| 193|    |-		Mpd.SetPassword(wFooter->prompt("", -1, true));
+| 194|    |-		try {
+| 195|    |-			Mpd.SendPassword();
+| 196|    |-			Statusbar::print("Password accepted");
+| 197|    |-		} catch (MPD::ServerError &e_prim) {
+| 198|    |-			handleServerError(e_prim);
+| 199|    |-		}
+| 200|    |-	}
+|    | 179|+void
+|    | 180|+Status::handleClientError (MPD::ClientError & e)
+|    | 181|+{
+|    | 182|+    if (!e.clearable ())
+|    | 183|+        Mpd.Disconnect ();
+|    | 184|+    Statusbar::printf ("ncmpcpp: %1%", e.what ());
+|    | 185|+}
+|    | 186|+
+|    | 187|+void
+|    | 188|+Status::handleServerError (MPD::ServerError & e)
+|    | 189|+{
+|    | 190|+    Statusbar::printf ("MPD: %1%", e.what ());
+|    | 191|+    if (e.code () == MPD_SERVER_ERROR_PERMISSION)
+|    | 192|+      {
+|    | 193|+          NC::Window::ScopedPromptHook helper (*wFooter, nullptr);
+|    | 194|+          Statusbar::put () << "Password: ";
+|    | 195|+          Mpd.SetPassword (wFooter->prompt ("", -1, true));
+|    | 196|+          try
+|    | 197|+          {
+|    | 198|+              Mpd.SendPassword ();
+|    | 199|+              Statusbar::print ("Password accepted");
+|    | 200|+          }
+|    | 201|+          catch (MPD::ServerError & e_prim)
+|    | 202|+          {
+|    | 203|+              handleServerError (e_prim);
+|    | 204|+          }
+|    | 205|+      }
+| 201| 206| }
+| 202| 207| 
+| 203| 208| /*************************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.cpp
+|    |++++| /app/src/status.cpp
+| 202| 202| 
+| 203| 203| /*************************************************************************/
+| 204| 204| 
+| 205|    |-void Status::trace(bool update_timer, bool update_window_timeout)
+| 206|    |-{
+| 207|    |-	if (update_timer)
+| 208|    |-		Timer = boost::posix_time::microsec_clock::local_time();
+| 209|    |-	if (update_window_timeout)
+| 210|    |-	{
+| 211|    |-		// set appropriate window timeout
+| 212|    |-		int nc_wtimeout = std::numeric_limits<int>::max();
+| 213|    |-		applyToVisibleWindows([&nc_wtimeout](BaseScreen *s) {
+| 214|    |-			nc_wtimeout = std::min(nc_wtimeout, s->windowTimeout());
+| 215|    |-		});
+| 216|    |-		wFooter->setTimeout(nc_wtimeout);
+| 217|    |-	}
+| 218|    |-	if (Mpd.Connected())
+| 219|    |-	{
+| 220|    |-		if (!m_status_initialized)
+| 221|    |-			initialize_status();
+| 222|    |-
+| 223|    |-		if (m_player_state == MPD::psPlay
+| 224|    |-		&&  Global::Timer - past > boost::posix_time::seconds(1))
+| 225|    |-		{
+| 226|    |-			// update elapsed time/bitrate of the current song
+| 227|    |-			Status::Changes::elapsedTime(true);
+| 228|    |-			wFooter->refresh();
+| 229|    |-			past = Timer;
+| 230|    |-		}
+| 231|    |-
+| 232|    |-		applyToVisibleWindows(&BaseScreen::update);
+| 233|    |-		Statusbar::tryRedraw();
+| 234|    |-
+| 235|    |-		Mpd.idle();
+| 236|    |-	}
+| 237|    |-}
+| 238|    |-
+| 239|    |-void Status::update(int event)
+| 240|    |-{
+| 241|    |-	auto st = Mpd.getStatus();
+| 242|    |-	m_current_song_pos = st.currentSongPosition();
+| 243|    |-	m_elapsed_time = st.elapsedTime();
+| 244|    |-	m_kbps = st.kbps();
+| 245|    |-	m_player_state = st.playerState();
+| 246|    |-	m_playlist_length = st.playlistLength();
+| 247|    |-	m_total_time = st.totalTime();
+| 248|    |-	m_volume = st.volume();
+| 249|    |-
+| 250|    |-	if (event & MPD_IDLE_DATABASE)
+| 251|    |-		Changes::database();
+| 252|    |-	if (event & MPD_IDLE_STORED_PLAYLIST)
+| 253|    |-		Changes::storedPlaylists();
+| 254|    |-	if (event & MPD_IDLE_PLAYLIST)
+| 255|    |-	{
+| 256|    |-		Changes::playlist(m_playlist_version);
+| 257|    |-		m_playlist_version = st.playlistVersion();
+| 258|    |-	}
+| 259|    |-	if (event & MPD_IDLE_PLAYER)
+| 260|    |-	{
+| 261|    |-		Changes::playerState();
+| 262|    |-		if (m_current_song_id != st.currentSongID())
+| 263|    |-		{
+| 264|    |-			Changes::songID(st.currentSongID());
+| 265|    |-			m_current_song_id = st.currentSongID();
+| 266|    |-		}
+| 267|    |-	}
+| 268|    |-	if (event & MPD_IDLE_MIXER)
+| 269|    |-		Changes::mixer();
+| 270|    |-	if (event & MPD_IDLE_OUTPUT)
+| 271|    |-		Changes::outputs();
+| 272|    |-	if (event & (MPD_IDLE_UPDATE | MPD_IDLE_OPTIONS))
+| 273|    |-	{
+| 274|    |-		if (event & MPD_IDLE_UPDATE)
+| 275|    |-		{
+| 276|    |-			m_db_updating = st.updateID() ? 'U' : 0;
+| 277|    |-			if (m_status_initialized)
+| 278|    |-				Statusbar::printf("Database update %1%", m_db_updating ? "started" : "finished");
+| 279|    |-		}
+| 280|    |-		if (event & MPD_IDLE_OPTIONS)
+| 281|    |-		{
+| 282|    |-			if (('r' == m_repeat) != st.repeat())
+| 283|    |-			{
+| 284|    |-				m_repeat = st.repeat() ? 'r' : 0;
+| 285|    |-				if (m_status_initialized)
+| 286|    |-					Statusbar::printf("Repeat mode is %1%", !m_repeat ? "off" : "on");
+| 287|    |-			}
+| 288|    |-			if (('z' == m_random) != st.random())
+| 289|    |-			{
+| 290|    |-				m_random = st.random() ? 'z' : 0;
+| 291|    |-				if (m_status_initialized)
+| 292|    |-					Statusbar::printf("Random mode is %1%", !m_random ? "off" : "on");
+| 293|    |-			}
+| 294|    |-			if (('s' == m_single) != st.single())
+| 295|    |-			{
+| 296|    |-				m_single = st.single() ? 's' : 0;
+| 297|    |-				if (m_status_initialized)
+| 298|    |-					Statusbar::printf("Single mode is %1%", !m_single ? "off" : "on");
+| 299|    |-			}
+| 300|    |-			if (('c' == m_consume) != st.consume())
+| 301|    |-			{
+| 302|    |-				m_consume = st.consume() ? 'c' : 0;
+| 303|    |-				if (m_status_initialized)
+| 304|    |-					Statusbar::printf("Consume mode is %1%", !m_consume ? "off" : "on");
+| 305|    |-			}
+| 306|    |-			if (('x' == m_crossfade) != (st.crossfade() != 0))
+| 307|    |-			{
+| 308|    |-				int crossfade = st.crossfade();
+| 309|    |-				m_crossfade = crossfade ? 'x' : 0;
+| 310|    |-				if (m_status_initialized)
+| 311|    |-					Statusbar::printf("Crossfade set to %1% seconds", crossfade);
+| 312|    |-			}
+| 313|    |-		}
+| 314|    |-		Changes::flags();
+| 315|    |-	}
+| 316|    |-	m_status_initialized = true;
+| 317|    |-
+| 318|    |-	if (event & MPD_IDLE_PLAYER)
+| 319|    |-		wFooter->refresh();
+| 320|    |-
+| 321|    |-	if (event & (MPD_IDLE_PLAYLIST | MPD_IDLE_DATABASE | MPD_IDLE_PLAYER))
+| 322|    |-		applyToVisibleWindows(&BaseScreen::refreshWindow);
+| 323|    |-}
+| 324|    |-
+| 325|    |-void Status::clear()
+| 326|    |-{
+| 327|    |-	// reset local variables
+| 328|    |-	m_status_initialized = false;
+| 329|    |-	m_repeat = 0;
+| 330|    |-	m_random = 0;
+| 331|    |-	m_single = 0;
+| 332|    |-	m_consume = 0;
+| 333|    |-	m_crossfade = 0;
+| 334|    |-	m_db_updating = 0;
+| 335|    |-	m_current_song_id = -1;
+| 336|    |-	m_current_song_pos = -1;
+| 337|    |-	m_kbps = 0;
+| 338|    |-	m_player_state = MPD::psUnknown;
+| 339|    |-	m_playlist_length = 0;
+| 340|    |-	m_playlist_version = 0;
+| 341|    |-	m_total_time = 0;
+| 342|    |-	m_volume = -1;
+|    | 205|+void
+|    | 206|+Status::trace (bool update_timer, bool update_window_timeout)
+|    | 207|+{
+|    | 208|+    if (update_timer)
+|    | 209|+        Timer = boost::posix_time::microsec_clock::local_time ();
+|    | 210|+    if (update_window_timeout)
+|    | 211|+      {
+|    | 212|+          // set appropriate window timeout
+|    | 213|+          int nc_wtimeout = std::numeric_limits < int >::max ();
+|    | 214|+          applyToVisibleWindows ([&nc_wtimeout] (BaseScreen * s)
+|    | 215|+                                 {
+|    | 216|+                                 nc_wtimeout =
+|    | 217|+                                 std::min (nc_wtimeout,
+|    | 218|+                                           s->windowTimeout ());});
+|    | 219|+          wFooter->setTimeout (nc_wtimeout);
+|    | 220|+      }
+|    | 221|+    if (Mpd.Connected ())
+|    | 222|+      {
+|    | 223|+          if (!m_status_initialized)
+|    | 224|+              initialize_status ();
+|    | 225|+
+|    | 226|+          if (m_player_state == MPD::psPlay
+|    | 227|+              && Global::Timer - past > boost::posix_time::seconds (1))
+|    | 228|+            {
+|    | 229|+                // update elapsed time/bitrate of the current song
+|    | 230|+                Status::Changes::elapsedTime (true);
+|    | 231|+                wFooter->refresh ();
+|    | 232|+                past = Timer;
+|    | 233|+            }
+|    | 234|+
+|    | 235|+          applyToVisibleWindows (&BaseScreen::update);
+|    | 236|+          Statusbar::tryRedraw ();
+|    | 237|+
+|    | 238|+          Mpd.idle ();
+|    | 239|+      }
+|    | 240|+}
+|    | 241|+
+|    | 242|+void
+|    | 243|+Status::update (int event)
+|    | 244|+{
+|    | 245|+    auto st = Mpd.getStatus ();
+|    | 246|+    m_current_song_pos = st.currentSongPosition ();
+|    | 247|+    m_elapsed_time = st.elapsedTime ();
+|    | 248|+    m_kbps = st.kbps ();
+|    | 249|+    m_player_state = st.playerState ();
+|    | 250|+    m_playlist_length = st.playlistLength ();
+|    | 251|+    m_total_time = st.totalTime ();
+|    | 252|+    m_volume = st.volume ();
+|    | 253|+
+|    | 254|+    if (event & MPD_IDLE_DATABASE)
+|    | 255|+        Changes::database ();
+|    | 256|+    if (event & MPD_IDLE_STORED_PLAYLIST)
+|    | 257|+        Changes::storedPlaylists ();
+|    | 258|+    if (event & MPD_IDLE_PLAYLIST)
+|    | 259|+      {
+|    | 260|+          Changes::playlist (m_playlist_version);
+|    | 261|+          m_playlist_version = st.playlistVersion ();
+|    | 262|+      }
+|    | 263|+    if (event & MPD_IDLE_PLAYER)
+|    | 264|+      {
+|    | 265|+          Changes::playerState ();
+|    | 266|+          if (m_current_song_id != st.currentSongID ())
+|    | 267|+            {
+|    | 268|+                Changes::songID (st.currentSongID ());
+|    | 269|+                m_current_song_id = st.currentSongID ();
+|    | 270|+            }
+|    | 271|+      }
+|    | 272|+    if (event & MPD_IDLE_MIXER)
+|    | 273|+        Changes::mixer ();
+|    | 274|+    if (event & MPD_IDLE_OUTPUT)
+|    | 275|+        Changes::outputs ();
+|    | 276|+    if (event & (MPD_IDLE_UPDATE | MPD_IDLE_OPTIONS))
+|    | 277|+      {
+|    | 278|+          if (event & MPD_IDLE_UPDATE)
+|    | 279|+            {
+|    | 280|+                m_db_updating = st.updateID ()? 'U' : 0;
+|    | 281|+                if (m_status_initialized)
+|    | 282|+                    Statusbar::printf ("Database update %1%",
+|    | 283|+                                       m_db_updating ? "started" : "finished");
+|    | 284|+            }
+|    | 285|+          if (event & MPD_IDLE_OPTIONS)
+|    | 286|+            {
+|    | 287|+                if (('r' == m_repeat) != st.repeat ())
+|    | 288|+                  {
+|    | 289|+                      m_repeat = st.repeat ()? 'r' : 0;
+|    | 290|+                      if (m_status_initialized)
+|    | 291|+                          Statusbar::printf ("Repeat mode is %1%",
+|    | 292|+                                             !m_repeat ? "off" : "on");
+|    | 293|+                  }
+|    | 294|+                if (('z' == m_random) != st.random ())
+|    | 295|+                  {
+|    | 296|+                      m_random = st.random ()? 'z' : 0;
+|    | 297|+                      if (m_status_initialized)
+|    | 298|+                          Statusbar::printf ("Random mode is %1%",
+|    | 299|+                                             !m_random ? "off" : "on");
+|    | 300|+                  }
+|    | 301|+                if (('s' == m_single) != st.single ())
+|    | 302|+                  {
+|    | 303|+                      m_single = st.single ()? 's' : 0;
+|    | 304|+                      if (m_status_initialized)
+|    | 305|+                          Statusbar::printf ("Single mode is %1%",
+|    | 306|+                                             !m_single ? "off" : "on");
+|    | 307|+                  }
+|    | 308|+                if (('c' == m_consume) != st.consume ())
+|    | 309|+                  {
+|    | 310|+                      m_consume = st.consume ()? 'c' : 0;
+|    | 311|+                      if (m_status_initialized)
+|    | 312|+                          Statusbar::printf ("Consume mode is %1%",
+|    | 313|+                                             !m_consume ? "off" : "on");
+|    | 314|+                  }
+|    | 315|+                if (('x' == m_crossfade) != (st.crossfade () != 0))
+|    | 316|+                  {
+|    | 317|+                      int crossfade = st.crossfade ();
+|    | 318|+                      m_crossfade = crossfade ? 'x' : 0;
+|    | 319|+                      if (m_status_initialized)
+|    | 320|+                          Statusbar::printf ("Crossfade set to %1% seconds",
+|    | 321|+                                             crossfade);
+|    | 322|+                  }
+|    | 323|+            }
+|    | 324|+          Changes::flags ();
+|    | 325|+      }
+|    | 326|+    m_status_initialized = true;
+|    | 327|+
+|    | 328|+    if (event & MPD_IDLE_PLAYER)
+|    | 329|+        wFooter->refresh ();
+|    | 330|+
+|    | 331|+    if (event & (MPD_IDLE_PLAYLIST | MPD_IDLE_DATABASE | MPD_IDLE_PLAYER))
+|    | 332|+        applyToVisibleWindows (&BaseScreen::refreshWindow);
+|    | 333|+}
+|    | 334|+
+|    | 335|+void
+|    | 336|+Status::clear ()
+|    | 337|+{
+|    | 338|+    // reset local variables
+|    | 339|+    m_status_initialized = false;
+|    | 340|+    m_repeat = 0;
+|    | 341|+    m_random = 0;
+|    | 342|+    m_single = 0;
+|    | 343|+    m_consume = 0;
+|    | 344|+    m_crossfade = 0;
+|    | 345|+    m_db_updating = 0;
+|    | 346|+    m_current_song_id = -1;
+|    | 347|+    m_current_song_pos = -1;
+|    | 348|+    m_kbps = 0;
+|    | 349|+    m_player_state = MPD::psUnknown;
+|    | 350|+    m_playlist_length = 0;
+|    | 351|+    m_playlist_version = 0;
+|    | 352|+    m_total_time = 0;
+|    | 353|+    m_volume = -1;
+| 343| 354| }
+| 344| 355| 
+| 345| 356| /*************************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.cpp
+|    |++++| /app/src/status.cpp
+| 344| 344| 
+| 345| 345| /*************************************************************************/
+| 346| 346| 
+| 347|    |-bool Status::State::consume()
+| 348|    |-{
+| 349|    |-	return m_consume != 0;
+| 350|    |-}
+| 351|    |-
+| 352|    |-bool Status::State::crossfade()
+| 353|    |-{
+| 354|    |-	return m_crossfade != 0;
+| 355|    |-}
+| 356|    |-
+| 357|    |-bool Status::State::repeat()
+| 358|    |-{
+| 359|    |-	return m_repeat != 0;
+| 360|    |-}
+| 361|    |-
+| 362|    |-bool Status::State::random()
+| 363|    |-{
+| 364|    |-	return m_random != 0;
+| 365|    |-}
+| 366|    |-
+| 367|    |-bool Status::State::single()
+| 368|    |-{
+| 369|    |-	return m_single != 0;
+| 370|    |-}
+| 371|    |-
+| 372|    |-int Status::State::currentSongID()
+| 373|    |-{
+| 374|    |-	return m_current_song_id;
+| 375|    |-}
+| 376|    |-
+| 377|    |-int Status::State::currentSongPosition()
+| 378|    |-{
+| 379|    |-	return m_current_song_pos;
+| 380|    |-}
+| 381|    |-
+| 382|    |-unsigned Status::State::playlistLength()
+| 383|    |-{
+| 384|    |-	return m_playlist_length;
+| 385|    |-}
+| 386|    |-
+| 387|    |-unsigned Status::State::elapsedTime()
+| 388|    |-{
+| 389|    |-	return m_elapsed_time;
+| 390|    |-}
+| 391|    |-
+| 392|    |-MPD::PlayerState Status::State::player()
+| 393|    |-{
+| 394|    |-	return m_player_state;
+| 395|    |-}
+| 396|    |-
+| 397|    |-unsigned Status::State::totalTime()
+| 398|    |-{
+| 399|    |-	return m_total_time;
+| 400|    |-}
+| 401|    |-
+| 402|    |-int Status::State::volume()
+| 403|    |-{
+| 404|    |-	return m_volume;
+|    | 347|+bool
+|    | 348|+Status::State::consume ()
+|    | 349|+{
+|    | 350|+    return m_consume != 0;
+|    | 351|+}
+|    | 352|+
+|    | 353|+bool
+|    | 354|+Status::State::crossfade ()
+|    | 355|+{
+|    | 356|+    return m_crossfade != 0;
+|    | 357|+}
+|    | 358|+
+|    | 359|+bool
+|    | 360|+Status::State::repeat ()
+|    | 361|+{
+|    | 362|+    return m_repeat != 0;
+|    | 363|+}
+|    | 364|+
+|    | 365|+bool
+|    | 366|+Status::State::random ()
+|    | 367|+{
+|    | 368|+    return m_random != 0;
+|    | 369|+}
+|    | 370|+
+|    | 371|+bool
+|    | 372|+Status::State::single ()
+|    | 373|+{
+|    | 374|+    return m_single != 0;
+|    | 375|+}
+|    | 376|+
+|    | 377|+int
+|    | 378|+Status::State::currentSongID ()
+|    | 379|+{
+|    | 380|+    return m_current_song_id;
+|    | 381|+}
+|    | 382|+
+|    | 383|+int
+|    | 384|+Status::State::currentSongPosition ()
+|    | 385|+{
+|    | 386|+    return m_current_song_pos;
+|    | 387|+}
+|    | 388|+
+|    | 389|+unsigned
+|    | 390|+Status::State::playlistLength ()
+|    | 391|+{
+|    | 392|+    return m_playlist_length;
+|    | 393|+}
+|    | 394|+
+|    | 395|+unsigned
+|    | 396|+Status::State::elapsedTime ()
+|    | 397|+{
+|    | 398|+    return m_elapsed_time;
+|    | 399|+}
+|    | 400|+
+|    | 401|+MPD::PlayerState Status::State::player ()
+|    | 402|+{
+|    | 403|+    return m_player_state;
+|    | 404|+}
+|    | 405|+
+|    | 406|+unsigned
+|    | 407|+Status::State::totalTime ()
+|    | 408|+{
+|    | 409|+    return m_total_time;
+|    | 410|+}
+|    | 411|+
+|    | 412|+int
+|    | 413|+Status::State::volume ()
+|    | 414|+{
+|    | 415|+    return m_volume;
+| 405| 416| }
+| 406| 417| 
+| 407| 418| /*************************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.cpp
+|    |++++| /app/src/status.cpp
+| 406| 406| 
+| 407| 407| /*************************************************************************/
+| 408| 408| 
+| 409|    |-void Status::Changes::playlist(unsigned previous_version)
+| 410|    |-{
+| 411|    |-	{
+| 412|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter(ReapplyFilter::Yes, myPlaylist->main());
+| 413|    |-
+| 414|    |-		if (m_playlist_length < myPlaylist->main().size())
+| 415|    |-		{
+| 416|    |-			auto it = myPlaylist->main().begin()+m_playlist_length;
+| 417|    |-			auto end = myPlaylist->main().end();
+| 418|    |-			for (; it != end; ++it)
+| 419|    |-				myPlaylist->unregisterSong(it->value());
+| 420|    |-			myPlaylist->main().resizeList(m_playlist_length);
+| 421|    |-		}
+| 422|    |-
+| 423|    |-		MPD::SongIterator s = Mpd.GetPlaylistChanges(previous_version), end;
+| 424|    |-		for (; s != end; ++s)
+| 425|    |-		{
+| 426|    |-			size_t pos = s->getPosition();
+| 427|    |-			myPlaylist->registerSong(*s);
+| 428|    |-			if (pos < myPlaylist->main().size())
+| 429|    |-			{
+| 430|    |-				// if song's already in playlist, replace it with a new one
+| 431|    |-				MPD::Song &old_s = myPlaylist->main()[pos].value();
+| 432|    |-				myPlaylist->unregisterSong(old_s);
+| 433|    |-				old_s = std::move(*s);
+| 434|    |-			}
+| 435|    |-			else // otherwise just add it to playlist
+| 436|    |-				myPlaylist->main().addItem(std::move(*s));
+| 437|    |-		}
+| 438|    |-	}
+| 439|    |-
+| 440|    |-	myPlaylist->reloadTotalLength();
+| 441|    |-	myPlaylist->reloadRemaining();
+| 442|    |-
+| 443|    |-	// When we're in multi-column screens, it might happen that songs visible on
+| 444|    |-	// the screen are added, but they will not be immediately marked as such
+| 445|    |-	// because the window that contains them is not the active one at the moment,
+| 446|    |-	// so we need to refresh them manually.
+| 447|    |-	if (isVisible(myLibrary)
+| 448|    |-	    && !myLibrary->isActiveWindow(myLibrary->Songs))
+| 449|    |-		myLibrary->Songs.refresh();
+| 450|    |-	if (isVisible(myPlaylistEditor)
+| 451|    |-	    && !myPlaylistEditor->isActiveWindow(myPlaylistEditor->Content))
+| 452|    |-		myPlaylistEditor->Content.refresh();
+| 453|    |-}
+| 454|    |-
+| 455|    |-void Status::Changes::storedPlaylists()
+| 456|    |-{
+| 457|    |-	myPlaylistEditor->requestPlaylistsUpdate();
+| 458|    |-	myPlaylistEditor->requestContentUpdate();
+| 459|    |-	if (!myBrowser->isLocal() && myBrowser->inRootDirectory())
+| 460|    |-		myBrowser->requestUpdate();
+| 461|    |-}
+| 462|    |-
+| 463|    |-void Status::Changes::database()
+| 464|    |-{
+| 465|    |-	myBrowser->requestUpdate();
+|    | 409|+void
+|    | 410|+Status::Changes::playlist (unsigned previous_version)
+|    | 411|+{
+|    | 412|+    {
+|    | 413|+        ScopedUnfilteredMenu < MPD::Song > sunfilter (ReapplyFilter::Yes,
+|    | 414|+                                                      myPlaylist->main ());
+|    | 415|+
+|    | 416|+        if (m_playlist_length < myPlaylist->main ().size ())
+|    | 417|+          {
+|    | 418|+              auto
+|    | 419|+                  it = myPlaylist->main ().begin () + m_playlist_length;
+|    | 420|+              auto
+|    | 421|+                  end = myPlaylist->main ().end ();
+|    | 422|+              for (; it != end; ++it)
+|    | 423|+                  myPlaylist->unregisterSong (it->value ());
+|    | 424|+              myPlaylist->main ().resizeList (m_playlist_length);
+|    | 425|+          }
+|    | 426|+
+|    | 427|+        MPD::SongIterator s = Mpd.GetPlaylistChanges (previous_version), end;
+|    | 428|+        for (; s != end; ++s)
+|    | 429|+          {
+|    | 430|+              size_t
+|    | 431|+                  pos = s->getPosition ();
+|    | 432|+              myPlaylist->registerSong (*s);
+|    | 433|+              if (pos < myPlaylist->main ().size ())
+|    | 434|+                {
+|    | 435|+                    // if song's already in playlist, replace it with a new one
+|    | 436|+                    MPD::Song & old_s = myPlaylist->main ()[pos].value ();
+|    | 437|+                    myPlaylist->unregisterSong (old_s);
+|    | 438|+                    old_s = std::move (*s);
+|    | 439|+                }
+|    | 440|+              else              // otherwise just add it to playlist
+|    | 441|+                  myPlaylist->main ().addItem (std::move (*s));
+|    | 442|+          }
+|    | 443|+    }
+|    | 444|+
+|    | 445|+    myPlaylist->reloadTotalLength ();
+|    | 446|+    myPlaylist->reloadRemaining ();
+|    | 447|+
+|    | 448|+    // When we're in multi-column screens, it might happen that songs visible on
+|    | 449|+    // the screen are added, but they will not be immediately marked as such
+|    | 450|+    // because the window that contains them is not the active one at the moment,
+|    | 451|+    // so we need to refresh them manually.
+|    | 452|+    if (isVisible (myLibrary) && !myLibrary->isActiveWindow (myLibrary->Songs))
+|    | 453|+        myLibrary->Songs.refresh ();
+|    | 454|+    if (isVisible (myPlaylistEditor)
+|    | 455|+        && !myPlaylistEditor->isActiveWindow (myPlaylistEditor->Content))
+|    | 456|+        myPlaylistEditor->Content.refresh ();
+|    | 457|+}
+|    | 458|+
+|    | 459|+void
+|    | 460|+Status::Changes::storedPlaylists ()
+|    | 461|+{
+|    | 462|+    myPlaylistEditor->requestPlaylistsUpdate ();
+|    | 463|+    myPlaylistEditor->requestContentUpdate ();
+|    | 464|+    if (!myBrowser->isLocal () && myBrowser->inRootDirectory ())
+|    | 465|+        myBrowser->requestUpdate ();
+|    | 466|+}
+|    | 467|+
+|    | 468|+void
+|    | 469|+Status::Changes::database ()
+|    | 470|+{
+|    | 471|+    myBrowser->requestUpdate ();
+| 466| 472| #	ifdef HAVE_TAGLIB_H
+| 467|    |-	myTagEditor->Dirs->clear();
+|    | 473|+    myTagEditor->Dirs->clear ();
+| 468| 474| #	endif // HAVE_TAGLIB_H
+| 469|    |-	myLibrary->requestTagsUpdate();
+| 470|    |-	myLibrary->requestAlbumsUpdate();
+| 471|    |-	myLibrary->requestSongsUpdate();
+| 472|    |-}
+| 473|    |-
+| 474|    |-void Status::Changes::playerState()
+| 475|    |-{
+| 476|    |-	if (!Config.execute_on_player_state_change.empty())
+| 477|    |-	{
+| 478|    |-		auto stateToEnv = [](MPD::PlayerState st) -> const char * {
+| 479|    |-			switch (st)
+| 480|    |-			{
+| 481|    |-			case MPD::psPlay:    return "play";
+| 482|    |-			case MPD::psStop:    return "stop";
+| 483|    |-			case MPD::psPause:   return "pause";
+| 484|    |-			case MPD::psUnknown: return "unknown";
+| 485|    |-			}
+| 486|    |-			throw std::logic_error("unreachable");
+| 487|    |-		};
+| 488|    |-		GNUC_UNUSED int res;
+| 489|    |-		setenv("MPD_PLAYER_STATE", stateToEnv(m_player_state), 1);
+| 490|    |-		res = system(Config.execute_on_player_state_change.c_str());
+| 491|    |-		unsetenv("MPD_PLAYER_STATE");
+| 492|    |-	}
+| 493|    |-
+| 494|    |-	switch (m_player_state)
+| 495|    |-	{
+| 496|    |-		case MPD::psPlay:
+| 497|    |-		{
+| 498|    |-			auto np = myPlaylist->nowPlayingSong();
+| 499|    |-			if (!np.empty())
+| 500|    |-				drawTitle(np);
+| 501|    |-			myPlaylist->reloadRemaining();
+| 502|    |-			break;
+| 503|    |-		}
+| 504|    |-		case MPD::psStop:
+| 505|    |-			windowTitle("ncmpcpp " VERSION);
+| 506|    |-			if (Progressbar::isUnlocked())
+| 507|    |-				Progressbar::draw(0, 0);
+| 508|    |-			myPlaylist->reloadRemaining();
+| 509|    |-			if (Config.design == Design::Alternative)
+| 510|    |-			{
+| 511|    |-				*wHeader << NC::XY(0, 0) << NC::TermManip::ClearToEOL;
+| 512|    |-				*wHeader << NC::XY(0, 1) << NC::TermManip::ClearToEOL;
+| 513|    |-				mixer();
+| 514|    |-				flags();
+| 515|    |-			}
+|    | 475|+    myLibrary->requestTagsUpdate ();
+|    | 476|+    myLibrary->requestAlbumsUpdate ();
+|    | 477|+    myLibrary->requestSongsUpdate ();
+|    | 478|+}
+|    | 479|+
+|    | 480|+void
+|    | 481|+Status::Changes::playerState ()
+|    | 482|+{
+|    | 483|+    if (!Config.execute_on_player_state_change.empty ())
+|    | 484|+      {
+|    | 485|+          auto
+|    | 486|+              stateToEnv =[](MPD::PlayerState st)->const char *{
+|    | 487|+              switch (st)
+|    | 488|+                {
+|    | 489|+                case MPD::psPlay:
+|    | 490|+                 return "play";
+|    | 491|+                 case MPD::psStop:return "stop";
+|    | 492|+                 case MPD::psPause:return "pause";
+|    | 493|+                 case MPD::psUnknown:return "unknown";}
+|    | 494|+                 throw std::logic_error ("unreachable");};
+|    | 495|+                 GNUC_UNUSED int res;
+|    | 496|+                 setenv ("MPD_PLAYER_STATE", stateToEnv (m_player_state), 1);
+|    | 497|+                 res = system (Config.execute_on_player_state_change.c_str ());
+|    | 498|+                 unsetenv ("MPD_PLAYER_STATE");}
+|    | 499|+
+|    | 500|+                 switch (m_player_state)
+|    | 501|+                 {
+|    | 502|+case MPD::psPlay:
+|    | 503|+                 {
+|    | 504|+                 auto np = myPlaylist->nowPlayingSong ();
+|    | 505|+                 if (!np.empty ())drawTitle (np);
+|    | 506|+                 myPlaylist->reloadRemaining (); break;}
+|    | 507|+case MPD::psStop:
+|    | 508|+                 windowTitle ("ncmpcpp " VERSION);
+|    | 509|+                 if (Progressbar::isUnlocked ())Progressbar::draw (0, 0);
+|    | 510|+                 myPlaylist->reloadRemaining ();
+|    | 511|+                 if (Config.design == Design::Alternative)
+|    | 512|+                 {
+|    | 513|+                 *wHeader << NC::XY (0, 0) << NC::TermManip::ClearToEOL;
+|    | 514|+                 *wHeader << NC::XY (0, 1) << NC::TermManip::ClearToEOL;
+|    | 515|+                 mixer (); flags ();}
+| 516| 516| #			ifdef ENABLE_VISUALIZER
+| 517|    |-			if (isVisible(myVisualizer))
+| 518|    |-				myVisualizer->main().clear();
+|    | 517|+                 if (isVisible (myVisualizer)) myVisualizer->main ().clear ();
+| 519| 518| #			endif // ENABLE_VISUALIZER
+| 520|    |-			break;
+| 521|    |-		default:
+| 522|    |-			break;
+| 523|    |-	}
+| 524|    |-
+| 525|    |-	std::string state = playerStateToString(m_player_state);
+| 526|    |-	if (Config.design == Design::Alternative)
+| 527|    |-	{
+| 528|    |-		*wHeader << NC::XY(0, 1) << NC::Format::Bold << state << NC::Format::NoBold;
+| 529|    |-		wHeader->refresh();
+| 530|    |-	}
+| 531|    |-	else if (Statusbar::isUnlocked() && Config.statusbar_visibility)
+| 532|    |-	{
+| 533|    |-		*wFooter << NC::XY(0, 1);
+| 534|    |-		if (state.empty())
+| 535|    |-			*wFooter << NC::TermManip::ClearToEOL;
+| 536|    |-		else
+| 537|    |-			*wFooter << NC::Format::Bold << state << NC::Format::NoBold;
+| 538|    |-	}
+| 539|    |-
+| 540|    |-	// needed for immediate display after starting
+| 541|    |-	// player from stopped state or seeking
+| 542|    |-	elapsedTime(false);
+| 543|    |-}
+| 544|    |-
+| 545|    |-void Status::Changes::songID(int song_id)
+| 546|    |-{
+| 547|    |-	// update information about current song
+| 548|    |-	myPlaylist->reloadRemaining();
+| 549|    |-	playing_song_scroll_begin = 0;
+| 550|    |-	first_line_scroll_begin = 0;
+| 551|    |-	second_line_scroll_begin = 0;
+|    | 519|+break; default:
+|    | 520|+                 break;}
+|    | 521|+
+|    | 522|+                 std::string state = playerStateToString (m_player_state);
+|    | 523|+                 if (Config.design == Design::Alternative)
+|    | 524|+                 {
+|    | 525|+                 *wHeader << NC::XY (0,
+|    | 526|+                                     1) << NC::Format::Bold << state << NC::
+|    | 527|+                 Format::NoBold; wHeader->refresh ();}
+|    | 528|+                 else
+|    | 529|+                 if (Statusbar::isUnlocked () && Config.statusbar_visibility)
+|    | 530|+                 {
+|    | 531|+                 *wFooter << NC::XY (0, 1);
+|    | 532|+                 if (state.empty ()) * wFooter << NC::TermManip::ClearToEOL;
+|    | 533|+                 else
+|    | 534|+                 *wFooter << NC::Format::Bold << state << NC::Format::NoBold;}
+|    | 535|+
+|    | 536|+    // needed for immediate display after starting
+|    | 537|+    // player from stopped state or seeking
+|    | 538|+                 elapsedTime (false);}
+|    | 539|+
+|    | 540|+                 void Status::Changes::songID (int song_id)
+|    | 541|+                 {
+|    | 542|+                 // update information about current song
+|    | 543|+                 myPlaylist->reloadRemaining ();
+|    | 544|+                 playing_song_scroll_begin = 0;
+|    | 545|+                 first_line_scroll_begin = 0; second_line_scroll_begin = 0;
+| 552| 546| #	ifdef ENABLE_VISUALIZER
+| 553|    |-	myVisualizer->ResetAutoScaleMultiplier();
+|    | 547|+                 myVisualizer->ResetAutoScaleMultiplier ();
+| 554| 548| #	endif // ENABLE_VISUALIZER
+| 555|    |-	if (m_player_state != MPD::psStop)
+| 556|    |-	{
+| 557|    |-		auto &pl = myPlaylist->main();
+| 558|    |-
+| 559|    |-		// try to find the song with new id in the playlist
+| 560|    |-		auto it = std::find_if(pl.beginV(), pl.endV(), [song_id](const MPD::Song &s) {
+| 561|    |-			return s.getID() == unsigned(song_id);
+| 562|    |-		});
+| 563|    |-		// if it's not there (playlist may be outdated), fetch it
+| 564|    |-		const auto &s = it != pl.endV() ? *it : Mpd.GetCurrentSong();
+| 565|    |-		if (!s.empty())
+| 566|    |-		{
+| 567|    |-			GNUC_UNUSED int res;
+| 568|    |-			if (!Config.execute_on_song_change.empty())
+| 569|    |-				res = system(Config.execute_on_song_change.c_str());
+| 570|    |-
+| 571|    |-			if (Config.fetch_lyrics_in_background)
+| 572|    |-				myLyrics->fetchInBackground(s, false);
+| 573|    |-
+| 574|    |-			drawTitle(s);
+| 575|    |-
+| 576|    |-			if (Config.autocenter_mode)
+| 577|    |-				myPlaylist->locateSong(s);
+| 578|    |-
+| 579|    |-			if (Config.now_playing_lyrics
+| 580|    |-			    && isVisible(myLyrics)
+| 581|    |-			    && myLyrics->previousScreen() == myPlaylist)
+| 582|    |-				myLyrics->fetch(s);
+| 583|    |-		}
+| 584|    |-	}
+| 585|    |-	elapsedTime(false);
+| 586|    |-}
+| 587|    |-
+| 588|    |-void Status::Changes::elapsedTime(bool update_elapsed)
+| 589|    |-{
+| 590|    |-	auto np = myPlaylist->nowPlayingSong();
+| 591|    |-	if (m_player_state == MPD::psStop || np.empty())
+| 592|    |-	{
+| 593|    |-		// MPD is not playing, clear statusbar and exit.
+| 594|    |-		if (Statusbar::isUnlocked() && Config.statusbar_visibility)
+| 595|    |-			*wFooter << NC::XY(0, 1)
+| 596|    |-			         << NC::TermManip::ClearToEOL;
+| 597|    |-		return;
+| 598|    |-	}
+| 599|    |-
+| 600|    |-	if (update_elapsed)
+| 601|    |-	{
+| 602|    |-		auto st = Mpd.getStatus();
+| 603|    |-		m_elapsed_time = st.elapsedTime();
+| 604|    |-		m_kbps = st.kbps();
+| 605|    |-	}
+| 606|    |-
+| 607|    |-	std::string ps = playerStateToString(m_player_state);
+| 608|    |-	std::string tracklength;
+| 609|    |-
+| 610|    |-	drawTitle(np);
+| 611|    |-	switch (Config.design)
+| 612|    |-	{
+| 613|    |-		case Design::Classic:
+| 614|    |-			if (Statusbar::isUnlocked() && Config.statusbar_visibility)
+| 615|    |-			{
+| 616|    |-				if (Config.display_bitrate && m_kbps)
+| 617|    |-				{
+| 618|    |-					tracklength += "(";
+| 619|    |-					tracklength += boost::lexical_cast<std::string>(m_kbps);
+| 620|    |-					tracklength += " kbps) ";
+| 621|    |-				}
+| 622|    |-				tracklength += "[";
+| 623|    |-				if (m_total_time)
+| 624|    |-				{
+| 625|    |-					if (Config.display_remaining_time)
+| 626|    |-					{
+| 627|    |-						tracklength += "-";
+| 628|    |-						tracklength += MPD::Song::ShowTime(m_total_time-m_elapsed_time);
+| 629|    |-					}
+| 630|    |-					else
+| 631|    |-						tracklength += MPD::Song::ShowTime(m_elapsed_time);
+| 632|    |-					tracklength += "/";
+| 633|    |-					tracklength += MPD::Song::ShowTime(m_total_time);
+| 634|    |-				}
+| 635|    |-				else
+| 636|    |-					tracklength += MPD::Song::ShowTime(m_elapsed_time);
+| 637|    |-				tracklength += "]";
+| 638|    |-				NC::WBuffer np_song;
+| 639|    |-				Format::print(Config.song_status_wformat, np_song, &np);
+| 640|    |-				*wFooter << NC::XY(0, 1)
+| 641|    |-				         << NC::TermManip::ClearToEOL
+| 642|    |-				         << Config.player_state_color
+| 643|    |-				         << ps
+| 644|    |-				         << NC::FormattedColor::End<>(Config.player_state_color)
+| 645|    |-				         << " ";
+| 646|    |-				writeCyclicBuffer(
+| 647|    |-					np_song, *wFooter, playing_song_scroll_begin,
+| 648|    |-					wFooter->getWidth()-ps.length()-tracklength.length()-2, L" ** ");
+| 649|    |-				*wFooter << NC::XY(wFooter->getWidth()-tracklength.length(), 1)
+| 650|    |-				         << Config.statusbar_time_color
+| 651|    |-				         << tracklength
+| 652|    |-				         << NC::FormattedColor::End<>(Config.statusbar_time_color);
+| 653|    |-			}
+| 654|    |-			break;
+| 655|    |-		case Design::Alternative:
+| 656|    |-			if (Config.display_remaining_time)
+| 657|    |-			{
+| 658|    |-				tracklength = "-";
+| 659|    |-				tracklength += MPD::Song::ShowTime(m_total_time-m_elapsed_time);
+| 660|    |-			}
+| 661|    |-			else
+| 662|    |-				tracklength = MPD::Song::ShowTime(m_elapsed_time);
+| 663|    |-			if (m_total_time)
+| 664|    |-			{
+| 665|    |-				tracklength += "/";
+| 666|    |-				tracklength += MPD::Song::ShowTime(m_total_time);
+| 667|    |-			}
+| 668|    |-			// bitrate here doesn't look good, but it can be moved somewhere else later
+| 669|    |-			if (Config.display_bitrate && m_kbps)
+| 670|    |-			{
+| 671|    |-				tracklength += " (";
+| 672|    |-				tracklength += boost::lexical_cast<std::string>(m_kbps);
+| 673|    |-				tracklength += " kbps)";
+| 674|    |-			}
+| 675|    |-
+| 676|    |-			NC::WBuffer first, second;
+| 677|    |-			Format::print(Config.new_header_first_line, first, &np);
+| 678|    |-			Format::print(Config.new_header_second_line, second, &np);
+| 679|    |-
+| 680|    |-			size_t first_len = wideLength(first.str());
+| 681|    |-			size_t first_margin = std::max(tracklength.length()+1, VolumeState.length())*2;
+| 682|    |-			size_t first_start = first_len < COLS-first_margin
+| 683|    |-			                                 ? (COLS-first_len)/2
+| 684|    |-			                                 : tracklength.length()+1;
+| 685|    |-			size_t second_len = wideLength(second.str());
+| 686|    |-			size_t second_margin = (std::max(ps.length(), size_t(8))+1)*2;
+| 687|    |-			size_t second_start = second_len < COLS-second_margin
+| 688|    |-			                                   ? (COLS-second_len)/2
+| 689|    |-			                                   : ps.length()+1;
+| 690|    |-			if (!Global::SeekingInProgress)
+| 691|    |-				*wHeader << NC::XY(0, 0)
+| 692|    |-				         << NC::TermManip::ClearToEOL
+| 693|    |-				         << Config.statusbar_time_color
+| 694|    |-				         << tracklength
+| 695|    |-				         << NC::FormattedColor::End<>(Config.statusbar_time_color);
+| 696|    |-
+| 697|    |-			*wHeader << NC::XY(first_start, 0);
+| 698|    |-
+| 699|    |-			writeCyclicBuffer(first, *wHeader, first_line_scroll_begin,
+| 700|    |-			                  COLS-tracklength.length()-VolumeState.length()-1, L" ** ");
+| 701|    |-
+| 702|    |-			*wHeader << NC::XY(0, 1)
+| 703|    |-			         << NC::TermManip::ClearToEOL
+| 704|    |-			         << Config.player_state_color
+| 705|    |-			         << ps
+| 706|    |-			         << NC::FormattedColor::End<>(Config.player_state_color)
+| 707|    |-			         << NC::XY(second_start, 1);
+| 708|    |-
+| 709|    |-			writeCyclicBuffer(second, *wHeader, second_line_scroll_begin,
+| 710|    |-			                  COLS-ps.length()-8-2, L" ** ");
+| 711|    |-
+| 712|    |-			*wHeader << NC::XY(wHeader->getWidth()-VolumeState.length(), 0)
+| 713|    |-			         << Config.volume_color
+| 714|    |-			         << VolumeState
+| 715|    |-			         << NC::FormattedColor::End<>(Config.volume_color);
+| 716|    |-
+| 717|    |-			flags();
+| 718|    |-	}
+| 719|    |-	if (Progressbar::isUnlocked())
+| 720|    |-		Progressbar::draw(m_elapsed_time, m_total_time);
+| 721|    |-}
+| 722|    |-
+| 723|    |-void Status::Changes::flags()
+| 724|    |-{
+| 725|    |-	if (!Config.header_visibility && Config.design == Design::Classic)
+| 726|    |-		return;
+| 727|    |-
+| 728|    |-	std::string switch_state;
+| 729|    |-	switch (Config.design)
+| 730|    |-	{
+| 731|    |-		case Design::Classic:
+| 732|    |-			if (m_repeat)
+| 733|    |-				switch_state += m_repeat;
+| 734|    |-			if (m_random)
+| 735|    |-				switch_state += m_random;
+| 736|    |-			if (m_single)
+| 737|    |-				switch_state += m_single;
+| 738|    |-			if (m_consume)
+| 739|    |-				switch_state += m_consume;
+| 740|    |-			if (m_crossfade)
+| 741|    |-				switch_state += m_crossfade;
+| 742|    |-			if (m_db_updating)
+| 743|    |-				switch_state += m_db_updating;
+| 744|    |-
+| 745|    |-			*wHeader << Config.state_line_color;
+| 746|    |-			mvwhline(wHeader->raw(), 1, 0, 0, COLS);
+| 747|    |-			*wHeader << NC::FormattedColor::End<>(Config.state_line_color);
+| 748|    |-
+| 749|    |-			if (!switch_state.empty())
+| 750|    |-				*wHeader << NC::XY(COLS-switch_state.length()-3, 1)
+| 751|    |-				         << Config.state_line_color
+| 752|    |-				         << "["
+| 753|    |-				         << NC::FormattedColor::End<>(Config.state_line_color)
+| 754|    |-								 << Config.state_flags_color
+| 755|    |-								 << switch_state
+| 756|    |-				         << NC::FormattedColor::End<>(Config.state_flags_color)
+| 757|    |-				         << Config.state_line_color
+| 758|    |-								 << "]"
+| 759|    |-				         << NC::FormattedColor::End<>(Config.state_line_color);
+| 760|    |-
+| 761|    |-			break;
+| 762|    |-		case Design::Alternative:
+| 763|    |-			switch_state += '[';
+| 764|    |-			switch_state += m_repeat ? m_repeat : '-';
+| 765|    |-			switch_state += m_random ? m_random : '-';
+| 766|    |-			switch_state += m_single ? m_single : '-';
+| 767|    |-			switch_state += m_consume ? m_consume : '-';
+| 768|    |-			switch_state += m_crossfade ? m_crossfade : '-';
+| 769|    |-			switch_state += m_db_updating ? m_db_updating : '-';
+| 770|    |-			switch_state += ']';
+| 771|    |-			*wHeader << NC::XY(COLS-switch_state.length(), 1)
+| 772|    |-			         << Config.state_flags_color
+| 773|    |-			         << switch_state
+| 774|    |-			         << NC::FormattedColor::End<>(Config.state_flags_color);
+| 775|    |-			if (!Config.header_visibility) // in this case also draw separator
+| 776|    |-			{
+| 777|    |-				*wHeader << Config.alternative_ui_separator_color;
+| 778|    |-				mvwhline(wHeader->raw(), 2, 0, 0, COLS);
+| 779|    |-				*wHeader << NC::FormattedColor::End<>(Config.alternative_ui_separator_color);
+| 780|    |-			}
+| 781|    |-			break;
+| 782|    |-	}
+| 783|    |-	wHeader->refresh();
+| 784|    |-}
+| 785|    |-
+| 786|    |-void Status::Changes::mixer()
+| 787|    |-{
+| 788|    |-	if (!Config.display_volume_level
+| 789|    |-	    || (!Config.header_visibility && Config.design == Design::Classic))
+| 790|    |-		return;
+| 791|    |-
+| 792|    |-	switch (Config.design)
+| 793|    |-	{
+| 794|    |-		case Design::Classic:
+| 795|    |-			VolumeState = " Volume: ";
+| 796|    |-			break;
+| 797|    |-		case Design::Alternative:
+| 798|    |-			VolumeState = " Vol: ";
+| 799|    |-			break;
+| 800|    |-	}
+| 801|    |-	if (m_volume < 0)
+| 802|    |-		VolumeState += "n/a";
+| 803|    |-	else
+| 804|    |-	{
+| 805|    |-		VolumeState += boost::lexical_cast<std::string>(m_volume);
+| 806|    |-		VolumeState += "%";
+| 807|    |-	}
+| 808|    |-	*wHeader << NC::XY(wHeader->getWidth()-VolumeState.length(), 0)
+| 809|    |-	         << Config.volume_color
+| 810|    |-	         << VolumeState
+| 811|    |-	         << NC::FormattedColor::End<>(Config.volume_color);
+| 812|    |-	wHeader->refresh();
+| 813|    |-}
+| 814|    |-
+| 815|    |-void Status::Changes::outputs()
+| 816|    |-{
+|    | 549|+                 if (m_player_state != MPD::psStop)
+|    | 550|+                 {
+|    | 551|+                 auto & pl = myPlaylist->main ();
+|    | 552|+                 // try to find the song with new id in the playlist
+|    | 553|+                 auto it =
+|    | 554|+                 std::find_if (pl.beginV (), pl.endV (),
+|    | 555|+                               [song_id] (const MPD::Song & s)
+|    | 556|+                               {
+|    | 557|+                               return s.getID () == unsigned (song_id);});
+|    | 558|+                 // if it's not there (playlist may be outdated), fetch it
+|    | 559|+                 const auto & s =
+|    | 560|+                 it != pl.endV ()? *it : Mpd.GetCurrentSong ();
+|    | 561|+                 if (!s.empty ())
+|    | 562|+                 {
+|    | 563|+                 GNUC_UNUSED int res;
+|    | 564|+                 if (!Config.execute_on_song_change.empty ())res =
+|    | 565|+                 system (Config.execute_on_song_change.c_str ());
+|    | 566|+                 if (Config.fetch_lyrics_in_background) myLyrics->
+|    | 567|+                 fetchInBackground (s, false); drawTitle (s);
+|    | 568|+                 if (Config.autocenter_mode) myPlaylist->locateSong (s);
+|    | 569|+                 if (Config.now_playing_lyrics && isVisible (myLyrics)
+|    | 570|+                     && myLyrics->previousScreen () ==
+|    | 571|+                     myPlaylist) myLyrics->fetch (s);}
+|    | 572|+                 }
+|    | 573|+                 elapsedTime (false);}
+|    | 574|+
+|    | 575|+                 void Status::Changes::elapsedTime (bool update_elapsed)
+|    | 576|+                 {
+|    | 577|+                 auto np = myPlaylist->nowPlayingSong ();
+|    | 578|+                 if (m_player_state == MPD::psStop || np.empty ())
+|    | 579|+                 {
+|    | 580|+                 // MPD is not playing, clear statusbar and exit.
+|    | 581|+                 if (Statusbar::isUnlocked () && Config.statusbar_visibility)
+|    | 582|+                 * wFooter << NC::XY (0, 1)
+|    | 583|+                 << NC::TermManip::ClearToEOL; return;}
+|    | 584|+
+|    | 585|+                 if (update_elapsed)
+|    | 586|+                 {
+|    | 587|+                 auto st = Mpd.getStatus ();
+|    | 588|+                 m_elapsed_time = st.elapsedTime (); m_kbps = st.kbps ();}
+|    | 589|+
+|    | 590|+                 std::string ps = playerStateToString (m_player_state);
+|    | 591|+                 std::string tracklength;
+|    | 592|+                 drawTitle (np); switch (Config.design)
+|    | 593|+                 {
+|    | 594|+case Design::Classic:
+|    | 595|+                 if (Statusbar::isUnlocked () && Config.statusbar_visibility)
+|    | 596|+                 {
+|    | 597|+                 if (Config.display_bitrate && m_kbps)
+|    | 598|+                 {
+|    | 599|+                 tracklength += "(";
+|    | 600|+                 tracklength += boost::lexical_cast < std::string > (m_kbps);
+|    | 601|+                 tracklength += " kbps) ";}
+|    | 602|+                 tracklength += "["; if (m_total_time)
+|    | 603|+                 {
+|    | 604|+                 if (Config.display_remaining_time)
+|    | 605|+                 {
+|    | 606|+                 tracklength += "-";
+|    | 607|+                 tracklength +=
+|    | 608|+                 MPD::Song::ShowTime (m_total_time - m_elapsed_time);}
+|    | 609|+                 else
+|    | 610|+                 tracklength += MPD::Song::ShowTime (m_elapsed_time);
+|    | 611|+                 tracklength += "/";
+|    | 612|+                 tracklength += MPD::Song::ShowTime (m_total_time);}
+|    | 613|+                 else
+|    | 614|+                 tracklength += MPD::Song::ShowTime (m_elapsed_time);
+|    | 615|+                 tracklength += "]";
+|    | 616|+                 NC::WBuffer np_song;
+|    | 617|+                 Format::print (Config.song_status_wformat, np_song, &np);
+|    | 618|+                 *wFooter << NC::XY (0, 1)
+|    | 619|+                 << NC::TermManip::ClearToEOL
+|    | 620|+                 << Config.player_state_color
+|    | 621|+                 << ps
+|    | 622|+                 << NC::FormattedColor::End <> (Config.player_state_color)
+|    | 623|+                 << " ";
+|    | 624|+                 writeCyclicBuffer (np_song, *wFooter,
+|    | 625|+                                    playing_song_scroll_begin,
+|    | 626|+                                    wFooter->getWidth () - ps.length () -
+|    | 627|+                                    tracklength.length () - 2, L" ** ");
+|    | 628|+                 *wFooter << NC::XY (wFooter->getWidth () -
+|    | 629|+                                     tracklength.length (),
+|    | 630|+                                     1) << Config.
+|    | 631|+                 statusbar_time_color << tracklength << NC::FormattedColor::
+|    | 632|+                 End <> (Config.statusbar_time_color);}
+|    | 633|+break; case Design::Alternative:
+|    | 634|+                 if (Config.display_remaining_time)
+|    | 635|+                 {
+|    | 636|+                 tracklength = "-";
+|    | 637|+                 tracklength +=
+|    | 638|+                 MPD::Song::ShowTime (m_total_time - m_elapsed_time);}
+|    | 639|+                 else
+|    | 640|+                 tracklength = MPD::Song::ShowTime (m_elapsed_time);
+|    | 641|+                 if (m_total_time)
+|    | 642|+                 {
+|    | 643|+                 tracklength += "/";
+|    | 644|+                 tracklength += MPD::Song::ShowTime (m_total_time);}
+|    | 645|+                 // bitrate here doesn't look good, but it can be moved somewhere else later
+|    | 646|+                 if (Config.display_bitrate && m_kbps)
+|    | 647|+                 {
+|    | 648|+                 tracklength += " (";
+|    | 649|+                 tracklength += boost::lexical_cast < std::string > (m_kbps);
+|    | 650|+                 tracklength += " kbps)";}
+|    | 651|+
+|    | 652|+                 NC::WBuffer first, second;
+|    | 653|+                 Format::print (Config.new_header_first_line, first, &np);
+|    | 654|+                 Format::print (Config.new_header_second_line, second, &np);
+|    | 655|+                 size_t first_len = wideLength (first.str ());
+|    | 656|+                 size_t first_margin =
+|    | 657|+                 std::max (tracklength.length () + 1,
+|    | 658|+                           VolumeState.length ()) * 2;
+|    | 659|+                 size_t first_start =
+|    | 660|+                 first_len <
+|    | 661|+                 COLS - first_margin ? (COLS -
+|    | 662|+                                        first_len) /
+|    | 663|+                 2 : tracklength.length () + 1;
+|    | 664|+                 size_t second_len = wideLength (second.str ());
+|    | 665|+                 size_t second_margin =
+|    | 666|+                 (std::max (ps.length (), size_t (8)) + 1) * 2;
+|    | 667|+                 size_t second_start =
+|    | 668|+                 second_len <
+|    | 669|+                 COLS - second_margin ? (COLS -
+|    | 670|+                                         second_len) / 2 : ps.length () + 1;
+|    | 671|+                 if (!Global::SeekingInProgress) * wHeader << NC::XY (0,
+|    | 672|+                                                                      0) <<
+|    | 673|+                 NC::TermManip::ClearToEOL << Config.
+|    | 674|+                 statusbar_time_color << tracklength << NC::FormattedColor::
+|    | 675|+                 End <> (Config.statusbar_time_color);
+|    | 676|+                 *wHeader << NC::XY (first_start, 0);
+|    | 677|+                 writeCyclicBuffer (first, *wHeader, first_line_scroll_begin,
+|    | 678|+                                    COLS - tracklength.length () -
+|    | 679|+                                    VolumeState.length () - 1, L" ** ");
+|    | 680|+                 *wHeader << NC::XY (0,
+|    | 681|+                                     1) << NC::TermManip::ClearToEOL << Config.
+|    | 682|+                 player_state_color << ps << NC::FormattedColor::
+|    | 683|+                 End <> (Config.player_state_color) << NC::XY (second_start,
+|    | 684|+                                                               1);
+|    | 685|+                 writeCyclicBuffer (second, *wHeader, second_line_scroll_begin,
+|    | 686|+                                    COLS - ps.length () - 8 - 2, L" ** ");
+|    | 687|+                 *wHeader << NC::XY (wHeader->getWidth () -
+|    | 688|+                                     VolumeState.length (),
+|    | 689|+                                     0) << Config.
+|    | 690|+                 volume_color << VolumeState << NC::FormattedColor::
+|    | 691|+                 End <> (Config.volume_color); flags ();}
+|    | 692|+                 if (Progressbar::isUnlocked ())Progressbar::
+|    | 693|+                 draw (m_elapsed_time, m_total_time);}
+|    | 694|+
+|    | 695|+                 void Status::Changes::flags ()
+|    | 696|+                 {
+|    | 697|+                 if (!Config.header_visibility
+|    | 698|+                     && Config.design == Design::Classic) return;
+|    | 699|+                 std::string switch_state; switch (Config.design)
+|    | 700|+                 {
+|    | 701|+case Design::Classic:
+|    | 702|+if (m_repeat) switch_state += m_repeat; if (m_random) switch_state += m_random; if (m_single) switch_state += m_single; if (m_consume) switch_state += m_consume; if (m_crossfade) switch_state += m_crossfade; if (m_db_updating) switch_state += m_db_updating; *wHeader << Config.state_line_color; mvwhline (wHeader->raw (), 1, 0, 0, COLS); *wHeader << NC::FormattedColor::End <> (Config.state_line_color); if (!switch_state.empty ()) * wHeader << NC::XY (COLS - switch_state.length () - 3, 1) << Config.state_line_color << "[" << NC::FormattedColor::End <> (Config.state_line_color) << Config.state_flags_color << switch_state << NC::FormattedColor::End <> (Config.state_flags_color) << Config.state_line_color << "]" << NC::FormattedColor::End <> (Config.state_line_color); break; case Design::Alternative:
+|    | 703|+                 switch_state += '['; switch_state += m_repeat ? m_repeat : '-'; switch_state += m_random ? m_random : '-'; switch_state += m_single ? m_single : '-'; switch_state += m_consume ? m_consume : '-'; switch_state += m_crossfade ? m_crossfade : '-'; switch_state += m_db_updating ? m_db_updating : '-'; switch_state += ']'; *wHeader << NC::XY (COLS - switch_state.length (), 1) << Config.state_flags_color << switch_state << NC::FormattedColor::End <> (Config.state_flags_color); if (!Config.header_visibility)   // in this case also draw separator
+|    | 704|+                 {
+|    | 705|+                 *wHeader << Config.alternative_ui_separator_color;
+|    | 706|+                 mvwhline (wHeader->raw (), 2, 0, 0, COLS);
+|    | 707|+                 *wHeader << NC::FormattedColor::End <> (Config.
+|    | 708|+                                                         alternative_ui_separator_color);}
+|    | 709|+                 break;}
+|    | 710|+                 wHeader->refresh ();}
+|    | 711|+
+|    | 712|+                 void Status::Changes::mixer ()
+|    | 713|+                 {
+|    | 714|+                 if (!Config.display_volume_level
+|    | 715|+                     || (!Config.header_visibility
+|    | 716|+                         && Config.design == Design::Classic)) return;
+|    | 717|+                 switch (Config.design)
+|    | 718|+                 {
+|    | 719|+case Design::Classic:
+|    | 720|+VolumeState = " Volume: "; break; case Design::Alternative:
+|    | 721|+                 VolumeState = " Vol: "; break;}
+|    | 722|+                 if (m_volume < 0) VolumeState += "n/a";
+|    | 723|+                 else
+|    | 724|+                 {
+|    | 725|+                 VolumeState += boost::lexical_cast < std::string > (m_volume);
+|    | 726|+                 VolumeState += "%";}
+|    | 727|+                 *wHeader << NC::XY (wHeader->getWidth () -
+|    | 728|+                                     VolumeState.length (),
+|    | 729|+                                     0) << Config.
+|    | 730|+                 volume_color << VolumeState << NC::FormattedColor::
+|    | 731|+                 End <> (Config.volume_color); wHeader->refresh ();}
+|    | 732|+
+|    | 733|+                 void Status::Changes::outputs ()
+|    | 734|+                 {
+| 817| 735| #	ifdef ENABLE_OUTPUTS
+| 818|    |-	myOutputs->fetchList();
+| 819|    |-	if (isVisible(myOutputs))
+| 820|    |-		myOutputs->refreshWindow();
+|    | 736|+                 myOutputs->fetchList ();
+|    | 737|+                 if (isVisible (myOutputs)) myOutputs->refreshWindow ();
+| 821| 738| #	endif // ENABLE_OUTPUTS
+| 822|    |-}
+|    | 739|+                 }
+
+src/status.cpp
+|  40| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'consume' declared but not defined
+
+src/status.cpp
+|  41| #include•"screens/tag_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'crossfade' declared but not defined
+
+src/status.cpp
+|  42| #include•"screens/visualizer.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'repeat' declared but not defined
+
+src/status.cpp
+|  43| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'random' declared but not defined
+
+src/status.cpp
+|  44| #include•"utility/string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'single' declared but not defined
+
+src/status.cpp
+|  47| 
+|    | [NORMAL] CPPCleanBear:
+|    | 'currentSongID' declared but not defined
+
+src/status.cpp
+|  48| using•Global::wFooter;
+|    | [NORMAL] CPPCleanBear:
+|    | 'currentSongPosition' declared but not defined
+
+src/status.cpp
+|  49| using•Global::wHeader;
+|    | [NORMAL] CPPCleanBear:
+|    | 'playlistLength' declared but not defined
+
+src/status.cpp
+|  51| using•Global::Timer;
+|    | [NORMAL] CPPCleanBear:
+|    | 'player' declared but not defined
+
+src/status.cpp
+|  52| using•Global::VolumeState;
+|    | [NORMAL] CPPCleanBear:
+|    | 'totalTime' declared but not defined
+
+src/status.cpp
+|  53| 
+|    | [NORMAL] CPPCleanBear:
+|    | 'volume' declared but not defined
+
+src/status.cpp
+|  59| size_t•first_line_scroll_begin•=•0;
+|    | [NORMAL] CPPCleanBear:
+|    | 'playlist' declared but not defined
+
+src/status.cpp
+|  60| size_t•second_line_scroll_begin•=•0;
+|    | [NORMAL] CPPCleanBear:
+|    | 'storedPlaylists' declared but not defined
+
+src/status.cpp
+|  61| 
+|    | [NORMAL] CPPCleanBear:
+|    | 'database' declared but not defined
+
+src/status.cpp
+|  62| bool•m_status_initialized;
+|    | [NORMAL] CPPCleanBear:
+|    | 'playerState' declared but not defined
+
+src/status.cpp
+|  63| 
+|    | [NORMAL] CPPCleanBear:
+|    | 'songID' declared but not defined
+
+src/status.cpp
+|  64| char•m_consume;
+|    | [NORMAL] CPPCleanBear:
+|    | 'elapsedTime' declared but not defined
+
+src/status.cpp
+|  65| char•m_crossfade;
+|    | [NORMAL] CPPCleanBear:
+|    | 'flags' declared but not defined
+
+src/status.cpp
+|  66| char•m_db_updating;
+|    | [NORMAL] CPPCleanBear:
+|    | 'mixer' declared but not defined
+
+src/status.cpp
+|  67| char•m_repeat;
+|    | [NORMAL] CPPCleanBear:
+|    | 'outputs' declared but not defined
+
+src/status.cpp
+|  56| boost::posix_time::ptime•past•=•boost::posix_time::from_time_t(0);
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'past'
+
+src/status.cpp
+|  58| size_t•playing_song_scroll_begin•=•0;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'playing_song_scroll_begin'
+
+src/status.cpp
+|  59| size_t•first_line_scroll_begin•=•0;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'first_line_scroll_begin'
+
+src/status.cpp
+|  60| size_t•second_line_scroll_begin•=•0;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'second_line_scroll_begin'
+
+src/status.cpp
+|  62| bool•m_status_initialized;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_status_initialized'
+
+src/status.cpp
+|  64| char•m_consume;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_consume'
+
+src/status.cpp
+|  65| char•m_crossfade;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_crossfade'
+
+src/status.cpp
+|  66| char•m_db_updating;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_db_updating'
+
+src/status.cpp
+|  67| char•m_repeat;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_repeat'
+
+src/status.cpp
+|  68| char•m_random;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_random'
+
+src/status.cpp
+|  69| char•m_single;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_single'
+
+src/status.cpp
+|  71| int•m_current_song_id;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_current_song_id'
+
+src/status.cpp
+|  72| int•m_current_song_pos;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_current_song_pos'
+
+src/status.cpp
+|  73| unsigned•m_elapsed_time;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_elapsed_time'
+
+src/status.cpp
+|  74| unsigned•m_kbps;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_kbps'
+
+src/status.cpp
+|  75| MPD::PlayerState•m_player_state;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_player_state'
+
+src/status.cpp
+|  76| unsigned•m_playlist_version;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_playlist_version'
+
+src/status.cpp
+|  77| unsigned•m_playlist_length;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_playlist_length'
+
+src/status.cpp
+|  78| unsigned•m_total_time;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_total_time'
+
+src/status.cpp
+|  79| int•m_volume;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'm_volume'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  27|  27| #include "actions.h"
+|  28|  28| #include "macro_utilities.h"
+|  29|  29| 
+|  30|    |-NC::Key::Type readKey(NC::Window &w);
+|  31|    |-std::wstring keyToWString(const NC::Key::Type key);
+|    |  30|+NC::Key::Type readKey (NC::Window & w);
+|    |  31|+std::wstring keyToWString (const NC::Key::Type key);
+|  32|  32| 
+|  33|  33| /// Represents either single action or chain of actions bound to a certain key
+|  34|  34| struct Binding
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  33|  33| /// Represents either single action or chain of actions bound to a certain key
+|  34|  34| struct Binding
+|  35|  35| {
+|  36|    |-	typedef std::vector<std::shared_ptr<Actions::BaseAction>> ActionChain;
+|    |  36|+    typedef std::vector < std::shared_ptr < Actions::BaseAction >> ActionChain;
+|  37|  37| 
+|  38|    |-	template <typename ArgT>
+|  39|    |-	Binding(ArgT &&actions_)
+|  40|    |-	: m_actions(std::forward<ArgT>(actions_)) {
+|  41|    |-		assert(!m_actions.empty());
+|  42|    |-	}
+|  43|    |-	Binding(Actions::Type at)
+|  44|    |-	: Binding(ActionChain({Actions::get_(at)})) { }
+|    |  38|+      template < typename ArgT >
+|    |  39|+        Binding (ArgT && actions_):m_actions (std::forward < ArgT > (actions_))
+|    |  40|+    {
+|    |  41|+        assert (!m_actions.empty ());
+|    |  42|+    }
+|    |  43|+    Binding (Actions::Type at):Binding (ActionChain (
+|    |  44|+                                                        {
+|    |  45|+                                                        Actions::get_ (at)}))
+|    |  46|+    {
+|    |  47|+    }
+|  45|  48| 
+|  46|    |-	bool execute() const {
+|  47|    |-		return std::all_of(m_actions.begin(), m_actions.end(),
+|  48|    |-			std::bind(&Actions::BaseAction::execute, std::placeholders::_1)
+|  49|    |-		);
+|  50|    |-	}
+|    |  49|+    bool execute () const
+|    |  50|+    {
+|    |  51|+        return std::all_of (m_actions.begin (), m_actions.end (),
+|    |  52|+                            std::bind (&Actions::BaseAction::execute,
+|    |  53|+                                       std::placeholders::_1));
+|    |  54|+    }
+|  51|  55| 
+|  52|    |-	bool isSingle() const {
+|  53|    |-		return m_actions.size() == 1;
+|  54|    |-	}
+|    |  56|+    bool isSingle () const
+|    |  57|+    {
+|    |  58|+        return m_actions.size () == 1;
+|    |  59|+    }
+|  55|  60| 
+|  56|    |-	Actions::BaseAction &action() const {
+|  57|    |-		assert(isSingle());
+|  58|    |-		assert(m_actions[0] != nullptr);
+|  59|    |-		return *m_actions[0];
+|  60|    |-	}
+|    |  61|+    Actions::BaseAction & action () const
+|    |  62|+    {
+|    |  63|+        assert (isSingle ());
+|    |  64|+        assert (m_actions[0] != nullptr);
+|    |  65|+        return *m_actions[0];
+|    |  66|+    }
+|  61|  67| 
+|  62|    |-	const ActionChain &actions() const {
+|  63|    |-		return m_actions;
+|  64|    |-	}
+|    |  68|+    const ActionChain & actions () const
+|    |  69|+    {
+|    |  70|+        return m_actions;
+|    |  71|+    }
+|  65|  72| 
+|  66|    |-private:
+|  67|    |-	ActionChain m_actions;
+|    |  73|+  private:
+|    |  74|+      ActionChain m_actions;
+|  68|  75| };
+|  69|  76| 
+|  70|  77| /// Represents executable command
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  70|  70| /// Represents executable command
+|  71|  71| struct Command
+|  72|  72| {
+|  73|    |-	template <typename ArgT>
+|  74|    |-	Command(ArgT &&binding_, bool immediate_)
+|  75|    |-	: m_impl(std::forward<ArgT>(binding_), immediate_) { }
+|    |  73|+    template < typename ArgT >
+|    |  74|+        Command (ArgT
+|    |  75|+                 && binding_,
+|    |  76|+                 bool immediate_):m_impl (std::forward < ArgT > (binding_),
+|    |  77|+                                          immediate_)
+|    |  78|+    {
+|    |  79|+    }
+|  76|  80| 
+|  77|    |-	const Binding &binding() const { return std::get<0>(m_impl); }
+|  78|    |-	bool immediate() const { return std::get<1>(m_impl); }
+|    |  81|+    const Binding & binding () const
+|    |  82|+    {
+|    |  83|+        return std::get < 0 > (m_impl);
+|    |  84|+    }
+|    |  85|+    bool immediate () const
+|    |  86|+    {
+|    |  87|+        return std::get < 1 > (m_impl);
+|    |  88|+    }
+|  79|  89| 
+|  80|    |-private:
+|  81|    |-	std::tuple<Binding, bool> m_impl;
+|    |  90|+  private:
+|    |  91|+      std::tuple < Binding, bool > m_impl;
+|  82|  92| };
+|  83|  93| 
+|  84|  94| /// Keybindings configuration
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.h
+|    |++++| /app/src/bindings.h
+|  84|  84| /// Keybindings configuration
+|  85|  85| class BindingsConfiguration
+|  86|  86| {
+|  87|    |-	typedef std::unordered_map<std::string, Command> CommandsSet;
+|  88|    |-	typedef std::unordered_map<NC::Key::Type, std::vector<Binding>> BindingsMap;
+|    |  87|+    typedef std::unordered_map < std::string, Command > CommandsSet;
+|    |  88|+    typedef std::unordered_map < NC::Key::Type,
+|    |  89|+        std::vector < Binding >> BindingsMap;
+|  89|  90| 
+|  90|    |-public:
+|  91|    |-	typedef BindingsMap::value_type::second_type::iterator BindingIterator;
+|  92|    |-	typedef BindingsMap::value_type::second_type::const_iterator ConstBindingIterator;
+|  93|    |-	typedef std::pair<BindingIterator, BindingIterator> BindingIteratorPair;
+|    |  91|+  public:
+|    |  92|+    typedef BindingsMap::value_type::second_type::iterator BindingIterator;
+|    |  93|+    typedef BindingsMap::value_type::second_type::
+|    |  94|+        const_iterator ConstBindingIterator;
+|    |  95|+    typedef std::pair < BindingIterator, BindingIterator > BindingIteratorPair;
+|  94|  96| 
+|  95|    |-	bool read(const std::vector<std::string> &binding_paths);
+|  96|    |-	void generateDefaults();
+|    |  97|+    bool read (const std::vector < std::string > &binding_paths);
+|    |  98|+    void generateDefaults ();
+|  97|  99| 
+|  98|    |-	const Command *findCommand(const std::string &name);
+|  99|    |-	BindingIteratorPair get(const NC::Key::Type &k);
+|    | 100|+    const Command *findCommand (const std::string & name);
+|    | 101|+    BindingIteratorPair get (const NC::Key::Type & k);
+| 100| 102| 
+| 101|    |-	BindingsMap::const_iterator begin() const { return m_bindings.begin(); }
+| 102|    |-	BindingsMap::const_iterator end() const { return m_bindings.end(); }
+|    | 103|+      BindingsMap::const_iterator begin () const
+|    | 104|+    {
+|    | 105|+        return m_bindings.begin ();
+|    | 106|+    }
+|    | 107|+    BindingsMap::const_iterator end () const
+|    | 108|+    {
+|    | 109|+        return m_bindings.end ();
+|    | 110|+    }
+| 103| 111| 
+| 104|    |-private:
+| 105|    |-	bool notBound(const NC::Key::Type &k) const {
+| 106|    |-		return k != NC::Key::None && m_bindings.find(k) == m_bindings.end();
+| 107|    |-	}
+|    | 112|+  private:
+|    | 113|+      bool notBound (const NC::Key::Type & k) const
+|    | 114|+    {
+|    | 115|+        return k != NC::Key::None && m_bindings.find (k) == m_bindings.end ();
+|    | 116|+    }
+| 108| 117| 
+| 109|    |-	template <typename ArgT>
+| 110|    |-	void bind(NC::Key::Type k, ArgT &&t) {
+| 111|    |-		m_bindings[k].push_back(std::forward<ArgT>(t));
+| 112|    |-	}
+|    | 118|+    template < typename ArgT > void bind (NC::Key::Type k, ArgT && t)
+|    | 119|+    {
+|    | 120|+        m_bindings[k].push_back (std::forward < ArgT > (t));
+|    | 121|+    }
+| 113| 122| 
+| 114|    |-	bool read(const std::string &file);
+|    | 123|+    bool read (const std::string & file);
+| 115| 124| 
+| 116|    |-	BindingsMap m_bindings;
+| 117|    |-	CommandsSet m_commands;
+|    | 125|+    BindingsMap m_bindings;
+|    | 126|+    CommandsSet m_commands;
+| 118| 127| };
+| 119| 128| 
+| 120| 129| extern BindingsConfiguration Bindings;
+
+src/bindings.h
+|  28| #include•"macro_utilities.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'macro_utilities.h' does not need to be #included
+
+src/bindings.h
+| 120| extern•BindingsConfiguration•Bindings;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Bindings'
+
+src/bindings.h
+| 196| The line belonging to the following result cannot be printed because it refers to a line that doesn't seem to exist in the given file.
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/display.cpp
+|    |++++| /app/src/display.cpp
+|  33|  33| #include "utility/string.h"
+|  34|  34| #include "utility/type_conversions.h"
+|  35|  35| 
+|  36|    |-using Global::myScreen;
+|  37|    |-
+|  38|    |-namespace {
+|  39|    |-
+|  40|    |-const wchar_t *toColumnName(char c)
+|  41|    |-{
+|  42|    |-	switch (c)
+|  43|    |-	{
+|  44|    |-		case 'l':
+|  45|    |-			return L"Time";
+|  46|    |-		case 'f':
+|  47|    |-			return L"Filename";
+|  48|    |-		case 'D':
+|  49|    |-			return L"Directory";
+|  50|    |-		case 'a':
+|  51|    |-			return L"Artist";
+|  52|    |-		case 'A':
+|  53|    |-			return L"Album Artist";
+|  54|    |-		case 't':
+|  55|    |-			return L"Title";
+|  56|    |-		case 'b':
+|  57|    |-			return L"Album";
+|  58|    |-		case 'y':
+|  59|    |-			return L"Date";
+|  60|    |-		case 'n': case 'N':
+|  61|    |-			return L"Track";
+|  62|    |-		case 'g':
+|  63|    |-			return L"Genre";
+|  64|    |-		case 'c':
+|  65|    |-			return L"Composer";
+|  66|    |-		case 'p':
+|  67|    |-			return L"Performer";
+|  68|    |-		case 'd':
+|  69|    |-			return L"Disc";
+|  70|    |-		case 'C':
+|  71|    |-			return L"Comment";
+|  72|    |-		case 'P':
+|  73|    |-			return L"Priority";
+|  74|    |-		default:
+|  75|    |-			return L"?";
+|  76|    |-	}
+|  77|    |-}
+|  78|    |-
+|  79|    |-template <typename T>
+|  80|    |-void setProperties(NC::Menu<T> &menu, const MPD::Song &s, const SongList &list,
+|  81|    |-                   bool &separate_albums, bool &is_now_playing, bool &is_selected,
+|  82|    |-                   bool &is_in_playlist, bool &discard_colors)
+|  83|    |-{
+|  84|    |-	size_t drawn_pos = menu.drawn() - menu.begin();
+|  85|    |-	separate_albums = false;
+|  86|    |-	if (Config.playlist_separate_albums)
+|  87|    |-	{
+|  88|    |-		auto next = list.beginS() + drawn_pos + 1;
+|  89|    |-		if (next != list.endS())
+|  90|    |-		{
+|  91|    |-			if (next->song() != nullptr && next->song()->getAlbum() != s.getAlbum())
+|  92|    |-				separate_albums = true;
+|  93|    |-		}
+|  94|    |-	}
+|  95|    |-	if (separate_albums)
+|  96|    |-	{
+|  97|    |-		menu << NC::Format::Underline;
+|  98|    |-		mvwhline(menu.raw(), menu.getY(), 0, NC::Key::Space, menu.getWidth());
+|  99|    |-	}
+| 100|    |-
+| 101|    |-	int song_pos = s.getPosition();
+| 102|    |-	is_now_playing = Status::State::player() != MPD::psStop
+| 103|    |-		&& myPlaylist->isActiveWindow(menu)
+| 104|    |-		&& song_pos == Status::State::currentSongPosition();
+| 105|    |-	if (is_now_playing)
+| 106|    |-		menu << Config.now_playing_prefix;
+| 107|    |-
+| 108|    |-	is_in_playlist = !myPlaylist->isActiveWindow(menu)
+| 109|    |-		&& myPlaylist->checkForSong(s);
+| 110|    |-	if (is_in_playlist)
+| 111|    |-		menu << NC::Format::Bold;
+| 112|    |-
+| 113|    |-	is_selected = menu.drawn()->isSelected();
+| 114|    |-	discard_colors = Config.discard_colors_if_item_is_selected && is_selected;
+| 115|    |-}
+| 116|    |-
+| 117|    |-template <typename T>
+| 118|    |-void unsetProperties(NC::Menu<T> &menu, bool separate_albums, bool is_now_playing,
+| 119|    |-                     bool is_in_playlist)
+| 120|    |-{
+| 121|    |-	if (is_in_playlist)
+| 122|    |-		menu << NC::Format::NoBold;
+| 123|    |-
+| 124|    |-	if (is_now_playing)
+| 125|    |-		menu << Config.now_playing_suffix;
+| 126|    |-
+| 127|    |-	if (separate_albums)
+| 128|    |-		menu << NC::Format::NoUnderline;
+| 129|    |-}
+| 130|    |-
+| 131|    |-template <typename T>
+| 132|    |-void showSongs(NC::Menu<T> &menu, const MPD::Song &s, const SongList &list, const Format::AST<char> &ast)
+| 133|    |-{
+| 134|    |-	bool separate_albums, is_now_playing, is_selected, is_in_playlist, discard_colors;
+| 135|    |-	setProperties(menu, s, list, separate_albums, is_now_playing, is_selected,
+| 136|    |-	              is_in_playlist, discard_colors);
+| 137|    |-
+| 138|    |-	const size_t y = menu.getY();
+| 139|    |-	NC::Buffer right_aligned;
+| 140|    |-	Format::print(ast, menu, &s, &right_aligned,
+| 141|    |-		discard_colors ? Format::Flags::Tag | Format::Flags::OutputSwitch : Format::Flags::All
+| 142|    |-	);
+| 143|    |-	if (!right_aligned.str().empty())
+| 144|    |-	{
+| 145|    |-		size_t x_off = menu.getWidth() - wideLength(ToWString(right_aligned.str()));
+| 146|    |-		if (menu.isHighlighted() && list.currentS()->song() == &s)
+| 147|    |-		{
+| 148|    |-			if (menu.highlightSuffix() == Config.current_item_suffix)
+| 149|    |-				x_off -= Config.current_item_suffix_length;
+| 150|    |-			else
+| 151|    |-				x_off -= Config.current_item_inactive_column_suffix_length;
+| 152|    |-		}
+| 153|    |-		if (is_now_playing)
+| 154|    |-			x_off -= Config.now_playing_suffix_length;
+| 155|    |-		if (is_selected)
+| 156|    |-			x_off -= Config.selected_item_suffix_length;
+| 157|    |-		menu << NC::TermManip::ClearToEOL << NC::XY(x_off, y) << right_aligned;
+| 158|    |-	}
+| 159|    |-
+| 160|    |-	unsetProperties(menu, separate_albums, is_now_playing, is_in_playlist);
+| 161|    |-}
+| 162|    |-
+| 163|    |-template <typename T>
+| 164|    |-void showSongsInColumns(NC::Menu<T> &menu, const MPD::Song &s, const SongList &list)
+| 165|    |-{
+| 166|    |-	if (Config.columns.empty())
+| 167|    |-		return;
+| 168|    |-
+| 169|    |-	bool separate_albums, is_now_playing, is_selected, is_in_playlist, discard_colors;
+| 170|    |-	setProperties(menu, s, list, separate_albums, is_now_playing, is_selected,
+| 171|    |-	              is_in_playlist, discard_colors);
+| 172|    |-
+| 173|    |-	int menu_width = menu.getWidth();
+| 174|    |-	if (menu.isHighlighted() && list.currentS()->song() == &s)
+| 175|    |-	{
+| 176|    |-		if (menu.highlightPrefix() == Config.current_item_prefix)
+| 177|    |-			menu_width -= Config.current_item_prefix_length;
+| 178|    |-		else
+| 179|    |-			menu_width -= Config.current_item_inactive_column_prefix_length;
+| 180|    |-
+| 181|    |-		if (menu.highlightSuffix() == Config.current_item_suffix)
+| 182|    |-			menu_width -= Config.current_item_suffix_length;
+| 183|    |-		else
+| 184|    |-			menu_width -= Config.current_item_inactive_column_suffix_length;
+| 185|    |-	}
+| 186|    |-	if (is_now_playing)
+| 187|    |-	{
+| 188|    |-		menu_width -= Config.now_playing_prefix_length;
+| 189|    |-		menu_width -= Config.now_playing_suffix_length;
+| 190|    |-	}
+| 191|    |-	if (is_selected)
+| 192|    |-	{
+| 193|    |-		menu_width -= Config.selected_item_prefix_length;
+| 194|    |-		menu_width -= Config.selected_item_suffix_length;
+| 195|    |-	}
+| 196|    |-
+| 197|    |-	int width;
+| 198|    |-	int y = menu.getY();
+| 199|    |-	int remained_width = menu_width;
+| 200|    |-
+| 201|    |-	std::vector<Column>::const_iterator it, last = Config.columns.end() - 1;
+| 202|    |-	for (it = Config.columns.begin(); it != Config.columns.end(); ++it)
+| 203|    |-	{
+| 204|    |-		// check current X coordinate
+| 205|    |-		int x = menu.getX();
+| 206|    |-		// column has relative width and all after it have fixed width,
+| 207|    |-		// so stretch it so it fills whole screen along with these after.
+| 208|    |-		if (it->stretch_limit >= 0) // (*)
+| 209|    |-			width = remained_width - it->stretch_limit;
+| 210|    |-		else
+| 211|    |-			width = it->fixed ? it->width : it->width * menu_width * 0.01;
+| 212|    |-		// columns with relative width may shrink to 0, omit them
+| 213|    |-		if (width == 0)
+| 214|    |-			continue;
+| 215|    |-		// if column is not last, we need to have spacing between it
+| 216|    |-		// and next column, so we substract it now and restore later.
+| 217|    |-		if (it != last)
+| 218|    |-			--width;
+| 219|    |-
+| 220|    |-		// if column doesn't fit into screen, discard it and any other after it.
+| 221|    |-		if (remained_width-width < 0 || width < 0 /* this one may come from (*) */)
+| 222|    |-			break;
+| 223|    |-
+| 224|    |-		std::wstring tag;
+| 225|    |-		for (size_t i = 0; i < it->type.length(); ++i)
+| 226|    |-		{
+| 227|    |-			MPD::Song::GetFunction get = charToGetFunction(it->type[i]);
+| 228|    |-			assert(get);
+| 229|    |-			tag = ToWString(Charset::utf8ToLocale(s.getTags(get)));
+| 230|    |-			if (!tag.empty())
+| 231|    |-				break;
+| 232|    |-		}
+| 233|    |-		if (tag.empty() && it->display_empty_tag)
+| 234|    |-			tag = ToWString(Config.empty_tag);
+| 235|    |-		wideCut(tag, width);
+| 236|    |-
+| 237|    |-		if (!discard_colors && it->color != NC::Color::Default)
+| 238|    |-			menu << it->color;
+| 239|    |-
+| 240|    |-		int x_off = 0;
+| 241|    |-		// if column uses right alignment, calculate proper offset.
+| 242|    |-		// otherwise just assume offset is 0, ie. we start from the left.
+| 243|    |-		if (it->right_alignment)
+| 244|    |-			x_off = std::max(0, width - int(wideLength(tag)));
+| 245|    |-
+| 246|    |-		whline(menu.raw(), NC::Key::Space, width);
+| 247|    |-		menu.goToXY(x + x_off, y);
+| 248|    |-		menu << tag;
+| 249|    |-		menu.goToXY(x + width, y);
+| 250|    |-		if (it != last)
+| 251|    |-		{
+| 252|    |-			// add missing width's part and restore the value.
+| 253|    |-			menu << ' ';
+| 254|    |-			remained_width -= width+1;
+| 255|    |-		}
+| 256|    |-
+| 257|    |-		if (!discard_colors && it->color != NC::Color::Default)
+| 258|    |-			menu << NC::Color::End;
+| 259|    |-	}
+| 260|    |-
+| 261|    |-	unsetProperties(menu, separate_albums, is_now_playing, is_in_playlist);
+| 262|    |-}
+| 263|    |-
+| 264|    |-}
+| 265|    |-
+| 266|    |-std::string Display::Columns(size_t list_width)
+| 267|    |-{
+| 268|    |-	std::string result;
+| 269|    |-	if (Config.columns.empty())
+| 270|    |-		return result;
+| 271|    |-	
+| 272|    |-	int width;
+| 273|    |-	int remained_width = list_width;
+| 274|    |-	std::vector<Column>::const_iterator it, last = Config.columns.end() - 1;
+| 275|    |-	for (it = Config.columns.begin(); it != Config.columns.end(); ++it)
+| 276|    |-	{
+| 277|    |-		// column has relative width and all after it have fixed width,
+| 278|    |-		// so stretch it so it fills whole screen along with these after.
+| 279|    |-		if (it->stretch_limit >= 0) // (*)
+| 280|    |-			width = remained_width - it->stretch_limit;
+| 281|    |-		else
+| 282|    |-			width = it->fixed ? it->width : it->width * list_width * 0.01;
+| 283|    |-		// columns with relative width may shrink to 0, omit them
+| 284|    |-		if (width == 0)
+| 285|    |-			continue;
+| 286|    |-		// if column is not last, we need to have spacing between it
+| 287|    |-		// and next column, so we substract it now and restore later.
+| 288|    |-		if (it != last)
+| 289|    |-			--width;
+| 290|    |-		
+| 291|    |-		// if column doesn't fit into screen, discard it and any other after it.
+| 292|    |-		if (remained_width-width < 0 || width < 0 /* this one may come from (*) */)
+| 293|    |-			break;
+| 294|    |-		
+| 295|    |-		std::wstring name;
+| 296|    |-		if (it->name.empty())
+| 297|    |-		{
+| 298|    |-			size_t j = 0;
+| 299|    |-			while (true)
+| 300|    |-			{
+| 301|    |-				name += toColumnName(it->type[j]);
+| 302|    |-				++j;
+| 303|    |-				if (j < it->type.length())
+| 304|    |-					name += '/';
+| 305|    |-				else
+| 306|    |-					break;
+| 307|    |-			}
+| 308|    |-		}
+| 309|    |-		else
+| 310|    |-			name = it->name;
+| 311|    |-		wideCut(name, width);
+| 312|    |-		
+| 313|    |-		int x_off = std::max(0, width - int(wideLength(name)));
+| 314|    |-		if (it->right_alignment)
+| 315|    |-		{
+| 316|    |-			result += std::string(x_off, NC::Key::Space);
+| 317|    |-			result += Charset::utf8ToLocale(ToString(name));
+| 318|    |-		}
+| 319|    |-		else
+| 320|    |-		{
+| 321|    |-			result += Charset::utf8ToLocale(ToString(name));
+| 322|    |-			result += std::string(x_off, NC::Key::Space);
+| 323|    |-		}
+| 324|    |-		
+| 325|    |-		if (it != last)
+| 326|    |-		{
+| 327|    |-			// add missing width's part and restore the value.
+| 328|    |-			remained_width -= width+1;
+| 329|    |-			result += ' ';
+| 330|    |-		}
+| 331|    |-	}
+| 332|    |-	
+| 333|    |-	return result;
+| 334|    |-}
+| 335|    |-
+| 336|    |-void Display::SongsInColumns(NC::Menu<MPD::Song> &menu, const SongList &list)
+| 337|    |-{
+| 338|    |-	showSongsInColumns(menu, menu.drawn()->value(), list);
+| 339|    |-}
+| 340|    |-
+| 341|    |-void Display::Songs(NC::Menu<MPD::Song> &menu, const SongList &list, const Format::AST<char> &ast)
+| 342|    |-{
+| 343|    |-	showSongs(menu, menu.drawn()->value(), list, ast);
+|    |  36|+using
+|    |  37|+    Global::myScreen;
+|    |  38|+
+|    |  39|+namespace
+|    |  40|+{
+|    |  41|+
+|    |  42|+    const wchar_t *
+|    |  43|+    toColumnName (char c)
+|    |  44|+    {
+|    |  45|+        switch (c)
+|    |  46|+          {
+|    |  47|+          case 'l':
+|    |  48|+              return L"Time";
+|    |  49|+          case 'f':
+|    |  50|+              return L"Filename";
+|    |  51|+          case 'D':
+|    |  52|+              return L"Directory";
+|    |  53|+          case 'a':
+|    |  54|+              return L"Artist";
+|    |  55|+          case 'A':
+|    |  56|+              return L"Album Artist";
+|    |  57|+          case 't':
+|    |  58|+              return L"Title";
+|    |  59|+          case 'b':
+|    |  60|+              return L"Album";
+|    |  61|+          case 'y':
+|    |  62|+              return L"Date";
+|    |  63|+          case 'n':
+|    |  64|+          case 'N':
+|    |  65|+              return L"Track";
+|    |  66|+          case 'g':
+|    |  67|+              return L"Genre";
+|    |  68|+          case 'c':
+|    |  69|+              return L"Composer";
+|    |  70|+          case 'p':
+|    |  71|+              return L"Performer";
+|    |  72|+          case 'd':
+|    |  73|+              return L"Disc";
+|    |  74|+          case 'C':
+|    |  75|+              return L"Comment";
+|    |  76|+          case 'P':
+|    |  77|+              return L"Priority";
+|    |  78|+          default:
+|    |  79|+              return L"?";
+|    |  80|+          }
+|    |  81|+    }
+|    |  82|+
+|    |  83|+    template < typename T > void
+|    |  84|+    setProperties (NC::Menu < T > &menu, const MPD::Song & s,
+|    |  85|+                   const SongList & list, bool & separate_albums,
+|    |  86|+                   bool & is_now_playing, bool & is_selected,
+|    |  87|+                   bool & is_in_playlist, bool & discard_colors)
+|    |  88|+    {
+|    |  89|+        size_t
+|    |  90|+            drawn_pos = menu.drawn () - menu.begin ();
+|    |  91|+        separate_albums = false;
+|    |  92|+        if (Config.playlist_separate_albums)
+|    |  93|+          {
+|    |  94|+              auto
+|    |  95|+                  next = list.beginS () + drawn_pos + 1;
+|    |  96|+              if (next != list.endS ())
+|    |  97|+                {
+|    |  98|+                    if (next->song () != nullptr
+|    |  99|+                        && next->song ()->getAlbum () != s.getAlbum ())
+|    | 100|+                        separate_albums = true;
+|    | 101|+                }
+|    | 102|+          }
+|    | 103|+        if (separate_albums)
+|    | 104|+          {
+|    | 105|+              menu << NC::Format::Underline;
+|    | 106|+              mvwhline (menu.raw (), menu.getY (), 0, NC::Key::Space,
+|    | 107|+                        menu.getWidth ());
+|    | 108|+          }
+|    | 109|+
+|    | 110|+        int
+|    | 111|+            song_pos = s.getPosition ();
+|    | 112|+        is_now_playing = Status::State::player () != MPD::psStop
+|    | 113|+            && myPlaylist->isActiveWindow (menu)
+|    | 114|+            && song_pos == Status::State::currentSongPosition ();
+|    | 115|+        if (is_now_playing)
+|    | 116|+            menu << Config.now_playing_prefix;
+|    | 117|+
+|    | 118|+        is_in_playlist = !myPlaylist->isActiveWindow (menu)
+|    | 119|+            && myPlaylist->checkForSong (s);
+|    | 120|+        if (is_in_playlist)
+|    | 121|+            menu << NC::Format::Bold;
+|    | 122|+
+|    | 123|+        is_selected = menu.drawn ()->isSelected ();
+|    | 124|+        discard_colors = Config.discard_colors_if_item_is_selected
+|    | 125|+            && is_selected;
+|    | 126|+    }
+|    | 127|+
+|    | 128|+    template < typename T > void
+|    | 129|+    unsetProperties (NC::Menu < T > &menu, bool separate_albums,
+|    | 130|+                     bool is_now_playing, bool is_in_playlist)
+|    | 131|+    {
+|    | 132|+        if (is_in_playlist)
+|    | 133|+            menu << NC::Format::NoBold;
+|    | 134|+
+|    | 135|+        if (is_now_playing)
+|    | 136|+            menu << Config.now_playing_suffix;
+|    | 137|+
+|    | 138|+        if (separate_albums)
+|    | 139|+            menu << NC::Format::NoUnderline;
+|    | 140|+    }
+|    | 141|+
+|    | 142|+    template < typename T > void
+|    | 143|+    showSongs (NC::Menu < T > &menu, const MPD::Song & s,
+|    | 144|+               const SongList & list, const Format::AST < char >&ast)
+|    | 145|+    {
+|    | 146|+        bool
+|    | 147|+            separate_albums,
+|    | 148|+            is_now_playing,
+|    | 149|+            is_selected,
+|    | 150|+            is_in_playlist,
+|    | 151|+            discard_colors;
+|    | 152|+        setProperties (menu, s, list, separate_albums, is_now_playing,
+|    | 153|+                       is_selected, is_in_playlist, discard_colors);
+|    | 154|+
+|    | 155|+        const size_t
+|    | 156|+            y = menu.getY ();
+|    | 157|+        NC::Buffer right_aligned;
+|    | 158|+        Format::print (ast, menu, &s, &right_aligned,
+|    | 159|+                       discard_colors ? Format::Flags::Tag | Format::Flags::
+|    | 160|+                       OutputSwitch : Format::Flags::All);
+|    | 161|+        if (!right_aligned.str ().empty ())
+|    | 162|+          {
+|    | 163|+              size_t
+|    | 164|+                  x_off =
+|    | 165|+                  menu.getWidth () -
+|    | 166|+                  wideLength (ToWString (right_aligned.str ()));
+|    | 167|+              if (menu.isHighlighted () && list.currentS ()->song () == &s)
+|    | 168|+                {
+|    | 169|+                    if (menu.highlightSuffix () == Config.current_item_suffix)
+|    | 170|+                        x_off -= Config.current_item_suffix_length;
+|    | 171|+                    else
+|    | 172|+                        x_off -=
+|    | 173|+                            Config.current_item_inactive_column_suffix_length;
+|    | 174|+                }
+|    | 175|+              if (is_now_playing)
+|    | 176|+                  x_off -= Config.now_playing_suffix_length;
+|    | 177|+              if (is_selected)
+|    | 178|+                  x_off -= Config.selected_item_suffix_length;
+|    | 179|+              menu << NC::TermManip::ClearToEOL << NC::XY (x_off,
+|    | 180|+                                                           y) << right_aligned;
+|    | 181|+          }
+|    | 182|+
+|    | 183|+        unsetProperties (menu, separate_albums, is_now_playing,
+|    | 184|+                         is_in_playlist);
+|    | 185|+    }
+|    | 186|+
+|    | 187|+    template < typename T > void
+|    | 188|+    showSongsInColumns (NC::Menu < T > &menu, const MPD::Song & s,
+|    | 189|+                        const SongList & list)
+|    | 190|+    {
+|    | 191|+        if (Config.columns.empty ())
+|    | 192|+            return;
+|    | 193|+
+|    | 194|+        bool
+|    | 195|+            separate_albums,
+|    | 196|+            is_now_playing,
+|    | 197|+            is_selected,
+|    | 198|+            is_in_playlist,
+|    | 199|+            discard_colors;
+|    | 200|+        setProperties (menu, s, list, separate_albums, is_now_playing,
+|    | 201|+                       is_selected, is_in_playlist, discard_colors);
+|    | 202|+
+|    | 203|+        int
+|    | 204|+            menu_width = menu.getWidth ();
+|    | 205|+        if (menu.isHighlighted () && list.currentS ()->song () == &s)
+|    | 206|+          {
+|    | 207|+              if (menu.highlightPrefix () == Config.current_item_prefix)
+|    | 208|+                  menu_width -= Config.current_item_prefix_length;
+|    | 209|+              else
+|    | 210|+                  menu_width -=
+|    | 211|+                      Config.current_item_inactive_column_prefix_length;
+|    | 212|+
+|    | 213|+              if (menu.highlightSuffix () == Config.current_item_suffix)
+|    | 214|+                  menu_width -= Config.current_item_suffix_length;
+|    | 215|+              else
+|    | 216|+                  menu_width -=
+|    | 217|+                      Config.current_item_inactive_column_suffix_length;
+|    | 218|+          }
+|    | 219|+        if (is_now_playing)
+|    | 220|+          {
+|    | 221|+              menu_width -= Config.now_playing_prefix_length;
+|    | 222|+              menu_width -= Config.now_playing_suffix_length;
+|    | 223|+          }
+|    | 224|+        if (is_selected)
+|    | 225|+          {
+|    | 226|+              menu_width -= Config.selected_item_prefix_length;
+|    | 227|+              menu_width -= Config.selected_item_suffix_length;
+|    | 228|+          }
+|    | 229|+
+|    | 230|+        int
+|    | 231|+            width;
+|    | 232|+        int
+|    | 233|+            y = menu.getY ();
+|    | 234|+        int
+|    | 235|+            remained_width = menu_width;
+|    | 236|+
+|    | 237|+        std::vector < Column >::const_iterator it, last =
+|    | 238|+            Config.columns.end () - 1;
+|    | 239|+        for (it = Config.columns.begin (); it != Config.columns.end (); ++it)
+|    | 240|+          {
+|    | 241|+              // check current X coordinate
+|    | 242|+              int
+|    | 243|+                  x = menu.getX ();
+|    | 244|+              // column has relative width and all after it have fixed width,
+|    | 245|+              // so stretch it so it fills whole screen along with these after.
+|    | 246|+              if (it->stretch_limit >= 0)   // (*)
+|    | 247|+                  width = remained_width - it->stretch_limit;
+|    | 248|+              else
+|    | 249|+                  width =
+|    | 250|+                      it->fixed ? it->width : it->width * menu_width * 0.01;
+|    | 251|+              // columns with relative width may shrink to 0, omit them
+|    | 252|+              if (width == 0)
+|    | 253|+                  continue;
+|    | 254|+              // if column is not last, we need to have spacing between it
+|    | 255|+              // and next column, so we substract it now and restore later.
+|    | 256|+              if (it != last)
+|    | 257|+                  --width;
+|    | 258|+
+|    | 259|+              // if column doesn't fit into screen, discard it and any other after it.
+|    | 260|+              if (remained_width - width < 0
+|    | 261|+                  || width < 0 /* this one may come from (*) */ )
+|    | 262|+                  break;
+|    | 263|+
+|    | 264|+              std::wstring tag;
+|    | 265|+              for (size_t i = 0; i < it->type.length (); ++i)
+|    | 266|+                {
+|    | 267|+                    MPD::Song::GetFunction get =
+|    | 268|+                        charToGetFunction (it->type[i]);
+|    | 269|+                    assert (get);
+|    | 270|+                    tag = ToWString (Charset::utf8ToLocale (s.getTags (get)));
+|    | 271|+                    if (!tag.empty ())
+|    | 272|+                        break;
+|    | 273|+                }
+|    | 274|+              if (tag.empty () && it->display_empty_tag)
+|    | 275|+                  tag = ToWString (Config.empty_tag);
+|    | 276|+              wideCut (tag, width);
+|    | 277|+
+|    | 278|+              if (!discard_colors && it->color != NC::Color::Default)
+|    | 279|+                  menu << it->color;
+|    | 280|+
+|    | 281|+              int
+|    | 282|+                  x_off = 0;
+|    | 283|+              // if column uses right alignment, calculate proper offset.
+|    | 284|+              // otherwise just assume offset is 0, ie. we start from the left.
+|    | 285|+              if (it->right_alignment)
+|    | 286|+                  x_off = std::max (0, width - int (wideLength (tag)));
+|    | 287|+
+|    | 288|+              whline (menu.raw (), NC::Key::Space, width);
+|    | 289|+              menu.goToXY (x + x_off, y);
+|    | 290|+              menu << tag;
+|    | 291|+              menu.goToXY (x + width, y);
+|    | 292|+              if (it != last)
+|    | 293|+                {
+|    | 294|+                    // add missing width's part and restore the value.
+|    | 295|+                    menu << ' ';
+|    | 296|+                    remained_width -= width + 1;
+|    | 297|+                }
+|    | 298|+
+|    | 299|+              if (!discard_colors && it->color != NC::Color::Default)
+|    | 300|+                  menu << NC::Color::End;
+|    | 301|+          }
+|    | 302|+
+|    | 303|+        unsetProperties (menu, separate_albums, is_now_playing,
+|    | 304|+                         is_in_playlist);
+|    | 305|+    }
+|    | 306|+
+|    | 307|+}
+|    | 308|+
+|    | 309|+std::string Display::Columns (size_t list_width)
+|    | 310|+{
+|    | 311|+    std::string result;
+|    | 312|+    if (Config.columns.empty ())
+|    | 313|+        return result;
+|    | 314|+
+|    | 315|+    int
+|    | 316|+        width;
+|    | 317|+    int
+|    | 318|+        remained_width = list_width;
+|    | 319|+    std::vector < Column >::const_iterator it, last =
+|    | 320|+        Config.columns.end () - 1;
+|    | 321|+    for (it = Config.columns.begin (); it != Config.columns.end (); ++it)
+|    | 322|+      {
+|    | 323|+          // column has relative width and all after it have fixed width,
+|    | 324|+          // so stretch it so it fills whole screen along with these after.
+|    | 325|+          if (it->stretch_limit >= 0)   // (*)
+|    | 326|+              width = remained_width - it->stretch_limit;
+|    | 327|+          else
+|    | 328|+              width = it->fixed ? it->width : it->width * list_width * 0.01;
+|    | 329|+          // columns with relative width may shrink to 0, omit them
+|    | 330|+          if (width == 0)
+|    | 331|+              continue;
+|    | 332|+          // if column is not last, we need to have spacing between it
+|    | 333|+          // and next column, so we substract it now and restore later.
+|    | 334|+          if (it != last)
+|    | 335|+              --width;
+|    | 336|+
+|    | 337|+          // if column doesn't fit into screen, discard it and any other after it.
+|    | 338|+          if (remained_width - width < 0
+|    | 339|+              || width < 0 /* this one may come from (*) */ )
+|    | 340|+              break;
+|    | 341|+
+|    | 342|+          std::wstring name;
+|    | 343|+          if (it->name.empty ())
+|    | 344|+            {
+|    | 345|+                size_t
+|    | 346|+                    j = 0;
+|    | 347|+                while (true)
+|    | 348|+                  {
+|    | 349|+                      name += toColumnName (it->type[j]);
+|    | 350|+                      ++j;
+|    | 351|+                      if (j < it->type.length ())
+|    | 352|+                          name += '/';
+|    | 353|+                      else
+|    | 354|+                          break;
+|    | 355|+                  }
+|    | 356|+            }
+|    | 357|+          else
+|    | 358|+              name = it->name;
+|    | 359|+          wideCut (name, width);
+|    | 360|+
+|    | 361|+          int
+|    | 362|+              x_off = std::max (0, width - int (wideLength (name)));
+|    | 363|+          if (it->right_alignment)
+|    | 364|+            {
+|    | 365|+                result += std::string (x_off, NC::Key::Space);
+|    | 366|+                result += Charset::utf8ToLocale (ToString (name));
+|    | 367|+            }
+|    | 368|+          else
+|    | 369|+            {
+|    | 370|+                result += Charset::utf8ToLocale (ToString (name));
+|    | 371|+                result += std::string (x_off, NC::Key::Space);
+|    | 372|+            }
+|    | 373|+
+|    | 374|+          if (it != last)
+|    | 375|+            {
+|    | 376|+                // add missing width's part and restore the value.
+|    | 377|+                remained_width -= width + 1;
+|    | 378|+                result += ' ';
+|    | 379|+            }
+|    | 380|+      }
+|    | 381|+
+|    | 382|+    return result;
+|    | 383|+}
+|    | 384|+
+|    | 385|+void
+|    | 386|+Display::SongsInColumns (NC::Menu < MPD::Song > &menu, const SongList & list)
+|    | 387|+{
+|    | 388|+    showSongsInColumns (menu, menu.drawn ()->value (), list);
+|    | 389|+}
+|    | 390|+
+|    | 391|+void
+|    | 392|+Display::Songs (NC::Menu < MPD::Song > &menu, const SongList & list,
+|    | 393|+                const Format::AST < char >&ast)
+|    | 394|+{
+|    | 395|+    showSongs (menu, menu.drawn ()->value (), list, ast);
+| 344| 396| }
+| 345| 397| 
+| 346| 398| #ifdef HAVE_TAGLIB_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/display.cpp
+|    |++++| /app/src/display.cpp
+| 344| 344| }
+| 345| 345| 
+| 346| 346| #ifdef HAVE_TAGLIB_H
+| 347|    |-void Display::Tags(NC::Menu<MPD::MutableSong> &menu)
+| 348|    |-{
+| 349|    |-	const MPD::MutableSong &s = menu.drawn()->value();
+| 350|    |-	if (s.isModified())
+| 351|    |-		menu << Config.modified_item_prefix;
+| 352|    |-	size_t i = myTagEditor->TagTypes->choice();
+| 353|    |-	if (i < 11)
+| 354|    |-	{
+| 355|    |-		ShowTag(menu, Charset::utf8ToLocale(s.getTags(SongInfo::Tags[i].Get)));
+| 356|    |-	}
+| 357|    |-	else if (i == 12)
+| 358|    |-	{
+| 359|    |-		if (s.getNewName().empty())
+| 360|    |-			menu << Charset::utf8ToLocale(s.getName());
+| 361|    |-		else
+| 362|    |-			menu << Charset::utf8ToLocale(s.getName())
+| 363|    |-			     << Config.color2
+| 364|    |-			     << " -> "
+| 365|    |-			     << NC::FormattedColor::End<>(Config.color2)
+| 366|    |-			     << Charset::utf8ToLocale(s.getNewName());
+| 367|    |-	}
+|    | 347|+void
+|    | 348|+Display::Tags (NC::Menu < MPD::MutableSong > &menu)
+|    | 349|+{
+|    | 350|+    const MPD::MutableSong & s = menu.drawn ()->value ();
+|    | 351|+    if (s.isModified ())
+|    | 352|+        menu << Config.modified_item_prefix;
+|    | 353|+    size_t i = myTagEditor->TagTypes->choice ();
+|    | 354|+    if (i < 11)
+|    | 355|+      {
+|    | 356|+          ShowTag (menu,
+|    | 357|+                   Charset::utf8ToLocale (s.getTags (SongInfo::Tags[i].Get)));
+|    | 358|+      }
+|    | 359|+    else if (i == 12)
+|    | 360|+      {
+|    | 361|+          if (s.getNewName ().empty ())
+|    | 362|+              menu << Charset::utf8ToLocale (s.getName ());
+|    | 363|+          else
+|    | 364|+              menu << Charset::utf8ToLocale (s.getName ())
+|    | 365|+                  << Config.color2
+|    | 366|+                  << " -> "
+|    | 367|+                  << NC::FormattedColor::End <> (Config.color2)
+|    | 368|+                  << Charset::utf8ToLocale (s.getNewName ());
+|    | 369|+      }
+| 368| 370| }
+| 369| 371| #endif // HAVE_TAGLIB_H
+| 370| 372| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/display.cpp
+|    |++++| /app/src/display.cpp
+| 368| 368| }
+| 369| 369| #endif // HAVE_TAGLIB_H
+| 370| 370| 
+| 371|    |-void Display::Items(NC::Menu<MPD::Item> &menu, const SongList &list)
+| 372|    |-{
+| 373|    |-	const MPD::Item &item = menu.drawn()->value();
+| 374|    |-	switch (item.type())
+| 375|    |-	{
+| 376|    |-		case MPD::Item::Type::Directory:
+| 377|    |-			menu << "["
+| 378|    |-			     << Charset::utf8ToLocale(getBasename(item.directory().path()))
+| 379|    |-			     << "]";
+| 380|    |-			break;
+| 381|    |-		case MPD::Item::Type::Song:
+| 382|    |-			switch (Config.browser_display_mode)
+| 383|    |-			{
+| 384|    |-				case DisplayMode::Classic:
+| 385|    |-					showSongs(menu, item.song(), list, Config.song_list_format);
+| 386|    |-					break;
+| 387|    |-				case DisplayMode::Columns:
+| 388|    |-					showSongsInColumns(menu, item.song(), list);
+| 389|    |-					break;
+| 390|    |-			}
+| 391|    |-			break;
+| 392|    |-		case MPD::Item::Type::Playlist:
+| 393|    |-			menu << Config.browser_playlist_prefix
+| 394|    |-			     << Charset::utf8ToLocale(getBasename(item.playlist().path()));
+| 395|    |-			break;
+| 396|    |-	}
+| 397|    |-}
+| 398|    |-
+| 399|    |-void Display::SEItems(NC::Menu<SEItem> &menu, const SongList &list)
+| 400|    |-{
+| 401|    |-	const SEItem &si = menu.drawn()->value();
+| 402|    |-	if (si.isSong())
+| 403|    |-	{
+| 404|    |-		switch (Config.search_engine_display_mode)
+| 405|    |-		{
+| 406|    |-			case DisplayMode::Classic:
+| 407|    |-				showSongs(menu, si.song(), list, Config.song_list_format);
+| 408|    |-				break;
+| 409|    |-			case DisplayMode::Columns:
+| 410|    |-				showSongsInColumns(menu, si.song(), list);
+| 411|    |-				break;
+| 412|    |-		}
+| 413|    |-	}
+| 414|    |-	else
+| 415|    |-		menu << si.buffer();
+| 416|    |-}
+|    | 371|+void
+|    | 372|+Display::Items (NC::Menu < MPD::Item > &menu, const SongList & list)
+|    | 373|+{
+|    | 374|+    const MPD::Item & item = menu.drawn ()->value ();
+|    | 375|+    switch (item.type ())
+|    | 376|+      {
+|    | 377|+      case MPD::Item::Type::Directory:
+|    | 378|+          menu << "["
+|    | 379|+              << Charset::
+|    | 380|+              utf8ToLocale (getBasename (item.directory ().path ())) << "]";
+|    | 381|+          break;
+|    | 382|+      case MPD::Item::Type::Song:
+|    | 383|+          switch (Config.browser_display_mode)
+|    | 384|+            {
+|    | 385|+            case DisplayMode::Classic:
+|    | 386|+                showSongs (menu, item.song (), list, Config.song_list_format);
+|    | 387|+                break;
+|    | 388|+            case DisplayMode::Columns:
+|    | 389|+                showSongsInColumns (menu, item.song (), list);
+|    | 390|+                break;
+|    | 391|+            }
+|    | 392|+          break;
+|    | 393|+      case MPD::Item::Type::Playlist:
+|    | 394|+          menu << Config.browser_playlist_prefix
+|    | 395|+              << Charset::
+|    | 396|+              utf8ToLocale (getBasename (item.playlist ().path ()));
+|    | 397|+          break;
+|    | 398|+      }
+|    | 399|+}
+|    | 400|+
+|    | 401|+void
+|    | 402|+Display::SEItems (NC::Menu < SEItem > &menu, const SongList & list)
+|    | 403|+{
+|    | 404|+    const SEItem & si = menu.drawn ()->value ();
+|    | 405|+    if (si.isSong ())
+|    | 406|+      {
+|    | 407|+          switch (Config.search_engine_display_mode)
+|    | 408|+            {
+|    | 409|+            case DisplayMode::Classic:
+|    | 410|+                showSongs (menu, si.song (), list, Config.song_list_format);
+|    | 411|+                break;
+|    | 412|+            case DisplayMode::Columns:
+|    | 413|+                showSongsInColumns (menu, si.song (), list);
+|    | 414|+                break;
+|    | 415|+            }
+|    | 416|+      }
+|    | 417|+    else
+|    | 418|+        menu << si.buffer ();
+|    | 419|+}
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+|  27|  27| #include "curses/formatted_color.h"
+|  28|  28| #include "curses/window.h"
+|  29|  29| 
+|  30|    |-namespace NC {
+|    |  30|+namespace NC
+|    |  31|+{
+|  31|  32| 
+|  32|  33| /// Buffer template class that stores text
+|  33|  34| /// along with its properties (colors/formatting).
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+|  31|  31| 
+|  32|  32| /// Buffer template class that stores text
+|  33|  33| /// along with its properties (colors/formatting).
+|  34|    |-template <typename CharT> class BasicBuffer
+|  35|    |-{
+|  36|    |-	struct Property
+|  37|    |-	{
+|  38|    |-		template <typename ArgT>
+|  39|    |-		Property(ArgT &&arg, size_t id_)
+|  40|    |-		: m_impl(std::forward<ArgT>(arg)), m_id(id_) { }
+|  41|    |-		
+|  42|    |-		size_t id() const { return m_id; }
+|  43|    |-
+|  44|    |-		bool operator==(const Property &rhs) const
+|  45|    |-		{
+|  46|    |-			return m_id == rhs.m_id && m_impl == rhs.m_impl;
+|  47|    |-		}
+|  48|    |-
+|  49|    |-		template <typename OutputStreamT>
+|  50|    |-		friend OutputStreamT &operator<<(OutputStreamT &os, const Property &p)
+|  51|    |-		{
+|  52|    |-			boost::apply_visitor([&os](const auto &v) { os << v; }, p.m_impl);
+|  53|    |-			return os;
+|  54|    |-		}
+|  55|    |-		
+|  56|    |-	private:
+|  57|    |-		boost::variant<Color,
+|  58|    |-		               Format,
+|  59|    |-		               FormattedColor,
+|  60|    |-		               FormattedColor::End<StorageKind::Value>
+|  61|    |-		               > m_impl;
+|  62|    |-		size_t m_id;
+|  63|    |-	};
+|  64|    |-	
+|  65|    |-public:
+|  66|    |-	typedef std::basic_string<CharT> StringType;
+|  67|    |-	typedef std::multimap<size_t, Property> Properties;
+|  68|    |-	
+|  69|    |-	const StringType &str() const { return m_string; }
+|  70|    |-	const Properties &properties() const { return m_properties; }
+|  71|    |-	
+|  72|    |-	template <typename PropertyT>
+|  73|    |-	void addProperty(size_t position, PropertyT &&property, size_t id = -1)
+|  74|    |-	{
+|  75|    |-		assert(position <= m_string.size());
+|  76|    |-		m_properties.emplace(position, Property(std::forward<PropertyT>(property), id));
+|  77|    |-	}
+|  78|    |-
+|  79|    |-	void removeProperties(size_t id = -1)
+|  80|    |-	{
+|  81|    |-		auto it = m_properties.begin();
+|  82|    |-		while (it != m_properties.end())
+|  83|    |-		{
+|  84|    |-			if (it->second.id() == id)
+|  85|    |-				m_properties.erase(it++);
+|  86|    |-			else
+|  87|    |-				++it;
+|  88|    |-		}
+|  89|    |-	}
+|  90|    |-
+|  91|    |-	bool empty() const
+|  92|    |-	{
+|  93|    |-		return m_string.empty() && m_properties.empty();
+|  94|    |-	}
+|  95|    |-
+|  96|    |-	void clear()
+|  97|    |-	{
+|  98|    |-		m_string.clear();
+|  99|    |-		m_properties.clear();
+| 100|    |-	}
+| 101|    |-	
+| 102|    |-	BasicBuffer<CharT> &operator<<(int n)
+| 103|    |-	{
+| 104|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 105|    |-		return *this;
+| 106|    |-	}
+| 107|    |-	
+| 108|    |-	BasicBuffer<CharT> &operator<<(long int n)
+| 109|    |-	{
+| 110|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 111|    |-		return *this;
+| 112|    |-	}
+| 113|    |-	
+| 114|    |-	BasicBuffer<CharT> &operator<<(unsigned int n)
+| 115|    |-	{
+| 116|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 117|    |-		return *this;
+| 118|    |-	}
+| 119|    |-	
+| 120|    |-	BasicBuffer<CharT> &operator<<(unsigned long int n)
+| 121|    |-	{
+| 122|    |-		m_string += boost::lexical_cast<StringType>(n);
+| 123|    |-		return *this;
+| 124|    |-	}
+| 125|    |-	
+| 126|    |-	BasicBuffer<CharT> &operator<<(CharT c)
+| 127|    |-	{
+| 128|    |-		m_string += c;
+| 129|    |-		return *this;
+| 130|    |-	}
+| 131|    |-
+| 132|    |-	BasicBuffer<CharT> &operator<<(const CharT *s)
+| 133|    |-	{
+| 134|    |-		m_string += s;
+| 135|    |-		return *this;
+| 136|    |-	}
+| 137|    |-	
+| 138|    |-	BasicBuffer<CharT> &operator<<(const StringType &s)
+| 139|    |-	{
+| 140|    |-		m_string += s;
+| 141|    |-		return *this;
+| 142|    |-	}
+| 143|    |-	
+| 144|    |-	BasicBuffer<CharT> &operator<<(const Color &color)
+| 145|    |-	{
+| 146|    |-		addProperty(m_string.size(), color);
+| 147|    |-		return *this;
+| 148|    |-	}
+| 149|    |-	
+| 150|    |-	BasicBuffer<CharT> &operator<<(const Format &format)
+| 151|    |-	{
+| 152|    |-		addProperty(m_string.size(), format);
+| 153|    |-		return *this;
+| 154|    |-	}
+| 155|    |-
+| 156|    |-	// static variadic initializer. used instead of a proper constructor because
+| 157|    |-	// it's too polymorphic and would end up invoked as a copy/move constructor.
+| 158|    |-	template <typename... Args>
+| 159|    |-	static BasicBuffer init(Args&&... args)
+| 160|    |-	{
+| 161|    |-		BasicBuffer result;
+| 162|    |-		result.construct(std::forward<Args>(args)...);
+| 163|    |-		return result;
+| 164|    |-	}
+| 165|    |-
+| 166|    |-private:
+| 167|    |-	void construct() { }
+| 168|    |-	template <typename ArgT, typename... Args>
+| 169|    |-	void construct(ArgT &&arg, Args&&... args)
+| 170|    |-	{
+| 171|    |-		*this << std::forward<ArgT>(arg);
+| 172|    |-		construct(std::forward<Args>(args)...);
+| 173|    |-	}
+| 174|    |-
+| 175|    |-	StringType m_string;
+| 176|    |-	Properties m_properties;
+| 177|    |-};
+| 178|    |-
+| 179|    |-typedef BasicBuffer<char> Buffer;
+| 180|    |-typedef BasicBuffer<wchar_t> WBuffer;
+| 181|    |-
+| 182|    |-template <typename CharT>
+| 183|    |-bool operator==(const BasicBuffer<CharT> &lhs, const BasicBuffer<CharT> &rhs)
+| 184|    |-{
+| 185|    |-	return lhs.str() == rhs.str()
+| 186|    |-		&& lhs.properties() == rhs.properties();
+|    |  34|+    template < typename CharT > class BasicBuffer
+|    |  35|+    {
+|    |  36|+        struct Property
+|    |  37|+        {
+|    |  38|+            template < typename ArgT >
+|    |  39|+                Property (ArgT
+|    |  40|+                          && arg,
+|    |  41|+                          size_t id_):m_impl (std::forward < ArgT > (arg)),
+|    |  42|+                m_id (id_)
+|    |  43|+            {
+|    |  44|+            }
+|    |  45|+
+|    |  46|+            size_t id () const
+|    |  47|+            {
+|    |  48|+                return m_id;
+|    |  49|+            }
+|    |  50|+
+|    |  51|+            bool operator== (const Property & rhs) const
+|    |  52|+            {
+|    |  53|+                return m_id == rhs.m_id && m_impl == rhs.m_impl;
+|    |  54|+            }
+|    |  55|+
+|    |  56|+            template < typename OutputStreamT >
+|    |  57|+                friend OutputStreamT & operator<< (OutputStreamT & os,
+|    |  58|+                                                   const Property & p)
+|    |  59|+            {
+|    |  60|+                boost::apply_visitor ([&os] (const auto & v)
+|    |  61|+                                      {
+|    |  62|+                                      os << v;
+|    |  63|+                                      }, p.m_impl);
+|    |  64|+                return os;
+|    |  65|+            }
+|    |  66|+
+|    |  67|+          private:
+|    |  68|+            boost::variant < Color,
+|    |  69|+                Format,
+|    |  70|+                FormattedColor,
+|    |  71|+                FormattedColor::End < StorageKind::Value > >m_impl;
+|    |  72|+            size_t m_id;
+|    |  73|+        };
+|    |  74|+
+|    |  75|+      public:
+|    |  76|+        typedef std::basic_string < CharT > StringType;
+|    |  77|+        typedef std::multimap < size_t, Property > Properties;
+|    |  78|+
+|    |  79|+        const StringType & str () const
+|    |  80|+        {
+|    |  81|+            return m_string;
+|    |  82|+        }
+|    |  83|+        const Properties & properties () const
+|    |  84|+        {
+|    |  85|+            return m_properties;
+|    |  86|+        }
+|    |  87|+
+|    |  88|+        template < typename PropertyT >
+|    |  89|+            void addProperty (size_t position, PropertyT
+|    |  90|+                              && property, size_t id = -1)
+|    |  91|+        {
+|    |  92|+            assert (position <= m_string.size ());
+|    |  93|+            m_properties.emplace (position,
+|    |  94|+                                  Property (std::forward < PropertyT >
+|    |  95|+                                            (property), id));
+|    |  96|+        }
+|    |  97|+
+|    |  98|+        void removeProperties (size_t id = -1)
+|    |  99|+        {
+|    | 100|+            auto it = m_properties.begin ();
+|    | 101|+            while (it != m_properties.end ())
+|    | 102|+              {
+|    | 103|+                  if (it->second.id () == id)
+|    | 104|+                      m_properties.erase (it++);
+|    | 105|+                  else
+|    | 106|+                      ++it;
+|    | 107|+              }
+|    | 108|+        }
+|    | 109|+
+|    | 110|+        bool empty () const
+|    | 111|+        {
+|    | 112|+            return m_string.empty () && m_properties.empty ();
+|    | 113|+        }
+|    | 114|+
+|    | 115|+        void clear ()
+|    | 116|+        {
+|    | 117|+            m_string.clear ();
+|    | 118|+            m_properties.clear ();
+|    | 119|+        }
+|    | 120|+
+|    | 121|+        BasicBuffer < CharT > &operator<< (int n)
+|    | 122|+        {
+|    | 123|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 124|+            return *this;
+|    | 125|+        }
+|    | 126|+
+|    | 127|+        BasicBuffer < CharT > &operator<< (long int n)
+|    | 128|+        {
+|    | 129|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 130|+            return *this;
+|    | 131|+        }
+|    | 132|+
+|    | 133|+        BasicBuffer < CharT > &operator<< (unsigned int n)
+|    | 134|+        {
+|    | 135|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 136|+            return *this;
+|    | 137|+        }
+|    | 138|+
+|    | 139|+        BasicBuffer < CharT > &operator<< (unsigned long int n)
+|    | 140|+        {
+|    | 141|+            m_string += boost::lexical_cast < StringType > (n);
+|    | 142|+            return *this;
+|    | 143|+        }
+|    | 144|+
+|    | 145|+        BasicBuffer < CharT > &operator<< (CharT c)
+|    | 146|+        {
+|    | 147|+            m_string += c;
+|    | 148|+            return *this;
+|    | 149|+        }
+|    | 150|+
+|    | 151|+        BasicBuffer < CharT > &operator<< (const CharT * s)
+|    | 152|+        {
+|    | 153|+            m_string += s;
+|    | 154|+            return *this;
+|    | 155|+        }
+|    | 156|+
+|    | 157|+        BasicBuffer < CharT > &operator<< (const StringType & s)
+|    | 158|+        {
+|    | 159|+            m_string += s;
+|    | 160|+            return *this;
+|    | 161|+        }
+|    | 162|+
+|    | 163|+        BasicBuffer < CharT > &operator<< (const Color & color)
+|    | 164|+        {
+|    | 165|+            addProperty (m_string.size (), color);
+|    | 166|+            return *this;
+|    | 167|+        }
+|    | 168|+
+|    | 169|+        BasicBuffer < CharT > &operator<< (const Format & format)
+|    | 170|+        {
+|    | 171|+            addProperty (m_string.size (), format);
+|    | 172|+            return *this;
+|    | 173|+        }
+|    | 174|+
+|    | 175|+        // static variadic initializer. used instead of a proper constructor because
+|    | 176|+        // it's too polymorphic and would end up invoked as a copy/move constructor.
+|    | 177|+        template < typename...Args > static BasicBuffer init (Args && ... args)
+|    | 178|+        {
+|    | 179|+            BasicBuffer result;
+|    | 180|+            result.construct (std::forward < Args > (args)...);
+|    | 181|+            return result;
+|    | 182|+        }
+|    | 183|+
+|    | 184|+      private:
+|    | 185|+        void construct ()
+|    | 186|+        {
+|    | 187|+        }
+|    | 188|+        template < typename ArgT, typename...Args >
+|    | 189|+            void construct (ArgT && arg, Args && ... args)
+|    | 190|+        {
+|    | 191|+            *this << std::forward < ArgT > (arg);
+|    | 192|+            construct (std::forward < Args > (args)...);
+|    | 193|+        }
+|    | 194|+
+|    | 195|+        StringType m_string;
+|    | 196|+        Properties m_properties;
+|    | 197|+    };
+|    | 198|+
+|    | 199|+    typedef BasicBuffer < char >Buffer;
+|    | 200|+    typedef BasicBuffer < wchar_t > WBuffer;
+|    | 201|+
+|    | 202|+    template < typename CharT >
+|    | 203|+        bool operator== (const BasicBuffer < CharT > &lhs,
+|    | 204|+                         const BasicBuffer < CharT > &rhs)
+|    | 205|+    {
+|    | 206|+        return lhs.str () == rhs.str ()
+|    | 207|+            && lhs.properties () == rhs.properties ();
+|    | 208|+    }
+|    | 209|+
+|    | 210|+    template < typename OutputStreamT, typename CharT >
+|    | 211|+        OutputStreamT & operator<< (OutputStreamT & os,
+|    | 212|+                                    const BasicBuffer < CharT > &buffer)
+|    | 213|+    {
+|    | 214|+        if (buffer.properties ().empty ())
+|    | 215|+            os << buffer.str ();
+|    | 216|+        else
+|    | 217|+          {
+|    | 218|+              auto & s = buffer.str ();
+|    | 219|+              auto & ps = buffer.properties ();
+|    | 220|+              auto p = ps.begin ();
+|    | 221|+              for (size_t i = 0;; ++i)
+|    | 222|+                {
+|    | 223|+                    for (; p != ps.end () && p->first == i; ++p)
+|    | 224|+                        os << p->second;
+|    | 225|+                    if (i < s.size ())
+|    | 226|+                        os << s[i];
+|    | 227|+                    else
+|    | 228|+                        break;
+|    | 229|+                }
+|    | 230|+          }
+|    | 231|+        return os;
+|    | 232|+    }
+|    | 233|+
+| 187| 234| }
+| 188| 235| 
+| 189| 236| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/strbuffer.h
+|    |++++| /app/src/curses/strbuffer.h
+| 186| 186| 		&& lhs.properties() == rhs.properties();
+| 187| 187| }
+| 188| 188| 
+| 189|    |-
+| 190|    |-template <typename OutputStreamT, typename CharT>
+| 191|    |-OutputStreamT &operator<<(OutputStreamT &os, const BasicBuffer<CharT> &buffer)
+| 192|    |-{
+| 193|    |-	if (buffer.properties().empty())
+| 194|    |-		os << buffer.str();
+| 195|    |-	else
+| 196|    |-	{
+| 197|    |-		auto &s = buffer.str();
+| 198|    |-		auto &ps = buffer.properties();
+| 199|    |-		auto p = ps.begin();
+| 200|    |-		for (size_t i = 0;; ++i)
+| 201|    |-		{
+| 202|    |-			for (; p != ps.end() && p->first == i; ++p)
+| 203|    |-				os << p->second;
+| 204|    |-			if (i < s.size())
+| 205|    |-				os << s[i];
+| 206|    |-			else
+| 207|    |-				break;
+| 208|    |-		}
+| 209|    |-	}
+| 210|    |-	return os;
+| 211|    |-}
+| 212|    |-
+| 213|    |-}
+| 214|    |-
+| 215| 189| #endif // NCMPCPP_STRBUFFER_H
+
+src/curses/strbuffer.h
+|  27| #include•"curses/formatted_color.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/formatted_color.h'
+
+src/curses/strbuffer.h
+|  28| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen_type.cpp
+|    |++++| /app/src/screens/screen_type.cpp
+|  39|  39| #include "screens/tiny_tag_editor.h"
+|  40|  40| #include "screens/visualizer.h"
+|  41|  41| 
+|  42|    |-std::string screenTypeToString(ScreenType st)
+|  43|    |-{
+|  44|    |-	switch (st)
+|  45|    |-	{
+|  46|    |-	case ScreenType::Browser:
+|  47|    |-		return "browser";
+|    |  42|+std::string screenTypeToString (ScreenType st)
+|    |  43|+{
+|    |  44|+    switch (st)
+|    |  45|+      {
+|    |  46|+      case ScreenType::Browser:
+|    |  47|+          return "browser";
+|  48|  48| #ifdef ENABLE_CLOCK
+|  49|    |-	case ScreenType::Clock:
+|  50|    |-		return "clock";
+|    |  49|+      case ScreenType::Clock:
+|    |  50|+          return "clock";
+|  51|  51| #endif // ENABLE_CLOCK
+|  52|    |-	case ScreenType::Help:
+|  53|    |-		return "help";
+|  54|    |-	case ScreenType::Lastfm:
+|  55|    |-		return "last_fm";
+|  56|    |-	case ScreenType::Lyrics:
+|  57|    |-		return "lyrics";
+|  58|    |-	case ScreenType::MediaLibrary:
+|  59|    |-		return "media_library";
+|    |  52|+      case ScreenType::Help:
+|    |  53|+          return "help";
+|    |  54|+      case ScreenType::Lastfm:
+|    |  55|+          return "last_fm";
+|    |  56|+      case ScreenType::Lyrics:
+|    |  57|+          return "lyrics";
+|    |  58|+      case ScreenType::MediaLibrary:
+|    |  59|+          return "media_library";
+|  60|  60| #ifdef ENABLE_OUTPUTS
+|  61|    |-	case ScreenType::Outputs:
+|  62|    |-		return "outputs";
+|    |  61|+      case ScreenType::Outputs:
+|    |  62|+          return "outputs";
+|  63|  63| #endif // ENABLE_OUTPUTS
+|  64|    |-	case ScreenType::Playlist:
+|  65|    |-		return "playlist";
+|  66|    |-	case ScreenType::PlaylistEditor:
+|  67|    |-		return "playlist_editor";
+|  68|    |-	case ScreenType::SearchEngine:
+|  69|    |-		return "search_engine";
+|  70|    |-	case ScreenType::SelectedItemsAdder:
+|  71|    |-		return "selected_items_adder";
+|  72|    |-	case ScreenType::ServerInfo:
+|  73|    |-		return "server_info";
+|  74|    |-	case ScreenType::SongInfo:
+|  75|    |-		return "song_info";
+|  76|    |-	case ScreenType::SortPlaylistDialog:
+|  77|    |-		return "sort_playlist_dialog";
+|    |  64|+      case ScreenType::Playlist:
+|    |  65|+          return "playlist";
+|    |  66|+      case ScreenType::PlaylistEditor:
+|    |  67|+          return "playlist_editor";
+|    |  68|+      case ScreenType::SearchEngine:
+|    |  69|+          return "search_engine";
+|    |  70|+      case ScreenType::SelectedItemsAdder:
+|    |  71|+          return "selected_items_adder";
+|    |  72|+      case ScreenType::ServerInfo:
+|    |  73|+          return "server_info";
+|    |  74|+      case ScreenType::SongInfo:
+|    |  75|+          return "song_info";
+|    |  76|+      case ScreenType::SortPlaylistDialog:
+|    |  77|+          return "sort_playlist_dialog";
+|  78|  78| #ifdef HAVE_TAGLIB_H
+|  79|    |-	case ScreenType::TagEditor:
+|  80|    |-		return "tag_editor";
+|  81|    |-	case ScreenType::TinyTagEditor:
+|  82|    |-		return "tiny_tag_editor";
+|    |  79|+      case ScreenType::TagEditor:
+|    |  80|+          return "tag_editor";
+|    |  81|+      case ScreenType::TinyTagEditor:
+|    |  82|+          return "tiny_tag_editor";
+|  83|  83| #endif // HAVE_TAGLIB_H
+|  84|    |-	case ScreenType::Unknown:
+|  85|    |-		return "unknown";
+|    |  84|+      case ScreenType::Unknown:
+|    |  85|+          return "unknown";
+|  86|  86| #ifdef ENABLE_VISUALIZER
+|  87|    |-	case ScreenType::Visualizer:
+|  88|    |-		return "visualizer";
+|    |  87|+      case ScreenType::Visualizer:
+|    |  88|+          return "visualizer";
+|  89|  89| #endif // ENABLE_VISUALIZER
+|  90|    |-	}
+|  91|    |-	// silence gcc warning
+|  92|    |-	throw std::runtime_error("unreachable");
+|  93|    |-}
+|  94|    |-
+|  95|    |-ScreenType stringtoStartupScreenType(const std::string &s)
+|  96|    |-{
+|  97|    |-	ScreenType result = ScreenType::Unknown;
+|  98|    |-	if (s == "browser")
+|  99|    |-		result = ScreenType::Browser;
+|    |  90|+      }
+|    |  91|+    // silence gcc warning
+|    |  92|+    throw std::runtime_error ("unreachable");
+|    |  93|+}
+|    |  94|+
+|    |  95|+ScreenType
+|    |  96|+stringtoStartupScreenType (const std::string & s)
+|    |  97|+{
+|    |  98|+    ScreenType result = ScreenType::Unknown;
+|    |  99|+    if (s == "browser")
+|    | 100|+        result = ScreenType::Browser;
+| 100| 101| #	ifdef ENABLE_CLOCK
+| 101|    |-	else if (s == "clock")
+| 102|    |-		result = ScreenType::Clock;
+|    | 102|+    else if (s == "clock")
+|    | 103|+        result = ScreenType::Clock;
+| 103| 104| #	endif // ENABLE_CLOCK
+| 104|    |-	else if (s == "help")
+| 105|    |-		result = ScreenType::Help;
+| 106|    |-	else if (s == "media_library")
+| 107|    |-		result = ScreenType::MediaLibrary;
+|    | 105|+    else if (s == "help")
+|    | 106|+        result = ScreenType::Help;
+|    | 107|+    else if (s == "media_library")
+|    | 108|+        result = ScreenType::MediaLibrary;
+| 108| 109| #	ifdef ENABLE_OUTPUTS
+| 109|    |-	else if (s == "outputs")
+| 110|    |-		result = ScreenType::Outputs;
+|    | 110|+    else if (s == "outputs")
+|    | 111|+        result = ScreenType::Outputs;
+| 111| 112| #	endif // ENABLE_OUTPUTS
+| 112|    |-	else if (s == "playlist")
+| 113|    |-		result = ScreenType::Playlist;
+| 114|    |-	else if (s == "playlist_editor")
+| 115|    |-		result = ScreenType::PlaylistEditor;
+| 116|    |-	else if (s == "search_engine")
+| 117|    |-		result = ScreenType::SearchEngine;
+|    | 113|+    else if (s == "playlist")
+|    | 114|+        result = ScreenType::Playlist;
+|    | 115|+    else if (s == "playlist_editor")
+|    | 116|+        result = ScreenType::PlaylistEditor;
+|    | 117|+    else if (s == "search_engine")
+|    | 118|+        result = ScreenType::SearchEngine;
+| 118| 119| #	ifdef HAVE_TAGLIB_H
+| 119|    |-	else if (s == "tag_editor")
+| 120|    |-		result = ScreenType::TagEditor;
+|    | 120|+    else if (s == "tag_editor")
+|    | 121|+        result = ScreenType::TagEditor;
+| 121| 122| #	endif // HAVE_TAGLIB_H
+| 122| 123| #	ifdef ENABLE_VISUALIZER
+| 123| 124| 	else if (s == "visualizer")
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen_type.cpp
+|    |++++| /app/src/screens/screen_type.cpp
+| 120| 120| 		result = ScreenType::TagEditor;
+| 121| 121| #	endif // HAVE_TAGLIB_H
+| 122| 122| #	ifdef ENABLE_VISUALIZER
+| 123|    |-	else if (s == "visualizer")
+| 124|    |-		result = ScreenType::Visualizer;
+|    | 123|+    else if (s == "visualizer")
+|    | 124|+        result = ScreenType::Visualizer;
+| 125| 125| #	endif // ENABLE_VISUALIZER
+| 126|    |-	else if (s == "lyrics")
+| 127|    |-		result = ScreenType::Lyrics;
+| 128|    |-	else if (s == "last_fm")
+| 129|    |-		result = ScreenType::Lastfm;
+| 130|    |-	return result;
+| 131|    |-}
+| 132|    |-
+| 133|    |-ScreenType stringToScreenType(const std::string &s)
+| 134|    |-{
+| 135|    |-	ScreenType result = stringtoStartupScreenType(s);
+| 136|    |-	if (result == ScreenType::Unknown)
+| 137|    |-	{
+| 138|    |-		if (s == "lyrics")
+| 139|    |-			result = ScreenType::Lyrics;
+| 140|    |-		else if (s == "last_fm")
+| 141|    |-			result = ScreenType::Lastfm;
+| 142|    |-		else if (s == "selected_items_adder")
+| 143|    |-			result = ScreenType::SelectedItemsAdder;
+| 144|    |-		else if (s == "server_info")
+| 145|    |-			result = ScreenType::ServerInfo;
+| 146|    |-		else if (s == "song_info")
+| 147|    |-			result = ScreenType::SongInfo;
+| 148|    |-		else if (s == "sort_playlist_dialog")
+| 149|    |-			result = ScreenType::SortPlaylistDialog;
+|    | 126|+    else if (s == "lyrics")
+|    | 127|+        result = ScreenType::Lyrics;
+|    | 128|+    else if (s == "last_fm")
+|    | 129|+        result = ScreenType::Lastfm;
+|    | 130|+    return result;
+|    | 131|+}
+|    | 132|+
+|    | 133|+ScreenType
+|    | 134|+stringToScreenType (const std::string & s)
+|    | 135|+{
+|    | 136|+    ScreenType result = stringtoStartupScreenType (s);
+|    | 137|+    if (result == ScreenType::Unknown)
+|    | 138|+      {
+|    | 139|+          if (s == "lyrics")
+|    | 140|+              result = ScreenType::Lyrics;
+|    | 141|+          else if (s == "last_fm")
+|    | 142|+              result = ScreenType::Lastfm;
+|    | 143|+          else if (s == "selected_items_adder")
+|    | 144|+              result = ScreenType::SelectedItemsAdder;
+|    | 145|+          else if (s == "server_info")
+|    | 146|+              result = ScreenType::ServerInfo;
+|    | 147|+          else if (s == "song_info")
+|    | 148|+              result = ScreenType::SongInfo;
+|    | 149|+          else if (s == "sort_playlist_dialog")
+|    | 150|+              result = ScreenType::SortPlaylistDialog;
+| 150| 151| #		ifdef HAVE_TAGLIB_H
+| 151|    |-		else if (s == "tiny_tag_editor")
+| 152|    |-			result = ScreenType::TinyTagEditor;
+|    | 152|+          else if (s == "tiny_tag_editor")
+|    | 153|+              result = ScreenType::TinyTagEditor;
+| 153| 154| #		endif // HAVE_TAGLIB_H
+| 154|    |-	}
+| 155|    |-	return result;
+| 156|    |-}
+| 157|    |-
+| 158|    |-BaseScreen *toScreen(ScreenType st)
+| 159|    |-{
+| 160|    |-	switch (st)
+| 161|    |-	{
+| 162|    |-		case ScreenType::Browser:
+| 163|    |-			return myBrowser;
+|    | 155|+      }
+|    | 156|+    return result;
+|    | 157|+}
+|    | 158|+
+|    | 159|+BaseScreen *
+|    | 160|+toScreen (ScreenType st)
+|    | 161|+{
+|    | 162|+    switch (st)
+|    | 163|+      {
+|    | 164|+      case ScreenType::Browser:
+|    | 165|+          return myBrowser;
+| 164| 166| #		ifdef ENABLE_CLOCK
+| 165|    |-		case ScreenType::Clock:
+| 166|    |-			return myClock;
+|    | 167|+      case ScreenType::Clock:
+|    | 168|+          return myClock;
+| 167| 169| #		endif // ENABLE_CLOCK
+| 168|    |-		case ScreenType::Help:
+| 169|    |-			return myHelp;
+| 170|    |-		case ScreenType::Lastfm:
+| 171|    |-			return myLastfm;
+| 172|    |-		case ScreenType::Lyrics:
+| 173|    |-			return myLyrics;
+| 174|    |-		case ScreenType::MediaLibrary:
+| 175|    |-			return myLibrary;
+|    | 170|+      case ScreenType::Help:
+|    | 171|+          return myHelp;
+|    | 172|+      case ScreenType::Lastfm:
+|    | 173|+          return myLastfm;
+|    | 174|+      case ScreenType::Lyrics:
+|    | 175|+          return myLyrics;
+|    | 176|+      case ScreenType::MediaLibrary:
+|    | 177|+          return myLibrary;
+| 176| 178| #		ifdef ENABLE_OUTPUTS
+| 177|    |-		case ScreenType::Outputs:
+| 178|    |-			return myOutputs;
+|    | 179|+      case ScreenType::Outputs:
+|    | 180|+          return myOutputs;
+| 179| 181| #		endif // ENABLE_OUTPUTS
+| 180|    |-		case ScreenType::Playlist:
+| 181|    |-			return myPlaylist;
+| 182|    |-		case ScreenType::PlaylistEditor:
+| 183|    |-			return myPlaylistEditor;
+| 184|    |-		case ScreenType::SearchEngine:
+| 185|    |-			return mySearcher;
+| 186|    |-		case ScreenType::SelectedItemsAdder:
+| 187|    |-			return mySelectedItemsAdder;
+| 188|    |-		case ScreenType::ServerInfo:
+| 189|    |-			return myServerInfo;
+| 190|    |-		case ScreenType::SongInfo:
+| 191|    |-			return mySongInfo;
+| 192|    |-		case ScreenType::SortPlaylistDialog:
+| 193|    |-			return mySortPlaylistDialog;
+|    | 182|+      case ScreenType::Playlist:
+|    | 183|+          return myPlaylist;
+|    | 184|+      case ScreenType::PlaylistEditor:
+|    | 185|+          return myPlaylistEditor;
+|    | 186|+      case ScreenType::SearchEngine:
+|    | 187|+          return mySearcher;
+|    | 188|+      case ScreenType::SelectedItemsAdder:
+|    | 189|+          return mySelectedItemsAdder;
+|    | 190|+      case ScreenType::ServerInfo:
+|    | 191|+          return myServerInfo;
+|    | 192|+      case ScreenType::SongInfo:
+|    | 193|+          return mySongInfo;
+|    | 194|+      case ScreenType::SortPlaylistDialog:
+|    | 195|+          return mySortPlaylistDialog;
+| 194| 196| #		ifdef HAVE_TAGLIB_H
+| 195|    |-		case ScreenType::TagEditor:
+| 196|    |-			return myTagEditor;
+| 197|    |-		case ScreenType::TinyTagEditor:
+| 198|    |-			return myTinyTagEditor;
+|    | 197|+      case ScreenType::TagEditor:
+|    | 198|+          return myTagEditor;
+|    | 199|+      case ScreenType::TinyTagEditor:
+|    | 200|+          return myTinyTagEditor;
+| 199| 201| #		endif // HAVE_TAGLIB_H
+| 200| 202| #		ifdef ENABLE_VISUALIZER
+| 201| 203| 		case ScreenType::Visualizer:
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/screen_type.cpp
+|    |++++| /app/src/screens/screen_type.cpp
+| 198| 198| 			return myTinyTagEditor;
+| 199| 199| #		endif // HAVE_TAGLIB_H
+| 200| 200| #		ifdef ENABLE_VISUALIZER
+| 201|    |-		case ScreenType::Visualizer:
+| 202|    |-			return myVisualizer;
+|    | 201|+      case ScreenType::Visualizer:
+|    | 202|+          return myVisualizer;
+| 203| 203| #		endif // ENABLE_VISUALIZER
+| 204|    |-		default:
+| 205|    |-			return nullptr;
+| 206|    |-	}
+| 207|    |-}
+|    | 204|+      default:
+|    | 205|+          return nullptr;
+|    | 206|+      }
+|    | 207|+}
+
+src/screens/screen_type.cpp
+|  21| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/screen_type.cpp
+|  22| #include•"screens/screen_type.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_type.h'
+
+src/screens/screen_type.cpp
+|  24| #include•"screens/browser.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/browser.h'
+
+src/screens/screen_type.cpp
+|  25| #include•"screens/clock.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/clock.h'
+
+src/screens/screen_type.cpp
+|  26| #include•"screens/help.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/help.h'
+
+src/screens/screen_type.cpp
+|  27| #include•"screens/lastfm.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/lastfm.h'
+
+src/screens/screen_type.cpp
+|  28| #include•"screens/lyrics.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/lyrics.h'
+
+src/screens/screen_type.cpp
+|  29| #include•"screens/media_library.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/media_library.h'
+
+src/screens/screen_type.cpp
+|  30| #include•"screens/outputs.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/outputs.h'
+
+src/screens/screen_type.cpp
+|  31| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist.h'
+
+src/screens/screen_type.cpp
+|  32| #include•"screens/playlist_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist_editor.h'
+
+src/screens/screen_type.cpp
+|  33| #include•"screens/search_engine.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/search_engine.h'
+
+src/screens/screen_type.cpp
+|  34| #include•"screens/sel_items_adder.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/sel_items_adder.h'
+
+src/screens/screen_type.cpp
+|  35| #include•"screens/server_info.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/server_info.h'
+
+src/screens/screen_type.cpp
+|  36| #include•"screens/song_info.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/song_info.h'
+
+src/screens/screen_type.cpp
+|  37| #include•"screens/sort_playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/sort_playlist.h'
+
+src/screens/screen_type.cpp
+|  38| #include•"screens/tag_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/tag_editor.h'
+
+src/screens/screen_type.cpp
+|  39| #include•"screens/tiny_tag_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/tiny_tag_editor.h'
+
+src/screens/screen_type.cpp
+|  40| #include•"screens/visualizer.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/visualizer.h'
+
+src/screens/screen_type.cpp
+|  42| std::string•screenTypeToString(ScreenType•st)
+|    | [NORMAL] CPPCleanBear:
+|    | 'screenTypeToString' not found in any directly #included header
+
+src/screens/screen_type.cpp
+|  95| ScreenType•stringtoStartupScreenType(const•std::string•&s)
+|    | [NORMAL] CPPCleanBear:
+|    | 'stringtoStartupScreenType' not found in any directly #included header
+
+src/screens/screen_type.cpp
+| 133| ScreenType•stringToScreenType(const•std::string•&s)
+|    | [NORMAL] CPPCleanBear:
+|    | 'stringToScreenType' not found in any directly #included header
+
+src/screens/screen_type.cpp
+| 158| BaseScreen•*toScreen(ScreenType•st)
+|    | [NORMAL] CPPCleanBear:
+|    | 'toScreen' not found in any directly #included header
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.cpp
+|    |++++| /app/src/screens/playlist_editor.cpp
+|  41|  41| #include "title.h"
+|  42|  42| #include "screens/screen_switcher.h"
+|  43|  43| 
+|  44|    |-using Global::MainHeight;
+|  45|    |-using Global::MainStartY;
+|  46|    |-
+|  47|    |-namespace ph = std::placeholders;
+|  48|    |-
+|  49|    |-PlaylistEditor *myPlaylistEditor;
+|  50|    |-
+|  51|    |-namespace {
+|  52|    |-
+|  53|    |-size_t LeftColumnStartX;
+|  54|    |-size_t LeftColumnWidth;
+|  55|    |-size_t RightColumnStartX;
+|  56|    |-size_t RightColumnWidth;
+|  57|    |-
+|  58|    |-std::string SongToString(const MPD::Song &s);
+|  59|    |-bool PlaylistEntryMatcher(const Regex::Regex &rx, const MPD::Playlist &playlist);
+|  60|    |-bool SongEntryMatcher(const Regex::Regex &rx, const MPD::Song &s);
+|  61|    |-boost::optional<size_t> GetSongIndexInPlaylist(MPD::Playlist playlist, const MPD::Song &song);
+|  62|    |-}
+|  63|    |-
+|  64|    |-PlaylistEditor::PlaylistEditor()
+|  65|    |-: m_timer(boost::posix_time::from_time_t(0))
+|  66|    |-, m_window_timeout(Config.data_fetching_delay ? 250 : BaseScreen::defaultWindowTimeout)
+|  67|    |-, m_fetching_delay(boost::posix_time::milliseconds(Config.data_fetching_delay ? 250 : -1))
+|  68|    |-{
+|  69|    |-	LeftColumnWidth = COLS/3-1;
+|  70|    |-	RightColumnStartX = LeftColumnWidth+1;
+|  71|    |-	RightColumnWidth = COLS-LeftColumnWidth-1;
+|  72|    |-	
+|  73|    |-	Playlists = NC::Menu<MPD::Playlist>(0, MainStartY, LeftColumnWidth, MainHeight, Config.titles_visibility ? "Playlists" : "", Config.main_color, NC::Border());
+|  74|    |-	setHighlightFixes(Playlists);
+|  75|    |-	Playlists.cyclicScrolling(Config.use_cyclic_scrolling);
+|  76|    |-	Playlists.centeredCursor(Config.centered_cursor);
+|  77|    |-	Playlists.setSelectedPrefix(Config.selected_item_prefix);
+|  78|    |-	Playlists.setSelectedSuffix(Config.selected_item_suffix);
+|  79|    |-	Playlists.setItemDisplayer([](NC::Menu<MPD::Playlist> &menu) {
+|  80|    |-		menu << Charset::utf8ToLocale(menu.drawn()->value().path());
+|  81|    |-	});
+|  82|    |-	
+|  83|    |-	Content = NC::Menu<MPD::Song>(RightColumnStartX, MainStartY, RightColumnWidth, MainHeight, Config.titles_visibility ? "Content" : "", Config.main_color, NC::Border());
+|  84|    |-	setHighlightInactiveColumnFixes(Content);
+|  85|    |-	Content.cyclicScrolling(Config.use_cyclic_scrolling);
+|  86|    |-	Content.centeredCursor(Config.centered_cursor);
+|  87|    |-	Content.setSelectedPrefix(Config.selected_item_prefix);
+|  88|    |-	Content.setSelectedSuffix(Config.selected_item_suffix);
+|  89|    |-	switch (Config.playlist_editor_display_mode)
+|  90|    |-	{
+|  91|    |-		case DisplayMode::Classic:
+|  92|    |-			Content.setItemDisplayer(std::bind(
+|  93|    |-				Display::Songs, ph::_1, std::cref(Content), std::cref(Config.song_list_format)
+|  94|    |-			));
+|  95|    |-			break;
+|  96|    |-		case DisplayMode::Columns:
+|  97|    |-			Content.setItemDisplayer(std::bind(
+|  98|    |-				Display::SongsInColumns, ph::_1, std::cref(Content)
+|  99|    |-			));
+| 100|    |-			break;
+| 101|    |-	}
+| 102|    |-	
+| 103|    |-	w = &Playlists;
+| 104|    |-}
+| 105|    |-
+| 106|    |-void PlaylistEditor::resize()
+| 107|    |-{
+| 108|    |-	size_t x_offset, width;
+| 109|    |-	getWindowResizeParams(x_offset, width);
+| 110|    |-	
+| 111|    |-	LeftColumnStartX = x_offset;
+| 112|    |-	LeftColumnWidth = width/3-1;
+| 113|    |-	RightColumnStartX = LeftColumnStartX+LeftColumnWidth+1;
+| 114|    |-	RightColumnWidth = width-LeftColumnWidth-1;
+| 115|    |-	
+| 116|    |-	Playlists.resize(LeftColumnWidth, MainHeight);
+| 117|    |-	Content.resize(RightColumnWidth, MainHeight);
+| 118|    |-	
+| 119|    |-	Playlists.moveTo(LeftColumnStartX, MainStartY);
+| 120|    |-	Content.moveTo(RightColumnStartX, MainStartY);
+| 121|    |-	
+| 122|    |-	hasToBeResized = 0;
+| 123|    |-}
+| 124|    |-
+| 125|    |-std::wstring PlaylistEditor::title()
+| 126|    |-{
+| 127|    |-	return L"Playlist editor";
+| 128|    |-}
+| 129|    |-
+| 130|    |-void PlaylistEditor::refresh()
+| 131|    |-{
+| 132|    |-	Playlists.display();
+| 133|    |-	drawSeparator(RightColumnStartX-1);
+| 134|    |-	Content.display();
+| 135|    |-}
+| 136|    |-
+| 137|    |-void PlaylistEditor::switchTo()
+| 138|    |-{
+| 139|    |-	SwitchTo::execute(this);
+| 140|    |-	drawHeader();
+| 141|    |-	refresh();
+| 142|    |-}
+| 143|    |-
+| 144|    |-void PlaylistEditor::update()
+| 145|    |-{
+| 146|    |-	{
+| 147|    |-		ScopedUnfilteredMenu<MPD::Playlist> sunfilter_playlists(ReapplyFilter::No, Playlists);
+| 148|    |-		if (Playlists.empty() || m_playlists_update_requested)
+| 149|    |-		{
+| 150|    |-			m_playlists_update_requested = false;
+| 151|    |-			sunfilter_playlists.set(ReapplyFilter::Yes, true);
+| 152|    |-			size_t idx = 0;
+| 153|    |-			try
+| 154|    |-			{
+| 155|    |-				for (MPD::PlaylistIterator it = Mpd.GetPlaylists(), end; it != end; ++it, ++idx)
+| 156|    |-				{
+| 157|    |-					if (idx < Playlists.size())
+| 158|    |-						Playlists[idx].value() = std::move(*it);
+| 159|    |-					else
+| 160|    |-						Playlists.addItem(std::move(*it));
+| 161|    |-				};
+| 162|    |-			}
+| 163|    |-			catch (MPD::ServerError &e)
+| 164|    |-			{
+| 165|    |-				if (e.code() == MPD_SERVER_ERROR_SYSTEM) // no playlists directory
+| 166|    |-					Statusbar::print(e.what());
+| 167|    |-				else
+| 168|    |-					throw;
+| 169|    |-			}
+| 170|    |-			if (idx < Playlists.size())
+| 171|    |-				Playlists.resizeList(idx);
+| 172|    |-			std::sort(Playlists.beginV(), Playlists.endV(),
+| 173|    |-			          LocaleBasedSorting(std::locale(), Config.ignore_leading_the));
+| 174|    |-		}
+| 175|    |-	}
+| 176|    |-
+| 177|    |-	{
+| 178|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter_content(ReapplyFilter::No, Content);
+| 179|    |-		if (!Playlists.empty()
+| 180|    |-		    && ((Content.empty() && Global::Timer - m_timer > m_fetching_delay)
+| 181|    |-		        || m_content_update_requested))
+| 182|    |-		{
+| 183|    |-			m_content_update_requested = false;
+| 184|    |-			sunfilter_content.set(ReapplyFilter::Yes, true);
+| 185|    |-			size_t idx = 0;
+| 186|    |-			MPD::SongIterator s = Mpd.GetPlaylistContent(Playlists.current()->value().path()), end;
+| 187|    |-			for (; s != end; ++s, ++idx)
+| 188|    |-			{
+| 189|    |-				if (idx < Content.size())
+| 190|    |-					Content[idx].value() = std::move(*s);
+| 191|    |-				else
+| 192|    |-					Content.addItem(std::move(*s));
+| 193|    |-			}
+| 194|    |-			if (idx < Content.size())
+| 195|    |-				Content.resizeList(idx);
+| 196|    |-			std::string wtitle;
+| 197|    |-			if (Config.titles_visibility)
+| 198|    |-			{
+| 199|    |-				wtitle = (boost::format("Content (%1% %2%)")
+| 200|    |-				          % boost::lexical_cast<std::string>(Content.size())
+| 201|    |-				          % (Content.size() == 1 ? "item" : "items")).str();
+| 202|    |-				wtitle.resize(Content.getWidth());
+| 203|    |-			}
+| 204|    |-			Content.setTitle(wtitle);
+| 205|    |-			Content.refreshBorder();
+| 206|    |-		}
+| 207|    |-	}
+| 208|    |-}
+| 209|    |-
+| 210|    |-int PlaylistEditor::windowTimeout()
+| 211|    |-{
+| 212|    |-	ScopedUnfilteredMenu<MPD::Song> sunfilter_content(ReapplyFilter::No, Content);
+| 213|    |-	if (Content.empty())
+| 214|    |-		return m_window_timeout;
+| 215|    |-	else
+| 216|    |-		return Screen<WindowType>::windowTimeout();
+| 217|    |-}
+| 218|    |-
+| 219|    |-void PlaylistEditor::mouseButtonPressed(MEVENT me)
+| 220|    |-{
+| 221|    |-	if (Playlists.hasCoords(me.x, me.y))
+| 222|    |-	{
+| 223|    |-		if (!isActiveWindow(Playlists))
+| 224|    |-		{
+| 225|    |-			if (previousColumnAvailable())
+| 226|    |-				previousColumn();
+| 227|    |-			else
+| 228|    |-				return;
+| 229|    |-		}
+| 230|    |-		if (size_t(me.y) < Playlists.size() && (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED)))
+| 231|    |-		{
+| 232|    |-			Playlists.Goto(me.y);
+| 233|    |-			if (me.bstate & BUTTON3_PRESSED)
+| 234|    |-				addItemToPlaylist(false);
+| 235|    |-		}
+| 236|    |-		else
+| 237|    |-			Screen<WindowType>::mouseButtonPressed(me);
+| 238|    |-		Content.clear();
+| 239|    |-	}
+| 240|    |-	else if (Content.hasCoords(me.x, me.y))
+| 241|    |-	{
+| 242|    |-		if (!isActiveWindow(Content))
+| 243|    |-		{
+| 244|    |-			if (nextColumnAvailable())
+| 245|    |-				nextColumn();
+| 246|    |-			else
+| 247|    |-				return;
+| 248|    |-		}
+| 249|    |-		if (size_t(me.y) < Content.size() && (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED)))
+| 250|    |-		{
+| 251|    |-			Content.Goto(me.y);
+| 252|    |-			bool play = me.bstate & BUTTON3_PRESSED;
+| 253|    |-			addItemToPlaylist(play);
+| 254|    |-		}
+| 255|    |-		else
+| 256|    |-			Screen<WindowType>::mouseButtonPressed(me);
+| 257|    |-	}
+|    |  44|+using
+|    |  45|+    Global::MainHeight;
+|    |  46|+using
+|    |  47|+    Global::MainStartY;
+|    |  48|+
+|    |  49|+namespace
+|    |  50|+    ph = std::placeholders;
+|    |  51|+
+|    |  52|+PlaylistEditor *
+|    |  53|+    myPlaylistEditor;
+|    |  54|+
+|    |  55|+namespace
+|    |  56|+{
+|    |  57|+
+|    |  58|+    size_t
+|    |  59|+        LeftColumnStartX;
+|    |  60|+    size_t
+|    |  61|+        LeftColumnWidth;
+|    |  62|+    size_t
+|    |  63|+        RightColumnStartX;
+|    |  64|+    size_t
+|    |  65|+        RightColumnWidth;
+|    |  66|+
+|    |  67|+    std::string SongToString (const MPD::Song & s);
+|    |  68|+    bool
+|    |  69|+    PlaylistEntryMatcher (const Regex::Regex & rx,
+|    |  70|+                          const MPD::Playlist & playlist);
+|    |  71|+    bool
+|    |  72|+    SongEntryMatcher (const Regex::Regex & rx, const MPD::Song & s);
+|    |  73|+    boost::optional < size_t > GetSongIndexInPlaylist (MPD::Playlist playlist,
+|    |  74|+                                                       const MPD::Song & song);
+|    |  75|+}
+|    |  76|+
+|    |  77|+PlaylistEditor::PlaylistEditor ():m_timer (boost::posix_time::from_time_t (0)),
+|    |  78|+m_window_timeout (Config.
+|    |  79|+                  data_fetching_delay ? 250 : BaseScreen::
+|    |  80|+                  defaultWindowTimeout),
+|    |  81|+m_fetching_delay (boost::posix_time::
+|    |  82|+                  milliseconds (Config.data_fetching_delay ? 250 : -1))
+|    |  83|+{
+|    |  84|+    LeftColumnWidth = COLS / 3 - 1;
+|    |  85|+    RightColumnStartX = LeftColumnWidth + 1;
+|    |  86|+    RightColumnWidth = COLS - LeftColumnWidth - 1;
+|    |  87|+
+|    |  88|+    Playlists =
+|    |  89|+        NC::Menu < MPD::Playlist > (0, MainStartY, LeftColumnWidth, MainHeight,
+|    |  90|+                                    Config.
+|    |  91|+                                    titles_visibility ? "Playlists" : "",
+|    |  92|+                                    Config.main_color, NC::Border ());
+|    |  93|+    setHighlightFixes (Playlists);
+|    |  94|+    Playlists.cyclicScrolling (Config.use_cyclic_scrolling);
+|    |  95|+    Playlists.centeredCursor (Config.centered_cursor);
+|    |  96|+    Playlists.setSelectedPrefix (Config.selected_item_prefix);
+|    |  97|+    Playlists.setSelectedSuffix (Config.selected_item_suffix);
+|    |  98|+    Playlists.setItemDisplayer ([](NC::Menu < MPD::Playlist > &menu)
+|    |  99|+                                {
+|    | 100|+                                menu << Charset::utf8ToLocale (menu.drawn ()->
+|    | 101|+                                                               value ().
+|    | 102|+                                                               path ());});
+|    | 103|+
+|    | 104|+    Content =
+|    | 105|+        NC::Menu < MPD::Song > (RightColumnStartX, MainStartY,
+|    | 106|+                                RightColumnWidth, MainHeight,
+|    | 107|+                                Config.titles_visibility ? "Content" : "",
+|    | 108|+                                Config.main_color, NC::Border ());
+|    | 109|+    setHighlightInactiveColumnFixes (Content);
+|    | 110|+    Content.cyclicScrolling (Config.use_cyclic_scrolling);
+|    | 111|+    Content.centeredCursor (Config.centered_cursor);
+|    | 112|+    Content.setSelectedPrefix (Config.selected_item_prefix);
+|    | 113|+    Content.setSelectedSuffix (Config.selected_item_suffix);
+|    | 114|+    switch (Config.playlist_editor_display_mode)
+|    | 115|+      {
+|    | 116|+      case DisplayMode::Classic:
+|    | 117|+          Content.
+|    | 118|+              setItemDisplayer (std::
+|    | 119|+                                bind (Display::Songs, ph::_1,
+|    | 120|+                                      std::cref (Content),
+|    | 121|+                                      std::cref (Config.song_list_format)));
+|    | 122|+          break;
+|    | 123|+      case DisplayMode::Columns:
+|    | 124|+          Content.
+|    | 125|+              setItemDisplayer (std::
+|    | 126|+                                bind (Display::SongsInColumns, ph::_1,
+|    | 127|+                                      std::cref (Content)));
+|    | 128|+          break;
+|    | 129|+      }
+|    | 130|+
+|    | 131|+    w = &Playlists;
+|    | 132|+}
+|    | 133|+
+|    | 134|+void
+|    | 135|+PlaylistEditor::resize ()
+|    | 136|+{
+|    | 137|+    size_t x_offset, width;
+|    | 138|+    getWindowResizeParams (x_offset, width);
+|    | 139|+
+|    | 140|+    LeftColumnStartX = x_offset;
+|    | 141|+    LeftColumnWidth = width / 3 - 1;
+|    | 142|+    RightColumnStartX = LeftColumnStartX + LeftColumnWidth + 1;
+|    | 143|+    RightColumnWidth = width - LeftColumnWidth - 1;
+|    | 144|+
+|    | 145|+    Playlists.resize (LeftColumnWidth, MainHeight);
+|    | 146|+    Content.resize (RightColumnWidth, MainHeight);
+|    | 147|+
+|    | 148|+    Playlists.moveTo (LeftColumnStartX, MainStartY);
+|    | 149|+    Content.moveTo (RightColumnStartX, MainStartY);
+|    | 150|+
+|    | 151|+    hasToBeResized = 0;
+|    | 152|+}
+|    | 153|+
+|    | 154|+std::wstring PlaylistEditor::title ()
+|    | 155|+{
+|    | 156|+    return L"Playlist editor";
+|    | 157|+}
+|    | 158|+
+|    | 159|+void
+|    | 160|+PlaylistEditor::refresh ()
+|    | 161|+{
+|    | 162|+    Playlists.display ();
+|    | 163|+    drawSeparator (RightColumnStartX - 1);
+|    | 164|+    Content.display ();
+|    | 165|+}
+|    | 166|+
+|    | 167|+void
+|    | 168|+PlaylistEditor::switchTo ()
+|    | 169|+{
+|    | 170|+    SwitchTo::execute (this);
+|    | 171|+    drawHeader ();
+|    | 172|+    refresh ();
+|    | 173|+}
+|    | 174|+
+|    | 175|+void
+|    | 176|+PlaylistEditor::update ()
+|    | 177|+{
+|    | 178|+    {
+|    | 179|+        ScopedUnfilteredMenu < MPD::Playlist >
+|    | 180|+            sunfilter_playlists (ReapplyFilter::No, Playlists);
+|    | 181|+        if (Playlists.empty () || m_playlists_update_requested)
+|    | 182|+          {
+|    | 183|+              m_playlists_update_requested = false;
+|    | 184|+              sunfilter_playlists.set (ReapplyFilter::Yes, true);
+|    | 185|+              size_t idx = 0;
+|    | 186|+              try
+|    | 187|+              {
+|    | 188|+                  for (MPD::PlaylistIterator it = Mpd.GetPlaylists (), end;
+|    | 189|+                       it != end; ++it, ++idx)
+|    | 190|+                    {
+|    | 191|+                        if (idx < Playlists.size ())
+|    | 192|+                            Playlists[idx].value () = std::move (*it);
+|    | 193|+                        else
+|    | 194|+                            Playlists.addItem (std::move (*it));
+|    | 195|+                    };
+|    | 196|+              }
+|    | 197|+              catch (MPD::ServerError & e)
+|    | 198|+              {
+|    | 199|+                  if (e.code () == MPD_SERVER_ERROR_SYSTEM) // no playlists directory
+|    | 200|+                      Statusbar::print (e.what ());
+|    | 201|+                  else
+|    | 202|+                      throw;
+|    | 203|+              }
+|    | 204|+              if (idx < Playlists.size ())
+|    | 205|+                  Playlists.resizeList (idx);
+|    | 206|+              std::sort (Playlists.beginV (), Playlists.endV (),
+|    | 207|+                         LocaleBasedSorting (std::locale (),
+|    | 208|+                                             Config.ignore_leading_the));
+|    | 209|+          }
+|    | 210|+    }
+|    | 211|+
+|    | 212|+    {
+|    | 213|+        ScopedUnfilteredMenu < MPD::Song >
+|    | 214|+            sunfilter_content (ReapplyFilter::No, Content);
+|    | 215|+        if (!Playlists.empty ()
+|    | 216|+            &&
+|    | 217|+            ((Content.empty () && Global::Timer - m_timer > m_fetching_delay)
+|    | 218|+             || m_content_update_requested))
+|    | 219|+          {
+|    | 220|+              m_content_update_requested = false;
+|    | 221|+              sunfilter_content.set (ReapplyFilter::Yes, true);
+|    | 222|+              size_t idx = 0;
+|    | 223|+              MPD::SongIterator s =
+|    | 224|+                  Mpd.GetPlaylistContent (Playlists.current ()->value ().
+|    | 225|+                                          path ()), end;
+|    | 226|+              for (; s != end; ++s, ++idx)
+|    | 227|+                {
+|    | 228|+                    if (idx < Content.size ())
+|    | 229|+                        Content[idx].value () = std::move (*s);
+|    | 230|+                    else
+|    | 231|+                        Content.addItem (std::move (*s));
+|    | 232|+                }
+|    | 233|+              if (idx < Content.size ())
+|    | 234|+                  Content.resizeList (idx);
+|    | 235|+              std::string wtitle;
+|    | 236|+              if (Config.titles_visibility)
+|    | 237|+                {
+|    | 238|+                    wtitle = (boost::format ("Content (%1% %2%)")
+|    | 239|+                              % boost::lexical_cast < std::string >
+|    | 240|+                              (Content.size ()) % (Content.size () ==
+|    | 241|+                                                   1 ? "item" : "items")).
+|    | 242|+                        str ();
+|    | 243|+                    wtitle.resize (Content.getWidth ());
+|    | 244|+                }
+|    | 245|+              Content.setTitle (wtitle);
+|    | 246|+              Content.refreshBorder ();
+|    | 247|+          }
+|    | 248|+    }
+|    | 249|+}
+|    | 250|+
+|    | 251|+int
+|    | 252|+PlaylistEditor::windowTimeout ()
+|    | 253|+{
+|    | 254|+    ScopedUnfilteredMenu < MPD::Song > sunfilter_content (ReapplyFilter::No,
+|    | 255|+                                                          Content);
+|    | 256|+    if (Content.empty ())
+|    | 257|+        return m_window_timeout;
+|    | 258|+    else
+|    | 259|+        return Screen < WindowType >::windowTimeout ();
+|    | 260|+}
+|    | 261|+
+|    | 262|+void
+|    | 263|+PlaylistEditor::mouseButtonPressed (MEVENT me)
+|    | 264|+{
+|    | 265|+    if (Playlists.hasCoords (me.x, me.y))
+|    | 266|+      {
+|    | 267|+          if (!isActiveWindow (Playlists))
+|    | 268|+            {
+|    | 269|+                if (previousColumnAvailable ())
+|    | 270|+                    previousColumn ();
+|    | 271|+                else
+|    | 272|+                    return;
+|    | 273|+            }
+|    | 274|+          if (size_t (me.y) < Playlists.size ()
+|    | 275|+              && (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED)))
+|    | 276|+            {
+|    | 277|+                Playlists.Goto (me.y);
+|    | 278|+                if (me.bstate & BUTTON3_PRESSED)
+|    | 279|+                    addItemToPlaylist (false);
+|    | 280|+            }
+|    | 281|+          else
+|    | 282|+              Screen < WindowType >::mouseButtonPressed (me);
+|    | 283|+          Content.clear ();
+|    | 284|+      }
+|    | 285|+    else if (Content.hasCoords (me.x, me.y))
+|    | 286|+      {
+|    | 287|+          if (!isActiveWindow (Content))
+|    | 288|+            {
+|    | 289|+                if (nextColumnAvailable ())
+|    | 290|+                    nextColumn ();
+|    | 291|+                else
+|    | 292|+                    return;
+|    | 293|+            }
+|    | 294|+          if (size_t (me.y) < Content.size ()
+|    | 295|+              && (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED)))
+|    | 296|+            {
+|    | 297|+                Content.Goto (me.y);
+|    | 298|+                bool play = me.bstate & BUTTON3_PRESSED;
+|    | 299|+                addItemToPlaylist (play);
+|    | 300|+            }
+|    | 301|+          else
+|    | 302|+              Screen < WindowType >::mouseButtonPressed (me);
+|    | 303|+      }
+| 258| 304| }
+| 259| 305| 
+| 260| 306| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.cpp
+|    |++++| /app/src/screens/playlist_editor.cpp
+| 259| 259| 
+| 260| 260| /***********************************************************************/
+| 261| 261| 
+| 262|    |-bool PlaylistEditor::allowsSearching()
+| 263|    |-{
+| 264|    |-	return true;
+| 265|    |-}
+| 266|    |-
+| 267|    |-const std::string &PlaylistEditor::searchConstraint()
+| 268|    |-{
+| 269|    |-	if (isActiveWindow(Playlists))
+| 270|    |-		return m_playlists_search_predicate.constraint();
+| 271|    |-	else if (isActiveWindow(Content))
+| 272|    |-		return m_content_search_predicate.constraint();
+| 273|    |-	throw std::runtime_error("no active window");
+| 274|    |-}
+| 275|    |-
+| 276|    |-void PlaylistEditor::setSearchConstraint(const std::string &constraint)
+| 277|    |-{
+| 278|    |-	if (isActiveWindow(Playlists))
+| 279|    |-	{
+| 280|    |-		m_playlists_search_predicate = Regex::Filter<MPD::Playlist>(
+| 281|    |-			constraint,
+| 282|    |-			Config.regex_type,
+| 283|    |-			PlaylistEntryMatcher);
+| 284|    |-	}
+| 285|    |-	else if (isActiveWindow(Content))
+| 286|    |-	{
+| 287|    |-		m_content_search_predicate = Regex::Filter<MPD::Song>(
+| 288|    |-			constraint,
+| 289|    |-			Config.regex_type,
+| 290|    |-			SongEntryMatcher);
+| 291|    |-	}
+| 292|    |-}
+| 293|    |-
+| 294|    |-void PlaylistEditor::clearSearchConstraint()
+| 295|    |-{
+| 296|    |-	if (isActiveWindow(Playlists))
+| 297|    |-		m_playlists_search_predicate.clear();
+| 298|    |-	else if (isActiveWindow(Content))
+| 299|    |-		m_content_search_predicate.clear();
+| 300|    |-}
+| 301|    |-
+| 302|    |-bool PlaylistEditor::search(SearchDirection direction, bool wrap, bool skip_current)
+| 303|    |-{
+| 304|    |-	bool result = false;
+| 305|    |-	if (isActiveWindow(Playlists))
+| 306|    |-		result = ::search(Playlists, m_playlists_search_predicate, direction, wrap, skip_current);
+| 307|    |-	else if (isActiveWindow(Content))
+| 308|    |-		result = ::search(Content, m_content_search_predicate, direction, wrap, skip_current);
+| 309|    |-	return result;
+|    | 262|+bool
+|    | 263|+PlaylistEditor::allowsSearching ()
+|    | 264|+{
+|    | 265|+    return true;
+|    | 266|+}
+|    | 267|+
+|    | 268|+const
+|    | 269|+    std::string &
+|    | 270|+PlaylistEditor::searchConstraint ()
+|    | 271|+{
+|    | 272|+    if (isActiveWindow (Playlists))
+|    | 273|+        return m_playlists_search_predicate.constraint ();
+|    | 274|+    else if (isActiveWindow (Content))
+|    | 275|+        return m_content_search_predicate.constraint ();
+|    | 276|+    throw std::runtime_error ("no active window");
+|    | 277|+}
+|    | 278|+
+|    | 279|+void
+|    | 280|+PlaylistEditor::setSearchConstraint (const std::string & constraint)
+|    | 281|+{
+|    | 282|+    if (isActiveWindow (Playlists))
+|    | 283|+      {
+|    | 284|+          m_playlists_search_predicate =
+|    | 285|+              Regex::Filter < MPD::Playlist > (constraint, Config.regex_type,
+|    | 286|+                                               PlaylistEntryMatcher);
+|    | 287|+      }
+|    | 288|+    else if (isActiveWindow (Content))
+|    | 289|+      {
+|    | 290|+          m_content_search_predicate = Regex::Filter < MPD::Song > (constraint,
+|    | 291|+                                                                    Config.
+|    | 292|+                                                                    regex_type,
+|    | 293|+                                                                    SongEntryMatcher);
+|    | 294|+      }
+|    | 295|+}
+|    | 296|+
+|    | 297|+void
+|    | 298|+PlaylistEditor::clearSearchConstraint ()
+|    | 299|+{
+|    | 300|+    if (isActiveWindow (Playlists))
+|    | 301|+        m_playlists_search_predicate.clear ();
+|    | 302|+    else if (isActiveWindow (Content))
+|    | 303|+        m_content_search_predicate.clear ();
+|    | 304|+}
+|    | 305|+
+|    | 306|+bool
+|    | 307|+PlaylistEditor::search (SearchDirection direction, bool wrap,
+|    | 308|+                        bool skip_current)
+|    | 309|+{
+|    | 310|+    bool result = false;
+|    | 311|+    if (isActiveWindow (Playlists))
+|    | 312|+        result =::search (Playlists, m_playlists_search_predicate, direction,
+|    | 313|+                          wrap, skip_current);
+|    | 314|+    else if (isActiveWindow (Content))
+|    | 315|+        result =::search (Content, m_content_search_predicate, direction, wrap,
+|    | 316|+                          skip_current);
+|    | 317|+    return result;
+| 310| 318| }
+| 311| 319| 
+| 312| 320| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.cpp
+|    |++++| /app/src/screens/playlist_editor.cpp
+| 311| 311| 
+| 312| 312| /***********************************************************************/
+| 313| 313| 
+| 314|    |-bool PlaylistEditor::allowsFiltering()
+| 315|    |-{
+| 316|    |-	return allowsSearching();
+| 317|    |-}
+| 318|    |-
+| 319|    |-std::string PlaylistEditor::currentFilter()
+| 320|    |-{
+| 321|    |-	std::string result;
+| 322|    |-	if (isActiveWindow(Playlists))
+| 323|    |-	{
+| 324|    |-		if (auto pred = Playlists.filterPredicate<Regex::Filter<MPD::Playlist>>())
+| 325|    |-			result = pred->constraint();
+| 326|    |-	}
+| 327|    |-	else if (isActiveWindow(Content))
+| 328|    |-	{
+| 329|    |-		if (auto pred = Content.filterPredicate<Regex::Filter<MPD::Song>>())
+| 330|    |-			result = pred->constraint();
+| 331|    |-	}
+| 332|    |-	return result;
+| 333|    |-}
+| 334|    |-
+| 335|    |-void PlaylistEditor::applyFilter(const std::string &constraint)
+| 336|    |-{
+| 337|    |-	if (isActiveWindow(Playlists))
+| 338|    |-	{
+| 339|    |-		if (!constraint.empty())
+| 340|    |-		{
+| 341|    |-			Playlists.applyFilter(Regex::Filter<MPD::Playlist>(
+| 342|    |-				                      constraint,
+| 343|    |-				                      Config.regex_type,
+| 344|    |-				                      PlaylistEntryMatcher));
+| 345|    |-		}
+| 346|    |-		else
+| 347|    |-			Playlists.clearFilter();
+| 348|    |-	}
+| 349|    |-	else if (isActiveWindow(Content))
+| 350|    |-	{
+| 351|    |-		if (!constraint.empty())
+| 352|    |-		{
+| 353|    |-			Content.applyFilter(Regex::Filter<MPD::Song>(
+| 354|    |-				                    constraint,
+| 355|    |-				                    Config.regex_type,
+| 356|    |-				                    SongEntryMatcher));
+| 357|    |-		}
+| 358|    |-		else
+| 359|    |-			Content.clearFilter();
+| 360|    |-	}
+| 361|    |-}
+| 362|    |-
+|    | 314|+bool
+|    | 315|+PlaylistEditor::allowsFiltering ()
+|    | 316|+{
+|    | 317|+    return allowsSearching ();
+|    | 318|+}
+|    | 319|+
+|    | 320|+std::string PlaylistEditor::currentFilter ()
+|    | 321|+{
+|    | 322|+    std::string result;
+|    | 323|+    if (isActiveWindow (Playlists))
+|    | 324|+      {
+|    | 325|+          if (auto pred =
+|    | 326|+              Playlists.filterPredicate < Regex::Filter < MPD::Playlist >> ())
+|    | 327|+              result = pred->constraint ();
+|    | 328|+      }
+|    | 329|+    else if (isActiveWindow (Content))
+|    | 330|+      {
+|    | 331|+          if (auto pred =
+|    | 332|+              Content.filterPredicate < Regex::Filter < MPD::Song >> ())
+|    | 333|+              result = pred->constraint ();
+|    | 334|+      }
+|    | 335|+    return result;
+|    | 336|+}
+|    | 337|+
+|    | 338|+void
+|    | 339|+PlaylistEditor::applyFilter (const std::string & constraint)
+|    | 340|+{
+|    | 341|+    if (isActiveWindow (Playlists))
+|    | 342|+      {
+|    | 343|+          if (!constraint.empty ())
+|    | 344|+            {
+|    | 345|+                Playlists.applyFilter (Regex::Filter < MPD::Playlist >
+|    | 346|+                                       (constraint, Config.regex_type,
+|    | 347|+                                        PlaylistEntryMatcher));
+|    | 348|+            }
+|    | 349|+          else
+|    | 350|+              Playlists.clearFilter ();
+|    | 351|+      }
+|    | 352|+    else if (isActiveWindow (Content))
+|    | 353|+      {
+|    | 354|+          if (!constraint.empty ())
+|    | 355|+            {
+|    | 356|+                Content.applyFilter (Regex::Filter < MPD::Song > (constraint,
+|    | 357|+                                                                  Config.
+|    | 358|+                                                                  regex_type,
+|    | 359|+                                                                  SongEntryMatcher));
+|    | 360|+            }
+|    | 361|+          else
+|    | 362|+              Content.clearFilter ();
+|    | 363|+      }
+|    | 364|+}
+| 363| 365| 
+| 364| 366| /***********************************************************************/
+| 365| 367| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.cpp
+|    |++++| /app/src/screens/playlist_editor.cpp
+| 363| 363| 
+| 364| 364| /***********************************************************************/
+| 365| 365| 
+| 366|    |-bool PlaylistEditor::itemAvailable()
+| 367|    |-{
+| 368|    |-	if (isActiveWindow(Playlists))
+| 369|    |-		return !Playlists.empty();
+| 370|    |-	if (isActiveWindow(Content))
+| 371|    |-		return !Content.empty();
+| 372|    |-	return false;
+| 373|    |-}
+| 374|    |-
+| 375|    |-bool PlaylistEditor::addItemToPlaylist(bool play)
+| 376|    |-{
+| 377|    |-	bool result = false;
+| 378|    |-	if (isActiveWindow(Playlists))
+| 379|    |-	{
+| 380|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter_content(ReapplyFilter::No, Content);
+| 381|    |-		result = addSongsToPlaylist(Content.beginV(), Content.endV(), play, -1);
+| 382|    |-		Statusbar::printf("Playlist \"%1%\" loaded%2%",
+| 383|    |-		                  Playlists.current()->value().path(), withErrors(result));
+| 384|    |-	}
+| 385|    |-	else if (isActiveWindow(Content))
+| 386|    |-		result = addSongToPlaylist(Content.current()->value(), play);
+| 387|    |-	return result;
+| 388|    |-}
+| 389|    |-
+| 390|    |-std::vector<MPD::Song> PlaylistEditor::getSelectedSongs()
+| 391|    |-{
+| 392|    |-	std::vector<MPD::Song> result;
+| 393|    |-	if (isActiveWindow(Playlists))
+| 394|    |-	{
+| 395|    |-		bool any_selected = false;
+| 396|    |-		for (auto &e : Playlists)
+| 397|    |-		{
+| 398|    |-			if (e.isSelected())
+| 399|    |-			{
+| 400|    |-				any_selected = true;
+| 401|    |-				std::copy(
+| 402|    |-					std::make_move_iterator(Mpd.GetPlaylistContent(e.value().path())),
+| 403|    |-					std::make_move_iterator(MPD::SongIterator()),
+| 404|    |-					std::back_inserter(result));
+| 405|    |-			}
+| 406|    |-		}
+| 407|    |-		// if no item is selected, add songs from right column
+| 408|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter_content(ReapplyFilter::No, Content);
+| 409|    |-		if (!any_selected && !Playlists.empty())
+| 410|    |-			std::copy(Content.beginV(), Content.endV(), std::back_inserter(result));
+| 411|    |-	}
+| 412|    |-	else if (isActiveWindow(Content))
+| 413|    |-		result = Content.getSelectedSongs();
+| 414|    |-	return result;
+|    | 366|+bool
+|    | 367|+PlaylistEditor::itemAvailable ()
+|    | 368|+{
+|    | 369|+    if (isActiveWindow (Playlists))
+|    | 370|+        return !Playlists.empty ();
+|    | 371|+    if (isActiveWindow (Content))
+|    | 372|+        return !Content.empty ();
+|    | 373|+    return false;
+|    | 374|+}
+|    | 375|+
+|    | 376|+bool
+|    | 377|+PlaylistEditor::addItemToPlaylist (bool play)
+|    | 378|+{
+|    | 379|+    bool result = false;
+|    | 380|+    if (isActiveWindow (Playlists))
+|    | 381|+      {
+|    | 382|+          ScopedUnfilteredMenu < MPD::Song >
+|    | 383|+              sunfilter_content (ReapplyFilter::No, Content);
+|    | 384|+          result =
+|    | 385|+              addSongsToPlaylist (Content.beginV (), Content.endV (), play,
+|    | 386|+                                  -1);
+|    | 387|+          Statusbar::printf ("Playlist \"%1%\" loaded%2%",
+|    | 388|+                             Playlists.current ()->value ().path (),
+|    | 389|+                             withErrors (result));
+|    | 390|+      }
+|    | 391|+    else if (isActiveWindow (Content))
+|    | 392|+        result = addSongToPlaylist (Content.current ()->value (), play);
+|    | 393|+    return result;
+|    | 394|+}
+|    | 395|+
+|    | 396|+std::vector < MPD::Song > PlaylistEditor::getSelectedSongs ()
+|    | 397|+{
+|    | 398|+    std::vector < MPD::Song > result;
+|    | 399|+    if (isActiveWindow (Playlists))
+|    | 400|+      {
+|    | 401|+          bool
+|    | 402|+              any_selected = false;
+|    | 403|+        for (auto & e:Playlists)
+|    | 404|+            {
+|    | 405|+                if (e.isSelected ())
+|    | 406|+                  {
+|    | 407|+                      any_selected = true;
+|    | 408|+                      std::copy (std::
+|    | 409|+                                 make_move_iterator (Mpd.
+|    | 410|+                                                     GetPlaylistContent (e.
+|    | 411|+                                                                         value
+|    | 412|+                                                                         ().
+|    | 413|+                                                                         path
+|    | 414|+                                                                         ())),
+|    | 415|+                                 std::make_move_iterator (MPD::
+|    | 416|+                                                          SongIterator ()),
+|    | 417|+                                 std::back_inserter (result));
+|    | 418|+                  }
+|    | 419|+            }
+|    | 420|+          // if no item is selected, add songs from right column
+|    | 421|+          ScopedUnfilteredMenu < MPD::Song >
+|    | 422|+              sunfilter_content (ReapplyFilter::No, Content);
+|    | 423|+          if (!any_selected && !Playlists.empty ())
+|    | 424|+              std::copy (Content.beginV (), Content.endV (),
+|    | 425|+                         std::back_inserter (result));
+|    | 426|+      }
+|    | 427|+    else if (isActiveWindow (Content))
+|    | 428|+        result = Content.getSelectedSongs ();
+|    | 429|+    return result;
+| 415| 430| }
+| 416| 431| 
+| 417| 432| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.cpp
+|    |++++| /app/src/screens/playlist_editor.cpp
+| 416| 416| 
+| 417| 417| /***********************************************************************/
+| 418| 418| 
+| 419|    |-bool PlaylistEditor::previousColumnAvailable()
+| 420|    |-{
+| 421|    |-	if (isActiveWindow(Content))
+| 422|    |-	{
+| 423|    |-		ScopedUnfilteredMenu<MPD::Playlist> sunfilter_playlists(ReapplyFilter::No, Playlists);
+| 424|    |-		if (!Playlists.empty())
+| 425|    |-			return true;
+| 426|    |-	}
+| 427|    |-	return false;
+| 428|    |-}
+| 429|    |-
+| 430|    |-void PlaylistEditor::previousColumn()
+| 431|    |-{
+| 432|    |-	if (isActiveWindow(Content))
+| 433|    |-	{
+| 434|    |-		setHighlightInactiveColumnFixes(Content);
+| 435|    |-		w->refresh();
+| 436|    |-		w = &Playlists;
+| 437|    |-		setHighlightFixes(Playlists);
+| 438|    |-	}
+| 439|    |-}
+| 440|    |-
+| 441|    |-bool PlaylistEditor::nextColumnAvailable()
+| 442|    |-{
+| 443|    |-	if (isActiveWindow(Playlists))
+| 444|    |-	{
+| 445|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter_content(ReapplyFilter::No, Content);
+| 446|    |-		if (!Content.empty())
+| 447|    |-			return true;
+| 448|    |-	}
+| 449|    |-	return false;
+| 450|    |-}
+| 451|    |-
+| 452|    |-void PlaylistEditor::nextColumn()
+| 453|    |-{
+| 454|    |-	if (isActiveWindow(Playlists))
+| 455|    |-	{
+| 456|    |-		setHighlightInactiveColumnFixes(Playlists);
+| 457|    |-		w->refresh();
+| 458|    |-		w = &Content;
+| 459|    |-		setHighlightFixes(Content);
+| 460|    |-	}
+|    | 419|+bool
+|    | 420|+PlaylistEditor::previousColumnAvailable ()
+|    | 421|+{
+|    | 422|+    if (isActiveWindow (Content))
+|    | 423|+      {
+|    | 424|+          ScopedUnfilteredMenu < MPD::Playlist >
+|    | 425|+              sunfilter_playlists (ReapplyFilter::No, Playlists);
+|    | 426|+          if (!Playlists.empty ())
+|    | 427|+              return true;
+|    | 428|+      }
+|    | 429|+    return false;
+|    | 430|+}
+|    | 431|+
+|    | 432|+void
+|    | 433|+PlaylistEditor::previousColumn ()
+|    | 434|+{
+|    | 435|+    if (isActiveWindow (Content))
+|    | 436|+      {
+|    | 437|+          setHighlightInactiveColumnFixes (Content);
+|    | 438|+          w->refresh ();
+|    | 439|+          w = &Playlists;
+|    | 440|+          setHighlightFixes (Playlists);
+|    | 441|+      }
+|    | 442|+}
+|    | 443|+
+|    | 444|+bool
+|    | 445|+PlaylistEditor::nextColumnAvailable ()
+|    | 446|+{
+|    | 447|+    if (isActiveWindow (Playlists))
+|    | 448|+      {
+|    | 449|+          ScopedUnfilteredMenu < MPD::Song >
+|    | 450|+              sunfilter_content (ReapplyFilter::No, Content);
+|    | 451|+          if (!Content.empty ())
+|    | 452|+              return true;
+|    | 453|+      }
+|    | 454|+    return false;
+|    | 455|+}
+|    | 456|+
+|    | 457|+void
+|    | 458|+PlaylistEditor::nextColumn ()
+|    | 459|+{
+|    | 460|+    if (isActiveWindow (Playlists))
+|    | 461|+      {
+|    | 462|+          setHighlightInactiveColumnFixes (Playlists);
+|    | 463|+          w->refresh ();
+|    | 464|+          w = &Content;
+|    | 465|+          setHighlightFixes (Content);
+|    | 466|+      }
+| 461| 467| }
+| 462| 468| 
+| 463| 469| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist_editor.cpp
+|    |++++| /app/src/screens/playlist_editor.cpp
+| 462| 462| 
+| 463| 463| /***********************************************************************/
+| 464| 464| 
+| 465|    |-void PlaylistEditor::updateTimer()
+| 466|    |-{
+| 467|    |-	m_timer = Global::Timer;
+| 468|    |-}
+| 469|    |-
+| 470|    |-void PlaylistEditor::locatePlaylist(const MPD::Playlist &playlist)
+| 471|    |-{
+| 472|    |-	update();
+| 473|    |-	Playlists.clearFilter();
+| 474|    |-	auto first = Playlists.beginV(), last = Playlists.endV();
+| 475|    |-	auto it = std::find(first, last, playlist);
+| 476|    |-	if (it != last)
+| 477|    |-	{
+| 478|    |-		Playlists.highlight(it - first);
+| 479|    |-		Content.clear();
+| 480|    |-		Content.clearFilter();
+| 481|    |-		switchTo();
+| 482|    |-	}
+| 483|    |-}
+| 484|    |-
+| 485|    |-void PlaylistEditor::locateSong(const MPD::Song &s)
+| 486|    |-{
+| 487|    |-	if (Playlists.empty())
+| 488|    |-		return;
+| 489|    |-
+| 490|    |-	Content.clearFilter();
+| 491|    |-	Playlists.clearFilter();
+| 492|    |-
+| 493|    |-	auto locate_song_in_current_playlist = [this, &s](auto front, auto back) {
+| 494|    |-		if (!Content.empty())
+| 495|    |-		{
+| 496|    |-			auto it = std::find(front, back, s);
+| 497|    |-			if (it != back)
+| 498|    |-			{
+| 499|    |-				Content.highlight(it - Content.beginV());
+| 500|    |-				nextColumn();
+| 501|    |-				return true;
+| 502|    |-			}
+| 503|    |-		}
+| 504|    |-		return false;
+| 505|    |-	};
+| 506|    |-	auto locate_song_in_playlists = [this, &s](auto front, auto back) {
+| 507|    |-		for (auto it = front; it != back; ++it)
+| 508|    |-		{
+| 509|    |-			if (auto song_index = GetSongIndexInPlaylist(*it, s))
+| 510|    |-			{
+| 511|    |-				Playlists.highlight(it - Playlists.beginV());
+| 512|    |-				Playlists.refresh();
+| 513|    |-
+| 514|    |-				requestContentUpdate();
+| 515|    |-				update();
+| 516|    |-				Content.highlight(*song_index);
+| 517|    |-				nextColumn();
+| 518|    |-
+| 519|    |-				return true;
+| 520|    |-			}
+| 521|    |-		}
+| 522|    |-		return false;
+| 523|    |-	};
+| 524|    |-
+| 525|    |-
+| 526|    |-	if (locate_song_in_current_playlist(Content.currentV() + 1, Content.endV()))
+| 527|    |-		return;
+| 528|    |-	Statusbar::print("Jumping to song...");
+| 529|    |-	if (locate_song_in_playlists(Playlists.currentV() + 1, Playlists.endV()))
+| 530|    |-		return;
+| 531|    |-	if (locate_song_in_playlists(Playlists.beginV(), Playlists.currentV()))
+| 532|    |-		return;
+| 533|    |-	if (locate_song_in_current_playlist(Content.beginV(), Content.currentV()))
+| 534|    |-		return;
+| 535|    |-
+| 536|    |-	// Highlighted song was skipped, so if that's the one we're looking for, we're
+| 537|    |-	// good.
+| 538|    |-	if (Content.empty() || *Content.currentV() != s)
+| 539|    |-		Statusbar::print("Song was not found in playlists");
+| 540|    |-}
+| 541|    |-
+| 542|    |-namespace {
+| 543|    |-
+| 544|    |-std::string SongToString(const MPD::Song &s)
+| 545|    |-{
+| 546|    |-	std::string result;
+| 547|    |-	switch (Config.playlist_display_mode)
+| 548|    |-	{
+| 549|    |-		case DisplayMode::Classic:
+| 550|    |-			result = Format::stringify<char>(Config.song_list_format, &s);
+| 551|    |-			break;
+| 552|    |-		case DisplayMode::Columns:
+| 553|    |-			result = Format::stringify<char>(Config.song_columns_mode_format, &s);
+| 554|    |-			break;
+| 555|    |-	}
+| 556|    |-	return result;
+| 557|    |-}
+| 558|    |-
+| 559|    |-bool PlaylistEntryMatcher(const Regex::Regex &rx, const MPD::Playlist &playlist)
+| 560|    |-{
+| 561|    |-	return Regex::search(playlist.path(), rx, Config.ignore_diacritics);
+| 562|    |-}
+| 563|    |-
+| 564|    |-bool SongEntryMatcher(const Regex::Regex &rx, const MPD::Song &s)
+| 565|    |-{
+| 566|    |-	return Regex::search(SongToString(s), rx, Config.ignore_diacritics);
+| 567|    |-}
+| 568|    |-
+| 569|    |-boost::optional<size_t> GetSongIndexInPlaylist(MPD::Playlist playlist, const MPD::Song &song)
+| 570|    |-{
+| 571|    |-	size_t index = 0;
+| 572|    |-	MPD::SongIterator it = Mpd.GetPlaylistContentNoInfo(playlist.path()), end;
+| 573|    |-
+| 574|    |-	for (;;)
+| 575|    |-	{
+| 576|    |-		if (it == end)
+| 577|    |-			return boost::none;
+| 578|    |-		if (*it == song)
+| 579|    |-			return index;
+| 580|    |-
+| 581|    |-		++it, ++index;
+| 582|    |-	}
+| 583|    |-}
+| 584|    |-
+| 585|    |-}
+|    | 465|+void
+|    | 466|+PlaylistEditor::updateTimer ()
+|    | 467|+{
+|    | 468|+    m_timer = Global::Timer;
+|    | 469|+}
+|    | 470|+
+|    | 471|+void
+|    | 472|+PlaylistEditor::locatePlaylist (const MPD::Playlist & playlist)
+|    | 473|+{
+|    | 474|+    update ();
+|    | 475|+    Playlists.clearFilter ();
+|    | 476|+    auto first = Playlists.beginV (), last = Playlists.endV ();
+|    | 477|+    auto it = std::find (first, last, playlist);
+|    | 478|+    if (it != last)
+|    | 479|+      {
+|    | 480|+          Playlists.highlight (it - first);
+|    | 481|+          Content.clear ();
+|    | 482|+          Content.clearFilter ();
+|    | 483|+          switchTo ();
+|    | 484|+      }
+|    | 485|+}
+|    | 486|+
+|    | 487|+void
+|    | 488|+PlaylistEditor::locateSong (const MPD::Song & s)
+|    | 489|+{
+|    | 490|+    if (Playlists.empty ())
+|    | 491|+        return;
+|    | 492|+
+|    | 493|+    Content.clearFilter ();
+|    | 494|+    Playlists.clearFilter ();
+|    | 495|+
+|    | 496|+    auto locate_song_in_current_playlist =[this, &s] (auto front, auto back) {
+|    | 497|+        if (!Content.empty ())
+|    | 498|+          {
+|    | 499|+           auto it = std::find (front, back, s); if (it != back)
+|    | 500|+           {
+|    | 501|+           Content.highlight (it - Content.beginV ());
+|    | 502|+           nextColumn (); return true;}
+|    | 503|+           }
+|    | 504|+           return false;};
+|    | 505|+           auto locate_song_in_playlists =[this, &s] (auto front, auto back)
+|    | 506|+           {
+|    | 507|+           for (auto it = front; it != back; ++it)
+|    | 508|+           {
+|    | 509|+           if (auto song_index = GetSongIndexInPlaylist (*it, s))
+|    | 510|+           {
+|    | 511|+           Playlists.highlight (it - Playlists.beginV ());
+|    | 512|+           Playlists.refresh ();
+|    | 513|+           requestContentUpdate ();
+|    | 514|+           update ();
+|    | 515|+           Content.highlight (*song_index); nextColumn (); return true;}
+|    | 516|+           }
+|    | 517|+           return false;};
+|    | 518|+           if (locate_song_in_current_playlist
+|    | 519|+               (Content.currentV () + 1, Content.endV ()))return;
+|    | 520|+           Statusbar::print ("Jumping to song...");
+|    | 521|+           if (locate_song_in_playlists
+|    | 522|+               (Playlists.currentV () + 1, Playlists.endV ()))return;
+|    | 523|+           if (locate_song_in_playlists
+|    | 524|+               (Playlists.beginV (), Playlists.currentV ()))return;
+|    | 525|+           if (locate_song_in_current_playlist
+|    | 526|+               (Content.beginV (), Content.currentV ()))return;
+|    | 527|+           // Highlighted song was skipped, so if that's the one we're looking for, we're
+|    | 528|+           // good.
+|    | 529|+           if (Content.empty () || *Content.currentV () != s)
+|    | 530|+           Statusbar::print ("Song was not found in playlists");}
+|    | 531|+
+|    | 532|+           namespace
+|    | 533|+           {
+|    | 534|+
+|    | 535|+           std::string SongToString (const MPD::Song & s)
+|    | 536|+           {
+|    | 537|+           std::string result; switch (Config.playlist_display_mode)
+|    | 538|+           {
+|    | 539|+case DisplayMode::Classic:
+|    | 540|+result = Format::stringify < char >(Config.song_list_format, &s); break; case DisplayMode::Columns:
+|    | 541|+           result =
+|    | 542|+           Format::stringify < char >(Config.song_columns_mode_format, &s);
+|    | 543|+           break;}
+|    | 544|+           return result;}
+|    | 545|+
+|    | 546|+           bool PlaylistEntryMatcher (const Regex::Regex & rx,
+|    | 547|+                                      const MPD::Playlist & playlist)
+|    | 548|+           {
+|    | 549|+           return Regex::search (playlist.path (), rx,
+|    | 550|+                                 Config.ignore_diacritics);}
+|    | 551|+
+|    | 552|+           bool SongEntryMatcher (const Regex::Regex & rx, const MPD::Song & s)
+|    | 553|+           {
+|    | 554|+           return Regex::search (SongToString (s), rx,
+|    | 555|+                                 Config.ignore_diacritics);}
+|    | 556|+
+|    | 557|+           boost::optional < size_t >
+|    | 558|+           GetSongIndexInPlaylist (MPD::Playlist playlist,
+|    | 559|+                                   const MPD::Song & song)
+|    | 560|+           {
+|    | 561|+           size_t index = 0;
+|    | 562|+           MPD::SongIterator it =
+|    | 563|+           Mpd.GetPlaylistContentNoInfo (playlist.path ()), end; for (;;)
+|    | 564|+           {
+|    | 565|+           if (it == end)
+|    | 566|+           return boost::none; if (*it == song) return index; ++it, ++index;}
+|    | 567|+           }
+|    | 568|+
+|    | 569|+           }
+
+src/screens/playlist_editor.cpp
+|  26| #include•"curses/menu_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/menu_impl.h'
+
+src/screens/playlist_editor.cpp
+|  27| #include•"charset.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'charset.h'
+
+src/screens/playlist_editor.cpp
+|  28| #include•"display.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'display.h'
+
+src/screens/playlist_editor.cpp
+|  29| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/playlist_editor.cpp
+|  30| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/playlist_editor.cpp
+|  31| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist.h'
+
+src/screens/playlist_editor.cpp
+|  32| #include•"screens/playlist_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist_editor.h'
+
+src/screens/playlist_editor.cpp
+|  33| #include•"mpdpp.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'mpdpp.h'
+
+src/screens/playlist_editor.cpp
+|  34| #include•"status.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'status.h'
+
+src/screens/playlist_editor.cpp
+|  35| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'statusbar.h'
+
+src/screens/playlist_editor.cpp
+|  36| #include•"screens/tag_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/tag_editor.h'
+
+src/screens/playlist_editor.cpp
+|  37| #include•"format_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'format_impl.h'
+
+src/screens/playlist_editor.cpp
+|  38| #include•"helpers/song_iterator_maker.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers/song_iterator_maker.h'
+
+src/screens/playlist_editor.cpp
+|  39| #include•"utility/functional.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/functional.h'
+
+src/screens/playlist_editor.cpp
+|  40| #include•"utility/comparators.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/comparators.h'
+
+src/screens/playlist_editor.cpp
+|  41| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/playlist_editor.cpp
+|  42| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/playlist_editor.cpp
+|  49| PlaylistEditor•*myPlaylistEditor;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myPlaylistEditor'
+
+src/screens/playlist_editor.cpp
+|  53| size_t•LeftColumnStartX;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'LeftColumnStartX'
+
+src/screens/playlist_editor.cpp
+|  54| size_t•LeftColumnWidth;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'LeftColumnWidth'
+
+src/screens/playlist_editor.cpp
+|  55| size_t•RightColumnStartX;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'RightColumnStartX'
+
+src/screens/playlist_editor.cpp
+|  56| size_t•RightColumnWidth;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'RightColumnWidth'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+|  30|  30| #include "title.h"
+|  31|  31| #include "screens/screen_switcher.h"
+|  32|  32| 
+|  33|    |-using Global::MainHeight;
+|  34|    |-using Global::MainStartY;
+|  35|    |-
+|  36|    |-Help *myHelp;
+|  37|    |-
+|  38|    |-namespace {
+|  39|    |-
+|  40|    |-std::string align_key_rep(std::wstring keys)
+|  41|    |-{
+|  42|    |-	size_t i = 0, len = 0;
+|  43|    |-	const size_t max_len = 20;
+|  44|    |-	for (; i < keys.size(); ++i)
+|  45|    |-	{
+|  46|    |-		int width = std::max(1, wcwidth(keys[i]));
+|  47|    |-		if (len+width > max_len)
+|  48|    |-			break;
+|  49|    |-		else
+|  50|    |-			len += width;
+|  51|    |-	}
+|  52|    |-	keys.resize(i + max_len - len, ' ');
+|  53|    |-	return ToString(keys);
+|  54|    |-}
+|  55|    |-
+|  56|    |-std::string display_keys(const Actions::Type at)
+|  57|    |-{
+|  58|    |-	std::wstring result, skey;
+|  59|    |-	for (auto it = Bindings.begin(); it != Bindings.end(); ++it)
+|  60|    |-	{
+|  61|    |-		for (auto j = it->second.begin(); j != it->second.end(); ++j)
+|  62|    |-		{
+|  63|    |-			if (j->isSingle() && j->action().type() == at)
+|  64|    |-			{
+|  65|    |-				skey = keyToWString(it->first);
+|  66|    |-				if (!skey.empty())
+|  67|    |-				{
+|  68|    |-					result += std::move(skey);
+|  69|    |-					result += ' ';
+|  70|    |-				}
+|  71|    |-			}
+|  72|    |-		}
+|  73|    |-	}
+|  74|    |-	return align_key_rep(std::move(result));
+|  75|    |-}
+|  76|    |-
+|  77|    |-void section(NC::Scrollpad &w, const char *type_, const char *title_)
+|  78|    |-{
+|  79|    |-	w << "\n  " << NC::Format::Bold;
+|  80|    |-	if (type_[0] != '\0')
+|  81|    |-		w << type_ << " - ";
+|  82|    |-	w << title_ << NC::Format::NoBold << "\n\n";
+|  83|    |-}
+|    |  33|+using
+|    |  34|+    Global::MainHeight;
+|    |  35|+using
+|    |  36|+    Global::MainStartY;
+|    |  37|+
+|    |  38|+Help *
+|    |  39|+    myHelp;
+|    |  40|+
+|    |  41|+namespace
+|    |  42|+{
+|    |  43|+
+|    |  44|+    std::string align_key_rep (std::wstring keys)
+|    |  45|+    {
+|    |  46|+        size_t
+|    |  47|+            i = 0, len = 0;
+|    |  48|+        const size_t
+|    |  49|+            max_len = 20;
+|    |  50|+        for (; i < keys.size (); ++i)
+|    |  51|+          {
+|    |  52|+              int
+|    |  53|+                  width = std::max (1, wcwidth (keys[i]));
+|    |  54|+              if (len + width > max_len)
+|    |  55|+                  break;
+|    |  56|+              else
+|    |  57|+                  len += width;
+|    |  58|+          }
+|    |  59|+        keys.resize (i + max_len - len, ' ');
+|    |  60|+        return ToString (keys);
+|    |  61|+    }
+|    |  62|+
+|    |  63|+    std::string display_keys (const Actions::Type at)
+|    |  64|+    {
+|    |  65|+        std::wstring result, skey;
+|    |  66|+        for (auto it = Bindings.begin (); it != Bindings.end (); ++it)
+|    |  67|+          {
+|    |  68|+              for (auto j = it->second.begin (); j != it->second.end (); ++j)
+|    |  69|+                {
+|    |  70|+                    if (j->isSingle () && j->action ().type () == at)
+|    |  71|+                      {
+|    |  72|+                          skey = keyToWString (it->first);
+|    |  73|+                          if (!skey.empty ())
+|    |  74|+                            {
+|    |  75|+                                result += std::move (skey);
+|    |  76|+                                result += ' ';
+|    |  77|+                            }
+|    |  78|+                      }
+|    |  79|+                }
+|    |  80|+          }
+|    |  81|+        return align_key_rep (std::move (result));
+|    |  82|+    }
+|    |  83|+
+|    |  84|+    void
+|    |  85|+    section (NC::Scrollpad & w, const char *type_, const char *title_)
+|    |  86|+    {
+|    |  87|+        w << "\n  " << NC::Format::Bold;
+|    |  88|+        if (type_[0] != '\0')
+|    |  89|+            w << type_ << " - ";
+|    |  90|+        w << title_ << NC::Format::NoBold << "\n\n";
+|    |  91|+    }
+|  84|  92| 
+|  85|  93| /**********************************************************************/
+|  86|  94| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+|  84|  84| 
+|  85|  85| /**********************************************************************/
+|  86|  86| 
+|  87|    |-void key_section(NC::Scrollpad &w, const char *title_)
+|  88|    |-{
+|  89|    |-	section(w, "Keys", title_);
+|  90|    |-}
+|  91|    |-
+|  92|    |-void key(NC::Scrollpad &w, const Actions::Type at, const char *desc)
+|  93|    |-{
+|  94|    |-	w << "    " << display_keys(at) << " : " << desc << '\n';
+|  95|    |-}
+|  96|    |-
+|  97|    |-void key(NC::Scrollpad &w, const Actions::Type at, const boost::format &desc)
+|  98|    |-{
+|  99|    |-	w << "    " << display_keys(at) << " : " << desc.str() << '\n';
+| 100|    |-}
+| 101|    |-
+| 102|    |-void key(NC::Scrollpad &w, NC::Key::Type k, const std::string &desc)
+| 103|    |-{
+| 104|    |-	w << "    " << align_key_rep(keyToWString(k)) << " : " << desc << '\n';
+| 105|    |-}
+|    |  87|+    void
+|    |  88|+    key_section (NC::Scrollpad & w, const char *title_)
+|    |  89|+    {
+|    |  90|+        section (w, "Keys", title_);
+|    |  91|+    }
+|    |  92|+
+|    |  93|+    void
+|    |  94|+    key (NC::Scrollpad & w, const Actions::Type at, const char *desc)
+|    |  95|+    {
+|    |  96|+        w << "    " << display_keys (at) << " : " << desc << '\n';
+|    |  97|+    }
+|    |  98|+
+|    |  99|+    void
+|    | 100|+    key (NC::Scrollpad & w, const Actions::Type at, const boost::format & desc)
+|    | 101|+    {
+|    | 102|+        w << "    " << display_keys (at) << " : " << desc.str () << '\n';
+|    | 103|+    }
+|    | 104|+
+|    | 105|+    void
+|    | 106|+    key (NC::Scrollpad & w, NC::Key::Type k, const std::string & desc)
+|    | 107|+    {
+|    | 108|+        w << "    " << align_key_rep (keyToWString (k)) << " : " << desc <<
+|    | 109|+            '\n';
+|    | 110|+    }
+| 106| 111| 
+| 107| 112| /**********************************************************************/
+| 108| 113| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 106| 106| 
+| 107| 107| /**********************************************************************/
+| 108| 108| 
+| 109|    |-void mouse_section(NC::Scrollpad &w, const char *title_)
+| 110|    |-{
+| 111|    |-	section(w, "Mouse", title_);
+| 112|    |-}
+| 113|    |-
+| 114|    |-void mouse(NC::Scrollpad &w, std::string action, const char *desc, bool indent = false)
+| 115|    |-{
+| 116|    |-	action.resize(31 - (indent ? 2 : 0), ' ');
+| 117|    |-	w << "    " << (indent ? "  " : "") << action;
+| 118|    |-	w << ": " << desc << '\n';
+| 119|    |-}
+| 120|    |-
+| 121|    |-void mouse_column(NC::Scrollpad &w, const char *column)
+| 122|    |-{
+| 123|    |-	w << NC::Format::Bold << "    " << column << " column:\n" << NC::Format::NoBold;
+| 124|    |-}
+|    | 109|+    void
+|    | 110|+    mouse_section (NC::Scrollpad & w, const char *title_)
+|    | 111|+    {
+|    | 112|+        section (w, "Mouse", title_);
+|    | 113|+    }
+|    | 114|+
+|    | 115|+    void
+|    | 116|+    mouse (NC::Scrollpad & w, std::string action, const char *desc,
+|    | 117|+           bool indent = false)
+|    | 118|+    {
+|    | 119|+        action.resize (31 - (indent ? 2 : 0), ' ');
+|    | 120|+        w << "    " << (indent ? "  " : "") << action;
+|    | 121|+        w << ": " << desc << '\n';
+|    | 122|+    }
+|    | 123|+
+|    | 124|+    void
+|    | 125|+    mouse_column (NC::Scrollpad & w, const char *column)
+|    | 126|+    {
+|    | 127|+        w << NC::Format::Bold << "    " << column << " column:\n" << NC::
+|    | 128|+            Format::NoBold;
+|    | 129|+    }
+| 125| 130| 
+| 126| 131| /**********************************************************************/
+| 127| 132| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 125| 125| 
+| 126| 126| /**********************************************************************/
+| 127| 127| 
+| 128|    |-void write_bindings(NC::Scrollpad &w)
+| 129|    |-{
+| 130|    |-	using Actions::Type;
+| 131|    |-
+| 132|    |-	key_section(w, "Movement");
+| 133|    |-	key(w, Type::ScrollUp, "Move cursor up");
+| 134|    |-	key(w, Type::ScrollDown, "Move cursor down");
+| 135|    |-	key(w, Type::ScrollUpAlbum, "Move cursor up one album");
+| 136|    |-	key(w, Type::ScrollDownAlbum, "Move cursor down one album");
+| 137|    |-	key(w, Type::ScrollUpArtist, "Move cursor up one artist");
+| 138|    |-	key(w, Type::ScrollDownArtist, "Move cursor down one artist");
+| 139|    |-	key(w, Type::PageUp, "Page up");
+| 140|    |-	key(w, Type::PageDown, "Page down");
+| 141|    |-	key(w, Type::MoveHome, "Home");
+| 142|    |-	key(w, Type::MoveEnd, "End");
+| 143|    |-	w << '\n';
+| 144|    |-	if (Config.screen_switcher_previous)
+| 145|    |-	{
+| 146|    |-		key(w, Type::NextScreen, "Switch between current and last screen");
+| 147|    |-		key(w, Type::PreviousScreen, "Switch between current and last screen");
+| 148|    |-	}
+| 149|    |-	else
+| 150|    |-	{
+| 151|    |-		key(w, Type::NextScreen, "Switch to next screen in sequence");
+| 152|    |-		key(w, Type::PreviousScreen, "Switch to previous screen in sequence");
+| 153|    |-	}
+| 154|    |-	key(w, Type::ShowHelp, "Show help");
+| 155|    |-	key(w, Type::ShowPlaylist, "Show playlist");
+| 156|    |-	key(w, Type::ShowBrowser, "Show browser");
+| 157|    |-	key(w, Type::ShowSearchEngine, "Show search engine");
+| 158|    |-	key(w, Type::ShowMediaLibrary, "Show media library");
+| 159|    |-	key(w, Type::ShowPlaylistEditor, "Show playlist editor");
+| 160|    |-#	ifdef HAVE_TAGLIB_H
+| 161|    |-	key(w, Type::ShowTagEditor, "Show tag editor");
+|    | 128|+    void
+|    | 129|+    write_bindings (NC::Scrollpad & w)
+|    | 130|+    {
+|    | 131|+        using
+|    | 132|+            Actions::Type;
+|    | 133|+
+|    | 134|+        key_section (w, "Movement");
+|    | 135|+        key (w, Type::ScrollUp, "Move cursor up");
+|    | 136|+        key (w, Type::ScrollDown, "Move cursor down");
+|    | 137|+        key (w, Type::ScrollUpAlbum, "Move cursor up one album");
+|    | 138|+        key (w, Type::ScrollDownAlbum, "Move cursor down one album");
+|    | 139|+        key (w, Type::ScrollUpArtist, "Move cursor up one artist");
+|    | 140|+        key (w, Type::ScrollDownArtist, "Move cursor down one artist");
+|    | 141|+        key (w, Type::PageUp, "Page up");
+|    | 142|+        key (w, Type::PageDown, "Page down");
+|    | 143|+        key (w, Type::MoveHome, "Home");
+|    | 144|+        key (w, Type::MoveEnd, "End");
+|    | 145|+        w << '\n';
+|    | 146|+        if (Config.screen_switcher_previous)
+|    | 147|+          {
+|    | 148|+              key (w, Type::NextScreen,
+|    | 149|+                   "Switch between current and last screen");
+|    | 150|+              key (w, Type::PreviousScreen,
+|    | 151|+                   "Switch between current and last screen");
+|    | 152|+          }
+|    | 153|+        else
+|    | 154|+          {
+|    | 155|+              key (w, Type::NextScreen, "Switch to next screen in sequence");
+|    | 156|+              key (w, Type::PreviousScreen,
+|    | 157|+                   "Switch to previous screen in sequence");
+|    | 158|+          }
+|    | 159|+        key (w, Type::ShowHelp, "Show help");
+|    | 160|+        key (w, Type::ShowPlaylist, "Show playlist");
+|    | 161|+        key (w, Type::ShowBrowser, "Show browser");
+|    | 162|+        key (w, Type::ShowSearchEngine, "Show search engine");
+|    | 163|+        key (w, Type::ShowMediaLibrary, "Show media library");
+|    | 164|+        key (w, Type::ShowPlaylistEditor, "Show playlist editor");
+|    | 165|+#	ifdef HAVE_TAGLIB_H
+|    | 166|+        key (w, Type::ShowTagEditor, "Show tag editor");
+| 162| 167| #	endif // HAVE_TAGLIB_H
+| 163| 168| #	ifdef ENABLE_OUTPUTS
+| 164| 169| 	key(w, Type::ShowOutputs, "Show outputs");
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 161| 161| 	key(w, Type::ShowTagEditor, "Show tag editor");
+| 162| 162| #	endif // HAVE_TAGLIB_H
+| 163| 163| #	ifdef ENABLE_OUTPUTS
+| 164|    |-	key(w, Type::ShowOutputs, "Show outputs");
+|    | 164|+        key (w, Type::ShowOutputs, "Show outputs");
+| 165| 165| #	endif // ENABLE_OUTPUTS
+| 166| 166| #	ifdef ENABLE_VISUALIZER
+| 167| 167| 	key(w, Type::ShowVisualizer, "Show music visualizer");
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 164| 164| 	key(w, Type::ShowOutputs, "Show outputs");
+| 165| 165| #	endif // ENABLE_OUTPUTS
+| 166| 166| #	ifdef ENABLE_VISUALIZER
+| 167|    |-	key(w, Type::ShowVisualizer, "Show music visualizer");
+|    | 167|+        key (w, Type::ShowVisualizer, "Show music visualizer");
+| 168| 168| #	endif // ENABLE_VISUALIZER
+| 169| 169| #	ifdef ENABLE_CLOCK
+| 170| 170| 	key(w, Type::ShowClock, "Show clock");
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 167| 167| 	key(w, Type::ShowVisualizer, "Show music visualizer");
+| 168| 168| #	endif // ENABLE_VISUALIZER
+| 169| 169| #	ifdef ENABLE_CLOCK
+| 170|    |-	key(w, Type::ShowClock, "Show clock");
+|    | 170|+        key (w, Type::ShowClock, "Show clock");
+| 171| 171| #	endif // ENABLE_CLOCK
+| 172|    |-	w << '\n';
+| 173|    |-	key(w, Type::ShowServerInfo, "Show server info");
+| 174|    |-
+| 175|    |-	key_section(w, "Global");
+| 176|    |-	key(w, Type::Stop, "Stop");
+| 177|    |-	key(w, Type::Pause, "Pause");
+| 178|    |-	key(w, Type::Next, "Next track");
+| 179|    |-	key(w, Type::Previous, "Previous track");
+| 180|    |-	key(w, Type::ReplaySong, "Replay playing song");
+| 181|    |-	key(w, Type::SeekForward, "Seek forward in playing song");
+| 182|    |-	key(w, Type::SeekBackward, "Seek backward in playing song");
+| 183|    |-	key(w, Type::VolumeDown,
+| 184|    |-		boost::format("Decrease volume by %1%%%") % Config.volume_change_step
+| 185|    |-	);
+| 186|    |-	key(w, Type::VolumeUp,
+| 187|    |-		boost::format("Increase volume by %1%%%") % Config.volume_change_step
+| 188|    |-	);
+| 189|    |-	w << '\n';
+| 190|    |-	key(w, Type::ToggleAddMode, "Toggle add mode (add or remove/always add)");
+| 191|    |-	key(w, Type::ToggleMouse, "Toggle mouse support");
+| 192|    |-	key(w, Type::SelectRange, "Select range");
+| 193|    |-	key(w, Type::ReverseSelection, "Reverse selection");
+| 194|    |-	key(w, Type::RemoveSelection, "Remove selection");
+| 195|    |-	key(w, Type::SelectItem, "Select current item");
+| 196|    |-	key(w, Type::SelectFoundItems, "Select found items");
+| 197|    |-	key(w, Type::SelectAlbum, "Select songs of album around the cursor");
+| 198|    |-	key(w, Type::AddSelectedItems, "Add selected items to playlist");
+| 199|    |-	key(w, Type::AddRandomItems, "Add random items to playlist");
+| 200|    |-	w << '\n';
+| 201|    |-	key(w, Type::ToggleRepeat, "Toggle repeat mode");
+| 202|    |-	key(w, Type::ToggleRandom, "Toggle random mode");
+| 203|    |-	key(w, Type::ToggleSingle, "Toggle single mode");
+| 204|    |-	key(w, Type::ToggleConsume, "Toggle consume mode");
+| 205|    |-	key(w, Type::ToggleReplayGainMode, "Toggle replay gain mode");
+| 206|    |-	key(w, Type::ToggleBitrateVisibility, "Toggle bitrate visibility");
+| 207|    |-	key(w, Type::ToggleCrossfade, "Toggle crossfade mode");
+| 208|    |-	key(w, Type::SetCrossfade, "Set crossfade");
+| 209|    |-	key(w, Type::SetVolume, "Set volume");
+| 210|    |-	key(w, Type::UpdateDatabase, "Start music database update");
+| 211|    |-	w << '\n';
+| 212|    |-	key(w, Type::ExecuteCommand, "Execute command");
+| 213|    |-	key(w, Type::ApplyFilter, "Apply filter");
+| 214|    |-	key(w, Type::FindItemForward, "Find item forward");
+| 215|    |-	key(w, Type::FindItemBackward, "Find item backward");
+| 216|    |-	key(w, Type::PreviousFoundItem, "Jump to previous found item");
+| 217|    |-	key(w, Type::NextFoundItem, "Jump to next found item");
+| 218|    |-	key(w, Type::ToggleFindMode, "Toggle find mode (normal/wrapped)");
+| 219|    |-	key(w, Type::JumpToBrowser, "Locate song in browser");
+| 220|    |-	key(w, Type::JumpToMediaLibrary, "Locate song in media library");
+| 221|    |-	key(w, Type::ToggleScreenLock, "Lock/unlock current screen");
+| 222|    |-	key(w, Type::MasterScreen, "Switch to master screen (left one)");
+| 223|    |-	key(w, Type::SlaveScreen, "Switch to slave screen (right one)");
+| 224|    |-#	ifdef HAVE_TAGLIB_H
+| 225|    |-	key(w, Type::JumpToTagEditor, "Locate song in tag editor");
+| 226|    |-#	endif // HAVE_TAGLIB_H
+| 227|    |-	key(w, Type::ToggleDisplayMode, "Toggle display mode");
+| 228|    |-	key(w, Type::ToggleInterface, "Toggle user interface");
+| 229|    |-	key(w, Type::ToggleSeparatorsBetweenAlbums, "Toggle displaying separators between albums");
+| 230|    |-	key(w, Type::JumpToPositionInSong, "Jump to given position in playing song (formats: mm:ss, x%)");
+| 231|    |-	key(w, Type::ShowSongInfo, "Show song info");
+| 232|    |-	key(w, Type::ShowArtistInfo, "Show artist info");
+| 233|    |-	key(w, Type::FetchLyricsInBackground, "Fetch lyrics for selected songs");
+| 234|    |-	key(w, Type::ToggleLyricsFetcher, "Toggle lyrics fetcher");
+| 235|    |-	key(w, Type::ToggleFetchingLyricsInBackground, "Toggle fetching lyrics for playing songs in background");
+| 236|    |-	key(w, Type::ShowLyrics, "Show/hide song lyrics");
+| 237|    |-	w << '\n';
+| 238|    |-	key(w, Type::Quit, "Quit");
+| 239|    |-
+| 240|    |-	key_section(w, "Playlist");
+| 241|    |-	key(w, Type::PlayItem, "Play selected item");
+| 242|    |-	key(w, Type::DeletePlaylistItems, "Delete selected item(s) from playlist");
+| 243|    |-	key(w, Type::ClearMainPlaylist, "Clear playlist");
+| 244|    |-	key(w, Type::CropMainPlaylist, "Clear playlist except selected item(s)");
+| 245|    |-	key(w, Type::SetSelectedItemsPriority, "Set priority of selected items");
+| 246|    |-	key(w, Type::MoveSelectedItemsUp, "Move selected item(s) up");
+| 247|    |-	key(w, Type::MoveSelectedItemsDown, "Move selected item(s) down");
+| 248|    |-	key(w, Type::MoveSelectedItemsTo, "Move selected item(s) to cursor position");
+| 249|    |-	key(w, Type::Add, "Add item to playlist");
+| 250|    |-#	ifdef HAVE_TAGLIB_H
+| 251|    |-	key(w, Type::EditSong, "Edit song");
+| 252|    |-#	endif // HAVE_TAGLIB_H
+| 253|    |-	key(w, Type::SavePlaylist, "Save playlist");
+| 254|    |-	key(w, Type::Shuffle, "Shuffle range");
+| 255|    |-	key(w, Type::SortPlaylist, "Sort range");
+| 256|    |-	key(w, Type::ReversePlaylist, "Reverse range");
+| 257|    |-	key(w, Type::JumpToPlayingSong, "Jump to current song");
+| 258|    |-	key(w, Type::TogglePlayingSongCentering, "Toggle playing song centering");
+| 259|    |-
+| 260|    |-	key_section(w, "Browser");
+| 261|    |-	key(w, Type::EnterDirectory, "Enter directory");
+| 262|    |-	key(w, Type::PlayItem, "Add item to playlist and play it");
+| 263|    |-	key(w, Type::AddItemToPlaylist, "Add item to playlist");
+| 264|    |-#	ifdef HAVE_TAGLIB_H
+| 265|    |-	key(w, Type::EditSong, "Edit song");
+| 266|    |-#	endif // HAVE_TAGLIB_H
+| 267|    |-	key(w, Type::EditDirectoryName, "Edit directory name");
+| 268|    |-	key(w, Type::EditPlaylistName, "Edit playlist name");
+| 269|    |-	key(w, Type::ChangeBrowseMode, "Browse MPD database/local filesystem");
+| 270|    |-	key(w, Type::ToggleBrowserSortMode, "Toggle sort mode");
+| 271|    |-	key(w, Type::JumpToPlayingSong, "Locate current song");
+| 272|    |-	key(w, Type::JumpToParentDirectory, "Jump to parent directory");
+| 273|    |-	key(w, Type::DeleteBrowserItems, "Delete selected items from disk");
+| 274|    |-	key(w, Type::JumpToPlaylistEditor, "Jump to playlist editor (playlists only)");
+| 275|    |-
+| 276|    |-	key_section(w, "Search engine");
+| 277|    |-	key(w, Type::RunAction, "Modify option / Run action");
+| 278|    |-	key(w, Type::AddItemToPlaylist, "Add item to playlist");
+| 279|    |-	key(w, Type::PlayItem, "Add item to playlist and play it");
+| 280|    |-#	ifdef HAVE_TAGLIB_H
+| 281|    |-	key(w, Type::EditSong, "Edit song");
+| 282|    |-#	endif // HAVE_TAGLIB_H
+| 283|    |-	key(w, Type::StartSearching, "Start searching");
+| 284|    |-	key(w, Type::ResetSearchEngine, "Reset search constraints and clear results");
+| 285|    |-
+| 286|    |-	key_section(w, "Media library");
+| 287|    |-	key(w, Type::ToggleMediaLibraryColumnsMode, "Switch between two/three columns mode");
+| 288|    |-	key(w, Type::PreviousColumn, "Previous column");
+| 289|    |-	key(w, Type::NextColumn, "Next column");
+| 290|    |-	key(w, Type::PlayItem, "Add item to playlist and play it");
+| 291|    |-	key(w, Type::AddItemToPlaylist, "Add item to playlist");
+| 292|    |-	key(w, Type::JumpToPlayingSong, "Locate current song");
+| 293|    |-#	ifdef HAVE_TAGLIB_H
+| 294|    |-	key(w, Type::EditSong, "Edit song");
+| 295|    |-#	endif // HAVE_TAGLIB_H
+| 296|    |-	key(w, Type::EditLibraryTag, "Edit tag (left column)/album (middle/right column)");
+| 297|    |-	key(w, Type::ToggleLibraryTagType, "Toggle type of tag used in left column");
+| 298|    |-	key(w, Type::ToggleMediaLibrarySortMode, "Toggle sort mode");
+| 299|    |-
+| 300|    |-	key_section(w, "Playlist editor");
+| 301|    |-	key(w, Type::PreviousColumn, "Previous column");
+| 302|    |-	key(w, Type::NextColumn, "Next column");
+| 303|    |-	key(w, Type::PlayItem, "Add item to playlist and play it");
+| 304|    |-	key(w, Type::AddItemToPlaylist, "Add item to playlist");
+| 305|    |-	key(w, Type::JumpToPlayingSong, "Locate current song");
+| 306|    |-#	ifdef HAVE_TAGLIB_H
+| 307|    |-	key(w, Type::EditSong, "Edit song");
+| 308|    |-#	endif // HAVE_TAGLIB_H
+| 309|    |-	key(w, Type::EditPlaylistName, "Edit playlist name");
+| 310|    |-	key(w, Type::MoveSelectedItemsUp, "Move selected item(s) up");
+| 311|    |-	key(w, Type::MoveSelectedItemsDown, "Move selected item(s) down");
+| 312|    |-	key(w, Type::DeleteStoredPlaylist, "Delete selected playlists (left column)");
+| 313|    |-	key(w, Type::DeletePlaylistItems, "Delete selected item(s) from playlist (right column)");
+| 314|    |-	key(w, Type::ClearPlaylist, "Clear playlist");
+| 315|    |-	key(w, Type::CropPlaylist, "Clear playlist except selected items");
+| 316|    |-
+| 317|    |-	key_section(w, "Lyrics");
+| 318|    |-	key(w, Type::ToggleLyricsUpdateOnSongChange, "Toggle lyrics update on song change");
+| 319|    |-	key(w, Type::EditLyrics, "Open lyrics in external editor");
+| 320|    |-	key(w, Type::RefetchLyrics, "Refetch lyrics");
+| 321|    |-
+| 322|    |-#	ifdef HAVE_TAGLIB_H
+| 323|    |-	key_section(w, "Tiny tag editor");
+| 324|    |-	key(w, Type::RunAction, "Edit tag / Run action");
+| 325|    |-	key(w, Type::SaveTagChanges, "Save");
+| 326|    |-
+| 327|    |-	key_section(w, "Tag editor");
+| 328|    |-	key(w, Type::EnterDirectory, "Enter directory (right column)");
+| 329|    |-	key(w, Type::RunAction, "Perform operation on selected items (middle column)");
+| 330|    |-	key(w, Type::RunAction, "Edit item (left column)");
+| 331|    |-	key(w, Type::PreviousColumn, "Previous column");
+| 332|    |-	key(w, Type::NextColumn, "Next column");
+| 333|    |-	key(w, Type::JumpToParentDirectory, "Jump to parent directory (left column, directories view)");
+|    | 172|+        w << '\n';
+|    | 173|+        key (w, Type::ShowServerInfo, "Show server info");
+|    | 174|+
+|    | 175|+        key_section (w, "Global");
+|    | 176|+        key (w, Type::Stop, "Stop");
+|    | 177|+        key (w, Type::Pause, "Pause");
+|    | 178|+        key (w, Type::Next, "Next track");
+|    | 179|+        key (w, Type::Previous, "Previous track");
+|    | 180|+        key (w, Type::ReplaySong, "Replay playing song");
+|    | 181|+        key (w, Type::SeekForward, "Seek forward in playing song");
+|    | 182|+        key (w, Type::SeekBackward, "Seek backward in playing song");
+|    | 183|+        key (w, Type::VolumeDown,
+|    | 184|+             boost::format ("Decrease volume by %1%%%") %
+|    | 185|+             Config.volume_change_step);
+|    | 186|+        key (w, Type::VolumeUp,
+|    | 187|+             boost::format ("Increase volume by %1%%%") %
+|    | 188|+             Config.volume_change_step);
+|    | 189|+        w << '\n';
+|    | 190|+        key (w, Type::ToggleAddMode,
+|    | 191|+             "Toggle add mode (add or remove/always add)");
+|    | 192|+        key (w, Type::ToggleMouse, "Toggle mouse support");
+|    | 193|+        key (w, Type::SelectRange, "Select range");
+|    | 194|+        key (w, Type::ReverseSelection, "Reverse selection");
+|    | 195|+        key (w, Type::RemoveSelection, "Remove selection");
+|    | 196|+        key (w, Type::SelectItem, "Select current item");
+|    | 197|+        key (w, Type::SelectFoundItems, "Select found items");
+|    | 198|+        key (w, Type::SelectAlbum, "Select songs of album around the cursor");
+|    | 199|+        key (w, Type::AddSelectedItems, "Add selected items to playlist");
+|    | 200|+        key (w, Type::AddRandomItems, "Add random items to playlist");
+|    | 201|+        w << '\n';
+|    | 202|+        key (w, Type::ToggleRepeat, "Toggle repeat mode");
+|    | 203|+        key (w, Type::ToggleRandom, "Toggle random mode");
+|    | 204|+        key (w, Type::ToggleSingle, "Toggle single mode");
+|    | 205|+        key (w, Type::ToggleConsume, "Toggle consume mode");
+|    | 206|+        key (w, Type::ToggleReplayGainMode, "Toggle replay gain mode");
+|    | 207|+        key (w, Type::ToggleBitrateVisibility, "Toggle bitrate visibility");
+|    | 208|+        key (w, Type::ToggleCrossfade, "Toggle crossfade mode");
+|    | 209|+        key (w, Type::SetCrossfade, "Set crossfade");
+|    | 210|+        key (w, Type::SetVolume, "Set volume");
+|    | 211|+        key (w, Type::UpdateDatabase, "Start music database update");
+|    | 212|+        w << '\n';
+|    | 213|+        key (w, Type::ExecuteCommand, "Execute command");
+|    | 214|+        key (w, Type::ApplyFilter, "Apply filter");
+|    | 215|+        key (w, Type::FindItemForward, "Find item forward");
+|    | 216|+        key (w, Type::FindItemBackward, "Find item backward");
+|    | 217|+        key (w, Type::PreviousFoundItem, "Jump to previous found item");
+|    | 218|+        key (w, Type::NextFoundItem, "Jump to next found item");
+|    | 219|+        key (w, Type::ToggleFindMode, "Toggle find mode (normal/wrapped)");
+|    | 220|+        key (w, Type::JumpToBrowser, "Locate song in browser");
+|    | 221|+        key (w, Type::JumpToMediaLibrary, "Locate song in media library");
+|    | 222|+        key (w, Type::ToggleScreenLock, "Lock/unlock current screen");
+|    | 223|+        key (w, Type::MasterScreen, "Switch to master screen (left one)");
+|    | 224|+        key (w, Type::SlaveScreen, "Switch to slave screen (right one)");
+|    | 225|+#	ifdef HAVE_TAGLIB_H
+|    | 226|+        key (w, Type::JumpToTagEditor, "Locate song in tag editor");
+|    | 227|+#	endif // HAVE_TAGLIB_H
+|    | 228|+        key (w, Type::ToggleDisplayMode, "Toggle display mode");
+|    | 229|+        key (w, Type::ToggleInterface, "Toggle user interface");
+|    | 230|+        key (w, Type::ToggleSeparatorsBetweenAlbums,
+|    | 231|+             "Toggle displaying separators between albums");
+|    | 232|+        key (w, Type::JumpToPositionInSong,
+|    | 233|+             "Jump to given position in playing song (formats: mm:ss, x%)");
+|    | 234|+        key (w, Type::ShowSongInfo, "Show song info");
+|    | 235|+        key (w, Type::ShowArtistInfo, "Show artist info");
+|    | 236|+        key (w, Type::FetchLyricsInBackground,
+|    | 237|+             "Fetch lyrics for selected songs");
+|    | 238|+        key (w, Type::ToggleLyricsFetcher, "Toggle lyrics fetcher");
+|    | 239|+        key (w, Type::ToggleFetchingLyricsInBackground,
+|    | 240|+             "Toggle fetching lyrics for playing songs in background");
+|    | 241|+        key (w, Type::ShowLyrics, "Show/hide song lyrics");
+|    | 242|+        w << '\n';
+|    | 243|+        key (w, Type::Quit, "Quit");
+|    | 244|+
+|    | 245|+        key_section (w, "Playlist");
+|    | 246|+        key (w, Type::PlayItem, "Play selected item");
+|    | 247|+        key (w, Type::DeletePlaylistItems,
+|    | 248|+             "Delete selected item(s) from playlist");
+|    | 249|+        key (w, Type::ClearMainPlaylist, "Clear playlist");
+|    | 250|+        key (w, Type::CropMainPlaylist,
+|    | 251|+             "Clear playlist except selected item(s)");
+|    | 252|+        key (w, Type::SetSelectedItemsPriority,
+|    | 253|+             "Set priority of selected items");
+|    | 254|+        key (w, Type::MoveSelectedItemsUp, "Move selected item(s) up");
+|    | 255|+        key (w, Type::MoveSelectedItemsDown, "Move selected item(s) down");
+|    | 256|+        key (w, Type::MoveSelectedItemsTo,
+|    | 257|+             "Move selected item(s) to cursor position");
+|    | 258|+        key (w, Type::Add, "Add item to playlist");
+|    | 259|+#	ifdef HAVE_TAGLIB_H
+|    | 260|+        key (w, Type::EditSong, "Edit song");
+|    | 261|+#	endif // HAVE_TAGLIB_H
+|    | 262|+        key (w, Type::SavePlaylist, "Save playlist");
+|    | 263|+        key (w, Type::Shuffle, "Shuffle range");
+|    | 264|+        key (w, Type::SortPlaylist, "Sort range");
+|    | 265|+        key (w, Type::ReversePlaylist, "Reverse range");
+|    | 266|+        key (w, Type::JumpToPlayingSong, "Jump to current song");
+|    | 267|+        key (w, Type::TogglePlayingSongCentering,
+|    | 268|+             "Toggle playing song centering");
+|    | 269|+
+|    | 270|+        key_section (w, "Browser");
+|    | 271|+        key (w, Type::EnterDirectory, "Enter directory");
+|    | 272|+        key (w, Type::PlayItem, "Add item to playlist and play it");
+|    | 273|+        key (w, Type::AddItemToPlaylist, "Add item to playlist");
+|    | 274|+#	ifdef HAVE_TAGLIB_H
+|    | 275|+        key (w, Type::EditSong, "Edit song");
+|    | 276|+#	endif // HAVE_TAGLIB_H
+|    | 277|+        key (w, Type::EditDirectoryName, "Edit directory name");
+|    | 278|+        key (w, Type::EditPlaylistName, "Edit playlist name");
+|    | 279|+        key (w, Type::ChangeBrowseMode,
+|    | 280|+             "Browse MPD database/local filesystem");
+|    | 281|+        key (w, Type::ToggleBrowserSortMode, "Toggle sort mode");
+|    | 282|+        key (w, Type::JumpToPlayingSong, "Locate current song");
+|    | 283|+        key (w, Type::JumpToParentDirectory, "Jump to parent directory");
+|    | 284|+        key (w, Type::DeleteBrowserItems, "Delete selected items from disk");
+|    | 285|+        key (w, Type::JumpToPlaylistEditor,
+|    | 286|+             "Jump to playlist editor (playlists only)");
+|    | 287|+
+|    | 288|+        key_section (w, "Search engine");
+|    | 289|+        key (w, Type::RunAction, "Modify option / Run action");
+|    | 290|+        key (w, Type::AddItemToPlaylist, "Add item to playlist");
+|    | 291|+        key (w, Type::PlayItem, "Add item to playlist and play it");
+|    | 292|+#	ifdef HAVE_TAGLIB_H
+|    | 293|+        key (w, Type::EditSong, "Edit song");
+|    | 294|+#	endif // HAVE_TAGLIB_H
+|    | 295|+        key (w, Type::StartSearching, "Start searching");
+|    | 296|+        key (w, Type::ResetSearchEngine,
+|    | 297|+             "Reset search constraints and clear results");
+|    | 298|+
+|    | 299|+        key_section (w, "Media library");
+|    | 300|+        key (w, Type::ToggleMediaLibraryColumnsMode,
+|    | 301|+             "Switch between two/three columns mode");
+|    | 302|+        key (w, Type::PreviousColumn, "Previous column");
+|    | 303|+        key (w, Type::NextColumn, "Next column");
+|    | 304|+        key (w, Type::PlayItem, "Add item to playlist and play it");
+|    | 305|+        key (w, Type::AddItemToPlaylist, "Add item to playlist");
+|    | 306|+        key (w, Type::JumpToPlayingSong, "Locate current song");
+|    | 307|+#	ifdef HAVE_TAGLIB_H
+|    | 308|+        key (w, Type::EditSong, "Edit song");
+|    | 309|+#	endif // HAVE_TAGLIB_H
+|    | 310|+        key (w, Type::EditLibraryTag,
+|    | 311|+             "Edit tag (left column)/album (middle/right column)");
+|    | 312|+        key (w, Type::ToggleLibraryTagType,
+|    | 313|+             "Toggle type of tag used in left column");
+|    | 314|+        key (w, Type::ToggleMediaLibrarySortMode, "Toggle sort mode");
+|    | 315|+
+|    | 316|+        key_section (w, "Playlist editor");
+|    | 317|+        key (w, Type::PreviousColumn, "Previous column");
+|    | 318|+        key (w, Type::NextColumn, "Next column");
+|    | 319|+        key (w, Type::PlayItem, "Add item to playlist and play it");
+|    | 320|+        key (w, Type::AddItemToPlaylist, "Add item to playlist");
+|    | 321|+        key (w, Type::JumpToPlayingSong, "Locate current song");
+|    | 322|+#	ifdef HAVE_TAGLIB_H
+|    | 323|+        key (w, Type::EditSong, "Edit song");
+|    | 324|+#	endif // HAVE_TAGLIB_H
+|    | 325|+        key (w, Type::EditPlaylistName, "Edit playlist name");
+|    | 326|+        key (w, Type::MoveSelectedItemsUp, "Move selected item(s) up");
+|    | 327|+        key (w, Type::MoveSelectedItemsDown, "Move selected item(s) down");
+|    | 328|+        key (w, Type::DeleteStoredPlaylist,
+|    | 329|+             "Delete selected playlists (left column)");
+|    | 330|+        key (w, Type::DeletePlaylistItems,
+|    | 331|+             "Delete selected item(s) from playlist (right column)");
+|    | 332|+        key (w, Type::ClearPlaylist, "Clear playlist");
+|    | 333|+        key (w, Type::CropPlaylist, "Clear playlist except selected items");
+|    | 334|+
+|    | 335|+        key_section (w, "Lyrics");
+|    | 336|+        key (w, Type::ToggleLyricsUpdateOnSongChange,
+|    | 337|+             "Toggle lyrics update on song change");
+|    | 338|+        key (w, Type::EditLyrics, "Open lyrics in external editor");
+|    | 339|+        key (w, Type::RefetchLyrics, "Refetch lyrics");
+|    | 340|+
+|    | 341|+#	ifdef HAVE_TAGLIB_H
+|    | 342|+        key_section (w, "Tiny tag editor");
+|    | 343|+        key (w, Type::RunAction, "Edit tag / Run action");
+|    | 344|+        key (w, Type::SaveTagChanges, "Save");
+|    | 345|+
+|    | 346|+        key_section (w, "Tag editor");
+|    | 347|+        key (w, Type::EnterDirectory, "Enter directory (right column)");
+|    | 348|+        key (w, Type::RunAction,
+|    | 349|+             "Perform operation on selected items (middle column)");
+|    | 350|+        key (w, Type::RunAction, "Edit item (left column)");
+|    | 351|+        key (w, Type::PreviousColumn, "Previous column");
+|    | 352|+        key (w, Type::NextColumn, "Next column");
+|    | 353|+        key (w, Type::JumpToParentDirectory,
+|    | 354|+             "Jump to parent directory (left column, directories view)");
+| 334| 355| #	endif // HAVE_TAGLIB_H
+| 335| 356| 
+| 336| 357| #	ifdef ENABLE_OUTPUTS
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 334| 334| #	endif // HAVE_TAGLIB_H
+| 335| 335| 
+| 336| 336| #	ifdef ENABLE_OUTPUTS
+| 337|    |-	key_section(w, "Outputs");
+| 338|    |-	key(w, Type::ToggleOutput, "Toggle output");
+|    | 337|+        key_section (w, "Outputs");
+|    | 338|+        key (w, Type::ToggleOutput, "Toggle output");
+| 339| 339| #	endif // ENABLE_OUTPUTS
+| 340| 340| 
+| 341| 341| #	if defined(ENABLE_VISUALIZER) && defined(HAVE_FFTW3_H)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 339| 339| #	endif // ENABLE_OUTPUTS
+| 340| 340| 
+| 341| 341| #	if defined(ENABLE_VISUALIZER) && defined(HAVE_FFTW3_H)
+| 342|    |-	key_section(w, "Music visualizer");
+| 343|    |-	key(w, Type::ToggleVisualizationType, "Toggle visualization type");
+|    | 342|+        key_section (w, "Music visualizer");
+|    | 343|+        key (w, Type::ToggleVisualizationType, "Toggle visualization type");
+| 344| 344| #	endif // ENABLE_VISUALIZER && HAVE_FFTW3_H
+| 345| 345| 
+| 346| 346| 	mouse_section(w, "Global");
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 343| 343| 	key(w, Type::ToggleVisualizationType, "Toggle visualization type");
+| 344| 344| #	endif // ENABLE_VISUALIZER && HAVE_FFTW3_H
+| 345| 345| 
+| 346|    |-	mouse_section(w, "Global");
+| 347|    |-	mouse(w, "Left click on \"Playing/Paused\"", "Play/pause");
+| 348|    |-	mouse(w, "Left click on progressbar", "Jump to pointed position in playing song");
+| 349|    |-	w << '\n';
+| 350|    |-	mouse(w, "Mouse wheel on \"Volume: xx\"", "Adjust volume");
+| 351|    |-	mouse(w, "Mouse wheel on main window", "Scroll");
+| 352|    |-
+| 353|    |-	mouse_section(w, "Playlist");
+| 354|    |-	mouse(w, "Left click", "Select pointed item");
+| 355|    |-	mouse(w, "Right click", "Play");
+| 356|    |-
+| 357|    |-	mouse_section(w, "Browser");
+| 358|    |-	mouse(w, "Left click on directory", "Enter pointed directory");
+| 359|    |-	mouse(w, "Right click on directory", "Add pointed directory to playlist");
+| 360|    |-	w << '\n';
+| 361|    |-	mouse(w, "Left click on song/playlist", "Add pointed item to playlist");
+| 362|    |-	mouse(w, "Right click on song/playlist", "Add pointed item to playlist and play it");
+| 363|    |-
+| 364|    |-	mouse_section(w, "Search engine");
+| 365|    |-	mouse(w, "Left click", "Highlight/switch value");
+| 366|    |-	mouse(w, "Right click", "Change value");
+| 367|    |-
+| 368|    |-	mouse_section(w, "Media library");
+| 369|    |-	mouse_column(w, "Left/middle");
+| 370|    |-	mouse(w, "Left click", "Select pointed item", true);
+| 371|    |-	mouse(w, "Right click", "Add item to playlist", true);
+| 372|    |-	w << '\n';
+| 373|    |-	mouse_column(w, "Right");
+| 374|    |-	mouse(w, "Left Click", "Add pointed item to playlist", true);
+| 375|    |-	mouse(w, "Right Click", "Add pointed item to playlist and play it", true);
+| 376|    |-
+| 377|    |-	mouse_section(w, "Playlist editor");
+| 378|    |-	mouse_column(w, "Left");
+| 379|    |-	mouse(w, "Left click", "Select pointed item", true);
+| 380|    |-	mouse(w, "Right click", "Add item to playlist", true);
+| 381|    |-	w << '\n';
+| 382|    |-	mouse_column(w, "Right");
+| 383|    |-	mouse(w, "Left click", "Add pointed item to playlist", true);
+| 384|    |-	mouse(w, "Right click", "Add pointed item to playlist and play it", true);
+| 385|    |-
+| 386|    |-#	ifdef HAVE_TAGLIB_H
+| 387|    |-	mouse_section(w, "Tiny tag editor");
+| 388|    |-	mouse(w, "Left click", "Select option");
+| 389|    |-	mouse(w, "Right click", "Set value/execute");
+| 390|    |-
+| 391|    |-	mouse_section(w, "Tag editor");
+| 392|    |-	mouse_column(w, "Left");
+| 393|    |-	mouse(w, "Left click", "Enter pointed directory/select pointed album", true);
+| 394|    |-	mouse(w, "Right click", "Toggle view (directories/albums)", true);
+| 395|    |-	w << '\n';
+| 396|    |-	mouse_column(w, "Middle");
+| 397|    |-	mouse(w, "Left click", "Select option", true);
+| 398|    |-	mouse(w, "Right click", "Set value/execute", true);
+| 399|    |-	w << '\n';
+| 400|    |-	mouse_column(w, "Right");
+| 401|    |-	mouse(w, "Left click", "Select pointed item", true);
+| 402|    |-	mouse(w, "Right click", "Set value", true);
+|    | 346|+        mouse_section (w, "Global");
+|    | 347|+        mouse (w, "Left click on \"Playing/Paused\"", "Play/pause");
+|    | 348|+        mouse (w, "Left click on progressbar",
+|    | 349|+               "Jump to pointed position in playing song");
+|    | 350|+        w << '\n';
+|    | 351|+        mouse (w, "Mouse wheel on \"Volume: xx\"", "Adjust volume");
+|    | 352|+        mouse (w, "Mouse wheel on main window", "Scroll");
+|    | 353|+
+|    | 354|+        mouse_section (w, "Playlist");
+|    | 355|+        mouse (w, "Left click", "Select pointed item");
+|    | 356|+        mouse (w, "Right click", "Play");
+|    | 357|+
+|    | 358|+        mouse_section (w, "Browser");
+|    | 359|+        mouse (w, "Left click on directory", "Enter pointed directory");
+|    | 360|+        mouse (w, "Right click on directory",
+|    | 361|+               "Add pointed directory to playlist");
+|    | 362|+        w << '\n';
+|    | 363|+        mouse (w, "Left click on song/playlist",
+|    | 364|+               "Add pointed item to playlist");
+|    | 365|+        mouse (w, "Right click on song/playlist",
+|    | 366|+               "Add pointed item to playlist and play it");
+|    | 367|+
+|    | 368|+        mouse_section (w, "Search engine");
+|    | 369|+        mouse (w, "Left click", "Highlight/switch value");
+|    | 370|+        mouse (w, "Right click", "Change value");
+|    | 371|+
+|    | 372|+        mouse_section (w, "Media library");
+|    | 373|+        mouse_column (w, "Left/middle");
+|    | 374|+        mouse (w, "Left click", "Select pointed item", true);
+|    | 375|+        mouse (w, "Right click", "Add item to playlist", true);
+|    | 376|+        w << '\n';
+|    | 377|+        mouse_column (w, "Right");
+|    | 378|+        mouse (w, "Left Click", "Add pointed item to playlist", true);
+|    | 379|+        mouse (w, "Right Click", "Add pointed item to playlist and play it",
+|    | 380|+               true);
+|    | 381|+
+|    | 382|+        mouse_section (w, "Playlist editor");
+|    | 383|+        mouse_column (w, "Left");
+|    | 384|+        mouse (w, "Left click", "Select pointed item", true);
+|    | 385|+        mouse (w, "Right click", "Add item to playlist", true);
+|    | 386|+        w << '\n';
+|    | 387|+        mouse_column (w, "Right");
+|    | 388|+        mouse (w, "Left click", "Add pointed item to playlist", true);
+|    | 389|+        mouse (w, "Right click", "Add pointed item to playlist and play it",
+|    | 390|+               true);
+|    | 391|+
+|    | 392|+#	ifdef HAVE_TAGLIB_H
+|    | 393|+        mouse_section (w, "Tiny tag editor");
+|    | 394|+        mouse (w, "Left click", "Select option");
+|    | 395|+        mouse (w, "Right click", "Set value/execute");
+|    | 396|+
+|    | 397|+        mouse_section (w, "Tag editor");
+|    | 398|+        mouse_column (w, "Left");
+|    | 399|+        mouse (w, "Left click", "Enter pointed directory/select pointed album",
+|    | 400|+               true);
+|    | 401|+        mouse (w, "Right click", "Toggle view (directories/albums)", true);
+|    | 402|+        w << '\n';
+|    | 403|+        mouse_column (w, "Middle");
+|    | 404|+        mouse (w, "Left click", "Select option", true);
+|    | 405|+        mouse (w, "Right click", "Set value/execute", true);
+|    | 406|+        w << '\n';
+|    | 407|+        mouse_column (w, "Right");
+|    | 408|+        mouse (w, "Left click", "Select pointed item", true);
+|    | 409|+        mouse (w, "Right click", "Set value", true);
+| 403| 410| #	endif // HAVE_TAGLIB_H
+| 404| 411| 
+| 405| 412| #	ifdef ENABLE_OUTPUTS
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 403| 403| #	endif // HAVE_TAGLIB_H
+| 404| 404| 
+| 405| 405| #	ifdef ENABLE_OUTPUTS
+| 406|    |-	mouse_section(w, "Outputs");
+| 407|    |-	mouse(w, "Left click", "Select pointed output");
+| 408|    |-	mouse(w, "Right click", "Toggle output");
+|    | 406|+        mouse_section (w, "Outputs");
+|    | 407|+        mouse (w, "Left click", "Select pointed output");
+|    | 408|+        mouse (w, "Right click", "Toggle output");
+| 409| 409| #	endif // ENABLE_OUTPUTS
+| 410| 410| 
+| 411| 411| 	section(w, "", "Action chains");
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 408| 408| 	mouse(w, "Right click", "Toggle output");
+| 409| 409| #	endif // ENABLE_OUTPUTS
+| 410| 410| 
+| 411|    |-	section(w, "", "Action chains");
+| 412|    |-	for (const auto &k : Bindings)
+| 413|    |-	{
+| 414|    |-		for (const auto &binding : k.second)
+| 415|    |-		{
+| 416|    |-			if (!binding.isSingle())
+| 417|    |-			{
+| 418|    |-				std::vector<std::string> commands;
+| 419|    |-				for (const auto &action : binding.actions())
+| 420|    |-					commands.push_back(action->name());
+| 421|    |-				key(w, k.first, join<std::string>(commands, ", "));
+| 422|    |-			}
+| 423|    |-		}
+| 424|    |-	}
+| 425|    |-
+| 426|    |-	section(w, "", "List of available colors");
+| 427|    |-	for (int i = 0; i < COLORS; ++i)
+| 428|    |-		w << NC::Color(i, NC::Color::transparent) << i+1 << NC::Color::End << " ";
+| 429|    |-}
+| 430|    |-
+|    | 411|+        section (w, "", "Action chains");
+|    | 412|+      for (const auto & k:Bindings)
+|    | 413|+          {
+|    | 414|+            for (const auto & binding:k.second)
+|    | 415|+                {
+|    | 416|+                    if (!binding.isSingle ())
+|    | 417|+                      {
+|    | 418|+                          std::vector < std::string > commands;
+|    | 419|+                        for (const auto & action:binding.
+|    | 420|+                               actions
+|    | 421|+                               ())
+|    | 422|+                              commands.push_back (action->name ());
+|    | 423|+                          key (w, k.first,
+|    | 424|+                               join < std::string > (commands, ", "));
+|    | 425|+                      }
+|    | 426|+                }
+|    | 427|+          }
+|    | 428|+
+|    | 429|+        section (w, "", "List of available colors");
+|    | 430|+        for (int i = 0; i < COLORS; ++i)
+|    | 431|+            w << NC::Color (i,
+|    | 432|+                            NC::Color::transparent) << i +
+|    | 433|+                1 << NC::Color::End << " ";
+|    | 434|+    }
+|    | 435|+
+|    | 436|+}
+|    | 437|+
+|    | 438|+Help::Help ():Screen (NC::
+|    | 439|+        Scrollpad (0, MainStartY, COLS, MainHeight, "", Config.main_color,
+|    | 440|+                   NC::Border ()))
+|    | 441|+{
+|    | 442|+    write_bindings (w);
+|    | 443|+    w.flush ();
+| 431| 444| }
+| 432| 445| 
+| 433| 446| Help::Help()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 430| 430| 
+| 431| 431| }
+| 432| 432| 
+| 433|    |-Help::Help()
+| 434|    |-: Screen(NC::Scrollpad(0, MainStartY, COLS, MainHeight, "", Config.main_color, NC::Border()))
+| 435|    |-{
+| 436|    |-	write_bindings(w);
+| 437|    |-	w.flush();
+|    | 433|+void
+|    | 434|+Help::resize ()
+|    | 435|+{
+|    | 436|+    size_t x_offset, width;
+|    | 437|+    getWindowResizeParams (x_offset, width);
+|    | 438|+    w.resize (width, MainHeight);
+|    | 439|+    w.moveTo (x_offset, MainStartY);
+|    | 440|+    hasToBeResized = 0;
+| 438| 441| }
+| 439| 442| 
+| 440| 443| void Help::resize()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 437| 437| 	w.flush();
+| 438| 438| }
+| 439| 439| 
+| 440|    |-void Help::resize()
+| 441|    |-{
+| 442|    |-	size_t x_offset, width;
+| 443|    |-	getWindowResizeParams(x_offset, width);
+| 444|    |-	w.resize(width, MainHeight);
+| 445|    |-	w.moveTo(x_offset, MainStartY);
+| 446|    |-	hasToBeResized = 0;
+|    | 440|+void
+|    | 441|+Help::switchTo ()
+|    | 442|+{
+|    | 443|+    SwitchTo::execute (this);
+|    | 444|+    drawHeader ();
+| 447| 445| }
+| 448| 446| 
+| 449| 447| void Help::switchTo()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/help.cpp
+|    |++++| /app/src/screens/help.cpp
+| 446| 446| 	hasToBeResized = 0;
+| 447| 447| }
+| 448| 448| 
+| 449|    |-void Help::switchTo()
+| 450|    |-{
+| 451|    |-	SwitchTo::execute(this);
+| 452|    |-	drawHeader();
+| 453|    |-}
+| 454|    |-
+| 455|    |-std::wstring Help::title()
+| 456|    |-{
+| 457|    |-	return L"Help";
+| 458|    |-}
+|    | 449|+std::wstring Help::title ()
+|    | 450|+{
+|    | 451|+    return L"Help";
+|    | 452|+}
+
+src/screens/help.cpp
+|  21| #include•"mpdpp.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'mpdpp.h'
+
+src/screens/help.cpp
+|  23| #include•"bindings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'bindings.h'
+
+src/screens/help.cpp
+|  24| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/help.cpp
+|  25| #include•"screens/help.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/help.h'
+
+src/screens/help.cpp
+|  26| #include•"settings.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'settings.h'
+
+src/screens/help.cpp
+|  27| #include•"status.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'status.h'
+
+src/screens/help.cpp
+|  28| #include•"utility/string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/string.h'
+
+src/screens/help.cpp
+|  29| #include•"utility/wide_string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/wide_string.h'
+
+src/screens/help.cpp
+|  30| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/help.cpp
+|  31| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/help.cpp
+|  36| Help•*myHelp;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myHelp'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format.cpp
+|    |++++| /app/src/format.cpp
+|  23|  23| #include "format_impl.h"
+|  24|  24| #include "utility/type_conversions.h"
+|  25|  25| 
+|  26|    |-namespace {
+|  27|    |-
+|  28|    |-const unsigned properties = Format::Flags::Color
+|  29|    |-                          | Format::Flags::Format
+|  30|    |-                          | Format::Flags::OutputSwitch;
+|  31|    |-
+|  32|    |-template <typename CharT> using string = std::basic_string<CharT>;
+|  33|    |-template <typename CharT> using iterator = typename std::basic_string<CharT>::const_iterator;
+|  34|    |-template <typename CharT> using expressions = std::vector<Format::Expression<CharT>>;
+|  35|    |-
+|  36|    |-template <typename CharT>
+|  37|    |-std::string invalidCharacter(CharT c)
+|  38|    |-{
+|  39|    |-	return "invalid character '"
+|  40|    |-	     + convertString<char, CharT>::apply(boost::lexical_cast<string<CharT>>(c))
+|  41|    |-	     + "'";
+|    |  26|+namespace
+|    |  27|+{
+|    |  28|+
+|    |  29|+    const unsigned properties = Format::Flags::Color
+|    |  30|+        | Format::Flags::Format | Format::Flags::OutputSwitch;
+|    |  31|+
+|    |  32|+    template < typename CharT > using string = std::basic_string < CharT >;
+|    |  33|+    template < typename CharT > using iterator =
+|    |  34|+        typename std::basic_string < CharT >::const_iterator;
+|    |  35|+    template < typename CharT > using expressions =
+|    |  36|+        std::vector < Format::Expression < CharT >>;
+|    |  37|+
+|    |  38|+    template < typename CharT > std::string invalidCharacter (CharT c)
+|    |  39|+    {
+|    |  40|+        return "invalid character '"
+|    |  41|+            + convertString < char,
+|    |  42|+            CharT >::apply (boost::lexical_cast < string < CharT >> (c)) + "'";
+|    |  43|+    }
+|    |  44|+
+|    |  45|+    template < typename CharT >
+|    |  46|+        void throwError (const string < CharT > &s, iterator < CharT > current,
+|    |  47|+                         std::string msg)
+|    |  48|+    {
+|    |  49|+        throw std::runtime_error (std::move (msg) + " at position " +
+|    |  50|+                                  boost::lexical_cast < std::string >
+|    |  51|+                                  (current - s.begin ()));
+|    |  52|+    }
+|    |  53|+
+|    |  54|+    template < typename CharT >
+|    |  55|+        void rangeCheck (const string < CharT > &s, iterator < CharT > current,
+|    |  56|+                         iterator < CharT > end)
+|    |  57|+    {
+|    |  58|+        if (current >= end)
+|    |  59|+            throwError (s, current, "unexpected end");
+|    |  60|+    }
+|    |  61|+
+|    |  62|+    template < typename CharT >
+|    |  63|+        expressions < CharT > parseBracket (const string < CharT > &s,
+|    |  64|+                                            iterator < CharT > it,
+|    |  65|+                                            iterator < CharT > end,
+|    |  66|+                                            const unsigned flags)
+|    |  67|+    {
+|    |  68|+        string < CharT > token;
+|    |  69|+        expressions < CharT > tmp, result;
+|    |  70|+        auto push_token =[&]{
+|    |  71|+            if (!token.empty ())
+|    |  72|+                result.push_back (std::move (token));
+|    |  73|+        };
+|    |  74|+        for (; it != end; ++it)
+|    |  75|+          {
+|    |  76|+              if (*it == '{')
+|    |  77|+                {
+|    |  78|+                    push_token ();
+|    |  79|+                    bool done;
+|    |  80|+                    Format::FirstOf < CharT > first_of;
+|    |  81|+                    do
+|    |  82|+                      {
+|    |  83|+                          auto jt = it;
+|    |  84|+                          done = true;
+|    |  85|+                          // get to the corresponding closing bracket
+|    |  86|+                          unsigned brackets = 1;
+|    |  87|+                          while (brackets > 0)
+|    |  88|+                            {
+|    |  89|+                                if (++jt == end)
+|    |  90|+                                    break;
+|    |  91|+                                if (*jt == '{')
+|    |  92|+                                    ++brackets;
+|    |  93|+                                else if (*jt == '}')
+|    |  94|+                                    --brackets;
+|    |  95|+                            }
+|    |  96|+                          // check if we're still in range
+|    |  97|+                          rangeCheck (s, jt, end);
+|    |  98|+                          // skip the opening bracket
+|    |  99|+                          ++it;
+|    | 100|+                          // recursively parse the bracket
+|    | 101|+                          tmp = parseBracket (s, it, jt, flags);
+|    | 102|+                          // if the inner bracket contains only one expression,
+|    | 103|+                          // put it as is. otherwise make a group out of them.
+|    | 104|+                          if (tmp.size () == 1)
+|    | 105|+                              first_of.base ().push_back (std::move (tmp[0]));
+|    | 106|+                          else
+|    | 107|+                              first_of.base ().push_back (Format::Group <
+|    | 108|+                                                          CharT >
+|    | 109|+                                                          (std::move (tmp)));
+|    | 110|+                          it = jt;
+|    | 111|+                          // check for the alternative
+|    | 112|+                          ++jt;
+|    | 113|+                          if (jt != end && *jt == '|')
+|    | 114|+                            {
+|    | 115|+                                ++jt;
+|    | 116|+                                rangeCheck (s, jt, end);
+|    | 117|+                                if (*jt != '{')
+|    | 118|+                                    throwError (s, jt,
+|    | 119|+                                                invalidCharacter (*jt) +
+|    | 120|+                                                ", expected '{'");
+|    | 121|+                                it = jt;
+|    | 122|+                                done = false;
+|    | 123|+                            }
+|    | 124|+                      }
+|    | 125|+                    while (!done);
+|    | 126|+                    assert (!first_of.base ().empty ());
+|    | 127|+                    result.push_back (std::move (first_of));
+|    | 128|+                }
+|    | 129|+              else if (flags & Format::Flags::Tag && *it == '%')
+|    | 130|+                {
+|    | 131|+                    ++it;
+|    | 132|+                    rangeCheck (s, it, end);
+|    | 133|+                    // %% is escaped %
+|    | 134|+                    if (*it == '%')
+|    | 135|+                      {
+|    | 136|+                          token += '%';
+|    | 137|+                          continue;
+|    | 138|+                      }
+|    | 139|+                    push_token ();
+|    | 140|+                    // check for tag delimiter
+|    | 141|+                    unsigned delimiter = 0;
+|    | 142|+                    if (isdigit (*it))
+|    | 143|+                      {
+|    | 144|+                          string < CharT > sdelimiter;
+|    | 145|+                          do
+|    | 146|+                              sdelimiter += *it++;
+|    | 147|+                          while (it != end && isdigit (*it));
+|    | 148|+                          rangeCheck (s, it, end);
+|    | 149|+                          delimiter =
+|    | 150|+                              boost::lexical_cast < unsigned >(sdelimiter);
+|    | 151|+                      }
+|    | 152|+                    auto f = charToGetFunction (*it);
+|    | 153|+                    if (f == nullptr)
+|    | 154|+                        throwError (s, it, invalidCharacter (*it));
+|    | 155|+                    result.push_back (Format::SongTag (f, delimiter));
+|    | 156|+                }
+|    | 157|+              else if (flags & properties && *it == '$')
+|    | 158|+                {
+|    | 159|+                    ++it;
+|    | 160|+                    rangeCheck (s, it, end);
+|    | 161|+                    // $$ is escaped $
+|    | 162|+                    if (*it == '$')
+|    | 163|+                      {
+|    | 164|+                          token += '$';
+|    | 165|+                          continue;
+|    | 166|+                      }
+|    | 167|+                    push_token ();
+|    | 168|+                    // legacy colors
+|    | 169|+                    if (flags & Format::Flags::Color && isdigit (*it))
+|    | 170|+                      {
+|    | 171|+                          auto color = charToColor (*it);
+|    | 172|+                          result.push_back (color);
+|    | 173|+                      }
+|    | 174|+                    // new colors
+|    | 175|+                    else if (flags & Format::Flags::Color && *it == '(')
+|    | 176|+                      {
+|    | 177|+                          ++it;
+|    | 178|+                          rangeCheck (s, it, end);
+|    | 179|+                          auto jt = it;
+|    | 180|+                          string < CharT > scolor;
+|    | 181|+                          do
+|    | 182|+                              scolor += *it++;
+|    | 183|+                          while (it != end && *it != ')');
+|    | 184|+                          rangeCheck (s, it, end);
+|    | 185|+                          auto value =
+|    | 186|+                              convertString < char, CharT >::apply (scolor);
+|    | 187|+                          try
+|    | 188|+                          {
+|    | 189|+                              result.push_back (boost::lexical_cast <
+|    | 190|+                                                NC::Color > (value));
+|    | 191|+                          } catch (boost::bad_lexical_cast &)
+|    | 192|+                          {
+|    | 193|+                              throwError (s, jt,
+|    | 194|+                                          "invalid color \"" + value + "\"");
+|    | 195|+                          }
+|    | 196|+                      }
+|    | 197|+                    // output switch
+|    | 198|+                    else if (flags & Format::Flags::OutputSwitch && *it == 'R')
+|    | 199|+                        result.push_back (Format::OutputSwitch ());
+|    | 200|+                    // format
+|    | 201|+                    else if (flags & Format::Flags::Format && *it == 'b')
+|    | 202|+                        result.push_back (NC::Format::Bold);
+|    | 203|+                    else if (flags & Format::Flags::Format && *it == 'u')
+|    | 204|+                        result.push_back (NC::Format::Underline);
+|    | 205|+                    else if (flags & Format::Flags::Format && *it == 'a')
+|    | 206|+                        result.push_back (NC::Format::AltCharset);
+|    | 207|+                    else if (flags & Format::Flags::Format && *it == 'r')
+|    | 208|+                        result.push_back (NC::Format::Reverse);
+|    | 209|+                    else if (flags & Format::Flags::Format && *it == '/')
+|    | 210|+                      {
+|    | 211|+                          ++it;
+|    | 212|+                          rangeCheck (s, it, end);
+|    | 213|+                          if (*it == 'b')
+|    | 214|+                              result.push_back (NC::Format::NoBold);
+|    | 215|+                          else if (*it == 'u')
+|    | 216|+                              result.push_back (NC::Format::NoUnderline);
+|    | 217|+                          else if (*it == 'a')
+|    | 218|+                              result.push_back (NC::Format::NoAltCharset);
+|    | 219|+                          else if (*it == 'r')
+|    | 220|+                              result.push_back (NC::Format::NoReverse);
+|    | 221|+                          else
+|    | 222|+                              throwError (s, it, invalidCharacter (*it));
+|    | 223|+                      }
+|    | 224|+                    else
+|    | 225|+                        throwError (s, it, invalidCharacter (*it));
+|    | 226|+                }
+|    | 227|+              else
+|    | 228|+                  token += *it;
+|    | 229|+          }
+|    | 230|+        push_token ();
+|    | 231|+        return result;
+|    | 232|+    }
+|    | 233|+
+|  42| 234| }
+|  43| 235| 
+|  44| 236| template <typename CharT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/format.cpp
+|    |++++| /app/src/format.cpp
+|  41|  41| 	     + "'";
+|  42|  42| }
+|  43|  43| 
+|  44|    |-template <typename CharT>
+|  45|    |-void throwError(const string<CharT> &s, iterator<CharT> current, std::string msg)
+|    |  44|+namespace Format
+|  46|  45| {
+|  47|    |-	throw std::runtime_error(
+|  48|    |-		std::move(msg) + " at position " + boost::lexical_cast<std::string>(current - s.begin())
+|  49|    |-	);
+|  50|    |-}
+|  51|  46| 
+|  52|    |-template <typename CharT>
+|  53|    |-void rangeCheck(const string<CharT> &s, iterator<CharT> current, iterator<CharT> end)
+|  54|    |-{
+|  55|    |-	if (current >= end)
+|  56|    |-		throwError(s, current, "unexpected end");
+|  57|    |-}
+|    |  47|+    AST < char >parse (const std::string & s, const unsigned flags)
+|    |  48|+    {
+|    |  49|+        return AST < char >(parseBracket (s, s.begin (), s.end (), flags));
+|    |  50|+    }
+|  58|  51| 
+|  59|    |-template <typename CharT>
+|  60|    |-expressions<CharT> parseBracket(const string<CharT> &s,
+|  61|    |-                                iterator<CharT> it, iterator<CharT> end,
+|  62|    |-                                const unsigned flags)
+|  63|    |-{
+|  64|    |-	string<CharT> token;
+|  65|    |-	expressions<CharT> tmp, result;
+|  66|    |-	auto push_token = [&] {
+|  67|    |-		if (!token.empty())
+|  68|    |-			result.push_back(std::move(token));
+|  69|    |-	};
+|  70|    |-	for (; it != end; ++it)
+|  71|    |-	{
+|  72|    |-		if (*it == '{')
+|  73|    |-		{
+|  74|    |-			push_token();
+|  75|    |-			bool done;
+|  76|    |-			Format::FirstOf<CharT> first_of;
+|  77|    |-			do
+|  78|    |-			{
+|  79|    |-				auto jt = it;
+|  80|    |-				done = true;
+|  81|    |-				// get to the corresponding closing bracket
+|  82|    |-				unsigned brackets = 1;
+|  83|    |-				while (brackets > 0)
+|  84|    |-				{
+|  85|    |-					if (++jt == end)
+|  86|    |-						break;
+|  87|    |-					if (*jt == '{')
+|  88|    |-						++brackets;
+|  89|    |-					else if (*jt == '}')
+|  90|    |-						--brackets;
+|  91|    |-				}
+|  92|    |-				// check if we're still in range
+|  93|    |-				rangeCheck(s, jt, end);
+|  94|    |-				// skip the opening bracket
+|  95|    |-				++it;
+|  96|    |-				// recursively parse the bracket
+|  97|    |-				tmp = parseBracket(s, it, jt, flags);
+|  98|    |-				// if the inner bracket contains only one expression,
+|  99|    |-				// put it as is. otherwise make a group out of them.
+| 100|    |-				if (tmp.size() == 1)
+| 101|    |-					first_of.base().push_back(std::move(tmp[0]));
+| 102|    |-				else
+| 103|    |-					first_of.base().push_back(Format::Group<CharT>(std::move(tmp)));
+| 104|    |-				it = jt;
+| 105|    |-				// check for the alternative
+| 106|    |-				++jt;
+| 107|    |-				if (jt != end && *jt == '|')
+| 108|    |-				{
+| 109|    |-					++jt;
+| 110|    |-					rangeCheck(s, jt, end);
+| 111|    |-					if (*jt != '{')
+| 112|    |-						throwError(s, jt, invalidCharacter(*jt) + ", expected '{'");
+| 113|    |-					it = jt;
+| 114|    |-					done = false;
+| 115|    |-				}
+| 116|    |-			}
+| 117|    |-			while (!done);
+| 118|    |-			assert(!first_of.base().empty());
+| 119|    |-			result.push_back(std::move(first_of));
+| 120|    |-		}
+| 121|    |-		else if (flags & Format::Flags::Tag && *it == '%')
+| 122|    |-		{
+| 123|    |-			++it;
+| 124|    |-			rangeCheck(s, it, end);
+| 125|    |-			// %% is escaped %
+| 126|    |-			if (*it == '%')
+| 127|    |-			{
+| 128|    |-				token += '%';
+| 129|    |-				continue;
+| 130|    |-			}
+| 131|    |-			push_token();
+| 132|    |-			// check for tag delimiter
+| 133|    |-			unsigned delimiter = 0;
+| 134|    |-			if (isdigit(*it))
+| 135|    |-			{
+| 136|    |-				string<CharT> sdelimiter;
+| 137|    |-				do
+| 138|    |-					sdelimiter += *it++;
+| 139|    |-				while (it != end && isdigit(*it));
+| 140|    |-				rangeCheck(s, it, end);
+| 141|    |-				delimiter = boost::lexical_cast<unsigned>(sdelimiter);
+| 142|    |-			}
+| 143|    |-			auto f = charToGetFunction(*it);
+| 144|    |-			if (f == nullptr)
+| 145|    |-				throwError(s, it, invalidCharacter(*it));
+| 146|    |-			result.push_back(Format::SongTag(f, delimiter));
+| 147|    |-		}
+| 148|    |-		else if (flags & properties && *it == '$')
+| 149|    |-		{
+| 150|    |-			++it;
+| 151|    |-			rangeCheck(s, it, end);
+| 152|    |-			// $$ is escaped $
+| 153|    |-			if (*it == '$')
+| 154|    |-			{
+| 155|    |-				token += '$';
+| 156|    |-				continue;
+| 157|    |-			}
+| 158|    |-			push_token();
+| 159|    |-			// legacy colors
+| 160|    |-			if (flags & Format::Flags::Color && isdigit(*it))
+| 161|    |-			{
+| 162|    |-				auto color = charToColor(*it);
+| 163|    |-				result.push_back(color);
+| 164|    |-			}
+| 165|    |-			// new colors
+| 166|    |-			else if (flags & Format::Flags::Color && *it == '(')
+| 167|    |-			{
+| 168|    |-				++it;
+| 169|    |-				rangeCheck(s, it, end);
+| 170|    |-				auto jt = it;
+| 171|    |-				string<CharT> scolor;
+| 172|    |-				do
+| 173|    |-					scolor += *it++;
+| 174|    |-				while (it != end && *it != ')');
+| 175|    |-				rangeCheck(s, it, end);
+| 176|    |-				auto value = convertString<char, CharT>::apply(scolor);
+| 177|    |-				try {
+| 178|    |-					result.push_back(boost::lexical_cast<NC::Color>(value));
+| 179|    |-				} catch (boost::bad_lexical_cast &) {
+| 180|    |-					throwError(s, jt, "invalid color \"" + value + "\"");
+| 181|    |-				}
+| 182|    |-			}
+| 183|    |-			// output switch
+| 184|    |-			else if (flags & Format::Flags::OutputSwitch && *it == 'R')
+| 185|    |-				result.push_back(Format::OutputSwitch());
+| 186|    |-			// format
+| 187|    |-			else if (flags & Format::Flags::Format && *it == 'b')
+| 188|    |-				result.push_back(NC::Format::Bold);
+| 189|    |-			else if (flags & Format::Flags::Format && *it == 'u')
+| 190|    |-				result.push_back(NC::Format::Underline);
+| 191|    |-			else if (flags & Format::Flags::Format && *it == 'a')
+| 192|    |-				result.push_back(NC::Format::AltCharset);
+| 193|    |-			else if (flags & Format::Flags::Format && *it == 'r')
+| 194|    |-				result.push_back(NC::Format::Reverse);
+| 195|    |-			else if (flags & Format::Flags::Format && *it == '/')
+| 196|    |-			{
+| 197|    |-				++it;
+| 198|    |-				rangeCheck(s, it, end);
+| 199|    |-				if (*it == 'b')
+| 200|    |-					result.push_back(NC::Format::NoBold);
+| 201|    |-				else if (*it == 'u')
+| 202|    |-					result.push_back(NC::Format::NoUnderline);
+| 203|    |-				else if (*it == 'a')
+| 204|    |-					result.push_back(NC::Format::NoAltCharset);
+| 205|    |-				else if (*it == 'r')
+| 206|    |-					result.push_back(NC::Format::NoReverse);
+| 207|    |-				else
+| 208|    |-					throwError(s, it, invalidCharacter(*it));
+| 209|    |-			}
+| 210|    |-			else
+| 211|    |-				throwError(s, it, invalidCharacter(*it));
+| 212|    |-		}
+| 213|    |-		else
+| 214|    |-			token += *it;
+| 215|    |-	}
+| 216|    |-	push_token();
+| 217|    |-	return result;
+| 218|    |-}
+|    |  52|+    AST < wchar_t > parse (const std::wstring & s, const unsigned flags)
+|    |  53|+    {
+|    |  54|+        return AST < wchar_t > (parseBracket (s, s.begin (), s.end (), flags));
+|    |  55|+    }
+| 219|  56| 
+| 220|  57| }
+| 221|    |-
+| 222|    |-namespace Format {
+| 223|    |-
+| 224|    |-AST<char> parse(const std::string &s, const unsigned flags)
+| 225|    |-{
+| 226|    |-	return AST<char>(parseBracket(s, s.begin(), s.end(), flags));
+| 227|    |-}
+| 228|    |-
+| 229|    |-AST<wchar_t> parse(const std::wstring &s, const unsigned flags)
+| 230|    |-{
+| 231|    |-	return AST<wchar_t>(parseBracket(s, s.begin(), s.end(), flags));
+| 232|    |-}
+| 233|    |-
+| 234|    |-}
+
+src/format.cpp
+| 224| AST<char>•parse(const•std::string•&s,•const•unsigned•flags)
+|    | [NORMAL] CPPCleanBear:
+|    | 'parse' not found in any directly #included header
+
+src/format.cpp
+| 229| AST<wchar_t>•parse(const•std::wstring•&s,•const•unsigned•flags)
+|    | [NORMAL] CPPCleanBear:
+|    | 'parse' not found in any directly #included header
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/html.h
+|    |++++| /app/src/utility/html.h
+|  23|  23| 
+|  24|  24| #include <string>
+|  25|  25| 
+|  26|    |-std::string unescapeHtmlUtf8(const std::string &s);
+|  27|    |-void unescapeHtmlEntities(std::string &s);
+|  28|    |-void stripHtmlTags(std::string &s);
+|    |  26|+std::string unescapeHtmlUtf8 (const std::string & s);
+|    |  27|+void unescapeHtmlEntities (std::string & s);
+|    |  28|+void stripHtmlTags (std::string & s);
+|  29|  29| 
+|  30|  30| #endif // NCMPCPP_UTILITY_HTML_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mpdpp.cpp
+|    |++++| /app/src/mpdpp.cpp
+|  28|  28| 
+|  29|  29| MPD::Connection Mpd;
+|  30|  30| 
+|  31|    |-namespace {
+|  32|    |-
+|  33|    |-const char *mpdDirectory(const std::string &directory)
+|  34|    |-{
+|  35|    |-	// MPD <= 0.19 accepts "/" for a root directory whereas later
+|  36|    |-	// versions do not, so provide a compatibility layer.
+|  37|    |-	if (directory == "/")
+|  38|    |-		return "";
+|  39|    |-	else
+|  40|    |-		return directory.c_str();
+|    |  31|+namespace
+|    |  32|+{
+|    |  33|+
+|    |  34|+    const char *
+|    |  35|+    mpdDirectory (const std::string & directory)
+|    |  36|+    {
+|    |  37|+        // MPD <= 0.19 accepts "/" for a root directory whereas later
+|    |  38|+        // versions do not, so provide a compatibility layer.
+|    |  39|+        if (directory == "/")
+|    |  40|+            return "";
+|    |  41|+        else
+|    |  42|+            return directory.c_str ();
+|    |  43|+    }
+|    |  44|+
+|    |  45|+    template < typename ObjectT, typename SourceT >
+|    |  46|+        std::function < bool (typename MPD::Iterator < ObjectT >::State &) >
+|    |  47|+        defaultFetcher (SourceT * (fetcher) (mpd_connection *))
+|    |  48|+    {
+|    |  49|+        return[fetcher] (typename MPD::Iterator < ObjectT >::State & state)
+|    |  50|+        {
+|    |  51|+            auto
+|    |  52|+                src = fetcher (state.connection ());
+|    |  53|+            if (src != nullptr)
+|    |  54|+              {
+|    |  55|+                  state.setObject (src);
+|    |  56|+                  return true;
+|    |  57|+              }
+|    |  58|+            else
+|    |  59|+                return false;
+|    |  60|+        };
+|    |  61|+    }
+|    |  62|+
+|    |  63|+    bool
+|    |  64|+    fetchItemSong (MPD::SongIterator::State & state)
+|    |  65|+    {
+|    |  66|+        auto
+|    |  67|+            src = mpd_recv_entity (state.connection ());
+|    |  68|+        while (src != nullptr
+|    |  69|+               && mpd_entity_get_type (src) != MPD_ENTITY_TYPE_SONG)
+|    |  70|+          {
+|    |  71|+              mpd_entity_free (src);
+|    |  72|+              src = mpd_recv_entity (state.connection ());
+|    |  73|+          }
+|    |  74|+        if (src != nullptr)
+|    |  75|+          {
+|    |  76|+              state.setObject (mpd_song_dup (mpd_entity_get_song (src)));
+|    |  77|+              mpd_entity_free (src);
+|    |  78|+              return true;
+|    |  79|+          }
+|    |  80|+        else
+|    |  81|+            return false;
+|    |  82|+    }
+|    |  83|+
+|  41|  84| }
+|  42|  85| 
+|  43|  86| template <typename ObjectT, typename SourceT>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mpdpp.cpp
+|    |++++| /app/src/mpdpp.cpp
+|  40|  40| 		return directory.c_str();
+|  41|  41| }
+|  42|  42| 
+|  43|    |-template <typename ObjectT, typename SourceT>
+|  44|    |-std::function<bool(typename MPD::Iterator<ObjectT>::State &)>
+|  45|    |-defaultFetcher(SourceT *(fetcher)(mpd_connection *))
+|    |  43|+namespace
+|    |  44|+    MPD
+|  46|  45| {
+|  47|    |-	return [fetcher](typename MPD::Iterator<ObjectT>::State &state) {
+|  48|    |-		auto src = fetcher(state.connection());
+|  49|    |-		if (src != nullptr)
+|  50|    |-		{
+|  51|    |-			state.setObject(src);
+|  52|    |-			return true;
+|  53|    |-		}
+|  54|    |-		else
+|  55|    |-			return false;
+|  56|    |-	};
+|    |  46|+
+|    |  47|+    void
+|    |  48|+    checkConnectionErrors (mpd_connection * conn)
+|    |  49|+    {
+|    |  50|+        mpd_error
+|    |  51|+            code = mpd_connection_get_error (conn);
+|    |  52|+        if (code != MPD_ERROR_SUCCESS)
+|    |  53|+          {
+|    |  54|+              std::string msg = mpd_connection_get_error_message (conn);
+|    |  55|+              if (code == MPD_ERROR_SERVER)
+|    |  56|+                {
+|    |  57|+                    mpd_server_error
+|    |  58|+                        server_code = mpd_connection_get_server_error (conn);
+|    |  59|+                    bool
+|    |  60|+                        clearable = mpd_connection_clear_error (conn);
+|    |  61|+                    throw
+|    |  62|+                    ServerError (server_code, msg, clearable);
+|    |  63|+                }
+|    |  64|+              else
+|    |  65|+                {
+|    |  66|+                    bool
+|    |  67|+                        clearable = mpd_connection_clear_error (conn);
+|    |  68|+                    throw
+|    |  69|+                    ClientError (code, msg, clearable);
+|    |  70|+                }
+|    |  71|+          }
+|    |  72|+    }
+|    |  73|+
+|    |  74|+  Connection::Connection ():m_connection (nullptr),
+|    |  75|+        m_command_list_active (false),
+|    |  76|+        m_idle (false), m_host ("localhost"), m_port (6600), m_timeout (15)
+|    |  77|+    {
+|    |  78|+    }
+|    |  79|+
+|    |  80|+    void
+|    |  81|+    Connection::Connect ()
+|    |  82|+    {
+|    |  83|+        assert (!m_connection);
+|    |  84|+        try
+|    |  85|+        {
+|    |  86|+            m_connection.
+|    |  87|+                reset (mpd_connection_new
+|    |  88|+                       (m_host.c_str (), m_port, m_timeout * 1000));
+|    |  89|+            checkErrors ();
+|    |  90|+            if (!m_password.empty ())
+|    |  91|+                SendPassword ();
+|    |  92|+            m_fd = mpd_connection_get_fd (m_connection.get ());
+|    |  93|+            checkErrors ();
+|    |  94|+        }
+|    |  95|+        catch (MPD::ClientError & e)
+|    |  96|+        {
+|    |  97|+            Disconnect ();
+|    |  98|+            throw
+|    |  99|+                e;
+|    | 100|+        }
+|    | 101|+    }
+|    | 102|+
+|    | 103|+    bool
+|    | 104|+    Connection::Connected () const
+|    | 105|+    {
+|    | 106|+        return
+|    | 107|+            m_connection.
+|    | 108|+        get () !=
+|    | 109|+            nullptr;
+|    | 110|+    }
+|    | 111|+
+|    | 112|+    void
+|    | 113|+    Connection::Disconnect ()
+|    | 114|+    {
+|    | 115|+        m_connection = nullptr;
+|    | 116|+        m_command_list_active = false;
+|    | 117|+        m_idle = false;
+|    | 118|+    }
+|    | 119|+
+|    | 120|+    unsigned
+|    | 121|+    Connection::Version () const
+|    | 122|+    {
+|    | 123|+        return
+|    | 124|+            m_connection ?
+|    | 125|+        mpd_connection_get_server_version (m_connection.get ())[1] :
+|    | 126|+            0;
+|    | 127|+    }
+|    | 128|+
+|    | 129|+    void
+|    | 130|+    Connection::SetHostname (const std::string & host)
+|    | 131|+    {
+|    | 132|+        size_t
+|    | 133|+            at = host.find ("@");
+|    | 134|+        if (at != std::string::npos)
+|    | 135|+          {
+|    | 136|+              m_password = host.substr (0, at);
+|    | 137|+              m_host = host.substr (at + 1);
+|    | 138|+          }
+|    | 139|+        else
+|    | 140|+            m_host = host;
+|    | 141|+    }
+|    | 142|+
+|    | 143|+    void
+|    | 144|+    Connection::SendPassword ()
+|    | 145|+    {
+|    | 146|+        assert (m_connection);
+|    | 147|+        noidle ();
+|    | 148|+        assert (!m_command_list_active);
+|    | 149|+        mpd_run_password (m_connection.get (), m_password.c_str ());
+|    | 150|+        checkErrors ();
+|    | 151|+    }
+|    | 152|+
+|    | 153|+    void
+|    | 154|+    Connection::idle ()
+|    | 155|+    {
+|    | 156|+        checkConnection ();
+|    | 157|+        if (!m_idle)
+|    | 158|+          {
+|    | 159|+              mpd_send_idle (m_connection.get ());
+|    | 160|+              checkErrors ();
+|    | 161|+          }
+|    | 162|+        m_idle = true;
+|    | 163|+    }
+|    | 164|+
+|    | 165|+    int
+|    | 166|+    Connection::noidle ()
+|    | 167|+    {
+|    | 168|+        checkConnection ();
+|    | 169|+        int
+|    | 170|+            flags = 0;
+|    | 171|+        if (m_idle && mpd_send_noidle (m_connection.get ()))
+|    | 172|+          {
+|    | 173|+              m_idle = false;
+|    | 174|+              flags = mpd_recv_idle (m_connection.get (), true);
+|    | 175|+              mpd_response_finish (m_connection.get ());
+|    | 176|+              checkErrors ();
+|    | 177|+          }
+|    | 178|+        return flags;
+|    | 179|+    }
+|    | 180|+
+|    | 181|+    void
+|    | 182|+    Connection::setNoidleCallback (NoidleCallback callback)
+|    | 183|+    {
+|    | 184|+        m_noidle_callback = std::move (callback);
+|    | 185|+    }
+|    | 186|+
+|    | 187|+    Statistics
+|    | 188|+    Connection::getStatistics ()
+|    | 189|+    {
+|    | 190|+        prechecks ();
+|    | 191|+        mpd_stats *
+|    | 192|+            stats = mpd_run_stats (m_connection.get ());
+|    | 193|+        checkErrors ();
+|    | 194|+        return Statistics (stats);
+|    | 195|+    }
+|    | 196|+
+|    | 197|+    Status
+|    | 198|+    Connection::getStatus ()
+|    | 199|+    {
+|    | 200|+        prechecks ();
+|    | 201|+        mpd_status *
+|    | 202|+            status = mpd_run_status (m_connection.get ());
+|    | 203|+        checkErrors ();
+|    | 204|+        return Status (status);
+|    | 205|+    }
+|    | 206|+
+|    | 207|+    void
+|    | 208|+    Connection::UpdateDirectory (const std::string & path)
+|    | 209|+    {
+|    | 210|+        prechecksNoCommandsList ();
+|    | 211|+        mpd_run_update (m_connection.get (), path.c_str ());
+|    | 212|+        checkErrors ();
+|    | 213|+    }
+|    | 214|+
+|    | 215|+    void
+|    | 216|+    Connection::Play ()
+|    | 217|+    {
+|    | 218|+        prechecksNoCommandsList ();
+|    | 219|+        mpd_run_play (m_connection.get ());
+|    | 220|+        checkErrors ();
+|    | 221|+    }
+|    | 222|+
+|    | 223|+    void
+|    | 224|+    Connection::Play (int pos)
+|    | 225|+    {
+|    | 226|+        prechecksNoCommandsList ();
+|    | 227|+        mpd_run_play_pos (m_connection.get (), pos);
+|    | 228|+        checkErrors ();
+|    | 229|+    }
+|    | 230|+
+|    | 231|+    void
+|    | 232|+    Connection::PlayID (int id)
+|    | 233|+    {
+|    | 234|+        prechecksNoCommandsList ();
+|    | 235|+        mpd_run_play_id (m_connection.get (), id);
+|    | 236|+        checkErrors ();
+|    | 237|+    }
+|    | 238|+
+|    | 239|+    void
+|    | 240|+    Connection::Pause (bool state)
+|    | 241|+    {
+|    | 242|+        prechecksNoCommandsList ();
+|    | 243|+        mpd_run_pause (m_connection.get (), state);
+|    | 244|+        checkErrors ();
+|    | 245|+    }
+|    | 246|+
+|    | 247|+    void
+|    | 248|+    Connection::Toggle ()
+|    | 249|+    {
+|    | 250|+        prechecksNoCommandsList ();
+|    | 251|+        mpd_run_toggle_pause (m_connection.get ());
+|    | 252|+        checkErrors ();
+|    | 253|+    }
+|    | 254|+
+|    | 255|+    void
+|    | 256|+    Connection::Stop ()
+|    | 257|+    {
+|    | 258|+        prechecksNoCommandsList ();
+|    | 259|+        mpd_run_stop (m_connection.get ());
+|    | 260|+        checkErrors ();
+|    | 261|+    }
+|    | 262|+
+|    | 263|+    void
+|    | 264|+    Connection::Next ()
+|    | 265|+    {
+|    | 266|+        prechecksNoCommandsList ();
+|    | 267|+        mpd_run_next (m_connection.get ());
+|    | 268|+        checkErrors ();
+|    | 269|+    }
+|    | 270|+
+|    | 271|+    void
+|    | 272|+    Connection::Prev ()
+|    | 273|+    {
+|    | 274|+        prechecksNoCommandsList ();
+|    | 275|+        mpd_run_previous (m_connection.get ());
+|    | 276|+        checkErrors ();
+|    | 277|+    }
+|    | 278|+
+|    | 279|+    void
+|    | 280|+    Connection::Move (unsigned from, unsigned to)
+|    | 281|+    {
+|    | 282|+        prechecks ();
+|    | 283|+        if (m_command_list_active)
+|    | 284|+            mpd_send_move (m_connection.get (), from, to);
+|    | 285|+        else
+|    | 286|+          {
+|    | 287|+              mpd_run_move (m_connection.get (), from, to);
+|    | 288|+              checkErrors ();
+|    | 289|+          }
+|    | 290|+    }
+|    | 291|+
+|    | 292|+    void
+|    | 293|+    Connection::Swap (unsigned from, unsigned to)
+|    | 294|+    {
+|    | 295|+        prechecks ();
+|    | 296|+        if (m_command_list_active)
+|    | 297|+            mpd_send_swap (m_connection.get (), from, to);
+|    | 298|+        else
+|    | 299|+          {
+|    | 300|+              mpd_run_swap (m_connection.get (), from, to);
+|    | 301|+              checkErrors ();
+|    | 302|+          }
+|    | 303|+    }
+|    | 304|+
+|    | 305|+    void
+|    | 306|+    Connection::Seek (unsigned pos, unsigned where)
+|    | 307|+    {
+|    | 308|+        prechecksNoCommandsList ();
+|    | 309|+        mpd_run_seek_pos (m_connection.get (), pos, where);
+|    | 310|+        checkErrors ();
+|    | 311|+    }
+|    | 312|+
+|    | 313|+    void
+|    | 314|+    Connection::Shuffle ()
+|    | 315|+    {
+|    | 316|+        prechecksNoCommandsList ();
+|    | 317|+        mpd_run_shuffle (m_connection.get ());
+|    | 318|+        checkErrors ();
+|    | 319|+    }
+|    | 320|+
+|    | 321|+    void
+|    | 322|+    Connection::ShuffleRange (unsigned start, unsigned end)
+|    | 323|+    {
+|    | 324|+        prechecksNoCommandsList ();
+|    | 325|+        mpd_run_shuffle_range (m_connection.get (), start, end);
+|    | 326|+        checkErrors ();
+|    | 327|+    }
+|    | 328|+
+|    | 329|+    void
+|    | 330|+    Connection::ClearMainPlaylist ()
+|    | 331|+    {
+|    | 332|+        prechecksNoCommandsList ();
+|    | 333|+        mpd_run_clear (m_connection.get ());
+|    | 334|+        checkErrors ();
+|    | 335|+    }
+|    | 336|+
+|    | 337|+    void
+|    | 338|+    Connection::ClearPlaylist (const std::string & playlist)
+|    | 339|+    {
+|    | 340|+        prechecksNoCommandsList ();
+|    | 341|+        mpd_run_playlist_clear (m_connection.get (), playlist.c_str ());
+|    | 342|+        checkErrors ();
+|    | 343|+    }
+|    | 344|+
+|    | 345|+    void
+|    | 346|+    Connection::AddToPlaylist (const std::string & path, const Song & s)
+|    | 347|+    {
+|    | 348|+        AddToPlaylist (path, s.getURI ());
+|    | 349|+    }
+|    | 350|+
+|    | 351|+    void
+|    | 352|+    Connection::AddToPlaylist (const std::string & path,
+|    | 353|+                               const std::string & file)
+|    | 354|+    {
+|    | 355|+        prechecks ();
+|    | 356|+        if (m_command_list_active)
+|    | 357|+            mpd_send_playlist_add (m_connection.get (), path.c_str (),
+|    | 358|+                                   file.c_str ());
+|    | 359|+        else
+|    | 360|+          {
+|    | 361|+              mpd_run_playlist_add (m_connection.get (), path.c_str (),
+|    | 362|+                                    file.c_str ());
+|    | 363|+              checkErrors ();
+|    | 364|+          }
+|    | 365|+    }
+|    | 366|+
+|    | 367|+    void
+|    | 368|+    Connection::PlaylistMove (const std::string & path, int from, int to)
+|    | 369|+    {
+|    | 370|+        prechecks ();
+|    | 371|+        if (m_command_list_active)
+|    | 372|+            mpd_send_playlist_move (m_connection.get (), path.c_str (), from,
+|    | 373|+                                    to);
+|    | 374|+        else
+|    | 375|+          {
+|    | 376|+              mpd_send_playlist_move (m_connection.get (), path.c_str (), from,
+|    | 377|+                                      to);
+|    | 378|+              mpd_response_finish (m_connection.get ());
+|    | 379|+              checkErrors ();
+|    | 380|+          }
+|    | 381|+    }
+|    | 382|+
+|    | 383|+    void
+|    | 384|+    Connection::Rename (const std::string & from, const std::string & to)
+|    | 385|+    {
+|    | 386|+        prechecksNoCommandsList ();
+|    | 387|+        mpd_run_rename (m_connection.get (), from.c_str (), to.c_str ());
+|    | 388|+        checkErrors ();
+|    | 389|+    }
+|    | 390|+
+|    | 391|+    SongIterator
+|    | 392|+    Connection::GetPlaylistChanges (unsigned version)
+|    | 393|+    {
+|    | 394|+        prechecksNoCommandsList ();
+|    | 395|+        mpd_send_queue_changes_meta (m_connection.get (), version);
+|    | 396|+        checkErrors ();
+|    | 397|+        return SongIterator (m_connection.get (),
+|    | 398|+                             defaultFetcher < Song > (mpd_recv_song));
+|    | 399|+    }
+|    | 400|+
+|    | 401|+    Song
+|    | 402|+    Connection::GetCurrentSong ()
+|    | 403|+    {
+|    | 404|+        prechecksNoCommandsList ();
+|    | 405|+        mpd_send_current_song (m_connection.get ());
+|    | 406|+        mpd_song *
+|    | 407|+            s = mpd_recv_song (m_connection.get ());
+|    | 408|+        mpd_response_finish (m_connection.get ());
+|    | 409|+        checkErrors ();
+|    | 410|+        // currentsong doesn't return error if there is no playing song.
+|    | 411|+        if (s == nullptr)
+|    | 412|+            return Song ();
+|    | 413|+        else
+|    | 414|+            return Song (s);
+|    | 415|+    }
+|    | 416|+
+|    | 417|+    Song
+|    | 418|+    Connection::GetSong (const std::string & path)
+|    | 419|+    {
+|    | 420|+        prechecksNoCommandsList ();
+|    | 421|+        mpd_send_list_all_meta (m_connection.get (), path.c_str ());
+|    | 422|+        mpd_song *
+|    | 423|+            s = mpd_recv_song (m_connection.get ());
+|    | 424|+        mpd_response_finish (m_connection.get ());
+|    | 425|+        checkErrors ();
+|    | 426|+        return Song (s);
+|    | 427|+    }
+|    | 428|+
+|    | 429|+    SongIterator
+|    | 430|+    Connection::GetPlaylistContent (const std::string & path)
+|    | 431|+    {
+|    | 432|+        prechecksNoCommandsList ();
+|    | 433|+        mpd_send_list_playlist_meta (m_connection.get (), path.c_str ());
+|    | 434|+        SongIterator
+|    | 435|+        result (m_connection.get (), defaultFetcher < Song > (mpd_recv_song));
+|    | 436|+        checkErrors ();
+|    | 437|+        return result;
+|    | 438|+    }
+|    | 439|+
+|    | 440|+    SongIterator
+|    | 441|+    Connection::GetPlaylistContentNoInfo (const std::string & path)
+|    | 442|+    {
+|    | 443|+        prechecksNoCommandsList ();
+|    | 444|+        mpd_send_list_playlist (m_connection.get (), path.c_str ());
+|    | 445|+        SongIterator
+|    | 446|+        result (m_connection.get (), defaultFetcher < Song > (mpd_recv_song));
+|    | 447|+        checkErrors ();
+|    | 448|+        return result;
+|    | 449|+    }
+|    | 450|+
+|    | 451|+    StringIterator
+|    | 452|+    Connection::GetSupportedExtensions ()
+|    | 453|+    {
+|    | 454|+        prechecksNoCommandsList ();
+|    | 455|+        mpd_send_command (m_connection.get (), "decoders", NULL);
+|    | 456|+        checkErrors ();
+|    | 457|+        return StringIterator (m_connection.get (),
+|    | 458|+                               [](StringIterator::State & state)
+|    | 459|+                               {
+|    | 460|+                               auto src =
+|    | 461|+                               mpd_recv_pair_named (state.connection (),
+|    | 462|+                                                    "suffix");
+|    | 463|+                               if (src != nullptr)
+|    | 464|+                               {
+|    | 465|+                               state.setObject (src->value);
+|    | 466|+                               mpd_return_pair (state.connection (), src);
+|    | 467|+                               return true;}
+|    | 468|+                               else
+|    | 469|+                               return false;}
+|    | 470|+        ) ;
+|    | 471|+    }
+|    | 472|+
+|    | 473|+    void
+|    | 474|+    Connection::SetRepeat (bool mode)
+|    | 475|+    {
+|    | 476|+        prechecksNoCommandsList ();
+|    | 477|+        mpd_run_repeat (m_connection.get (), mode);
+|    | 478|+        checkErrors ();
+|    | 479|+    }
+|    | 480|+
+|    | 481|+    void
+|    | 482|+    Connection::SetRandom (bool mode)
+|    | 483|+    {
+|    | 484|+        prechecksNoCommandsList ();
+|    | 485|+        mpd_run_random (m_connection.get (), mode);
+|    | 486|+        checkErrors ();
+|    | 487|+    }
+|    | 488|+
+|    | 489|+    void
+|    | 490|+    Connection::SetSingle (bool mode)
+|    | 491|+    {
+|    | 492|+        prechecksNoCommandsList ();
+|    | 493|+        mpd_run_single (m_connection.get (), mode);
+|    | 494|+        checkErrors ();
+|    | 495|+    }
+|    | 496|+
+|    | 497|+    void
+|    | 498|+    Connection::SetConsume (bool mode)
+|    | 499|+    {
+|    | 500|+        prechecksNoCommandsList ();
+|    | 501|+        mpd_run_consume (m_connection.get (), mode);
+|    | 502|+        checkErrors ();
+|    | 503|+    }
+|    | 504|+
+|    | 505|+    void
+|    | 506|+    Connection::SetVolume (unsigned vol)
+|    | 507|+    {
+|    | 508|+        prechecksNoCommandsList ();
+|    | 509|+        mpd_run_set_volume (m_connection.get (), vol);
+|    | 510|+        checkErrors ();
+|    | 511|+    }
+|    | 512|+
+|    | 513|+    void
+|    | 514|+    Connection::ChangeVolume (int change)
+|    | 515|+    {
+|    | 516|+        prechecksNoCommandsList ();
+|    | 517|+        mpd_run_change_volume (m_connection.get (), change);
+|    | 518|+        checkErrors ();
+|    | 519|+    }
+|    | 520|+
+|    | 521|+    std::string Connection::GetReplayGainMode ()
+|    | 522|+    {
+|    | 523|+        prechecksNoCommandsList ();
+|    | 524|+        mpd_send_command (m_connection.get (), "replay_gain_status", NULL);
+|    | 525|+        std::string result;
+|    | 526|+        if (mpd_pair * pair =
+|    | 527|+            mpd_recv_pair_named (m_connection.get (), "replay_gain_mode"))
+|    | 528|+          {
+|    | 529|+              result = pair->value;
+|    | 530|+              mpd_return_pair (m_connection.get (), pair);
+|    | 531|+          }
+|    | 532|+        mpd_response_finish (m_connection.get ());
+|    | 533|+        checkErrors ();
+|    | 534|+        return result;
+|    | 535|+    }
+|    | 536|+
+|    | 537|+    void
+|    | 538|+    Connection::SetReplayGainMode (ReplayGainMode mode)
+|    | 539|+    {
+|    | 540|+        prechecksNoCommandsList ();
+|    | 541|+        const char *
+|    | 542|+            rg_mode;
+|    | 543|+        switch (mode)
+|    | 544|+          {
+|    | 545|+          case rgmOff:
+|    | 546|+              rg_mode = "off";
+|    | 547|+              break;
+|    | 548|+          case rgmTrack:
+|    | 549|+              rg_mode = "track";
+|    | 550|+              break;
+|    | 551|+          case rgmAlbum:
+|    | 552|+              rg_mode = "album";
+|    | 553|+              break;
+|    | 554|+          default:
+|    | 555|+              rg_mode = "";
+|    | 556|+              break;
+|    | 557|+          }
+|    | 558|+        mpd_send_command (m_connection.get (), "replay_gain_mode", rg_mode,
+|    | 559|+                          NULL);
+|    | 560|+        mpd_response_finish (m_connection.get ());
+|    | 561|+        checkErrors ();
+|    | 562|+    }
+|    | 563|+
+|    | 564|+    void
+|    | 565|+    Connection::SetCrossfade (unsigned crossfade)
+|    | 566|+    {
+|    | 567|+        prechecksNoCommandsList ();
+|    | 568|+        mpd_run_crossfade (m_connection.get (), crossfade);
+|    | 569|+        checkErrors ();
+|    | 570|+    }
+|    | 571|+
+|    | 572|+    void
+|    | 573|+    Connection::SetPriority (const Song & s, int prio)
+|    | 574|+    {
+|    | 575|+        prechecks ();
+|    | 576|+        if (m_command_list_active)
+|    | 577|+            mpd_send_prio_id (m_connection.get (), prio, s.getID ());
+|    | 578|+        else
+|    | 579|+          {
+|    | 580|+              mpd_run_prio_id (m_connection.get (), prio, s.getID ());
+|    | 581|+              checkErrors ();
+|    | 582|+          }
+|    | 583|+    }
+|    | 584|+
+|    | 585|+    int
+|    | 586|+    Connection::AddSong (const std::string & path, int pos)
+|    | 587|+    {
+|    | 588|+        prechecks ();
+|    | 589|+        int
+|    | 590|+            id;
+|    | 591|+        if (pos < 0)
+|    | 592|+            mpd_send_add_id (m_connection.get (), path.c_str ());
+|    | 593|+        else
+|    | 594|+            mpd_send_add_id_to (m_connection.get (), path.c_str (), pos);
+|    | 595|+        if (!m_command_list_active)
+|    | 596|+          {
+|    | 597|+              id = mpd_recv_song_id (m_connection.get ());
+|    | 598|+              mpd_response_finish (m_connection.get ());
+|    | 599|+              checkErrors ();
+|    | 600|+          }
+|    | 601|+        else
+|    | 602|+            id = 0;
+|    | 603|+        return id;
+|    | 604|+    }
+|    | 605|+
+|    | 606|+    int
+|    | 607|+    Connection::AddSong (const Song & s, int pos)
+|    | 608|+    {
+|    | 609|+        return AddSong ((!s.isFromDatabase ()? "file://" : "") + s.getURI (),
+|    | 610|+                        pos);
+|    | 611|+    }
+|    | 612|+
+|    | 613|+    void
+|    | 614|+    Connection::Add (const std::string & path)
+|    | 615|+    {
+|    | 616|+        prechecks ();
+|    | 617|+        if (m_command_list_active)
+|    | 618|+            mpd_send_add (m_connection.get (), path.c_str ());
+|    | 619|+        else
+|    | 620|+          {
+|    | 621|+              mpd_run_add (m_connection.get (), path.c_str ());
+|    | 622|+              checkErrors ();
+|    | 623|+          }
+|    | 624|+    }
+|    | 625|+
+|    | 626|+    bool
+|    | 627|+    Connection::AddRandomTag (mpd_tag_type tag, size_t number,
+|    | 628|+                              std::mt19937 & rng)
+|    | 629|+    {
+|    | 630|+        std::vector < std::string >
+|    | 631|+            tags (std::make_move_iterator (GetList (tag)),
+|    | 632|+                  std::make_move_iterator (StringIterator ()));
+|    | 633|+        if (number > tags.size ())
+|    | 634|+            return false;
+|    | 635|+
+|    | 636|+        std::shuffle (tags.begin (), tags.end (), rng);
+|    | 637|+        auto
+|    | 638|+            it = tags.begin ();
+|    | 639|+        for (size_t i = 0; i < number && it != tags.end (); ++i)
+|    | 640|+          {
+|    | 641|+              StartSearch (true);
+|    | 642|+              AddSearch (tag, *it++);
+|    | 643|+              std::vector < std::string > paths;
+|    | 644|+              MPD::SongIterator s = CommitSearchSongs (), end;
+|    | 645|+              for (; s != end; ++s)
+|    | 646|+                  paths.push_back (s->getURI ());
+|    | 647|+              StartCommandsList ();
+|    | 648|+            for (const auto & path:paths)
+|    | 649|+                  AddSong (path);
+|    | 650|+              CommitCommandsList ();
+|    | 651|+          }
+|    | 652|+        return true;
+|    | 653|+    }
+|    | 654|+
+|    | 655|+    bool
+|    | 656|+    Connection::AddRandomSongs (size_t number, std::mt19937 & rng)
+|    | 657|+    {
+|    | 658|+        prechecksNoCommandsList ();
+|    | 659|+        std::vector < std::string > files;
+|    | 660|+        mpd_send_list_all (m_connection.get (), "/");
+|    | 661|+        while (mpd_pair * item =
+|    | 662|+               mpd_recv_pair_named (m_connection.get (), "file"))
+|    | 663|+          {
+|    | 664|+              files.push_back (item->value);
+|    | 665|+              mpd_return_pair (m_connection.get (), item);
+|    | 666|+          }
+|    | 667|+        mpd_response_finish (m_connection.get ());
+|    | 668|+        checkErrors ();
+|    | 669|+
+|    | 670|+        if (number > files.size ())
+|    | 671|+          {
+|    | 672|+              //if (itsErrorHandler)
+|    | 673|+              //  itsErrorHandler(this, 0, "Requested number of random songs is bigger than size of your library", itsErrorHandlerUserdata);
+|    | 674|+              return false;
+|    | 675|+          }
+|    | 676|+        else
+|    | 677|+          {
+|    | 678|+              std::shuffle (files.begin (), files.end (), rng);
+|    | 679|+              StartCommandsList ();
+|    | 680|+              auto
+|    | 681|+                  it = files.begin ();
+|    | 682|+              for (size_t i = 0; i < number && it != files.end (); ++i, ++it)
+|    | 683|+                  AddSong (*it);
+|    | 684|+              CommitCommandsList ();
+|    | 685|+          }
+|    | 686|+        return true;
+|    | 687|+    }
+|    | 688|+
+|    | 689|+    void
+|    | 690|+    Connection::Delete (unsigned pos)
+|    | 691|+    {
+|    | 692|+        prechecks ();
+|    | 693|+        mpd_send_delete (m_connection.get (), pos);
+|    | 694|+        if (!m_command_list_active)
+|    | 695|+          {
+|    | 696|+              mpd_response_finish (m_connection.get ());
+|    | 697|+              checkErrors ();
+|    | 698|+          }
+|    | 699|+    }
+|    | 700|+
+|    | 701|+    void
+|    | 702|+    Connection::PlaylistDelete (const std::string & playlist, unsigned pos)
+|    | 703|+    {
+|    | 704|+        prechecks ();
+|    | 705|+        mpd_send_playlist_delete (m_connection.get (), playlist.c_str (), pos);
+|    | 706|+        if (!m_command_list_active)
+|    | 707|+          {
+|    | 708|+              mpd_response_finish (m_connection.get ());
+|    | 709|+              checkErrors ();
+|    | 710|+          }
+|    | 711|+    }
+|    | 712|+
+|    | 713|+    void
+|    | 714|+    Connection::StartCommandsList ()
+|    | 715|+    {
+|    | 716|+        prechecksNoCommandsList ();
+|    | 717|+        mpd_command_list_begin (m_connection.get (), true);
+|    | 718|+        m_command_list_active = true;
+|    | 719|+        checkErrors ();
+|    | 720|+    }
+|    | 721|+
+|    | 722|+    void
+|    | 723|+    Connection::CommitCommandsList ()
+|    | 724|+    {
+|    | 725|+        prechecks ();
+|    | 726|+        assert (m_command_list_active);
+|    | 727|+        mpd_command_list_end (m_connection.get ());
+|    | 728|+        mpd_response_finish (m_connection.get ());
+|    | 729|+        m_command_list_active = false;
+|    | 730|+        checkErrors ();
+|    | 731|+    }
+|    | 732|+
+|    | 733|+    void
+|    | 734|+    Connection::DeletePlaylist (const std::string & name)
+|    | 735|+    {
+|    | 736|+        prechecksNoCommandsList ();
+|    | 737|+        mpd_run_rm (m_connection.get (), name.c_str ());
+|    | 738|+        checkErrors ();
+|    | 739|+    }
+|    | 740|+
+|    | 741|+    void
+|    | 742|+    Connection::LoadPlaylist (const std::string & name)
+|    | 743|+    {
+|    | 744|+        prechecksNoCommandsList ();
+|    | 745|+        mpd_run_load (m_connection.get (), name.c_str ());
+|    | 746|+        checkErrors ();
+|    | 747|+    }
+|    | 748|+
+|    | 749|+    void
+|    | 750|+    Connection::SavePlaylist (const std::string & name)
+|    | 751|+    {
+|    | 752|+        prechecksNoCommandsList ();
+|    | 753|+        mpd_send_save (m_connection.get (), name.c_str ());
+|    | 754|+        mpd_response_finish (m_connection.get ());
+|    | 755|+        checkErrors ();
+|    | 756|+    }
+|    | 757|+
+|    | 758|+    PlaylistIterator
+|    | 759|+    Connection::GetPlaylists ()
+|    | 760|+    {
+|    | 761|+        prechecksNoCommandsList ();
+|    | 762|+        mpd_send_list_playlists (m_connection.get ());
+|    | 763|+        checkErrors ();
+|    | 764|+        return PlaylistIterator (m_connection.get (),
+|    | 765|+                                 defaultFetcher < Playlist >
+|    | 766|+                                 (mpd_recv_playlist));
+|    | 767|+    }
+|    | 768|+
+|    | 769|+    StringIterator
+|    | 770|+    Connection::GetList (mpd_tag_type type)
+|    | 771|+    {
+|    | 772|+        prechecksNoCommandsList ();
+|    | 773|+        mpd_search_db_tags (m_connection.get (), type);
+|    | 774|+        mpd_search_commit (m_connection.get ());
+|    | 775|+        checkErrors ();
+|    | 776|+        return StringIterator (m_connection.get (),
+|    | 777|+                               [type] (StringIterator::State & state)
+|    | 778|+                               {
+|    | 779|+                               auto src =
+|    | 780|+                               mpd_recv_pair_tag (state.connection (), type);
+|    | 781|+                               if (src != nullptr)
+|    | 782|+                               {
+|    | 783|+                               state.setObject (src->value);
+|    | 784|+                               mpd_return_pair (state.connection (), src);
+|    | 785|+                               return true;}
+|    | 786|+                               else
+|    | 787|+                               return false;}
+|    | 788|+        ) ;
+|    | 789|+    }
+|    | 790|+
+|    | 791|+    void
+|    | 792|+    Connection::StartSearch (bool exact_match)
+|    | 793|+    {
+|    | 794|+        prechecksNoCommandsList ();
+|    | 795|+        mpd_search_db_songs (m_connection.get (), exact_match);
+|    | 796|+    }
+|    | 797|+
+|    | 798|+    void
+|    | 799|+    Connection::StartFieldSearch (mpd_tag_type item)
+|    | 800|+    {
+|    | 801|+        prechecksNoCommandsList ();
+|    | 802|+        mpd_search_db_tags (m_connection.get (), item);
+|    | 803|+    }
+|    | 804|+
+|    | 805|+    void
+|    | 806|+    Connection::AddSearch (mpd_tag_type item, const std::string & str) const
+|    | 807|+    {
+|    | 808|+        checkConnection ();
+|    | 809|+        mpd_search_add_tag_constraint (m_connection.get (),
+|    | 810|+                                       MPD_OPERATOR_DEFAULT, item,
+|    | 811|+                                       str.c_str ());
+|    | 812|+    }
+|    | 813|+
+|    | 814|+    void
+|    | 815|+    Connection::AddSearchAny (const std::string & str) const
+|    | 816|+    {
+|    | 817|+        checkConnection ();
+|    | 818|+        mpd_search_add_any_tag_constraint (m_connection.get (),
+|    | 819|+                                           MPD_OPERATOR_DEFAULT, str.c_str ());
+|    | 820|+    }
+|    | 821|+
+|    | 822|+    void
+|    | 823|+    Connection::AddSearchURI (const std::string & str) const
+|    | 824|+    {
+|    | 825|+        checkConnection ();
+|    | 826|+        mpd_search_add_uri_constraint (m_connection.get (),
+|    | 827|+                                       MPD_OPERATOR_DEFAULT, str.c_str ());
+|    | 828|+    }
+|    | 829|+
+|    | 830|+    SongIterator
+|    | 831|+    Connection::CommitSearchSongs ()
+|    | 832|+    {
+|    | 833|+        prechecksNoCommandsList ();
+|    | 834|+        mpd_search_commit (m_connection.get ());
+|    | 835|+        checkErrors ();
+|    | 836|+        return SongIterator (m_connection.get (),
+|    | 837|+                             defaultFetcher < Song > (mpd_recv_song));
+|    | 838|+    }
+|    | 839|+
+|    | 840|+    ItemIterator
+|    | 841|+    Connection::GetDirectory (const std::string & directory)
+|    | 842|+    {
+|    | 843|+        prechecksNoCommandsList ();
+|    | 844|+        mpd_send_list_meta (m_connection.get (), mpdDirectory (directory));
+|    | 845|+        checkErrors ();
+|    | 846|+        return ItemIterator (m_connection.get (),
+|    | 847|+                             defaultFetcher < Item > (mpd_recv_entity));
+|    | 848|+    }
+|    | 849|+
+|    | 850|+    SongIterator
+|    | 851|+    Connection::GetDirectoryRecursive (const std::string & directory)
+|    | 852|+    {
+|    | 853|+        prechecksNoCommandsList ();
+|    | 854|+        mpd_send_list_all_meta (m_connection.get (), mpdDirectory (directory));
+|    | 855|+        checkErrors ();
+|    | 856|+        return SongIterator (m_connection.get (), fetchItemSong);
+|    | 857|+    }
+|    | 858|+
+|    | 859|+    DirectoryIterator
+|    | 860|+    Connection::GetDirectories (const std::string & directory)
+|    | 861|+    {
+|    | 862|+        prechecksNoCommandsList ();
+|    | 863|+        mpd_send_list_meta (m_connection.get (), mpdDirectory (directory));
+|    | 864|+        checkErrors ();
+|    | 865|+        return DirectoryIterator (m_connection.get (),
+|    | 866|+                                  defaultFetcher < Directory >
+|    | 867|+                                  (mpd_recv_directory));
+|    | 868|+    }
+|    | 869|+
+|    | 870|+    SongIterator
+|    | 871|+    Connection::GetSongs (const std::string & directory)
+|    | 872|+    {
+|    | 873|+        prechecksNoCommandsList ();
+|    | 874|+        mpd_send_list_meta (m_connection.get (), mpdDirectory (directory));
+|    | 875|+        checkErrors ();
+|    | 876|+        return SongIterator (m_connection.get (),
+|    | 877|+                             defaultFetcher < Song > (mpd_recv_song));
+|    | 878|+    }
+|    | 879|+
+|    | 880|+    OutputIterator
+|    | 881|+    Connection::GetOutputs ()
+|    | 882|+    {
+|    | 883|+        prechecksNoCommandsList ();
+|    | 884|+        mpd_send_outputs (m_connection.get ());
+|    | 885|+        checkErrors ();
+|    | 886|+        return OutputIterator (m_connection.get (),
+|    | 887|+                               defaultFetcher < Output > (mpd_recv_output));
+|    | 888|+    }
+|    | 889|+
+|    | 890|+    void
+|    | 891|+    Connection::EnableOutput (int id)
+|    | 892|+    {
+|    | 893|+        prechecksNoCommandsList ();
+|    | 894|+        mpd_run_enable_output (m_connection.get (), id);
+|    | 895|+        checkErrors ();
+|    | 896|+    }
+|    | 897|+
+|    | 898|+    void
+|    | 899|+    Connection::DisableOutput (int id)
+|    | 900|+    {
+|    | 901|+        prechecksNoCommandsList ();
+|    | 902|+        mpd_run_disable_output (m_connection.get (), id);
+|    | 903|+        checkErrors ();
+|    | 904|+    }
+|    | 905|+
+|    | 906|+    StringIterator
+|    | 907|+    Connection::GetURLHandlers ()
+|    | 908|+    {
+|    | 909|+        prechecksNoCommandsList ();
+|    | 910|+        mpd_send_list_url_schemes (m_connection.get ());
+|    | 911|+        checkErrors ();
+|    | 912|+        return StringIterator (m_connection.get (),
+|    | 913|+                               [](StringIterator::State & state)
+|    | 914|+                               {
+|    | 915|+                               auto src =
+|    | 916|+                               mpd_recv_pair_named (state.connection (),
+|    | 917|+                                                    "handler");
+|    | 918|+                               if (src != nullptr)
+|    | 919|+                               {
+|    | 920|+                               state.setObject (src->value);
+|    | 921|+                               mpd_return_pair (state.connection (), src);
+|    | 922|+                               return true;}
+|    | 923|+                               else
+|    | 924|+                               return false;}
+|    | 925|+        ) ;
+|    | 926|+    }
+|    | 927|+
+|    | 928|+    StringIterator
+|    | 929|+    Connection::GetTagTypes ()
+|    | 930|+    {
+|    | 931|+
+|    | 932|+        prechecksNoCommandsList ();
+|    | 933|+        mpd_send_list_tag_types (m_connection.get ());
+|    | 934|+        checkErrors ();
+|    | 935|+        return StringIterator (m_connection.get (),
+|    | 936|+                               [](StringIterator::State & state)
+|    | 937|+                               {
+|    | 938|+                               auto src =
+|    | 939|+                               mpd_recv_pair_named (state.connection (),
+|    | 940|+                                                    "tagtype");
+|    | 941|+                               if (src != nullptr)
+|    | 942|+                               {
+|    | 943|+                               state.setObject (src->value);
+|    | 944|+                               mpd_return_pair (state.connection (), src);
+|    | 945|+                               return true;}
+|    | 946|+                               else
+|    | 947|+                               return false;}
+|    | 948|+        ) ;
+|    | 949|+    }
+|    | 950|+
+|    | 951|+    void
+|    | 952|+    Connection::checkConnection () const
+|    | 953|+    {
+|    | 954|+        if (!m_connection)
+|    | 955|+            throw
+|    | 956|+            ClientError (MPD_ERROR_STATE, "No active MPD connection", false);
+|    | 957|+    }
+|    | 958|+
+|    | 959|+    void
+|    | 960|+    Connection::prechecks ()
+|    | 961|+    {
+|    | 962|+        checkConnection ();
+|    | 963|+        int
+|    | 964|+            flags = noidle ();
+|    | 965|+        if (flags && m_noidle_callback)
+|    | 966|+            m_noidle_callback (flags);
+|    | 967|+    }
+|    | 968|+
+|    | 969|+    void
+|    | 970|+    Connection::prechecksNoCommandsList ()
+|    | 971|+    {
+|    | 972|+        assert (!m_command_list_active);
+|    | 973|+        prechecks ();
+|    | 974|+    }
+|    | 975|+
+|    | 976|+    void
+|    | 977|+    Connection::checkErrors () const
+|    | 978|+    {
+|    | 979|+        checkConnectionErrors (m_connection.get ());
+|    | 980|+    }
+|    | 981|+
+|  57| 982| }
+|  58|    |-
+|  59|    |-bool fetchItemSong(MPD::SongIterator::State &state)
+|  60|    |-{
+|  61|    |-	auto src = mpd_recv_entity(state.connection());
+|  62|    |-	while (src != nullptr && mpd_entity_get_type(src) != MPD_ENTITY_TYPE_SONG)
+|  63|    |-	{
+|  64|    |-		mpd_entity_free(src);
+|  65|    |-		src = mpd_recv_entity(state.connection());
+|  66|    |-	}
+|  67|    |-	if (src != nullptr)
+|  68|    |-	{
+|  69|    |-		state.setObject(mpd_song_dup(mpd_entity_get_song(src)));
+|  70|    |-		mpd_entity_free(src);
+|  71|    |-		return true;
+|  72|    |-	}
+|  73|    |-	else
+|  74|    |-		return false;
+|  75|    |-}
+|  76|    |-
+|  77|    |-}
+|  78|    |-
+|  79|    |-namespace MPD {
+|  80|    |-
+|  81|    |-void checkConnectionErrors(mpd_connection *conn)
+|  82|    |-{
+|  83|    |-	mpd_error code = mpd_connection_get_error(conn);
+|  84|    |-	if (code != MPD_ERROR_SUCCESS)
+|  85|    |-	{
+|  86|    |-		std::string msg = mpd_connection_get_error_message(conn);
+|  87|    |-		if (code == MPD_ERROR_SERVER)
+|  88|    |-		{
+|  89|    |-			mpd_server_error server_code = mpd_connection_get_server_error(conn);
+|  90|    |-			bool clearable = mpd_connection_clear_error(conn);
+|  91|    |-			throw ServerError(server_code, msg, clearable);
+|  92|    |-		}
+|  93|    |-		else
+|  94|    |-		{
+|  95|    |-			bool clearable = mpd_connection_clear_error(conn);
+|  96|    |-			throw ClientError(code, msg, clearable);
+|  97|    |-		}
+|  98|    |-	}
+|  99|    |-}
+| 100|    |-
+| 101|    |-Connection::Connection() : m_connection(nullptr),
+| 102|    |-				m_command_list_active(false),
+| 103|    |-				m_idle(false),
+| 104|    |-				m_host("localhost"),
+| 105|    |-				m_port(6600),
+| 106|    |-				m_timeout(15)
+| 107|    |-{
+| 108|    |-}
+| 109|    |-
+| 110|    |-void Connection::Connect()
+| 111|    |-{
+| 112|    |-	assert(!m_connection);
+| 113|    |-	try
+| 114|    |-	{
+| 115|    |-		m_connection.reset(mpd_connection_new(m_host.c_str(), m_port, m_timeout * 1000));
+| 116|    |-		checkErrors();
+| 117|    |-		if (!m_password.empty())
+| 118|    |-			SendPassword();
+| 119|    |-		m_fd = mpd_connection_get_fd(m_connection.get());
+| 120|    |-		checkErrors();
+| 121|    |-	}
+| 122|    |-	catch (MPD::ClientError &e)
+| 123|    |-	{
+| 124|    |-		Disconnect();
+| 125|    |-		throw e;
+| 126|    |-	}
+| 127|    |-}
+| 128|    |-
+| 129|    |-bool Connection::Connected() const
+| 130|    |-{
+| 131|    |-	return m_connection.get() != nullptr;
+| 132|    |-}
+| 133|    |-
+| 134|    |-void Connection::Disconnect()
+| 135|    |-{
+| 136|    |-	m_connection = nullptr;
+| 137|    |-	m_command_list_active = false;
+| 138|    |-	m_idle = false;
+| 139|    |-}
+| 140|    |-
+| 141|    |-unsigned Connection::Version() const
+| 142|    |-{
+| 143|    |-	return m_connection ? mpd_connection_get_server_version(m_connection.get())[1] : 0;
+| 144|    |-}
+| 145|    |-
+| 146|    |-void Connection::SetHostname(const std::string &host)
+| 147|    |-{
+| 148|    |-	size_t at = host.find("@");
+| 149|    |-	if (at != std::string::npos)
+| 150|    |-	{
+| 151|    |-		m_password = host.substr(0, at);
+| 152|    |-		m_host = host.substr(at+1);
+| 153|    |-	}
+| 154|    |-	else
+| 155|    |-		m_host = host;
+| 156|    |-}
+| 157|    |-
+| 158|    |-void Connection::SendPassword()
+| 159|    |-{
+| 160|    |-	assert(m_connection);
+| 161|    |-	noidle();
+| 162|    |-	assert(!m_command_list_active);
+| 163|    |-	mpd_run_password(m_connection.get(), m_password.c_str());
+| 164|    |-	checkErrors();
+| 165|    |-}
+| 166|    |-
+| 167|    |-void Connection::idle()
+| 168|    |-{
+| 169|    |-	checkConnection();
+| 170|    |-	if (!m_idle)
+| 171|    |-	{
+| 172|    |-		mpd_send_idle(m_connection.get());
+| 173|    |-		checkErrors();
+| 174|    |-	}
+| 175|    |-	m_idle = true;
+| 176|    |-}
+| 177|    |-
+| 178|    |-int Connection::noidle()
+| 179|    |-{
+| 180|    |-	checkConnection();
+| 181|    |-	int flags = 0;
+| 182|    |-	if (m_idle && mpd_send_noidle(m_connection.get()))
+| 183|    |-	{
+| 184|    |-		m_idle = false;
+| 185|    |-		flags = mpd_recv_idle(m_connection.get(), true);
+| 186|    |-		mpd_response_finish(m_connection.get());
+| 187|    |-		checkErrors();
+| 188|    |-	}
+| 189|    |-	return flags;
+| 190|    |-}
+| 191|    |-
+| 192|    |-void Connection::setNoidleCallback(NoidleCallback callback)
+| 193|    |-{
+| 194|    |-	m_noidle_callback = std::move(callback);
+| 195|    |-}
+| 196|    |-
+| 197|    |-Statistics Connection::getStatistics()
+| 198|    |-{
+| 199|    |-	prechecks();
+| 200|    |-	mpd_stats *stats = mpd_run_stats(m_connection.get());
+| 201|    |-	checkErrors();
+| 202|    |-	return Statistics(stats);
+| 203|    |-}
+| 204|    |-
+| 205|    |-Status Connection::getStatus()
+| 206|    |-{
+| 207|    |-	prechecks();
+| 208|    |-	mpd_status *status = mpd_run_status(m_connection.get());
+| 209|    |-	checkErrors();
+| 210|    |-	return Status(status);
+| 211|    |-}
+| 212|    |-
+| 213|    |-void Connection::UpdateDirectory(const std::string &path)
+| 214|    |-{
+| 215|    |-	prechecksNoCommandsList();
+| 216|    |-	mpd_run_update(m_connection.get(), path.c_str());
+| 217|    |-	checkErrors();
+| 218|    |-}
+| 219|    |-
+| 220|    |-void Connection::Play()
+| 221|    |-{
+| 222|    |-	prechecksNoCommandsList();
+| 223|    |-	mpd_run_play(m_connection.get());
+| 224|    |-	checkErrors();
+| 225|    |-}
+| 226|    |-
+| 227|    |-void Connection::Play(int pos)
+| 228|    |-{
+| 229|    |-	prechecksNoCommandsList();
+| 230|    |-	mpd_run_play_pos(m_connection.get(), pos);
+| 231|    |-	checkErrors();
+| 232|    |-}
+| 233|    |-
+| 234|    |-void Connection::PlayID(int id)
+| 235|    |-{
+| 236|    |-	prechecksNoCommandsList();
+| 237|    |-	mpd_run_play_id(m_connection.get(), id);
+| 238|    |-	checkErrors();
+| 239|    |-}
+| 240|    |-
+| 241|    |-void Connection::Pause(bool state)
+| 242|    |-{
+| 243|    |-	prechecksNoCommandsList();
+| 244|    |-	mpd_run_pause(m_connection.get(), state);
+| 245|    |-	checkErrors();
+| 246|    |-}
+| 247|    |-
+| 248|    |-void Connection::Toggle()
+| 249|    |-{
+| 250|    |-	prechecksNoCommandsList();
+| 251|    |-	mpd_run_toggle_pause(m_connection.get());
+| 252|    |-	checkErrors();
+| 253|    |-}
+| 254|    |-
+| 255|    |-void Connection::Stop()
+| 256|    |-{
+| 257|    |-	prechecksNoCommandsList();
+| 258|    |-	mpd_run_stop(m_connection.get());
+| 259|    |-	checkErrors();
+| 260|    |-}
+| 261|    |-
+| 262|    |-void Connection::Next()
+| 263|    |-{
+| 264|    |-	prechecksNoCommandsList();
+| 265|    |-	mpd_run_next(m_connection.get());
+| 266|    |-	checkErrors();
+| 267|    |-}
+| 268|    |-
+| 269|    |-void Connection::Prev()
+| 270|    |-{
+| 271|    |-	prechecksNoCommandsList();
+| 272|    |-	mpd_run_previous(m_connection.get());
+| 273|    |-	checkErrors();
+| 274|    |-}
+| 275|    |-
+| 276|    |-void Connection::Move(unsigned from, unsigned to)
+| 277|    |-{
+| 278|    |-	prechecks();
+| 279|    |-	if (m_command_list_active)
+| 280|    |-		mpd_send_move(m_connection.get(), from, to);
+| 281|    |-	else
+| 282|    |-	{
+| 283|    |-		mpd_run_move(m_connection.get(), from, to);
+| 284|    |-		checkErrors();
+| 285|    |-	}
+| 286|    |-}
+| 287|    |-
+| 288|    |-void Connection::Swap(unsigned from, unsigned to)
+| 289|    |-{
+| 290|    |-	prechecks();
+| 291|    |-	if (m_command_list_active)
+| 292|    |-		mpd_send_swap(m_connection.get(), from, to);
+| 293|    |-	else
+| 294|    |-	{
+| 295|    |-		mpd_run_swap(m_connection.get(), from, to);
+| 296|    |-		checkErrors();
+| 297|    |-	}
+| 298|    |-}
+| 299|    |-
+| 300|    |-void Connection::Seek(unsigned pos, unsigned where)
+| 301|    |-{
+| 302|    |-	prechecksNoCommandsList();
+| 303|    |-	mpd_run_seek_pos(m_connection.get(), pos, where);
+| 304|    |-	checkErrors();
+| 305|    |-}
+| 306|    |-
+| 307|    |-void Connection::Shuffle()
+| 308|    |-{
+| 309|    |-	prechecksNoCommandsList();
+| 310|    |-	mpd_run_shuffle(m_connection.get());
+| 311|    |-	checkErrors();
+| 312|    |-}
+| 313|    |-
+| 314|    |-void Connection::ShuffleRange(unsigned start, unsigned end)
+| 315|    |-{
+| 316|    |-	prechecksNoCommandsList();
+| 317|    |-	mpd_run_shuffle_range(m_connection.get(), start, end);
+| 318|    |-	checkErrors();
+| 319|    |-}
+| 320|    |-
+| 321|    |-void Connection::ClearMainPlaylist()
+| 322|    |-{
+| 323|    |-	prechecksNoCommandsList();
+| 324|    |-	mpd_run_clear(m_connection.get());
+| 325|    |-	checkErrors();
+| 326|    |-}
+| 327|    |-
+| 328|    |-void Connection::ClearPlaylist(const std::string &playlist)
+| 329|    |-{
+| 330|    |-	prechecksNoCommandsList();
+| 331|    |-	mpd_run_playlist_clear(m_connection.get(), playlist.c_str());
+| 332|    |-	checkErrors();
+| 333|    |-}
+| 334|    |-
+| 335|    |-void Connection::AddToPlaylist(const std::string &path, const Song &s)
+| 336|    |-{
+| 337|    |-	AddToPlaylist(path, s.getURI());
+| 338|    |-}
+| 339|    |-
+| 340|    |-void Connection::AddToPlaylist(const std::string &path, const std::string &file)
+| 341|    |-{
+| 342|    |-	prechecks();
+| 343|    |-	if (m_command_list_active)
+| 344|    |-		mpd_send_playlist_add(m_connection.get(), path.c_str(), file.c_str());
+| 345|    |-	else
+| 346|    |-	{
+| 347|    |-		mpd_run_playlist_add(m_connection.get(), path.c_str(), file.c_str());
+| 348|    |-		checkErrors();
+| 349|    |-	}
+| 350|    |-}
+| 351|    |-
+| 352|    |-void Connection::PlaylistMove(const std::string &path, int from, int to)
+| 353|    |-{
+| 354|    |-	prechecks();
+| 355|    |-	if (m_command_list_active)
+| 356|    |-		mpd_send_playlist_move(m_connection.get(), path.c_str(), from, to);
+| 357|    |-	else
+| 358|    |-	{
+| 359|    |-		mpd_send_playlist_move(m_connection.get(), path.c_str(), from, to);
+| 360|    |-		mpd_response_finish(m_connection.get());
+| 361|    |-		checkErrors();
+| 362|    |-	}
+| 363|    |-}
+| 364|    |-
+| 365|    |-void Connection::Rename(const std::string &from, const std::string &to)
+| 366|    |-{
+| 367|    |-	prechecksNoCommandsList();
+| 368|    |-	mpd_run_rename(m_connection.get(), from.c_str(), to.c_str());
+| 369|    |-	checkErrors();
+| 370|    |-}
+| 371|    |-
+| 372|    |-SongIterator Connection::GetPlaylistChanges(unsigned version)
+| 373|    |-{
+| 374|    |-	prechecksNoCommandsList();
+| 375|    |-	mpd_send_queue_changes_meta(m_connection.get(), version);
+| 376|    |-	checkErrors();
+| 377|    |-	return SongIterator(m_connection.get(), defaultFetcher<Song>(mpd_recv_song));
+| 378|    |-}
+| 379|    |-
+| 380|    |-Song Connection::GetCurrentSong()
+| 381|    |-{
+| 382|    |-	prechecksNoCommandsList();
+| 383|    |-	mpd_send_current_song(m_connection.get());
+| 384|    |-	mpd_song *s = mpd_recv_song(m_connection.get());
+| 385|    |-	mpd_response_finish(m_connection.get());
+| 386|    |-	checkErrors();
+| 387|    |-	// currentsong doesn't return error if there is no playing song.
+| 388|    |-	if (s == nullptr)
+| 389|    |-		return Song();
+| 390|    |-	else
+| 391|    |-		return Song(s);
+| 392|    |-}
+| 393|    |-
+| 394|    |-Song Connection::GetSong(const std::string &path)
+| 395|    |-{
+| 396|    |-	prechecksNoCommandsList();
+| 397|    |-	mpd_send_list_all_meta(m_connection.get(), path.c_str());
+| 398|    |-	mpd_song *s = mpd_recv_song(m_connection.get());
+| 399|    |-	mpd_response_finish(m_connection.get());
+| 400|    |-	checkErrors();
+| 401|    |-	return Song(s);
+| 402|    |-}
+| 403|    |-
+| 404|    |-SongIterator Connection::GetPlaylistContent(const std::string &path)
+| 405|    |-{
+| 406|    |-	prechecksNoCommandsList();
+| 407|    |-	mpd_send_list_playlist_meta(m_connection.get(), path.c_str());
+| 408|    |-	SongIterator result(m_connection.get(), defaultFetcher<Song>(mpd_recv_song));
+| 409|    |-	checkErrors();
+| 410|    |-	return result;
+| 411|    |-}
+| 412|    |-
+| 413|    |-SongIterator Connection::GetPlaylistContentNoInfo(const std::string &path)
+| 414|    |-{
+| 415|    |-	prechecksNoCommandsList();
+| 416|    |-	mpd_send_list_playlist(m_connection.get(), path.c_str());
+| 417|    |-	SongIterator result(m_connection.get(), defaultFetcher<Song>(mpd_recv_song));
+| 418|    |-	checkErrors();
+| 419|    |-	return result;
+| 420|    |-}
+| 421|    |-
+| 422|    |-StringIterator Connection::GetSupportedExtensions()
+| 423|    |-{
+| 424|    |-	prechecksNoCommandsList();
+| 425|    |-	mpd_send_command(m_connection.get(), "decoders", NULL);
+| 426|    |-	checkErrors();
+| 427|    |-	return StringIterator(m_connection.get(), [](StringIterator::State &state) {
+| 428|    |-		auto src = mpd_recv_pair_named(state.connection(), "suffix");
+| 429|    |-		if (src != nullptr)
+| 430|    |-		{
+| 431|    |-			state.setObject(src->value);
+| 432|    |-			mpd_return_pair(state.connection(), src);
+| 433|    |-			return true;
+| 434|    |-		}
+| 435|    |-		else
+| 436|    |-			return false;
+| 437|    |-	});
+| 438|    |-}
+| 439|    |-
+| 440|    |-void Connection::SetRepeat(bool mode)
+| 441|    |-{
+| 442|    |-	prechecksNoCommandsList();
+| 443|    |-	mpd_run_repeat(m_connection.get(), mode);
+| 444|    |-	checkErrors();
+| 445|    |-}
+| 446|    |-
+| 447|    |-void Connection::SetRandom(bool mode)
+| 448|    |-{
+| 449|    |-	prechecksNoCommandsList();
+| 450|    |-	mpd_run_random(m_connection.get(), mode);
+| 451|    |-	checkErrors();
+| 452|    |-}
+| 453|    |-
+| 454|    |-void Connection::SetSingle(bool mode)
+| 455|    |-{
+| 456|    |-	prechecksNoCommandsList();
+| 457|    |-	mpd_run_single(m_connection.get(), mode);
+| 458|    |-	checkErrors();
+| 459|    |-}
+| 460|    |-
+| 461|    |-void Connection::SetConsume(bool mode)
+| 462|    |-{
+| 463|    |-	prechecksNoCommandsList();
+| 464|    |-	mpd_run_consume(m_connection.get(), mode);
+| 465|    |-	checkErrors();
+| 466|    |-}
+| 467|    |-
+| 468|    |-void Connection::SetVolume(unsigned vol)
+| 469|    |-{
+| 470|    |-	prechecksNoCommandsList();
+| 471|    |-	mpd_run_set_volume(m_connection.get(), vol);
+| 472|    |-	checkErrors();
+| 473|    |-}
+| 474|    |-
+| 475|    |-void Connection::ChangeVolume(int change)
+| 476|    |-{
+| 477|    |-	prechecksNoCommandsList();
+| 478|    |-	mpd_run_change_volume(m_connection.get(), change);
+| 479|    |-	checkErrors();
+| 480|    |-}
+| 481|    |-
+| 482|    |-
+| 483|    |-std::string Connection::GetReplayGainMode()
+| 484|    |-{
+| 485|    |-	prechecksNoCommandsList();
+| 486|    |-	mpd_send_command(m_connection.get(), "replay_gain_status", NULL);
+| 487|    |-	std::string result;
+| 488|    |-	if (mpd_pair *pair = mpd_recv_pair_named(m_connection.get(), "replay_gain_mode"))
+| 489|    |-	{
+| 490|    |-		result = pair->value;
+| 491|    |-		mpd_return_pair(m_connection.get(), pair);
+| 492|    |-	}
+| 493|    |-	mpd_response_finish(m_connection.get());
+| 494|    |-	checkErrors();
+| 495|    |-	return result;
+| 496|    |-}
+| 497|    |-
+| 498|    |-void Connection::SetReplayGainMode(ReplayGainMode mode)
+| 499|    |-{
+| 500|    |-	prechecksNoCommandsList();
+| 501|    |-	const char *rg_mode;
+| 502|    |-	switch (mode)
+| 503|    |-	{
+| 504|    |-		case rgmOff:
+| 505|    |-			rg_mode = "off";
+| 506|    |-			break;
+| 507|    |-		case rgmTrack:
+| 508|    |-			rg_mode = "track";
+| 509|    |-			break;
+| 510|    |-		case rgmAlbum:
+| 511|    |-			rg_mode = "album";
+| 512|    |-			break;
+| 513|    |-		default:
+| 514|    |-			rg_mode = "";
+| 515|    |-			break;
+| 516|    |-	}
+| 517|    |-	mpd_send_command(m_connection.get(), "replay_gain_mode", rg_mode, NULL);
+| 518|    |-	mpd_response_finish(m_connection.get());
+| 519|    |-	checkErrors();
+| 520|    |-}
+| 521|    |-
+| 522|    |-void Connection::SetCrossfade(unsigned crossfade)
+| 523|    |-{
+| 524|    |-	prechecksNoCommandsList();
+| 525|    |-	mpd_run_crossfade(m_connection.get(), crossfade);
+| 526|    |-	checkErrors();
+| 527|    |-}
+| 528|    |-
+| 529|    |-void Connection::SetPriority(const Song &s, int prio)
+| 530|    |-{
+| 531|    |-	prechecks();
+| 532|    |-	if (m_command_list_active)
+| 533|    |-		mpd_send_prio_id(m_connection.get(), prio, s.getID());
+| 534|    |-	else
+| 535|    |-	{
+| 536|    |-		mpd_run_prio_id(m_connection.get(), prio, s.getID());
+| 537|    |-		checkErrors();
+| 538|    |-	}
+| 539|    |-}
+| 540|    |-
+| 541|    |-int Connection::AddSong(const std::string &path, int pos)
+| 542|    |-{
+| 543|    |-	prechecks();
+| 544|    |-	int id;
+| 545|    |-	if (pos < 0)
+| 546|    |-		mpd_send_add_id(m_connection.get(), path.c_str());
+| 547|    |-	else
+| 548|    |-		mpd_send_add_id_to(m_connection.get(), path.c_str(), pos);
+| 549|    |-	if (!m_command_list_active)
+| 550|    |-	{
+| 551|    |-		id = mpd_recv_song_id(m_connection.get());
+| 552|    |-		mpd_response_finish(m_connection.get());
+| 553|    |-		checkErrors();
+| 554|    |-	}
+| 555|    |-	else
+| 556|    |-		id = 0;
+| 557|    |-	return id;
+| 558|    |-}
+| 559|    |-
+| 560|    |-int Connection::AddSong(const Song &s, int pos)
+| 561|    |-{
+| 562|    |-	return AddSong((!s.isFromDatabase() ? "file://" : "") + s.getURI(), pos);
+| 563|    |-}
+| 564|    |-
+| 565|    |-void Connection::Add(const std::string &path)
+| 566|    |-{
+| 567|    |-	prechecks();
+| 568|    |-	if (m_command_list_active)
+| 569|    |-		mpd_send_add(m_connection.get(), path.c_str());
+| 570|    |-	else
+| 571|    |-	{
+| 572|    |-		mpd_run_add(m_connection.get(), path.c_str());
+| 573|    |-		checkErrors();
+| 574|    |-	}
+| 575|    |-}
+| 576|    |-
+| 577|    |-bool Connection::AddRandomTag(mpd_tag_type tag, size_t number, std::mt19937 &rng)
+| 578|    |-{
+| 579|    |-	std::vector<std::string> tags(
+| 580|    |-		std::make_move_iterator(GetList(tag)),
+| 581|    |-		std::make_move_iterator(StringIterator())
+| 582|    |-	);
+| 583|    |-	if (number > tags.size())
+| 584|    |-		return false;
+| 585|    |-
+| 586|    |-	std::shuffle(tags.begin(), tags.end(), rng);
+| 587|    |-	auto it = tags.begin();
+| 588|    |-	for (size_t i = 0; i < number && it != tags.end(); ++i)
+| 589|    |-	{
+| 590|    |-		StartSearch(true);
+| 591|    |-		AddSearch(tag, *it++);
+| 592|    |-		std::vector<std::string> paths;
+| 593|    |-		MPD::SongIterator s = CommitSearchSongs(), end;
+| 594|    |-		for (; s != end; ++s)
+| 595|    |-			paths.push_back(s->getURI());
+| 596|    |-		StartCommandsList();
+| 597|    |-		for (const auto &path : paths)
+| 598|    |-			AddSong(path);
+| 599|    |-		CommitCommandsList();
+| 600|    |-	}
+| 601|    |-	return true;
+| 602|    |-}
+| 603|    |-
+| 604|    |-bool Connection::AddRandomSongs(size_t number, std::mt19937 &rng)
+| 605|    |-{
+| 606|    |-	prechecksNoCommandsList();
+| 607|    |-	std::vector<std::string> files;
+| 608|    |-	mpd_send_list_all(m_connection.get(), "/");
+| 609|    |-	while (mpd_pair *item = mpd_recv_pair_named(m_connection.get(), "file"))
+| 610|    |-	{
+| 611|    |-		files.push_back(item->value);
+| 612|    |-		mpd_return_pair(m_connection.get(), item);
+| 613|    |-	}
+| 614|    |-	mpd_response_finish(m_connection.get());
+| 615|    |-	checkErrors();
+| 616|    |-	
+| 617|    |-	if (number > files.size())
+| 618|    |-	{
+| 619|    |-		//if (itsErrorHandler)
+| 620|    |-		//	itsErrorHandler(this, 0, "Requested number of random songs is bigger than size of your library", itsErrorHandlerUserdata);
+| 621|    |-		return false;
+| 622|    |-	}
+| 623|    |-	else
+| 624|    |-	{
+| 625|    |-		std::shuffle(files.begin(), files.end(), rng);
+| 626|    |-		StartCommandsList();
+| 627|    |-		auto it = files.begin();
+| 628|    |-		for (size_t i = 0; i < number && it != files.end(); ++i, ++it)
+| 629|    |-			AddSong(*it);
+| 630|    |-		CommitCommandsList();
+| 631|    |-	}
+| 632|    |-	return true;
+| 633|    |-}
+| 634|    |-
+| 635|    |-void Connection::Delete(unsigned pos)
+| 636|    |-{
+| 637|    |-	prechecks();
+| 638|    |-	mpd_send_delete(m_connection.get(), pos);
+| 639|    |-	if (!m_command_list_active)
+| 640|    |-	{
+| 641|    |-		mpd_response_finish(m_connection.get());
+| 642|    |-		checkErrors();
+| 643|    |-	}
+| 644|    |-}
+| 645|    |-
+| 646|    |-void Connection::PlaylistDelete(const std::string &playlist, unsigned pos)
+| 647|    |-{
+| 648|    |-	prechecks();
+| 649|    |-	mpd_send_playlist_delete(m_connection.get(), playlist.c_str(), pos);
+| 650|    |-	if (!m_command_list_active)
+| 651|    |-	{
+| 652|    |-		mpd_response_finish(m_connection.get());
+| 653|    |-		checkErrors();
+| 654|    |-	}
+| 655|    |-}
+| 656|    |-
+| 657|    |-void Connection::StartCommandsList()
+| 658|    |-{
+| 659|    |-	prechecksNoCommandsList();
+| 660|    |-	mpd_command_list_begin(m_connection.get(), true);
+| 661|    |-	m_command_list_active = true;
+| 662|    |-	checkErrors();
+| 663|    |-}
+| 664|    |-
+| 665|    |-void Connection::CommitCommandsList()
+| 666|    |-{
+| 667|    |-	prechecks();
+| 668|    |-	assert(m_command_list_active);
+| 669|    |-	mpd_command_list_end(m_connection.get());
+| 670|    |-	mpd_response_finish(m_connection.get());
+| 671|    |-	m_command_list_active = false;
+| 672|    |-	checkErrors();
+| 673|    |-}
+| 674|    |-
+| 675|    |-void Connection::DeletePlaylist(const std::string &name)
+| 676|    |-{
+| 677|    |-	prechecksNoCommandsList();
+| 678|    |-	mpd_run_rm(m_connection.get(), name.c_str());
+| 679|    |-	checkErrors();
+| 680|    |-}
+| 681|    |-
+| 682|    |-void Connection::LoadPlaylist(const std::string &name)
+| 683|    |-{
+| 684|    |-	prechecksNoCommandsList();
+| 685|    |-	mpd_run_load(m_connection.get(), name.c_str());
+| 686|    |-	checkErrors();
+| 687|    |-}
+| 688|    |-
+| 689|    |-void Connection::SavePlaylist(const std::string &name)
+| 690|    |-{
+| 691|    |-	prechecksNoCommandsList();
+| 692|    |-	mpd_send_save(m_connection.get(), name.c_str());
+| 693|    |-	mpd_response_finish(m_connection.get());
+| 694|    |-	checkErrors();
+| 695|    |-}
+| 696|    |-
+| 697|    |-PlaylistIterator Connection::GetPlaylists()
+| 698|    |-{
+| 699|    |-	prechecksNoCommandsList();
+| 700|    |-	mpd_send_list_playlists(m_connection.get());
+| 701|    |-	checkErrors();
+| 702|    |-	return PlaylistIterator(m_connection.get(), defaultFetcher<Playlist>(mpd_recv_playlist));
+| 703|    |-}
+| 704|    |-
+| 705|    |-StringIterator Connection::GetList(mpd_tag_type type)
+| 706|    |-{
+| 707|    |-	prechecksNoCommandsList();
+| 708|    |-	mpd_search_db_tags(m_connection.get(), type);
+| 709|    |-	mpd_search_commit(m_connection.get());
+| 710|    |-	checkErrors();
+| 711|    |-	return StringIterator(m_connection.get(), [type](StringIterator::State &state) {
+| 712|    |-		auto src = mpd_recv_pair_tag(state.connection(), type);
+| 713|    |-		if (src != nullptr)
+| 714|    |-		{
+| 715|    |-			state.setObject(src->value);
+| 716|    |-			mpd_return_pair(state.connection(), src);
+| 717|    |-			return true;
+| 718|    |-		}
+| 719|    |-		else
+| 720|    |-			return false;
+| 721|    |-	});
+| 722|    |-}
+| 723|    |-
+| 724|    |-void Connection::StartSearch(bool exact_match)
+| 725|    |-{
+| 726|    |-	prechecksNoCommandsList();
+| 727|    |-	mpd_search_db_songs(m_connection.get(), exact_match);
+| 728|    |-}
+| 729|    |-
+| 730|    |-void Connection::StartFieldSearch(mpd_tag_type item)
+| 731|    |-{
+| 732|    |-	prechecksNoCommandsList();
+| 733|    |-	mpd_search_db_tags(m_connection.get(), item);
+| 734|    |-}
+| 735|    |-
+| 736|    |-void Connection::AddSearch(mpd_tag_type item, const std::string &str) const
+| 737|    |-{
+| 738|    |-	checkConnection();
+| 739|    |-	mpd_search_add_tag_constraint(m_connection.get(), MPD_OPERATOR_DEFAULT, item, str.c_str());
+| 740|    |-}
+| 741|    |-
+| 742|    |-void Connection::AddSearchAny(const std::string &str) const
+| 743|    |-{
+| 744|    |-	checkConnection();
+| 745|    |-	mpd_search_add_any_tag_constraint(m_connection.get(), MPD_OPERATOR_DEFAULT, str.c_str());
+| 746|    |-}
+| 747|    |-
+| 748|    |-void Connection::AddSearchURI(const std::string &str) const
+| 749|    |-{
+| 750|    |-	checkConnection();
+| 751|    |-	mpd_search_add_uri_constraint(m_connection.get(), MPD_OPERATOR_DEFAULT, str.c_str());
+| 752|    |-}
+| 753|    |-
+| 754|    |-SongIterator Connection::CommitSearchSongs()
+| 755|    |-{
+| 756|    |-	prechecksNoCommandsList();
+| 757|    |-	mpd_search_commit(m_connection.get());
+| 758|    |-	checkErrors();
+| 759|    |-	return SongIterator(m_connection.get(), defaultFetcher<Song>(mpd_recv_song));
+| 760|    |-}
+| 761|    |-
+| 762|    |-ItemIterator Connection::GetDirectory(const std::string &directory)
+| 763|    |-{
+| 764|    |-	prechecksNoCommandsList();
+| 765|    |-	mpd_send_list_meta(m_connection.get(), mpdDirectory(directory));
+| 766|    |-	checkErrors();
+| 767|    |-	return ItemIterator(m_connection.get(), defaultFetcher<Item>(mpd_recv_entity));
+| 768|    |-}
+| 769|    |-
+| 770|    |-SongIterator Connection::GetDirectoryRecursive(const std::string &directory)
+| 771|    |-{
+| 772|    |-	prechecksNoCommandsList();
+| 773|    |-	mpd_send_list_all_meta(m_connection.get(), mpdDirectory(directory));
+| 774|    |-	checkErrors();
+| 775|    |-	return SongIterator(m_connection.get(), fetchItemSong);
+| 776|    |-}
+| 777|    |-
+| 778|    |-DirectoryIterator Connection::GetDirectories(const std::string &directory)
+| 779|    |-{
+| 780|    |-	prechecksNoCommandsList();
+| 781|    |-	mpd_send_list_meta(m_connection.get(), mpdDirectory(directory));
+| 782|    |-	checkErrors();
+| 783|    |-	return DirectoryIterator(m_connection.get(), defaultFetcher<Directory>(mpd_recv_directory));
+| 784|    |-}
+| 785|    |-
+| 786|    |-SongIterator Connection::GetSongs(const std::string &directory)
+| 787|    |-{
+| 788|    |-	prechecksNoCommandsList();
+| 789|    |-	mpd_send_list_meta(m_connection.get(), mpdDirectory(directory));
+| 790|    |-	checkErrors();
+| 791|    |-	return SongIterator(m_connection.get(), defaultFetcher<Song>(mpd_recv_song));
+| 792|    |-}
+| 793|    |-
+| 794|    |-OutputIterator Connection::GetOutputs()
+| 795|    |-{
+| 796|    |-	prechecksNoCommandsList();
+| 797|    |-	mpd_send_outputs(m_connection.get());
+| 798|    |-	checkErrors();
+| 799|    |-	return OutputIterator(m_connection.get(), defaultFetcher<Output>(mpd_recv_output));
+| 800|    |-}
+| 801|    |-
+| 802|    |-void Connection::EnableOutput(int id)
+| 803|    |-{
+| 804|    |-	prechecksNoCommandsList();
+| 805|    |-	mpd_run_enable_output(m_connection.get(), id);
+| 806|    |-	checkErrors();
+| 807|    |-}
+| 808|    |-
+| 809|    |-void Connection::DisableOutput(int id)
+| 810|    |-{
+| 811|    |-	prechecksNoCommandsList();
+| 812|    |-	mpd_run_disable_output(m_connection.get(), id);
+| 813|    |-	checkErrors();
+| 814|    |-}
+| 815|    |-
+| 816|    |-StringIterator Connection::GetURLHandlers()
+| 817|    |-{
+| 818|    |-	prechecksNoCommandsList();
+| 819|    |-	mpd_send_list_url_schemes(m_connection.get());
+| 820|    |-	checkErrors();
+| 821|    |-	return StringIterator(m_connection.get(), [](StringIterator::State &state) {
+| 822|    |-		auto src = mpd_recv_pair_named(state.connection(), "handler");
+| 823|    |-		if (src != nullptr)
+| 824|    |-		{
+| 825|    |-			state.setObject(src->value);
+| 826|    |-			mpd_return_pair(state.connection(), src);
+| 827|    |-			return true;
+| 828|    |-		}
+| 829|    |-		else
+| 830|    |-			return false;
+| 831|    |-	});
+| 832|    |-}
+| 833|    |-
+| 834|    |-StringIterator Connection::GetTagTypes()
+| 835|    |-{
+| 836|    |-	
+| 837|    |-	prechecksNoCommandsList();
+| 838|    |-	mpd_send_list_tag_types(m_connection.get());
+| 839|    |-	checkErrors();
+| 840|    |-	return StringIterator(m_connection.get(), [](StringIterator::State &state) {
+| 841|    |-		auto src = mpd_recv_pair_named(state.connection(), "tagtype");
+| 842|    |-		if (src != nullptr)
+| 843|    |-		{
+| 844|    |-			state.setObject(src->value);
+| 845|    |-			mpd_return_pair(state.connection(), src);
+| 846|    |-			return true;
+| 847|    |-		}
+| 848|    |-		else
+| 849|    |-			return false;
+| 850|    |-	});
+| 851|    |-}
+| 852|    |-
+| 853|    |-void Connection::checkConnection() const
+| 854|    |-{
+| 855|    |-	if (!m_connection)
+| 856|    |-		throw ClientError(MPD_ERROR_STATE, "No active MPD connection", false);
+| 857|    |-}
+| 858|    |-
+| 859|    |-void Connection::prechecks()
+| 860|    |-{
+| 861|    |-	checkConnection();
+| 862|    |-	int flags = noidle();
+| 863|    |-	if (flags && m_noidle_callback)
+| 864|    |-		m_noidle_callback(flags);
+| 865|    |-}
+| 866|    |-
+| 867|    |-void Connection::prechecksNoCommandsList()
+| 868|    |-{
+| 869|    |-	assert(!m_command_list_active);
+| 870|    |-	prechecks();
+| 871|    |-}
+| 872|    |-
+| 873|    |-void Connection::checkErrors() const
+| 874|    |-{
+| 875|    |-	checkConnectionErrors(m_connection.get());
+| 876|    |-}
+| 877|    |-
+| 878|    |-}
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+|  28|  28| 
+|  29|  29| struct SongProperties
+|  30|  30| {
+|  31|    |-	enum class State { Undefined, Const, Mutable };
+|    |  31|+    enum class State
+|    |  32|+    { Undefined, Const, Mutable };
+|  32|  33| 
+|  33|    |-	SongProperties()
+|  34|    |-		: m_state(State::Undefined)
+|  35|    |-	{ }
+|    |  34|+      SongProperties ():m_state (State::Undefined)
+|    |  35|+    {
+|    |  36|+    }
+|  36|  37| 
+|  37|    |-	SongProperties &assign(NC::List::Properties *properties_, MPD::Song *song_)
+|  38|    |-	{
+|  39|    |-		m_state = State::Mutable;
+|  40|    |-		m_properties = properties_;
+|  41|    |-		m_song = song_;
+|  42|    |-		return *this;
+|  43|    |-	}
+|    |  38|+    SongProperties & assign (NC::List::Properties * properties_,
+|    |  39|+                             MPD::Song * song_)
+|    |  40|+    {
+|    |  41|+        m_state = State::Mutable;
+|    |  42|+        m_properties = properties_;
+|    |  43|+        m_song = song_;
+|    |  44|+        return *this;
+|    |  45|+    }
+|  44|  46| 
+|  45|    |-	SongProperties &assign(const NC::List::Properties *properties_, const MPD::Song *song_)
+|  46|    |-	{
+|  47|    |-		m_state = State::Const;
+|  48|    |-		m_const_properties = properties_;
+|  49|    |-		m_const_song = song_;
+|  50|    |-		return *this;
+|  51|    |-	}
+|    |  47|+    SongProperties & assign (const NC::List::Properties * properties_,
+|    |  48|+                             const MPD::Song * song_)
+|    |  49|+    {
+|    |  50|+        m_state = State::Const;
+|    |  51|+        m_const_properties = properties_;
+|    |  52|+        m_const_song = song_;
+|    |  53|+        return *this;
+|    |  54|+    }
+|  52|  55| 
+|  53|    |-	const NC::List::Properties &properties() const
+|  54|    |-	{
+|  55|    |-		assert(m_state != State::Undefined);
+|  56|    |-		return *m_const_properties;
+|  57|    |-	}
+|  58|    |-	const MPD::Song *song() const
+|  59|    |-	{
+|  60|    |-		assert(m_state != State::Undefined);
+|  61|    |-		return m_const_song;
+|  62|    |-	}
+|    |  56|+    const NC::List::Properties & properties () const
+|    |  57|+    {
+|    |  58|+        assert (m_state != State::Undefined);
+|    |  59|+        return *m_const_properties;
+|    |  60|+    }
+|    |  61|+    const MPD::Song * song () const
+|    |  62|+    {
+|    |  63|+        assert (m_state != State::Undefined);
+|    |  64|+        return m_const_song;
+|    |  65|+    }
+|  63|  66| 
+|  64|    |-	NC::List::Properties &properties()
+|  65|    |-	{
+|  66|    |-		assert(m_state == State::Mutable);
+|  67|    |-		return *m_properties;
+|  68|    |-	}
+|  69|    |-	MPD::Song *song()
+|  70|    |-	{
+|  71|    |-		assert(m_state == State::Mutable);
+|  72|    |-		return m_song;
+|  73|    |-	}
+|    |  67|+    NC::List::Properties & properties ()
+|    |  68|+    {
+|    |  69|+        assert (m_state == State::Mutable);
+|    |  70|+        return *m_properties;
+|    |  71|+    }
+|    |  72|+    MPD::Song * song ()
+|    |  73|+    {
+|    |  74|+        assert (m_state == State::Mutable);
+|    |  75|+        return m_song;
+|    |  76|+    }
+|  74|  77| 
+|  75|    |-private:
+|  76|    |-	State m_state;
+|    |  78|+  private:
+|    |  79|+    State m_state;
+|  77|  80| 
+|  78|    |-	union {
+|  79|    |-		NC::List::Properties *m_properties;
+|  80|    |-		const NC::List::Properties *m_const_properties;
+|  81|    |-	};
+|  82|    |-	union {
+|  83|    |-		MPD::Song *m_song;
+|  84|    |-		const MPD::Song *m_const_song;
+|  85|    |-	};
+|    |  81|+    union
+|    |  82|+    {
+|    |  83|+        NC::List::Properties * m_properties;
+|    |  84|+        const NC::List::Properties * m_const_properties;
+|    |  85|+    };
+|    |  86|+    union
+|    |  87|+    {
+|    |  88|+        MPD::Song * m_song;
+|    |  89|+        const MPD::Song * m_const_song;
+|    |  90|+    };
+|  86|  91| };
+|  87|  92| 
+|  88|  93| template <Const const_>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+|  85|  85| 	};
+|  86|  86| };
+|  87|  87| 
+|  88|    |-template <Const const_>
+|  89|    |-using SongIteratorT = boost::range_detail::any_iterator<
+|  90|    |-	typename std::conditional<
+|  91|    |-		const_ == Const::Yes,
+|  92|    |-		const SongProperties,
+|  93|    |-		SongProperties>::type,
+|  94|    |-	boost::random_access_traversal_tag,
+|  95|    |-	typename std::conditional<
+|  96|    |-		const_ == Const::Yes,
+|  97|    |-		const SongProperties &,
+|  98|    |-		SongProperties &>::type,
+|  99|    |-	std::ptrdiff_t
+| 100|    |-	>;
+|    |  88|+template < Const const_ >
+|    |  89|+    using SongIteratorT = boost::range_detail::any_iterator <
+|    |  90|+    typename std::conditional < const_ == Const::Yes, const
+|    |  91|+    SongProperties,
+|    |  92|+    SongProperties >::type,
+|    |  93|+    boost::random_access_traversal_tag,
+|    |  94|+    typename
+|    |  95|+    std::conditional <
+|    |  96|+    const_ == Const::Yes, const
+|    |  97|+    SongProperties &,
+|    |  98|+SongProperties & >::type,
+|    |  99|+    std::ptrdiff_t >;
+| 101| 100| 
+| 102|    |-typedef SongIteratorT<Const::No> SongIterator;
+| 103|    |-typedef SongIteratorT<Const::Yes> ConstSongIterator;
+|    | 101|+typedef
+|    | 102|+    SongIteratorT <
+|    | 103|+    Const::No >
+|    | 104|+    SongIterator;
+|    | 105|+typedef
+|    | 106|+    SongIteratorT <
+|    | 107|+    Const::Yes >
+|    | 108|+    ConstSongIterator;
+| 104| 109| 
+| 105| 110| struct SongList
+| 106| 111| {
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+| 104| 104| 
+| 105| 105| struct SongList
+| 106| 106| {
+| 107|    |-	virtual SongIterator currentS() = 0;
+| 108|    |-	virtual ConstSongIterator currentS() const = 0;
+| 109|    |-	virtual SongIterator beginS() = 0;
+| 110|    |-	virtual ConstSongIterator beginS() const = 0;
+| 111|    |-	virtual SongIterator endS() = 0;
+| 112|    |-	virtual ConstSongIterator endS() const = 0;
+|    | 107|+    virtual SongIterator
+|    | 108|+    currentS () = 0;
+|    | 109|+    virtual ConstSongIterator
+|    | 110|+    currentS () const = 0;
+|    | 111|+    virtual SongIterator
+|    | 112|+    beginS () = 0;
+|    | 113|+    virtual ConstSongIterator
+|    | 114|+    beginS () const = 0;
+|    | 115|+    virtual SongIterator
+|    | 116|+    endS () = 0;
+|    | 117|+    virtual ConstSongIterator
+|    | 118|+    endS () const = 0;
+| 113| 119| 
+| 114|    |-	virtual std::vector<MPD::Song> getSelectedSongs() = 0;
+|    | 120|+    virtual
+|    | 121|+        std::vector <
+|    | 122|+        MPD::Song >
+|    | 123|+    getSelectedSongs () = 0;
+| 115| 124| };
+| 116| 125| 
+| 117| 126| inline SongIterator begin(SongList &list) { return list.beginS(); }
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song_list.h
+|    |++++| /app/src/song_list.h
+| 114| 114| 	virtual std::vector<MPD::Song> getSelectedSongs() = 0;
+| 115| 115| };
+| 116| 116| 
+| 117|    |-inline SongIterator begin(SongList &list) { return list.beginS(); }
+| 118|    |-inline ConstSongIterator begin(const SongList &list) { return list.beginS(); }
+| 119|    |-inline SongIterator end(SongList &list) { return list.endS(); }
+| 120|    |-inline ConstSongIterator end(const SongList &list) { return list.endS(); }
+|    | 117|+inline SongIterator
+|    | 118|+begin (SongList & list)
+|    | 119|+{
+|    | 120|+    return list.beginS ();
+|    | 121|+}
+|    | 122|+inline ConstSongIterator
+|    | 123|+begin (const SongList & list)
+|    | 124|+{
+|    | 125|+    return list.beginS ();
+|    | 126|+}
+|    | 127|+inline SongIterator
+|    | 128|+end (SongList & list)
+|    | 129|+{
+|    | 130|+    return list.endS ();
+|    | 131|+}
+|    | 132|+inline ConstSongIterator
+|    | 133|+end (const SongList & list)
+|    | 134|+{
+|    | 135|+    return list.endS ();
+|    | 136|+}
+| 121| 137| 
+| 122|    |-struct SongMenu: NC::Menu<MPD::Song>, SongList
+|    | 138|+struct SongMenu:
+|    | 139|+    NC::Menu <
+|    | 140|+    MPD::Song >,
+|    | 141|+    SongList
+| 123| 142| {
+| 124|    |-	SongMenu() { }
+| 125|    |-	SongMenu(NC::Menu<MPD::Song> &&base)
+| 126|    |-	: NC::Menu<MPD::Song>(std::move(base)) { }
+|    | 143|+    SongMenu ()
+|    | 144|+    {
+|    | 145|+    }
+|    | 146|+    SongMenu (NC::Menu < MPD::Song > &&base):NC::Menu < MPD::Song >
+|    | 147|+        (std::move (base))
+|    | 148|+    {
+|    | 149|+    }
+| 127| 150| 
+| 128|    |-	virtual SongIterator currentS() override;
+| 129|    |-	virtual ConstSongIterator currentS() const override;
+| 130|    |-	virtual SongIterator beginS() override;
+| 131|    |-	virtual ConstSongIterator beginS() const override;
+| 132|    |-	virtual SongIterator endS() override;
+| 133|    |-	virtual ConstSongIterator endS() const override;
+|    | 151|+    virtual SongIterator currentS () override;
+|    | 152|+    virtual ConstSongIterator currentS () const override;
+|    | 153|+    virtual SongIterator beginS () override;
+|    | 154|+    virtual ConstSongIterator beginS () const override;
+|    | 155|+    virtual SongIterator endS () override;
+|    | 156|+    virtual ConstSongIterator endS () const override;
+| 134| 157| 
+| 135|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|    | 158|+    virtual std::vector < MPD::Song > getSelectedSongs () override;
+| 136| 159| };
+| 137| 160| 
+| 138| 161| #endif // NCMPCPP_SONG_LIST_H
+
+src/song_list.h
+|  24| #include•<boost/range/detail/any_iterator.hpp>
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/macro_utilities.cpp
+|    |++++| /app/src/macro_utilities.cpp
+|  24|  24| #include "utility/string.h"
+|  25|  25| #include "utility/wide_string.h"
+|  26|  26| 
+|  27|    |-namespace Actions {
+|    |  27|+namespace Actions
+|    |  28|+{
+|  28|  29| 
+|  29|    |-PushCharacters::PushCharacters(NC::Window **w, std::vector<NC::Key::Type> &&queue)
+|  30|    |-	: BaseAction(Type::MacroUtility, "push_characters")
+|  31|    |-	, m_window(w)
+|  32|    |-	, m_queue(queue)
+|  33|    |-{
+|  34|    |-	assert(w != nullptr);
+|  35|    |-	std::vector<std::string> keys;
+|  36|    |-	for (const auto &key : queue)
+|  37|    |-		keys.push_back(ToString(keyToWString(key)));
+|  38|    |-	m_name += " \"";
+|  39|    |-	m_name += join<std::string>(keys, ", ");
+|  40|    |-	m_name += "\"";
+|  41|    |-}
+|    |  30|+    PushCharacters::PushCharacters (NC::Window ** w,
+|    |  31|+                                    std::vector < NC::Key::Type >
+|    |  32|+                                    &&queue):BaseAction (Type::MacroUtility,
+|    |  33|+                                                         "push_characters"),
+|    |  34|+        m_window (w), m_queue (queue)
+|    |  35|+    {
+|    |  36|+        assert (w != nullptr);
+|    |  37|+        std::vector < std::string > keys;
+|    |  38|+        for (const auto & key:queue)
+|    |  39|+            keys.push_back (ToString (keyToWString (key)));
+|    |  40|+        m_name += " \"";
+|    |  41|+        m_name += join < std::string > (keys, ", ");
+|    |  42|+        m_name += "\"";
+|    |  43|+    }
+|  42|  44| 
+|  43|    |-void PushCharacters::run()
+|  44|    |-{
+|  45|    |-	for (auto it = m_queue.begin(); it != m_queue.end(); ++it)
+|  46|    |-		(*m_window)->pushChar(*it);
+|  47|    |-}
+|    |  45|+    void PushCharacters::run ()
+|    |  46|+    {
+|    |  47|+        for (auto it = m_queue.begin (); it != m_queue.end (); ++it)
+|    |  48|+            (*m_window)->pushChar (*it);
+|    |  49|+    }
+|  48|  50| 
+|  49|    |-RequireRunnable::RequireRunnable(std::shared_ptr<BaseAction> action)
+|  50|    |-	: BaseAction(Type::MacroUtility, "require_runnable")
+|  51|    |-	, m_action(std::move(action))
+|  52|    |-{
+|  53|    |-	assert(m_action != nullptr);
+|  54|    |-	m_name += " \"";
+|  55|    |-	m_name += m_action->name();
+|  56|    |-	m_name += "\"";
+|  57|    |-}
+|    |  51|+  RequireRunnable::RequireRunnable (std::shared_ptr < BaseAction > action):BaseAction (Type::MacroUtility, "require_runnable"),
+|    |  52|+        m_action (std::
+|    |  53|+                  move (action))
+|    |  54|+    {
+|    |  55|+        assert (m_action != nullptr);
+|    |  56|+        m_name += " \"";
+|    |  57|+        m_name += m_action->name ();
+|    |  58|+        m_name += "\"";
+|    |  59|+    }
+|  58|  60| 
+|  59|    |-bool RequireRunnable::canBeRun()
+|  60|    |-{
+|  61|    |-	return m_action->canBeRun();
+|  62|    |-}
+|    |  61|+    bool RequireRunnable::canBeRun ()
+|    |  62|+    {
+|    |  63|+        return m_action->canBeRun ();
+|    |  64|+    }
+|  63|  65| 
+|  64|    |-RequireScreen::RequireScreen(ScreenType screen_type)
+|  65|    |-	: BaseAction(Type::MacroUtility, "require_screen")
+|  66|    |-	, m_screen_type(screen_type)
+|  67|    |-{
+|  68|    |-	m_name += " \"";
+|  69|    |-	m_name +=	screenTypeToString(m_screen_type);
+|  70|    |-	m_name += "\"";
+|  71|    |-}
+|    |  66|+  RequireScreen::RequireScreen (ScreenType screen_type):BaseAction (Type::MacroUtility, "require_screen"),
+|    |  67|+        m_screen_type
+|    |  68|+        (screen_type)
+|    |  69|+    {
+|    |  70|+        m_name += " \"";
+|    |  71|+        m_name += screenTypeToString (m_screen_type);
+|    |  72|+        m_name += "\"";
+|    |  73|+    }
+|  72|  74| 
+|  73|    |-bool RequireScreen::canBeRun()
+|  74|    |-{
+|  75|    |-	return Global::myScreen->type() == m_screen_type;
+|  76|    |-}
+|    |  75|+    bool RequireScreen::canBeRun ()
+|    |  76|+    {
+|    |  77|+        return Global::myScreen->type () == m_screen_type;
+|    |  78|+    }
+|  77|  79| 
+|  78|    |-RunExternalCommand::RunExternalCommand(std::string &&command)
+|  79|    |-	: BaseAction(Type::MacroUtility, "run_external_command")
+|  80|    |-	, m_command(std::move(command))
+|  81|    |-{
+|  82|    |-	m_name += " \"";
+|  83|    |-	m_name += m_command;
+|  84|    |-	m_name += "\"";
+|  85|    |-}
+|    |  80|+  RunExternalCommand::RunExternalCommand (std::string && command):BaseAction (Type::MacroUtility, "run_external_command"),
+|    |  81|+        m_command (std::
+|    |  82|+                   move (command))
+|    |  83|+    {
+|    |  84|+        m_name += " \"";
+|    |  85|+        m_name += m_command;
+|    |  86|+        m_name += "\"";
+|    |  87|+    }
+|  86|  88| 
+|  87|    |-void RunExternalCommand::run()
+|  88|    |-{
+|  89|    |-	GNUC_UNUSED int res;
+|  90|    |-	res = std::system(m_command.c_str());
+|  91|    |-}
+|    |  89|+    void RunExternalCommand::run ()
+|    |  90|+    {
+|    |  91|+        GNUC_UNUSED int res;
+|    |  92|+        res = std::system (m_command.c_str ());
+|    |  93|+    }
+|  92|  94| 
+|  93|  95| }
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/mutable_song.cpp
+|    |++++| /app/src/mutable_song.cpp
+|  22|  22| #include <boost/algorithm/string/split.hpp>
+|  23|  23| #include "mutable_song.h"
+|  24|  24| 
+|  25|    |-namespace MPD {
+|  26|    |-
+|  27|    |-std::string MutableSong::getArtist(unsigned idx) const
+|    |  25|+namespace MPD
+|  28|  26| {
+|  29|    |-	return getTag(MPD_TAG_ARTIST, [this, idx](){ return Song::getArtist(idx); }, idx);
+|    |  27|+
+|    |  28|+    std::string MutableSong::getArtist (unsigned idx) const
+|    |  29|+    {
+|    |  30|+        return getTag (MPD_TAG_ARTIST,[this, idx] ()
+|    |  31|+                       {
+|    |  32|+                       return Song::getArtist (idx);
+|    |  33|+                       }
+|    |  34|+                       , idx);
+|    |  35|+    }
+|    |  36|+
+|    |  37|+    std::string MutableSong::getTitle (unsigned idx) const
+|    |  38|+    {
+|    |  39|+        return getTag (MPD_TAG_TITLE,[this, idx] ()
+|    |  40|+                       {
+|    |  41|+                       return Song::getTitle (idx);
+|    |  42|+                       }
+|    |  43|+                       , idx);
+|    |  44|+    }
+|    |  45|+
+|    |  46|+    std::string MutableSong::getAlbum (unsigned idx) const
+|    |  47|+    {
+|    |  48|+        return getTag (MPD_TAG_ALBUM,[this, idx] ()
+|    |  49|+                       {
+|    |  50|+                       return Song::getAlbum (idx);
+|    |  51|+                       }
+|    |  52|+                       , idx);
+|    |  53|+    }
+|    |  54|+
+|    |  55|+    std::string MutableSong::getAlbumArtist (unsigned idx) const
+|    |  56|+    {
+|    |  57|+        return getTag (MPD_TAG_ALBUM_ARTIST,[this, idx] ()
+|    |  58|+                       {
+|    |  59|+                       return Song::getAlbumArtist (idx);
+|    |  60|+                       }
+|    |  61|+                       , idx);
+|    |  62|+    }
+|    |  63|+
+|    |  64|+    std::string MutableSong::getTrack (unsigned idx) const
+|    |  65|+    {
+|    |  66|+        std::string track = getTag (MPD_TAG_TRACK,[this, idx] ()
+|    |  67|+                                    {
+|    |  68|+                                    return Song::getTrack (idx);
+|    |  69|+                                    }
+|    |  70|+                                    , idx);
+|    |  71|+        if ((track.length () == 1 && track[0] != '0')
+|    |  72|+            || (track.length () > 3 && track[1] == '/'))
+|    |  73|+            return "0" + track;
+|    |  74|+        else
+|    |  75|+            return track;
+|    |  76|+    }
+|    |  77|+
+|    |  78|+    std::string MutableSong::getDate (unsigned idx) const
+|    |  79|+    {
+|    |  80|+        return getTag (MPD_TAG_DATE,[this, idx] ()
+|    |  81|+                       {
+|    |  82|+                       return Song::getDate (idx);
+|    |  83|+                       }
+|    |  84|+                       , idx);
+|    |  85|+    }
+|    |  86|+
+|    |  87|+    std::string MutableSong::getGenre (unsigned idx) const
+|    |  88|+    {
+|    |  89|+        return getTag (MPD_TAG_GENRE,[this, idx] ()
+|    |  90|+                       {
+|    |  91|+                       return Song::getGenre (idx);
+|    |  92|+                       }
+|    |  93|+                       , idx);
+|    |  94|+    }
+|    |  95|+
+|    |  96|+    std::string MutableSong::getComposer (unsigned idx) const
+|    |  97|+    {
+|    |  98|+        return getTag (MPD_TAG_COMPOSER,[this, idx] ()
+|    |  99|+                       {
+|    | 100|+                       return Song::getComposer (idx);
+|    | 101|+                       }
+|    | 102|+                       , idx);
+|    | 103|+    }
+|    | 104|+
+|    | 105|+    std::string MutableSong::getPerformer (unsigned idx) const
+|    | 106|+    {
+|    | 107|+        return getTag (MPD_TAG_PERFORMER,[this, idx] ()
+|    | 108|+                       {
+|    | 109|+                       return Song::getPerformer (idx);
+|    | 110|+                       }
+|    | 111|+                       , idx);
+|    | 112|+    }
+|    | 113|+
+|    | 114|+    std::string MutableSong::getDisc (unsigned idx) const
+|    | 115|+    {
+|    | 116|+        return getTag (MPD_TAG_DISC,[this, idx] ()
+|    | 117|+                       {
+|    | 118|+                       return Song::getDisc (idx);
+|    | 119|+                       }
+|    | 120|+                       , idx);
+|    | 121|+    }
+|    | 122|+
+|    | 123|+    std::string MutableSong::getComment (unsigned idx) const
+|    | 124|+    {
+|    | 125|+        return getTag (MPD_TAG_COMMENT,[this, idx] ()
+|    | 126|+                       {
+|    | 127|+                       return Song::getComment (idx);
+|    | 128|+                       }
+|    | 129|+                       , idx);
+|    | 130|+    }
+|    | 131|+
+|    | 132|+    void MutableSong::setArtist (const std::string & value, unsigned idx)
+|    | 133|+    {
+|    | 134|+        replaceTag (MPD_TAG_ARTIST, Song::getArtist (idx), value, idx);
+|    | 135|+    }
+|    | 136|+
+|    | 137|+    void MutableSong::setTitle (const std::string & value, unsigned idx)
+|    | 138|+    {
+|    | 139|+        replaceTag (MPD_TAG_TITLE, Song::getTitle (idx), value, idx);
+|    | 140|+    }
+|    | 141|+
+|    | 142|+    void MutableSong::setAlbum (const std::string & value, unsigned idx)
+|    | 143|+    {
+|    | 144|+        replaceTag (MPD_TAG_ALBUM, Song::getAlbum (idx), value, idx);
+|    | 145|+    }
+|    | 146|+
+|    | 147|+    void MutableSong::setAlbumArtist (const std::string & value, unsigned idx)
+|    | 148|+    {
+|    | 149|+        replaceTag (MPD_TAG_ALBUM_ARTIST, Song::getAlbumArtist (idx), value,
+|    | 150|+                    idx);
+|    | 151|+    }
+|    | 152|+
+|    | 153|+    void MutableSong::setTrack (const std::string & value, unsigned idx)
+|    | 154|+    {
+|    | 155|+        replaceTag (MPD_TAG_TRACK, Song::getTrack (idx), value, idx);
+|    | 156|+    }
+|    | 157|+
+|    | 158|+    void MutableSong::setDate (const std::string & value, unsigned idx)
+|    | 159|+    {
+|    | 160|+        replaceTag (MPD_TAG_DATE, Song::getDate (idx), value, idx);
+|    | 161|+    }
+|    | 162|+
+|    | 163|+    void MutableSong::setGenre (const std::string & value, unsigned idx)
+|    | 164|+    {
+|    | 165|+        replaceTag (MPD_TAG_GENRE, Song::getGenre (idx), value, idx);
+|    | 166|+    }
+|    | 167|+
+|    | 168|+    void MutableSong::setComposer (const std::string & value, unsigned idx)
+|    | 169|+    {
+|    | 170|+        replaceTag (MPD_TAG_COMPOSER, Song::getComposer (idx), value, idx);
+|    | 171|+    }
+|    | 172|+
+|    | 173|+    void MutableSong::setPerformer (const std::string & value, unsigned idx)
+|    | 174|+    {
+|    | 175|+        replaceTag (MPD_TAG_PERFORMER, Song::getPerformer (idx), value, idx);
+|    | 176|+    }
+|    | 177|+
+|    | 178|+    void MutableSong::setDisc (const std::string & value, unsigned idx)
+|    | 179|+    {
+|    | 180|+        replaceTag (MPD_TAG_DISC, Song::getDisc (idx), value, idx);
+|    | 181|+    }
+|    | 182|+
+|    | 183|+    void MutableSong::setComment (const std::string & value, unsigned idx)
+|    | 184|+    {
+|    | 185|+        replaceTag (MPD_TAG_COMMENT, Song::getComment (idx), value, idx);
+|    | 186|+    }
+|    | 187|+
+|    | 188|+    const std::string & MutableSong::getNewName () const
+|    | 189|+    {
+|    | 190|+        return m_name;
+|    | 191|+    }
+|    | 192|+
+|    | 193|+    void MutableSong::setNewName (const std::string & value)
+|    | 194|+    {
+|    | 195|+        if (getName () == value)
+|    | 196|+            m_name.clear ();
+|    | 197|+        else
+|    | 198|+            m_name = value;
+|    | 199|+    }
+|    | 200|+
+|    | 201|+    unsigned MutableSong::getDuration () const
+|    | 202|+    {
+|    | 203|+        if (m_duration > 0)
+|    | 204|+            return m_duration;
+|    | 205|+        else
+|    | 206|+            return Song::getDuration ();
+|    | 207|+    }
+|    | 208|+
+|    | 209|+    time_t MutableSong::getMTime () const
+|    | 210|+    {
+|    | 211|+        if (m_mtime > 0)
+|    | 212|+            return m_mtime;
+|    | 213|+        else
+|    | 214|+            return Song::getMTime ();
+|    | 215|+    }
+|    | 216|+
+|    | 217|+    void MutableSong::setDuration (unsigned int duration)
+|    | 218|+    {
+|    | 219|+        m_duration = duration;
+|    | 220|+    }
+|    | 221|+
+|    | 222|+    void MutableSong::setMTime (time_t mtime)
+|    | 223|+    {
+|    | 224|+        m_mtime = mtime;
+|    | 225|+    }
+|    | 226|+
+|    | 227|+    void MutableSong::setTags (SetFunction set, const std::string & value)
+|    | 228|+    {
+|    | 229|+        std::vector < std::string > tags;
+|    | 230|+        boost::iter_split (tags, value,
+|    | 231|+                           boost::first_finder (Song::TagsSeparator));
+|    | 232|+        size_t i = 0;
+|    | 233|+        for (; i < tags.size (); ++i)
+|    | 234|+            (this->*set) (tags[i], i);
+|    | 235|+        // set next tag to be empty, so tags with bigger indexes won't be read
+|    | 236|+        (this->*set) ("", i);
+|    | 237|+    }
+|    | 238|+
+|    | 239|+    bool MutableSong::isModified () const
+|    | 240|+    {
+|    | 241|+        return !m_name.empty () || !m_tags.empty ();
+|    | 242|+    }
+|    | 243|+
+|    | 244|+    void MutableSong::clearModifications ()
+|    | 245|+    {
+|    | 246|+        m_name.clear ();
+|    | 247|+        m_tags.clear ();
+|    | 248|+    }
+|    | 249|+
+|    | 250|+    void MutableSong::replaceTag (mpd_tag_type tag_type,
+|    | 251|+                                  std::string orig_value,
+|    | 252|+                                  const std::string & value, unsigned idx)
+|    | 253|+    {
+|    | 254|+        Tag tag (tag_type, idx);
+|    | 255|+        if (value == orig_value)
+|    | 256|+          {
+|    | 257|+              auto it = m_tags.find (tag);
+|    | 258|+              if (it != m_tags.end ())
+|    | 259|+                  m_tags.erase (it);
+|    | 260|+          }
+|    | 261|+        else
+|    | 262|+            m_tags[tag] = value;
+|    | 263|+    }
+|    | 264|+
+|  30| 265| }
+|  31|    |-
+|  32|    |-std::string MutableSong::getTitle(unsigned idx) const
+|  33|    |-{
+|  34|    |-	return getTag(MPD_TAG_TITLE, [this, idx](){ return Song::getTitle(idx); }, idx);
+|  35|    |-}
+|  36|    |-
+|  37|    |-std::string MutableSong::getAlbum(unsigned idx) const
+|  38|    |-{
+|  39|    |-	return getTag(MPD_TAG_ALBUM, [this, idx](){ return Song::getAlbum(idx); }, idx);
+|  40|    |-}
+|  41|    |-
+|  42|    |-std::string MutableSong::getAlbumArtist(unsigned idx) const
+|  43|    |-{
+|  44|    |-	return getTag(MPD_TAG_ALBUM_ARTIST, [this, idx](){ return Song::getAlbumArtist(idx); }, idx);
+|  45|    |-}
+|  46|    |-
+|  47|    |-std::string MutableSong::getTrack(unsigned idx) const
+|  48|    |-{
+|  49|    |-	std::string track = getTag(MPD_TAG_TRACK, [this, idx](){ return Song::getTrack(idx); }, idx);
+|  50|    |-	if ((track.length() == 1 && track[0] != '0')
+|  51|    |-	||  (track.length() > 3  && track[1] == '/'))
+|  52|    |-		return "0"+track;
+|  53|    |-	else
+|  54|    |-		return track;
+|  55|    |-}
+|  56|    |-
+|  57|    |-std::string MutableSong::getDate(unsigned idx) const
+|  58|    |-{
+|  59|    |-	return getTag(MPD_TAG_DATE, [this, idx](){ return Song::getDate(idx); }, idx);
+|  60|    |-}
+|  61|    |-
+|  62|    |-std::string MutableSong::getGenre(unsigned idx) const
+|  63|    |-{
+|  64|    |-	return getTag(MPD_TAG_GENRE, [this, idx](){ return Song::getGenre(idx); }, idx);
+|  65|    |-}
+|  66|    |-
+|  67|    |-std::string MutableSong::getComposer(unsigned idx) const
+|  68|    |-{
+|  69|    |-	return getTag(MPD_TAG_COMPOSER, [this, idx](){ return Song::getComposer(idx); }, idx);
+|  70|    |-}
+|  71|    |-
+|  72|    |-std::string MutableSong::getPerformer(unsigned idx) const
+|  73|    |-{
+|  74|    |-	return getTag(MPD_TAG_PERFORMER, [this, idx](){ return Song::getPerformer(idx); }, idx);
+|  75|    |-}
+|  76|    |-
+|  77|    |-std::string MutableSong::getDisc(unsigned idx) const
+|  78|    |-{
+|  79|    |-	return getTag(MPD_TAG_DISC, [this, idx](){ return Song::getDisc(idx); }, idx);
+|  80|    |-}
+|  81|    |-
+|  82|    |-std::string MutableSong::getComment(unsigned idx) const
+|  83|    |-{
+|  84|    |-	return getTag(MPD_TAG_COMMENT, [this, idx](){ return Song::getComment(idx); }, idx);
+|  85|    |-}
+|  86|    |-
+|  87|    |-void MutableSong::setArtist(const std::string &value, unsigned idx)
+|  88|    |-{
+|  89|    |-	replaceTag(MPD_TAG_ARTIST, Song::getArtist(idx), value, idx);
+|  90|    |-}
+|  91|    |-
+|  92|    |-void MutableSong::setTitle(const std::string &value, unsigned idx)
+|  93|    |-{
+|  94|    |-	replaceTag(MPD_TAG_TITLE, Song::getTitle(idx), value, idx);
+|  95|    |-}
+|  96|    |-
+|  97|    |-void MutableSong::setAlbum(const std::string &value, unsigned idx)
+|  98|    |-{
+|  99|    |-	replaceTag(MPD_TAG_ALBUM, Song::getAlbum(idx), value, idx);
+| 100|    |-}
+| 101|    |-
+| 102|    |-void MutableSong::setAlbumArtist(const std::string &value, unsigned idx)
+| 103|    |-{
+| 104|    |-	replaceTag(MPD_TAG_ALBUM_ARTIST, Song::getAlbumArtist(idx), value, idx);
+| 105|    |-}
+| 106|    |-
+| 107|    |-void MutableSong::setTrack(const std::string &value, unsigned idx)
+| 108|    |-{
+| 109|    |-	replaceTag(MPD_TAG_TRACK, Song::getTrack(idx), value, idx);
+| 110|    |-}
+| 111|    |-
+| 112|    |-void MutableSong::setDate(const std::string &value, unsigned idx)
+| 113|    |-{
+| 114|    |-	replaceTag(MPD_TAG_DATE, Song::getDate(idx), value, idx);
+| 115|    |-}
+| 116|    |-
+| 117|    |-void MutableSong::setGenre(const std::string &value, unsigned idx)
+| 118|    |-{
+| 119|    |-	replaceTag(MPD_TAG_GENRE, Song::getGenre(idx), value, idx);
+| 120|    |-}
+| 121|    |-
+| 122|    |-void MutableSong::setComposer(const std::string &value, unsigned idx)
+| 123|    |-{
+| 124|    |-	replaceTag(MPD_TAG_COMPOSER, Song::getComposer(idx), value, idx);
+| 125|    |-}
+| 126|    |-
+| 127|    |-void MutableSong::setPerformer(const std::string &value, unsigned idx)
+| 128|    |-{
+| 129|    |-	replaceTag(MPD_TAG_PERFORMER, Song::getPerformer(idx), value, idx);
+| 130|    |-}
+| 131|    |-
+| 132|    |-void MutableSong::setDisc(const std::string &value, unsigned idx)
+| 133|    |-{
+| 134|    |-	replaceTag(MPD_TAG_DISC, Song::getDisc(idx), value, idx);
+| 135|    |-}
+| 136|    |-
+| 137|    |-void MutableSong::setComment(const std::string &value, unsigned idx)
+| 138|    |-{
+| 139|    |-	replaceTag(MPD_TAG_COMMENT, Song::getComment(idx), value, idx);
+| 140|    |-}
+| 141|    |-
+| 142|    |-const std::string &MutableSong::getNewName() const
+| 143|    |-{
+| 144|    |-	return m_name;
+| 145|    |-}
+| 146|    |-
+| 147|    |-void MutableSong::setNewName(const std::string &value)
+| 148|    |-{
+| 149|    |-	if (getName() == value)
+| 150|    |-		m_name.clear();
+| 151|    |-	else
+| 152|    |-		m_name = value;
+| 153|    |-}
+| 154|    |-
+| 155|    |-unsigned MutableSong::getDuration() const
+| 156|    |-{
+| 157|    |-	if (m_duration > 0)
+| 158|    |-		return m_duration;
+| 159|    |-	else
+| 160|    |-		return Song::getDuration();
+| 161|    |-}
+| 162|    |-
+| 163|    |-time_t MutableSong::getMTime() const
+| 164|    |-{
+| 165|    |-	if (m_mtime > 0)
+| 166|    |-		return m_mtime;
+| 167|    |-	else
+| 168|    |-		return Song::getMTime();
+| 169|    |-}
+| 170|    |-
+| 171|    |-void MutableSong::setDuration(unsigned int duration)
+| 172|    |-{
+| 173|    |-	m_duration = duration;
+| 174|    |-}
+| 175|    |-
+| 176|    |-void MutableSong::setMTime(time_t mtime)
+| 177|    |-{
+| 178|    |-	m_mtime = mtime;
+| 179|    |-}
+| 180|    |-
+| 181|    |-void MutableSong::setTags(SetFunction set, const std::string &value)
+| 182|    |-{
+| 183|    |-	std::vector<std::string> tags;
+| 184|    |-	boost::iter_split(tags, value, boost::first_finder(Song::TagsSeparator));
+| 185|    |-	size_t i = 0;
+| 186|    |-	for (; i < tags.size(); ++i)
+| 187|    |-		(this->*set)(tags[i], i);
+| 188|    |-	// set next tag to be empty, so tags with bigger indexes won't be read
+| 189|    |-	(this->*set)("", i);
+| 190|    |-}
+| 191|    |-
+| 192|    |-bool MutableSong::isModified() const
+| 193|    |-{
+| 194|    |-	return !m_name.empty() || !m_tags.empty();
+| 195|    |-}
+| 196|    |-
+| 197|    |-void MutableSong::clearModifications()
+| 198|    |-{
+| 199|    |-	m_name.clear();
+| 200|    |-	m_tags.clear();
+| 201|    |-}
+| 202|    |-
+| 203|    |-void MutableSong::replaceTag(mpd_tag_type tag_type, std::string orig_value, const std::string &value, unsigned idx)
+| 204|    |-{
+| 205|    |-	Tag tag(tag_type, idx);
+| 206|    |-	if (value == orig_value)
+| 207|    |-	{
+| 208|    |-		auto it = m_tags.find(tag);
+| 209|    |-		if (it != m_tags.end())
+| 210|    |-			m_tags.erase(it);
+| 211|    |-	}
+| 212|    |-	else
+| 213|    |-		m_tags[tag] = value;
+| 214|    |-}
+| 215|    |-
+| 216|    |-}
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.cpp
+|    |++++| /app/src/screens/server_info.cpp
+|  27|  27| #include "statusbar.h"
+|  28|  28| #include "screens/screen_switcher.h"
+|  29|  29| 
+|  30|    |-using Global::MainHeight;
+|  31|    |-using Global::MainStartY;
+|    |  30|+using
+|    |  31|+    Global::MainHeight;
+|    |  32|+using
+|    |  33|+    Global::MainStartY;
+|  32|  34| 
+|  33|    |-ServerInfo *myServerInfo;
+|    |  35|+ServerInfo *
+|    |  36|+    myServerInfo;
+|  34|  37| 
+|  35|    |-ServerInfo::ServerInfo()
+|  36|    |-: m_timer(boost::posix_time::from_time_t(0))
+|    |  38|+ServerInfo::ServerInfo ():m_timer (boost::posix_time::from_time_t (0))
+|  37|  39| {
+|  38|    |-	SetDimensions();
+|  39|    |-	w = NC::Scrollpad((COLS-m_width)/2, (MainHeight-m_height)/2+MainStartY, m_width, m_height, "MPD server info", Config.main_color, Config.window_border);
+|    |  40|+    SetDimensions ();
+|    |  41|+    w = NC::Scrollpad ((COLS - m_width) / 2,
+|    |  42|+                       (MainHeight - m_height) / 2 + MainStartY, m_width,
+|    |  43|+                       m_height, "MPD server info", Config.main_color,
+|    |  44|+                       Config.window_border);
+|  40|  45| }
+|  41|  46| 
+|  42|  47| void ServerInfo::switchTo()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.cpp
+|    |++++| /app/src/screens/server_info.cpp
+|  39|  39| 	w = NC::Scrollpad((COLS-m_width)/2, (MainHeight-m_height)/2+MainStartY, m_width, m_height, "MPD server info", Config.main_color, Config.window_border);
+|  40|  40| }
+|  41|  41| 
+|  42|    |-void ServerInfo::switchTo()
+|    |  42|+void
+|    |  43|+ServerInfo::switchTo ()
+|  43|  44| {
+|  44|    |-	using Global::myScreen;
+|  45|    |-	if (myScreen != this)
+|  46|    |-	{
+|  47|    |-		SwitchTo::execute(this);
+|  48|    |-		
+|  49|    |-		m_url_handlers.clear();
+|  50|    |-		std::copy(
+|  51|    |-			std::make_move_iterator(Mpd.GetURLHandlers()),
+|  52|    |-			std::make_move_iterator(MPD::StringIterator()),
+|  53|    |-			std::back_inserter(m_url_handlers)
+|  54|    |-		);
+|    |  45|+    using Global::myScreen;
+|    |  46|+    if (myScreen != this)
+|    |  47|+      {
+|    |  48|+          SwitchTo::execute (this);
+|  55|  49| 
+|  56|    |-		m_tag_types.clear();
+|  57|    |-		std::copy(
+|  58|    |-			std::make_move_iterator(Mpd.GetTagTypes()),
+|  59|    |-			std::make_move_iterator(MPD::StringIterator()),
+|  60|    |-			std::back_inserter(m_tag_types)
+|  61|    |-		);
+|  62|    |-	}
+|  63|    |-	else
+|  64|    |-		switchToPreviousScreen();
+|    |  50|+          m_url_handlers.clear ();
+|    |  51|+          std::copy (std::make_move_iterator (Mpd.GetURLHandlers ()),
+|    |  52|+                     std::make_move_iterator (MPD::StringIterator ()),
+|    |  53|+                     std::back_inserter (m_url_handlers));
+|    |  54|+
+|    |  55|+          m_tag_types.clear ();
+|    |  56|+          std::copy (std::make_move_iterator (Mpd.GetTagTypes ()),
+|    |  57|+                     std::make_move_iterator (MPD::StringIterator ()),
+|    |  58|+                     std::back_inserter (m_tag_types));
+|    |  59|+      }
+|    |  60|+    else
+|    |  61|+        switchToPreviousScreen ();
+|  65|  62| }
+|  66|  63| 
+|  67|  64| void ServerInfo::resize()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.cpp
+|    |++++| /app/src/screens/server_info.cpp
+|  64|  64| 		switchToPreviousScreen();
+|  65|  65| }
+|  66|  66| 
+|  67|    |-void ServerInfo::resize()
+|    |  67|+void
+|    |  68|+ServerInfo::resize ()
+|  68|  69| {
+|  69|    |-	SetDimensions();
+|  70|    |-	w.resize(m_width, m_height);
+|  71|    |-	w.moveTo((COLS-m_width)/2, (MainHeight-m_height)/2+MainStartY);
+|  72|    |-	if (previousScreen() && previousScreen()->hasToBeResized) // resize background window
+|  73|    |-	{
+|  74|    |-		previousScreen()->resize();
+|  75|    |-		previousScreen()->refresh();
+|  76|    |-	}
+|  77|    |-	hasToBeResized = 0;
+|    |  70|+    SetDimensions ();
+|    |  71|+    w.resize (m_width, m_height);
+|    |  72|+    w.moveTo ((COLS - m_width) / 2, (MainHeight - m_height) / 2 + MainStartY);
+|    |  73|+    if (previousScreen () && previousScreen ()->hasToBeResized) // resize background window
+|    |  74|+      {
+|    |  75|+          previousScreen ()->resize ();
+|    |  76|+          previousScreen ()->refresh ();
+|    |  77|+      }
+|    |  78|+    hasToBeResized = 0;
+|  78|  79| }
+|  79|  80| 
+|  80|  81| std::wstring ServerInfo::title()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.cpp
+|    |++++| /app/src/screens/server_info.cpp
+|  77|  77| 	hasToBeResized = 0;
+|  78|  78| }
+|  79|  79| 
+|  80|    |-std::wstring ServerInfo::title()
+|    |  80|+std::wstring ServerInfo::title ()
+|  81|  81| {
+|  82|    |-	return previousScreen()->title();
+|    |  82|+    return previousScreen ()->title ();
+|  83|  83| }
+|  84|  84| 
+|  85|  85| void ServerInfo::update()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.cpp
+|    |++++| /app/src/screens/server_info.cpp
+|  82|  82| 	return previousScreen()->title();
+|  83|  83| }
+|  84|  84| 
+|  85|    |-void ServerInfo::update()
+|    |  85|+void
+|    |  86|+ServerInfo::update ()
+|  86|  87| {
+|  87|    |-	if (Global::Timer - m_timer < boost::posix_time::seconds(1))
+|  88|    |-		return;
+|  89|    |-	m_timer = Global::Timer;
+|  90|    |-	
+|  91|    |-	MPD::Statistics stats = Mpd.getStatistics();
+|  92|    |-	if (stats.empty())
+|  93|    |-		return;
+|  94|    |-	
+|  95|    |-	w.clear();
+|  96|    |-	
+|  97|    |-	w << NC::Format::Bold << "Version: " << NC::Format::NoBold << "0." << Mpd.Version() << ".*\n";
+|  98|    |-	w << NC::Format::Bold << "Uptime: " << NC::Format::NoBold;
+|  99|    |-	ShowTime(w, stats.uptime(), 1);
+| 100|    |-	w << '\n';
+| 101|    |-	w << NC::Format::Bold << "Time playing: " << NC::Format::NoBold << MPD::Song::ShowTime(stats.playTime()) << '\n';
+| 102|    |-	w << '\n';
+| 103|    |-	w << NC::Format::Bold << "Total playtime: " << NC::Format::NoBold;
+| 104|    |-	ShowTime(w, stats.dbPlayTime(), 1);
+| 105|    |-	w << '\n';
+| 106|    |-	w << NC::Format::Bold << "Artist names: " << NC::Format::NoBold << stats.artists() << '\n';
+| 107|    |-	w << NC::Format::Bold << "Album names: " << NC::Format::NoBold << stats.albums() << '\n';
+| 108|    |-	w << NC::Format::Bold << "Songs in database: " << NC::Format::NoBold << stats.songs() << '\n';
+| 109|    |-	w << '\n';
+| 110|    |-	w << NC::Format::Bold << "Last DB update: " << NC::Format::NoBold << Timestamp(stats.dbUpdateTime()) << '\n';
+| 111|    |-	w << '\n';
+| 112|    |-	w << NC::Format::Bold << "URL Handlers:" << NC::Format::NoBold;
+| 113|    |-	for (auto it = m_url_handlers.begin(); it != m_url_handlers.end(); ++it)
+| 114|    |-		w << (it != m_url_handlers.begin() ? ", " : " ") << *it;
+| 115|    |-	w << "\n\n";
+| 116|    |-	w << NC::Format::Bold << "Tag Types:" << NC::Format::NoBold;
+| 117|    |-	for (auto it = m_tag_types.begin(); it != m_tag_types.end(); ++it)
+| 118|    |-		w << (it != m_tag_types.begin() ? ", " : " ") << *it;
+| 119|    |-	
+| 120|    |-	w.flush();
+| 121|    |-	w.refresh();
+|    |  88|+    if (Global::Timer - m_timer < boost::posix_time::seconds (1))
+|    |  89|+        return;
+|    |  90|+    m_timer = Global::Timer;
+|    |  91|+
+|    |  92|+    MPD::Statistics stats = Mpd.getStatistics ();
+|    |  93|+    if (stats.empty ())
+|    |  94|+        return;
+|    |  95|+
+|    |  96|+    w.clear ();
+|    |  97|+
+|    |  98|+    w << NC::Format::Bold << "Version: " << NC::Format::NoBold << "0." << Mpd.
+|    |  99|+        Version () << ".*\n";
+|    | 100|+    w << NC::Format::Bold << "Uptime: " << NC::Format::NoBold;
+|    | 101|+    ShowTime (w, stats.uptime (), 1);
+|    | 102|+    w << '\n';
+|    | 103|+    w << NC::Format::Bold << "Time playing: " << NC::Format::NoBold << MPD::
+|    | 104|+        Song::ShowTime (stats.playTime ()) << '\n';
+|    | 105|+    w << '\n';
+|    | 106|+    w << NC::Format::Bold << "Total playtime: " << NC::Format::NoBold;
+|    | 107|+    ShowTime (w, stats.dbPlayTime (), 1);
+|    | 108|+    w << '\n';
+|    | 109|+    w << NC::Format::Bold << "Artist names: " << NC::Format::NoBold << stats.
+|    | 110|+        artists () << '\n';
+|    | 111|+    w << NC::Format::Bold << "Album names: " << NC::Format::NoBold << stats.
+|    | 112|+        albums () << '\n';
+|    | 113|+    w << NC::Format::Bold << "Songs in database: " << NC::Format::
+|    | 114|+        NoBold << stats.songs () << '\n';
+|    | 115|+    w << '\n';
+|    | 116|+    w << NC::Format::Bold << "Last DB update: " << NC::Format::
+|    | 117|+        NoBold << Timestamp (stats.dbUpdateTime ()) << '\n';
+|    | 118|+    w << '\n';
+|    | 119|+    w << NC::Format::Bold << "URL Handlers:" << NC::Format::NoBold;
+|    | 120|+    for (auto it = m_url_handlers.begin (); it != m_url_handlers.end (); ++it)
+|    | 121|+        w << (it != m_url_handlers.begin ()? ", " : " ") << *it;
+|    | 122|+    w << "\n\n";
+|    | 123|+    w << NC::Format::Bold << "Tag Types:" << NC::Format::NoBold;
+|    | 124|+    for (auto it = m_tag_types.begin (); it != m_tag_types.end (); ++it)
+|    | 125|+        w << (it != m_tag_types.begin ()? ", " : " ") << *it;
+|    | 126|+
+|    | 127|+    w.flush ();
+|    | 128|+    w.refresh ();
+| 122| 129| }
+| 123| 130| 
+| 124| 131| void ServerInfo::SetDimensions()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.cpp
+|    |++++| /app/src/screens/server_info.cpp
+| 121| 121| 	w.refresh();
+| 122| 122| }
+| 123| 123| 
+| 124|    |-void ServerInfo::SetDimensions()
+|    | 124|+void
+|    | 125|+ServerInfo::SetDimensions ()
+| 125| 126| {
+| 126|    |-	m_width = COLS*0.6;
+| 127|    |-	m_height = std::min(size_t(LINES*0.7), MainHeight);
+|    | 127|+    m_width = COLS * 0.6;
+|    | 128|+    m_height = std::min (size_t (LINES * 0.7), MainHeight);
+| 128| 129| }
+| 129|    |-
+
+src/screens/server_info.cpp
+|  24| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/server_info.cpp
+|  25| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/server_info.cpp
+|  26| #include•"screens/server_info.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/server_info.h'
+
+src/screens/server_info.cpp
+|  27| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'statusbar.h'
+
+src/screens/server_info.cpp
+|  28| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/server_info.cpp
+|  33| ServerInfo•*myServerInfo;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myServerInfo'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  30|  30| #include "mpdpp.h"
+|  31|  31| #include "screens/screen.h"
+|  32|  32| 
+|  33|    |-struct Outputs: Screen<NC::Menu<MPD::Output>>, Tabbable
+|    |  33|+struct Outputs:Screen <
+|    |  34|+    NC::Menu <
+|    |  35|+    MPD::Output >>,
+|    |  36|+    Tabbable
+|  34|  37| {
+|  35|    |-	Outputs();
+|  36|    |-	
+|  37|    |-	// Screen< NC::Menu<MPD::Output> > implementation
+|  38|    |-	virtual void switchTo() override;
+|  39|    |-	virtual void resize() override;
+|  40|    |-	
+|  41|    |-	virtual std::wstring title() override;
+|  42|    |-	virtual ScreenType type() override { return ScreenType::Outputs; }
+|  43|    |-	
+|  44|    |-	virtual void update() override { }
+|  45|    |-	
+|  46|    |-	virtual void mouseButtonPressed(MEVENT me) override;
+|  47|    |-	
+|  48|    |-	virtual bool isLockable() override { return true; }
+|  49|    |-	virtual bool isMergable() override { return true; }
+|  50|    |-	
+|  51|    |-	// private members
+|  52|    |-	void fetchList();
+|  53|    |-	void toggleOutput();
+|    |  38|+    Outputs ();
+|    |  39|+
+|    |  40|+    // Screen< NC::Menu<MPD::Output> > implementation
+|    |  41|+    virtual void
+|    |  42|+    switchTo ()
+|    |  43|+        override;
+|    |  44|+    virtual void
+|    |  45|+    resize ()
+|    |  46|+        override;
+|    |  47|+
+|    |  48|+    virtual
+|    |  49|+        std::wstring
+|    |  50|+    title ()
+|    |  51|+        override;
+|    |  52|+    virtual ScreenType
+|    |  53|+    type ()
+|    |  54|+        override
+|    |  55|+    {
+|    |  56|+        return ScreenType::Outputs;
+|    |  57|+    }
+|    |  58|+
+|    |  59|+    virtual void
+|    |  60|+    update ()
+|    |  61|+        override
+|    |  62|+    {
+|    |  63|+    }
+|    |  64|+
+|    |  65|+    virtual void
+|    |  66|+    mouseButtonPressed (MEVENT me)
+|    |  67|+        override;
+|    |  68|+
+|    |  69|+    virtual bool
+|    |  70|+    isLockable ()
+|    |  71|+        override
+|    |  72|+    {
+|    |  73|+        return true;
+|    |  74|+    }
+|    |  75|+    virtual bool
+|    |  76|+    isMergable ()
+|    |  77|+        override
+|    |  78|+    {
+|    |  79|+        return true;
+|    |  80|+    }
+|    |  81|+
+|    |  82|+    // private members
+|    |  83|+    void
+|    |  84|+    fetchList ();
+|    |  85|+    void
+|    |  86|+    toggleOutput ();
+|  54|  87| };
+|  55|  88| 
+|  56|  89| extern Outputs *myOutputs;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  53|  53| 	void toggleOutput();
+|  54|  54| };
+|  55|  55| 
+|  56|    |-extern Outputs *myOutputs;
+|    |  56|+extern Outputs *
+|    |  57|+    myOutputs;
+|  57|  58| 
+|  58|  59| #endif // ENABLE_OUTPUTS
+|  59|  60| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/outputs.h
+|    |++++| /app/src/screens/outputs.h
+|  58|  58| #endif // ENABLE_OUTPUTS
+|  59|  59| 
+|  60|  60| #endif // NCMPCPP_OUTPUTS_H
+|  61|    |-
+
+src/screens/outputs.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/outputs.h
+|  28| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/outputs.h
+|  29| #include•"menu.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'menu.h'
+
+src/screens/outputs.h
+|  30| #include•"mpdpp.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'mpdpp.h'
+
+src/screens/outputs.h
+|  31| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/outputs.h
+|  56| extern•Outputs•*myOutputs;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myOutputs'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  31|  31| 
+|  32|  32| struct Searchable
+|  33|  33| {
+|  34|    |-	virtual bool allowsSearching() = 0;
+|    |  34|+    virtual bool allowsSearching () = 0;
+|  35|  35| 
+|  36|    |-	virtual const std::string &searchConstraint() = 0;
+|  37|    |-	virtual void setSearchConstraint(const std::string &constraint) = 0;
+|  38|    |-	virtual void clearSearchConstraint() = 0;
+|  39|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) = 0;
+|    |  36|+    virtual const std::string & searchConstraint () = 0;
+|    |  37|+    virtual void setSearchConstraint (const std::string & constraint) = 0;
+|    |  38|+    virtual void clearSearchConstraint () = 0;
+|    |  39|+    virtual bool search (SearchDirection direction, bool wrap,
+|    |  40|+                         bool skip_current) = 0;
+|  40|  41| };
+|  41|  42| 
+|  42|  43| struct Filterable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  41|  41| 
+|  42|  42| struct Filterable
+|  43|  43| {
+|  44|    |-	virtual bool allowsFiltering() = 0;
+|  45|    |-	virtual std::string currentFilter() = 0;
+|  46|    |-	virtual void applyFilter(const std::string &constraint) = 0;
+|    |  44|+    virtual bool allowsFiltering () = 0;
+|    |  45|+    virtual std::string currentFilter () = 0;
+|    |  46|+    virtual void applyFilter (const std::string & constraint) = 0;
+|  47|  47| };
+|  48|  48| 
+|  49|  49| struct HasActions
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  48|  48| 
+|  49|  49| struct HasActions
+|  50|  50| {
+|  51|    |-	virtual bool actionRunnable() = 0;
+|  52|    |-	virtual void runAction() = 0;
+|    |  51|+    virtual bool actionRunnable () = 0;
+|    |  52|+    virtual void runAction () = 0;
+|  53|  53| };
+|  54|  54| 
+|  55|  55| struct HasSongs
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  54|  54| 
+|  55|  55| struct HasSongs
+|  56|  56| {
+|  57|    |-	virtual bool itemAvailable() = 0;
+|  58|    |-	virtual bool addItemToPlaylist(bool play) = 0;
+|  59|    |-	virtual std::vector<MPD::Song> getSelectedSongs() = 0;
+|    |  57|+    virtual bool itemAvailable () = 0;
+|    |  58|+    virtual bool addItemToPlaylist (bool play) = 0;
+|    |  59|+    virtual std::vector < MPD::Song > getSelectedSongs () = 0;
+|  60|  60| };
+|  61|  61| 
+|  62|  62| struct HasColumns
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  61|  61| 
+|  62|  62| struct HasColumns
+|  63|  63| {
+|  64|    |-	virtual bool previousColumnAvailable() = 0;
+|  65|    |-	virtual void previousColumn() = 0;
+|  66|    |-	
+|  67|    |-	virtual bool nextColumnAvailable() = 0;
+|  68|    |-	virtual void nextColumn() = 0;
+|    |  64|+    virtual bool previousColumnAvailable () = 0;
+|    |  65|+    virtual void previousColumn () = 0;
+|    |  66|+
+|    |  67|+    virtual bool nextColumnAvailable () = 0;
+|    |  68|+    virtual void nextColumn () = 0;
+|  69|  69| };
+|  70|  70| 
+|  71|  71| struct Tabbable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/interfaces.h
+|    |++++| /app/src/interfaces.h
+|  70|  70| 
+|  71|  71| struct Tabbable
+|  72|  72| {
+|  73|    |-	Tabbable() : m_previous_screen(0) { }
+|  74|    |-	
+|  75|    |-	void switchToPreviousScreen() const {
+|  76|    |-		if (m_previous_screen)
+|  77|    |-			m_previous_screen->switchTo();
+|  78|    |-	}
+|  79|    |-	void setPreviousScreen(BaseScreen *screen) {
+|  80|    |-		m_previous_screen = screen;
+|  81|    |-	}
+|  82|    |-	BaseScreen *previousScreen() const {
+|  83|    |-		return m_previous_screen;
+|  84|    |-	}
+|  85|    |-	
+|  86|    |-private:
+|  87|    |-	BaseScreen *m_previous_screen;
+|    |  73|+    Tabbable ():m_previous_screen (0)
+|    |  74|+    {
+|    |  75|+    }
+|    |  76|+
+|    |  77|+    void switchToPreviousScreen () const
+|    |  78|+    {
+|    |  79|+        if (m_previous_screen)
+|    |  80|+            m_previous_screen->switchTo ();
+|    |  81|+    }
+|    |  82|+    void setPreviousScreen (BaseScreen * screen)
+|    |  83|+    {
+|    |  84|+        m_previous_screen = screen;
+|    |  85|+    }
+|    |  86|+    BaseScreen *previousScreen () const
+|    |  87|+    {
+|    |  88|+        return m_previous_screen;
+|    |  89|+    }
+|    |  90|+
+|    |  91|+  private:
+|    |  92|+      BaseScreen * m_previous_screen;
+|  88|  93| };
+|  89|  94| 
+|  90|  95| #endif // NCMPCPP_INTERFACES_H
+
+src/interfaces.h
+|  28| #include•"gcc.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'gcc.h' does not need to be #included
+
+src/interfaces.h
+|  30| #include•"song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'song.h' does not need to be #included; use a forward declaration instead
+
+src/interfaces.h
+|  27| #include•"enums.h"
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/macro_utilities.h
+|    |++++| /app/src/macro_utilities.h
+|  25|  25| #include "actions.h"
+|  26|  26| #include "screens/screen_type.h"
+|  27|  27| 
+|  28|    |-namespace Actions {
+|    |  28|+namespace Actions
+|    |  29|+{
+|  29|  30| 
+|  30|    |-struct PushCharacters: BaseAction
+|  31|    |-{
+|  32|    |-	PushCharacters(NC::Window **w, std::vector<NC::Key::Type> &&queue);
+|    |  31|+    struct PushCharacters:BaseAction
+|    |  32|+    {
+|    |  33|+        PushCharacters (NC::Window ** w,
+|    |  34|+                        std::vector < NC::Key::Type > &&queue);
+|  33|  35| 
+|  34|    |-private:
+|  35|    |-	virtual void run() override;
+|  36|    |-	
+|  37|    |-	NC::Window **m_window;
+|  38|    |-	std::vector<NC::Key::Type> m_queue;
+|  39|    |-};
+|    |  36|+      private:
+|    |  37|+        virtual void run () override;
+|  40|  38| 
+|  41|    |-struct RequireRunnable: BaseAction
+|  42|    |-{
+|  43|    |-	RequireRunnable(std::shared_ptr<BaseAction> action);
+|  44|    |-	
+|  45|    |-private:
+|  46|    |-	virtual bool canBeRun() override;
+|  47|    |-	virtual void run() override { }
+|  48|    |-	
+|  49|    |-	std::shared_ptr<BaseAction> m_action;
+|  50|    |-};
+|    |  39|+          NC::Window ** m_window;
+|    |  40|+          std::vector < NC::Key::Type > m_queue;
+|    |  41|+    };
+|  51|  42| 
+|  52|    |-struct RequireScreen: BaseAction
+|  53|    |-{
+|  54|    |-	RequireScreen(ScreenType screen_type);
+|  55|    |-	
+|  56|    |-private:
+|  57|    |-	virtual bool canBeRun() override;
+|  58|    |-	virtual void run() override { }
+|  59|    |-	
+|  60|    |-	ScreenType m_screen_type;
+|  61|    |-};
+|    |  43|+    struct RequireRunnable:BaseAction
+|    |  44|+    {
+|    |  45|+        RequireRunnable (std::shared_ptr < BaseAction > action);
+|  62|  46| 
+|  63|    |-struct RunExternalCommand: BaseAction
+|  64|    |-{
+|  65|    |-	RunExternalCommand(std::string &&command);
+|  66|    |-	
+|  67|    |-private:
+|  68|    |-	virtual void run() override;
+|  69|    |-	
+|  70|    |-	std::string m_command;
+|  71|    |-};
+|    |  47|+      private:
+|    |  48|+        virtual bool canBeRun () override;
+|    |  49|+        virtual void run () override
+|    |  50|+        {
+|    |  51|+        }
+|    |  52|+
+|    |  53|+        std::shared_ptr < BaseAction > m_action;
+|    |  54|+    };
+|    |  55|+
+|    |  56|+    struct RequireScreen:BaseAction
+|    |  57|+    {
+|    |  58|+        RequireScreen (ScreenType screen_type);
+|    |  59|+
+|    |  60|+      private:
+|    |  61|+        virtual bool canBeRun () override;
+|    |  62|+        virtual void run () override
+|    |  63|+        {
+|    |  64|+        }
+|    |  65|+
+|    |  66|+        ScreenType m_screen_type;
+|    |  67|+    };
+|    |  68|+
+|    |  69|+    struct RunExternalCommand:BaseAction
+|    |  70|+    {
+|    |  71|+        RunExternalCommand (std::string && command);
+|    |  72|+
+|    |  73|+      private:
+|    |  74|+        virtual void run () override;
+|    |  75|+
+|    |  76|+          std::string m_command;
+|    |  77|+    };
+|  72|  78| 
+|  73|  79| }
+|  74|  80| 
+
+src/macro_utilities.h
+| 196| The line belonging to the following result cannot be printed because it refers to a line that doesn't seem to exist in the given file.
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/helpers.cpp
+|    |++++| /app/src/helpers.cpp
+|  29|  29| #include "statusbar.h"
+|  30|  30| #include "utility/functional.h"
+|  31|  31| 
+|  32|    |-const MPD::Song *currentSong(const BaseScreen *screen)
+|  33|    |-{
+|  34|    |-	const MPD::Song *ptr = nullptr;
+|  35|    |-	const auto *list = dynamic_cast<const SongList *>(screen->activeWindow());
+|  36|    |-	if (list != nullptr)
+|  37|    |-	{
+|  38|    |-		const auto it = list->currentS();
+|  39|    |-		if (it != list->endS())
+|  40|    |-			ptr = it->song();
+|  41|    |-	}
+|  42|    |-	return ptr;
+|  43|    |-}
+|  44|    |-
+|  45|    |-MPD::SongIterator getDatabaseIterator(MPD::Connection &mpd)
+|  46|    |-{
+|  47|    |-	MPD::SongIterator result;
+|  48|    |-	try
+|  49|    |-	{
+|  50|    |-		result = mpd.GetDirectoryRecursive("/");
+|  51|    |-	}
+|  52|    |-	catch (MPD::ClientError &e)
+|  53|    |-	{
+|  54|    |-		if (e.code() == MPD_ERROR_CLOSED)
+|  55|    |-		{
+|  56|    |-			// If we can't get the database, display appropriate
+|  57|    |-			// error message and reconnect with the MPD server.
+|  58|    |-			Statusbar::print("Unable to fetch the data, increase max_output_buffer_size in your MPD configuration file");
+|  59|    |-			mpd.Disconnect();
+|  60|    |-			mpd.Connect();
+|  61|    |-		}
+|  62|    |-		else
+|  63|    |-			throw;
+|  64|    |-	}
+|  65|    |-	catch (MPD::ServerError &e)
+|  66|    |-	{
+|  67|    |-		// mopidy blacklists 'listallinfo' command by default and throws server
+|  68|    |-		// error when it receives it. Work around that to prevent ncmpcpp from
+|  69|    |-		// continuously retrying to send the command and looping.
+|  70|    |-		if (strstr(e.what(), "listallinfo") != nullptr
+|  71|    |-		    && strstr(e.what(), "disabled") != nullptr)
+|  72|    |-			Statusbar::print("Unable to fetch the data, server refused to process 'listallinfo' command");
+|  73|    |-		else
+|  74|    |-			throw;
+|  75|    |-	}
+|  76|    |-	return result;
+|  77|    |-}
+|  78|    |-
+|  79|    |-void removeSongFromPlaylist(const SongMenu &playlist, const MPD::Song &s)
+|  80|    |-{
+|  81|    |-	Mpd.StartCommandsList();
+|  82|    |-	for (auto &item : boost::adaptors::reverse(playlist))
+|  83|    |-		if (item.value() == s)
+|  84|    |-			Mpd.Delete(item.value().getPosition());
+|  85|    |-	Mpd.CommitCommandsList();
+|  86|    |-}
+|  87|    |-
+|  88|    |-bool addSongToPlaylist(const MPD::Song &s, bool play, int position)
+|  89|    |-{
+|  90|    |-	bool result = false;
+|  91|    |-	if (Config.space_add_mode == SpaceAddMode::AddRemove
+|  92|    |-	&&  myPlaylist->checkForSong(s)
+|  93|    |-	   )
+|  94|    |-	{
+|  95|    |-		result = true;
+|  96|    |-		if (play)
+|  97|    |-		{
+|  98|    |-			const auto begin = myPlaylist->main().beginV(), end = myPlaylist->main().endV();
+|  99|    |-			auto it = find_map_first(begin, end, s, [](const MPD::Song &found) {
+| 100|    |-				Mpd.PlayID(found.getID());
+| 101|    |-			});
+| 102|    |-			assert(it != end);
+| 103|    |-		}
+| 104|    |-		else
+| 105|    |-			removeSongFromPlaylist(myPlaylist->main(), s);
+| 106|    |-		return result;
+| 107|    |-	}
+| 108|    |-	int id = Mpd.AddSong(s, position);
+| 109|    |-	if (id >= 0)
+| 110|    |-	{
+| 111|    |-		Statusbar::printf("Added to playlist: %s",
+| 112|    |-			Format::stringify<char>(Config.song_status_format, &s)
+| 113|    |-		);
+| 114|    |-		if (play)
+| 115|    |-			Mpd.PlayID(id);
+| 116|    |-		result = true;
+| 117|    |-	}
+| 118|    |-	return result;
+| 119|    |-}
+| 120|    |-
+| 121|    |-std::string timeFormat(const char *format, time_t t)
+| 122|    |-{
+| 123|    |-	char result[32];
+| 124|    |-	tm tinfo;
+| 125|    |-	localtime_r(&t, &tinfo);
+| 126|    |-	strftime(result, sizeof(result), format, &tinfo);
+| 127|    |-	return result;
+| 128|    |-}
+| 129|    |-
+| 130|    |-std::string Timestamp(time_t t)
+| 131|    |-{
+| 132|    |-	char result[32];
+| 133|    |-	tm info;
+| 134|    |-	result[strftime(result, 31, "%x %X", localtime_r(&t, &info))] = 0;
+| 135|    |-	return result;
+| 136|    |-}
+| 137|    |-
+| 138|    |-std::wstring Scroller(const std::wstring &str, size_t &pos, size_t width)
+| 139|    |-{
+| 140|    |-	std::wstring s(str);
+| 141|    |-	if (!Config.header_text_scrolling)
+| 142|    |-		return s;
+| 143|    |-	std::wstring result;
+| 144|    |-	size_t len = wideLength(s);
+| 145|    |-	
+| 146|    |-	if (len > width)
+| 147|    |-	{
+| 148|    |-		s += L" ** ";
+| 149|    |-		len = 0;
+| 150|    |-		auto b = s.begin(), e = s.end();
+| 151|    |-		for (auto it = b+pos; it < e && len < width; ++it)
+| 152|    |-		{
+| 153|    |-			if ((len += wcwidth(*it)) > width)
+| 154|    |-				break;
+| 155|    |-			result += *it;
+| 156|    |-		}
+| 157|    |-		if (++pos >= s.length())
+| 158|    |-			pos = 0;
+| 159|    |-		for (; len < width; ++b)
+| 160|    |-		{
+| 161|    |-			if ((len += wcwidth(*b)) > width)
+| 162|    |-				break;
+| 163|    |-			result += *b;
+| 164|    |-		}
+| 165|    |-	}
+| 166|    |-	else
+| 167|    |-		result = s;
+| 168|    |-	return result;
+| 169|    |-}
+| 170|    |-
+| 171|    |-void writeCyclicBuffer(const NC::WBuffer &buf, NC::Window &w, size_t &start_pos,
+| 172|    |-                       size_t width, const std::wstring &separator)
+| 173|    |-{
+| 174|    |-	const auto &s = buf.str();
+| 175|    |-	size_t len = wideLength(s);
+| 176|    |-	if (len > width)
+| 177|    |-	{
+| 178|    |-		len = 0;
+| 179|    |-		const auto &ps = buf.properties();
+| 180|    |-		auto p = ps.begin();
+| 181|    |-		
+| 182|    |-		// load attributes from before starting pos
+| 183|    |-		for (; p != ps.end() && p->first < start_pos; ++p)
+| 184|    |-			w << p->second;
+| 185|    |-		
+| 186|    |-		auto write_buffer = [&](size_t start) {
+| 187|    |-			for (size_t i = start; i < s.length() && len < width; ++i)
+| 188|    |-			{
+| 189|    |-				for (; p != ps.end() && p->first == i; ++p)
+| 190|    |-					w << p->second;
+| 191|    |-				len += wcwidth(s[i]);
+| 192|    |-				if (len > width)
+| 193|    |-					break;
+| 194|    |-				w << s[i];
+| 195|    |-			}
+| 196|    |-			for (; p != ps.end(); ++p)
+| 197|    |-				w << p->second;
+| 198|    |-			p = ps.begin();
+| 199|    |-		};
+| 200|    |-		
+| 201|    |-		write_buffer(start_pos);
+| 202|    |-		size_t i = 0;
+| 203|    |-		if (start_pos > s.length())
+| 204|    |-			i = start_pos - s.length();
+| 205|    |-		for (; i < separator.length() && len < width; ++i)
+| 206|    |-		{
+| 207|    |-			len += wcwidth(separator[i]);
+| 208|    |-			if (len > width)
+| 209|    |-				break;
+| 210|    |-			w << separator[i];
+| 211|    |-		}
+| 212|    |-		write_buffer(0);
+| 213|    |-		
+| 214|    |-		++start_pos;
+| 215|    |-		if (start_pos >= s.length() + separator.length())
+| 216|    |-			start_pos = 0;
+| 217|    |-	}
+| 218|    |-	else
+| 219|    |-		w << buf;
+| 220|    |-}
+|    |  32|+const
+|    |  33|+    MPD::Song *
+|    |  34|+currentSong (const BaseScreen * screen)
+|    |  35|+{
+|    |  36|+    const MPD::Song * ptr = nullptr;
+|    |  37|+    const auto *list =
+|    |  38|+        dynamic_cast < const SongList * >(screen->activeWindow ());
+|    |  39|+    if (list != nullptr)
+|    |  40|+      {
+|    |  41|+          const auto it = list->currentS ();
+|    |  42|+          if (it != list->endS ())
+|    |  43|+              ptr = it->song ();
+|    |  44|+      }
+|    |  45|+    return ptr;
+|    |  46|+}
+|    |  47|+
+|    |  48|+MPD::SongIterator getDatabaseIterator (MPD::Connection & mpd)
+|    |  49|+{
+|    |  50|+    MPD::SongIterator result;
+|    |  51|+    try
+|    |  52|+    {
+|    |  53|+        result = mpd.GetDirectoryRecursive ("/");
+|    |  54|+    }
+|    |  55|+    catch (MPD::ClientError & e)
+|    |  56|+    {
+|    |  57|+        if (e.code () == MPD_ERROR_CLOSED)
+|    |  58|+          {
+|    |  59|+              // If we can't get the database, display appropriate
+|    |  60|+              // error message and reconnect with the MPD server.
+|    |  61|+              Statusbar::
+|    |  62|+                  print
+|    |  63|+                  ("Unable to fetch the data, increase max_output_buffer_size in your MPD configuration file");
+|    |  64|+              mpd.Disconnect ();
+|    |  65|+              mpd.Connect ();
+|    |  66|+          }
+|    |  67|+        else
+|    |  68|+            throw;
+|    |  69|+    }
+|    |  70|+    catch (MPD::ServerError & e)
+|    |  71|+    {
+|    |  72|+        // mopidy blacklists 'listallinfo' command by default and throws server
+|    |  73|+        // error when it receives it. Work around that to prevent ncmpcpp from
+|    |  74|+        // continuously retrying to send the command and looping.
+|    |  75|+        if (strstr (e.what (), "listallinfo") != nullptr
+|    |  76|+            && strstr (e.what (), "disabled") != nullptr)
+|    |  77|+            Statusbar::
+|    |  78|+                print
+|    |  79|+                ("Unable to fetch the data, server refused to process 'listallinfo' command");
+|    |  80|+        else
+|    |  81|+            throw;
+|    |  82|+    }
+|    |  83|+    return result;
+|    |  84|+}
+|    |  85|+
+|    |  86|+void
+|    |  87|+removeSongFromPlaylist (const SongMenu & playlist, const MPD::Song & s)
+|    |  88|+{
+|    |  89|+    Mpd.StartCommandsList ();
+|    |  90|+  for (auto & item:boost::adaptors::reverse (playlist))
+|    |  91|+        if (item.value () == s)
+|    |  92|+            Mpd.Delete (item.value ().getPosition ());
+|    |  93|+    Mpd.CommitCommandsList ();
+|    |  94|+}
+|    |  95|+
+|    |  96|+bool
+|    |  97|+addSongToPlaylist (const MPD::Song & s, bool play, int position)
+|    |  98|+{
+|    |  99|+    bool result = false;
+|    | 100|+    if (Config.space_add_mode == SpaceAddMode::AddRemove
+|    | 101|+        && myPlaylist->checkForSong (s))
+|    | 102|+      {
+|    | 103|+          result = true;
+|    | 104|+          if (play)
+|    | 105|+            {
+|    | 106|+                const auto begin = myPlaylist->main ().beginV (), end =
+|    | 107|+                    myPlaylist->main ().endV ();
+|    | 108|+                auto it =
+|    | 109|+                    find_map_first (begin, end, s,[](const MPD::Song & found) {
+|    | 110|+                                    Mpd.PlayID (found.getID ());});
+|    | 111|+                assert (it != end);
+|    | 112|+            }
+|    | 113|+          else
+|    | 114|+              removeSongFromPlaylist (myPlaylist->main (), s);
+|    | 115|+          return result;
+|    | 116|+      }
+|    | 117|+    int id = Mpd.AddSong (s, position);
+|    | 118|+    if (id >= 0)
+|    | 119|+      {
+|    | 120|+          Statusbar::printf ("Added to playlist: %s",
+|    | 121|+                             Format::stringify <
+|    | 122|+                             char >(Config.song_status_format, &s));
+|    | 123|+          if (play)
+|    | 124|+              Mpd.PlayID (id);
+|    | 125|+          result = true;
+|    | 126|+      }
+|    | 127|+    return result;
+|    | 128|+}
+|    | 129|+
+|    | 130|+std::string timeFormat (const char *format, time_t t)
+|    | 131|+{
+|    | 132|+    char result[32];
+|    | 133|+    tm tinfo;
+|    | 134|+    localtime_r (&t, &tinfo);
+|    | 135|+    strftime (result, sizeof (result), format, &tinfo);
+|    | 136|+    return result;
+|    | 137|+}
+|    | 138|+
+|    | 139|+std::string Timestamp (time_t t)
+|    | 140|+{
+|    | 141|+    char result[32];
+|    | 142|+    tm info;
+|    | 143|+    result[strftime (result, 31, "%x %X", localtime_r (&t, &info))] = 0;
+|    | 144|+    return result;
+|    | 145|+}
+|    | 146|+
+|    | 147|+std::wstring Scroller (const std::wstring & str, size_t & pos, size_t width)
+|    | 148|+{
+|    | 149|+    std::wstring s (str);
+|    | 150|+    if (!Config.header_text_scrolling)
+|    | 151|+        return s;
+|    | 152|+    std::wstring result;
+|    | 153|+    size_t len = wideLength (s);
+|    | 154|+
+|    | 155|+    if (len > width)
+|    | 156|+      {
+|    | 157|+          s += L" ** ";
+|    | 158|+          len = 0;
+|    | 159|+          auto b = s.begin (), e = s.end ();
+|    | 160|+          for (auto it = b + pos; it < e && len < width; ++it)
+|    | 161|+            {
+|    | 162|+                if ((len += wcwidth (*it)) > width)
+|    | 163|+                    break;
+|    | 164|+                result += *it;
+|    | 165|+            }
+|    | 166|+          if (++pos >= s.length ())
+|    | 167|+              pos = 0;
+|    | 168|+          for (; len < width; ++b)
+|    | 169|+            {
+|    | 170|+                if ((len += wcwidth (*b)) > width)
+|    | 171|+                    break;
+|    | 172|+                result += *b;
+|    | 173|+            }
+|    | 174|+      }
+|    | 175|+    else
+|    | 176|+        result = s;
+|    | 177|+    return result;
+|    | 178|+}
+|    | 179|+
+|    | 180|+void
+|    | 181|+writeCyclicBuffer (const NC::WBuffer & buf, NC::Window & w, size_t & start_pos,
+|    | 182|+                   size_t width, const std::wstring & separator)
+|    | 183|+{
+|    | 184|+    const auto & s = buf.str ();
+|    | 185|+    size_t len = wideLength (s);
+|    | 186|+    if (len > width)
+|    | 187|+      {
+|    | 188|+          len = 0;
+|    | 189|+          const auto & ps = buf.properties ();
+|    | 190|+          auto p = ps.begin ();
+|    | 191|+
+|    | 192|+          // load attributes from before starting pos
+|    | 193|+          for (; p != ps.end () && p->first < start_pos; ++p)
+|    | 194|+              w << p->second;
+|    | 195|+
+|    | 196|+          auto write_buffer =[&](size_t start) {
+|    | 197|+              for (size_t i = start; i < s.length () && len < width; ++i)
+|    | 198|+                {
+|    | 199|+                    for (; p != ps.end () && p->first == i; ++p)
+|    | 200|+                        w << p->second;
+|    | 201|+                    len += wcwidth (s[i]);
+|    | 202|+                    if (len > width)
+|    | 203|+                        break;
+|    | 204|+                    w << s[i];
+|    | 205|+                }
+|    | 206|+              for (; p != ps.end (); ++p)
+|    | 207|+                  w << p->second;
+|    | 208|+              p = ps.begin ();
+|    | 209|+          };
+|    | 210|+
+|    | 211|+          write_buffer (start_pos);
+|    | 212|+          size_t i = 0;
+|    | 213|+          if (start_pos > s.length ())
+|    | 214|+              i = start_pos - s.length ();
+|    | 215|+          for (; i < separator.length () && len < width; ++i)
+|    | 216|+            {
+|    | 217|+                len += wcwidth (separator[i]);
+|    | 218|+                if (len > width)
+|    | 219|+                    break;
+|    | 220|+                w << separator[i];
+|    | 221|+            }
+|    | 222|+          write_buffer (0);
+|    | 223|+
+|    | 224|+          ++start_pos;
+|    | 225|+          if (start_pos >= s.length () + separator.length ())
+|    | 226|+              start_pos = 0;
+|    | 227|+      }
+|    | 228|+    else
+|    | 229|+        w << buf;
+|    | 230|+}
+
+src/helpers.cpp
+|  28| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'screens/playlist.h' already #included in '/app/src/helpers.h'
+
+src/helpers.cpp
+|  79| void•removeSongFromPlaylist(const•SongMenu•&playlist,•const•MPD::Song•&s)
+|    | [NORMAL] CPPCleanBear:
+|    | 'removeSongFromPlaylist' not found in expected header '/app/src/helpers.h' or any other directly #included header
+
+src/helpers.cpp
+| 505| The line belonging to the following result cannot be printed because it refers to a line that doesn't seem to exist in the given file.
+|    | [NORMAL] CPPCleanBear:
+|    | 'ShowTag' declared but not defined
+
+src/helpers.cpp
+| 526| The line belonging to the following result cannot be printed because it refers to a line that doesn't seem to exist in the given file.
+|    | [NORMAL] CPPCleanBear:
+|    | 'withErrors' declared but not defined
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  24|  24| #include "interfaces.h"
+|  25|  25| #include "mpdpp.h"
+|  26|  26| 
+|  27|    |-namespace Status {
+|    |  27|+namespace Status
+|    |  28|+{
+|  28|  29| 
+|  29|    |-void handleClientError(MPD::ClientError &e);
+|  30|    |-void handleServerError(MPD::ServerError &e);
+|    |  30|+    void handleClientError (MPD::ClientError & e);
+|    |  31|+    void handleServerError (MPD::ServerError & e);
+|  31|  32| 
+|  32|    |-void trace(bool update_timer, bool update_window_timeout);
+|  33|    |-inline void trace() { trace(true, false); }
+|  34|    |-void update(int event);
+|  35|    |-void clear();
+|    |  33|+    void trace (bool update_timer, bool update_window_timeout);
+|    |  34|+    inline void trace ()
+|    |  35|+    {
+|    |  36|+        trace (true, false);
+|    |  37|+    }
+|    |  38|+    void update (int event);
+|    |  39|+    void clear ();
+|  36|  40| 
+|  37|    |-namespace State {
+|    |  41|+    namespace State
+|    |  42|+    {
+|  38|  43| 
+|  39|  44| // flags
+|  40|  45| bool consume();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  37|  37| namespace State {
+|  38|  38| 
+|  39|  39| // flags
+|  40|    |-bool consume();
+|  41|    |-bool crossfade();
+|  42|    |-bool repeat();
+|  43|    |-bool random();
+|  44|    |-bool single();
+|    |  40|+        bool consume ();
+|    |  41|+        bool crossfade ();
+|    |  42|+        bool repeat ();
+|    |  43|+        bool random ();
+|    |  44|+        bool single ();
+|  45|  45| 
+|  46|  46| // misc
+|  47|  47| int currentSongID();
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  44|  44| bool single();
+|  45|  45| 
+|  46|  46| // misc
+|  47|    |-int currentSongID();
+|  48|    |-int currentSongPosition();
+|  49|    |-unsigned playlistLength();
+|  50|    |-unsigned elapsedTime();
+|  51|    |-MPD::PlayerState player();
+|  52|    |-unsigned totalTime();
+|  53|    |-int volume();
+|    |  47|+        int currentSongID ();
+|    |  48|+        int currentSongPosition ();
+|    |  49|+        unsigned playlistLength ();
+|    |  50|+        unsigned elapsedTime ();
+|    |  51|+          MPD::PlayerState player ();
+|    |  52|+        unsigned totalTime ();
+|    |  53|+        int volume ();
+|    |  54|+
+|    |  55|+    }
+|    |  56|+
+|    |  57|+    namespace Changes
+|    |  58|+    {
+|    |  59|+
+|    |  60|+        void playlist (unsigned previous_version);
+|    |  61|+        void storedPlaylists ();
+|    |  62|+        void database ();
+|    |  63|+        void playerState ();
+|    |  64|+        void songID (int song_id);
+|    |  65|+        void elapsedTime (bool update_elapsed);
+|    |  66|+        void flags ();
+|    |  67|+        void mixer ();
+|    |  68|+        void outputs ();
+|    |  69|+
+|    |  70|+    }
+|  54|  71| 
+|  55|  72| }
+|  56|  73| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/status.h
+|    |++++| /app/src/status.h
+|  54|  54| 
+|  55|  55| }
+|  56|  56| 
+|  57|    |-namespace Changes {
+|  58|    |-
+|  59|    |-void playlist(unsigned previous_version);
+|  60|    |-void storedPlaylists();
+|  61|    |-void database();
+|  62|    |-void playerState();
+|  63|    |-void songID(int song_id);
+|  64|    |-void elapsedTime(bool update_elapsed);
+|  65|    |-void flags();
+|  66|    |-void mixer();
+|  67|    |-void outputs();
+|  68|    |-
+|  69|    |-}
+|  70|    |-
+|  71|    |-}
+|  72|    |-
+|  73|    |-#endif // NCMPCPP_STATUS_CHECKER_H
+|    |  57|+#endif                          // NCMPCPP_STATUS_CHECKER_H
+
+src/status.h
+|  24| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | 'interfaces.h' does not need to be #included
+
+src/status.h
+|  27| namespace•Status•{
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curl_handle.h
+|    |++++| /app/src/curl_handle.h
+|  28|  28| 
+|  29|  29| namespace Curl
+|  30|  30| {
+|  31|    |-	CURLcode perform(std::string &data, const std::string &URL, const std::string &referer = "", bool follow_redirect = false, unsigned timeout = 10);
+|  32|    |-	
+|  33|    |-	std::string escape(const std::string &s);
+|    |  31|+    CURLcode perform (std::string & data, const std::string & URL,
+|    |  32|+                      const std::string & referer = "", bool follow_redirect =
+|    |  33|+                      false, unsigned timeout = 10);
+|    |  34|+
+|    |  35|+      std::string escape (const std::string & s);
+|  34|  36| }
+|  35|  37| 
+|  36|  38| #endif // NCMPCPP_CURL_HANDLE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curl_handle.h
+|    |++++| /app/src/curl_handle.h
+|  33|  33| 	std::string escape(const std::string &s);
+|  34|  34| }
+|  35|  35| 
+|  36|    |-#endif // NCMPCPP_CURL_HANDLE_H
+|    |  36|+#endif                          // NCMPCPP_CURL_HANDLE_H
+
+src/curl_handle.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/curl_handle.h
+|  27| #include•"curl/curl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curl/curl.h'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/scoped_value.h
+|    |++++| /app/src/utility/scoped_value.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_SCOPED_VALUE_H
+|  22|  22| #define NCMPCPP_UTILITY_SCOPED_VALUE_H
+|  23|  23| 
+|  24|    |-template <typename ValueT>
+|  25|    |-struct ScopedValue
+|    |  24|+template < typename ValueT > struct ScopedValue
+|  26|  25| {
+|  27|    |-	ScopedValue(ValueT &ref, ValueT &&new_value)
+|  28|    |-		: m_ref(ref)
+|  29|    |-	{
+|  30|    |-		m_value = ref;
+|  31|    |-		m_ref = std::forward<ValueT>(new_value);
+|  32|    |-	}
+|    |  26|+    ScopedValue (ValueT & ref, ValueT && new_value):m_ref (ref)
+|    |  27|+    {
+|    |  28|+        m_value = ref;
+|    |  29|+        m_ref = std::forward < ValueT > (new_value);
+|    |  30|+    }
+|  33|  31| 
+|  34|    |-	~ScopedValue()
+|  35|    |-	{
+|  36|    |-		m_ref = std::move(m_value);
+|  37|    |-	}
+|    |  32|+     ~ScopedValue ()
+|    |  33|+    {
+|    |  34|+        m_ref = std::move (m_value);
+|    |  35|+    }
+|  38|  36| 
+|  39|    |-private:
+|  40|    |-	ValueT &m_ref;
+|  41|    |-	ValueT m_value;
+|    |  37|+  private:
+|    |  38|+    ValueT & m_ref;
+|    |  39|+    ValueT m_value;
+|  42|  40| };
+|  43|  41| 
+|  44|  42| #endif // NCMPCPP_UTILITY_SCOPED_VALUE_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/extras/artist_to_albumartist.cpp
+|    |++++| /app/extras/artist_to_albumartist.cpp
+|  29|  29| #include <id3v2tag.h>
+|  30|  30| #include <xiphcomment.h>
+|  31|  31| 
+|  32|    |-enum class CopyResult { Success, NoArtist, AlbumArtistAlreadyInPlace };
+|    |  32|+enum class CopyResult
+|    |  33|+{ Success, NoArtist, AlbumArtistAlreadyInPlace };
+|  33|  34| 
+|  34|    |-bool is_framelist_empty(const TagLib::ID3v2::FrameList &list)
+|    |  35|+bool
+|    |  36|+is_framelist_empty (const TagLib::ID3v2::FrameList & list)
+|  35|  37| {
+|  36|    |-	for (auto it = list.begin(); it != list.end(); ++it)
+|  37|    |-		if ((*it)->toString() != TagLib::String::null)
+|  38|    |-			return false;
+|  39|    |-	return true;
+|    |  38|+    for (auto it = list.begin (); it != list.end (); ++it)
+|    |  39|+        if ((*it)->toString () != TagLib::String::null)
+|    |  40|+            return false;
+|    |  41|+    return true;
+|  40|  42| }
+|  41|  43| 
+|  42|  44| CopyResult copy_album_artist(TagLib::ID3v2::Tag *tag)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/extras/artist_to_albumartist.cpp
+|    |++++| /app/extras/artist_to_albumartist.cpp
+|  39|  39| 	return true;
+|  40|  40| }
+|  41|  41| 
+|  42|    |-CopyResult copy_album_artist(TagLib::ID3v2::Tag *tag)
+|    |  42|+CopyResult
+|    |  43|+copy_album_artist (TagLib::ID3v2::Tag * tag)
+|  43|  44| {
+|  44|    |-	typedef TagLib::ID3v2::TextIdentificationFrame TextFrame;
+|  45|    |-	
+|  46|    |-	TagLib::ByteVector album_artist = "TPE2";
+|  47|    |-	if (!is_framelist_empty(tag->frameList(album_artist)))
+|  48|    |-		return CopyResult::AlbumArtistAlreadyInPlace;
+|  49|    |-	
+|  50|    |-	auto artists = tag->frameList("TPE1");
+|  51|    |-	if (artists.isEmpty())
+|  52|    |-		return CopyResult::NoArtist;
+|  53|    |-	
+|  54|    |-	for (auto it = artists.begin(); it != artists.end(); ++it)
+|  55|    |-	{
+|  56|    |-		// this cast should always succeed.
+|  57|    |-		auto &textIt = dynamic_cast<TextFrame &>(**it);
+|  58|    |-		auto frame = new TextFrame(album_artist, TagLib::String::UTF8);
+|  59|    |-		frame->setText(textIt.fieldList());
+|  60|    |-		tag->addFrame(frame);
+|  61|    |-	}
+|  62|    |-	
+|  63|    |-	return CopyResult::Success;
+|    |  45|+    typedef TagLib::ID3v2::TextIdentificationFrame TextFrame;
+|    |  46|+
+|    |  47|+    TagLib::ByteVector album_artist = "TPE2";
+|    |  48|+    if (!is_framelist_empty (tag->frameList (album_artist)))
+|    |  49|+        return CopyResult::AlbumArtistAlreadyInPlace;
+|    |  50|+
+|    |  51|+    auto artists = tag->frameList ("TPE1");
+|    |  52|+    if (artists.isEmpty ())
+|    |  53|+        return CopyResult::NoArtist;
+|    |  54|+
+|    |  55|+    for (auto it = artists.begin (); it != artists.end (); ++it)
+|    |  56|+      {
+|    |  57|+          // this cast should always succeed.
+|    |  58|+          auto & textIt = dynamic_cast < TextFrame & >(**it);
+|    |  59|+          auto frame = new TextFrame (album_artist, TagLib::String::UTF8);
+|    |  60|+          frame->setText (textIt.fieldList ());
+|    |  61|+          tag->addFrame (frame);
+|    |  62|+      }
+|    |  63|+
+|    |  64|+    return CopyResult::Success;
+|  64|  65| }
+|  65|  66| 
+|  66|  67| CopyResult copy_album_artist(TagLib::Ogg::XiphComment *tag)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/extras/artist_to_albumartist.cpp
+|    |++++| /app/extras/artist_to_albumartist.cpp
+|  63|  63| 	return CopyResult::Success;
+|  64|  64| }
+|  65|  65| 
+|  66|    |-CopyResult copy_album_artist(TagLib::Ogg::XiphComment *tag)
+|    |  66|+CopyResult
+|    |  67|+copy_album_artist (TagLib::Ogg::XiphComment * tag)
+|  67|  68| {
+|  68|    |-	if (tag->contains("ALBUM ARTIST") || tag->contains("ALBUMARTIST"))
+|  69|    |-		return CopyResult::AlbumArtistAlreadyInPlace;
+|  70|    |-	
+|  71|    |-	auto artists = tag->fieldListMap()["ARTIST"];
+|  72|    |-	if (artists.isEmpty())
+|  73|    |-		return CopyResult::NoArtist;
+|  74|    |-	
+|  75|    |-	for (auto it = artists.begin(); it != artists.end(); ++it)
+|  76|    |-		tag->addField("ALBUMARTIST", *it, false);
+|  77|    |-	
+|  78|    |-	return CopyResult::Success;
+|    |  69|+    if (tag->contains ("ALBUM ARTIST") || tag->contains ("ALBUMARTIST"))
+|    |  70|+        return CopyResult::AlbumArtistAlreadyInPlace;
+|    |  71|+
+|    |  72|+    auto artists = tag->fieldListMap ()["ARTIST"];
+|    |  73|+    if (artists.isEmpty ())
+|    |  74|+        return CopyResult::NoArtist;
+|    |  75|+
+|    |  76|+    for (auto it = artists.begin (); it != artists.end (); ++it)
+|    |  77|+        tag->addField ("ALBUMARTIST", *it, false);
+|    |  78|+
+|    |  79|+    return CopyResult::Success;
+|  79|  80| }
+|  80|  81| 
+|  81|  82| void convert(int n, char **files, bool dry_run)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/extras/artist_to_albumartist.cpp
+|    |++++| /app/extras/artist_to_albumartist.cpp
+|  78|  78| 	return CopyResult::Success;
+|  79|  79| }
+|  80|  80| 
+|  81|    |-void convert(int n, char **files, bool dry_run)
+|    |  81|+void
+|    |  82|+convert (int n, char **files, bool dry_run)
+|  82|  83| {
+|  83|    |-	if (n == 0)
+|  84|    |-	{
+|  85|    |-		std::cout << "No files to convert, exiting.\n";
+|  86|    |-		return;
+|  87|    |-	}
+|  88|    |-	if (dry_run)
+|  89|    |-		std::cout << "Dry run mode enabled, pretending to modify files.\n";
+|  90|    |-	
+|  91|    |-	for (int i = 0; i < n; ++i)
+|  92|    |-	{
+|  93|    |-		std::cout << "Modifying " << files[i] << "... ";
+|  94|    |-		
+|  95|    |-		TagLib::FileRef f(files[i]);
+|  96|    |-		if (!f.isNull())
+|  97|    |-		{
+|  98|    |-			CopyResult result;
+|  99|    |-			if (auto mp3_f = dynamic_cast<TagLib::MPEG::File *>(f.file()))
+| 100|    |-			{
+| 101|    |-				result = copy_album_artist(mp3_f->ID3v2Tag(true));
+| 102|    |-			}
+| 103|    |-			else if (auto ogg_f = dynamic_cast<TagLib::Ogg::Vorbis::File *>(f.file()))
+| 104|    |-			{
+| 105|    |-				result = copy_album_artist(ogg_f->tag());
+| 106|    |-			}
+| 107|    |-			else if (auto flac_f = dynamic_cast<TagLib::FLAC::File *>(f.file()))
+| 108|    |-			{
+| 109|    |-				result = copy_album_artist(flac_f->xiphComment(true));
+| 110|    |-			}
+| 111|    |-			else
+| 112|    |-			{
+| 113|    |-				std::cout << "Not mp3/ogg/flac file, skipping.\n";
+| 114|    |-				continue;
+| 115|    |-			}
+| 116|    |-			
+| 117|    |-			switch (result)
+| 118|    |-			{
+| 119|    |-				case CopyResult::Success:
+| 120|    |-					if (!dry_run)
+| 121|    |-						f.save();
+| 122|    |-					std::cout << "Done.\n";
+| 123|    |-					break;
+| 124|    |-				case CopyResult::NoArtist:
+| 125|    |-					std::cout << "Artist not found, skipping.\n";
+| 126|    |-					break;
+| 127|    |-				case CopyResult::AlbumArtistAlreadyInPlace:
+| 128|    |-					std::cout << "AlbumArtist is already there, skipping.\n";
+| 129|    |-					break;
+| 130|    |-			}
+| 131|    |-		}
+| 132|    |-		else
+| 133|    |-			std::cout << "Could not open file, skipping.\n";
+| 134|    |-	}
+|    |  84|+    if (n == 0)
+|    |  85|+      {
+|    |  86|+          std::cout << "No files to convert, exiting.\n";
+|    |  87|+          return;
+|    |  88|+      }
+|    |  89|+    if (dry_run)
+|    |  90|+        std::cout << "Dry run mode enabled, pretending to modify files.\n";
+|    |  91|+
+|    |  92|+    for (int i = 0; i < n; ++i)
+|    |  93|+      {
+|    |  94|+          std::cout << "Modifying " << files[i] << "... ";
+|    |  95|+
+|    |  96|+          TagLib::FileRef f (files[i]);
+|    |  97|+          if (!f.isNull ())
+|    |  98|+            {
+|    |  99|+                CopyResult result;
+|    | 100|+                if (auto mp3_f =
+|    | 101|+                    dynamic_cast < TagLib::MPEG::File * >(f.file ()))
+|    | 102|+                  {
+|    | 103|+                      result = copy_album_artist (mp3_f->ID3v2Tag (true));
+|    | 104|+                  }
+|    | 105|+                else if (auto ogg_f =
+|    | 106|+                         dynamic_cast <
+|    | 107|+                         TagLib::Ogg::Vorbis::File * >(f.file ()))
+|    | 108|+                  {
+|    | 109|+                      result = copy_album_artist (ogg_f->tag ());
+|    | 110|+                  }
+|    | 111|+                else if (auto flac_f =
+|    | 112|+                         dynamic_cast < TagLib::FLAC::File * >(f.file ()))
+|    | 113|+                  {
+|    | 114|+                      result = copy_album_artist (flac_f->xiphComment (true));
+|    | 115|+                  }
+|    | 116|+                else
+|    | 117|+                  {
+|    | 118|+                      std::cout << "Not mp3/ogg/flac file, skipping.\n";
+|    | 119|+                      continue;
+|    | 120|+                  }
+|    | 121|+
+|    | 122|+                switch (result)
+|    | 123|+                  {
+|    | 124|+                  case CopyResult::Success:
+|    | 125|+                      if (!dry_run)
+|    | 126|+                          f.save ();
+|    | 127|+                      std::cout << "Done.\n";
+|    | 128|+                      break;
+|    | 129|+                  case CopyResult::NoArtist:
+|    | 130|+                      std::cout << "Artist not found, skipping.\n";
+|    | 131|+                      break;
+|    | 132|+                  case CopyResult::AlbumArtistAlreadyInPlace:
+|    | 133|+                      std::cout << "AlbumArtist is already there, skipping.\n";
+|    | 134|+                      break;
+|    | 135|+                  }
+|    | 136|+            }
+|    | 137|+          else
+|    | 138|+              std::cout << "Could not open file, skipping.\n";
+|    | 139|+      }
+| 135| 140| }
+| 136| 141| 
+| 137| 142| int main(int argc, char **argv)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/extras/artist_to_albumartist.cpp
+|    |++++| /app/extras/artist_to_albumartist.cpp
+| 134| 134| 	}
+| 135| 135| }
+| 136| 136| 
+| 137|    |-int main(int argc, char **argv)
+|    | 137|+int
+|    | 138|+main (int argc, char **argv)
+| 138| 139| {
+| 139|    |-	if (argc < 2)
+| 140|    |-	{
+| 141|    |-		std::cout << "This little script copies Artist tag (if present) to\n";
+| 142|    |-		std::cout << "AlbumArtist (if not present) for given mp3/ogg/flac files.\n";
+| 143|    |-		std::cout << "\n";
+| 144|    |-		std::cout << "Usage: " << argv[0] << " [--dry-run] files\n";
+| 145|    |-		std::cout << "\n";
+| 146|    |-		std::cout << "Note: to run it recursively for all your files, you can use:\n";
+| 147|    |-		std::cout << "$ find DIRECTORY \\( -name \"*.flac\" -o -name \"*.mp3\" -o -name \"*.ogg\" \\) -exec ./artist_to_albumartist [--dry-run] {} \\;\n";
+| 148|    |-	}
+| 149|    |-	else
+| 150|    |-	{
+| 151|    |-		bool dry_run = !strcmp(argv[1], "--dry-run");
+| 152|    |-		convert(argc-1-dry_run, &argv[1+dry_run], dry_run);
+| 153|    |-	}
+| 154|    |-	return 0;
+|    | 140|+    if (argc < 2)
+|    | 141|+      {
+|    | 142|+          std::
+|    | 143|+              cout << "This little script copies Artist tag (if present) to\n";
+|    | 144|+          std::
+|    | 145|+              cout <<
+|    | 146|+              "AlbumArtist (if not present) for given mp3/ogg/flac files.\n";
+|    | 147|+          std::cout << "\n";
+|    | 148|+          std::cout << "Usage: " << argv[0] << " [--dry-run] files\n";
+|    | 149|+          std::cout << "\n";
+|    | 150|+          std::
+|    | 151|+              cout <<
+|    | 152|+              "Note: to run it recursively for all your files, you can use:\n";
+|    | 153|+          std::
+|    | 154|+              cout <<
+|    | 155|+              "$ find DIRECTORY \\( -name \"*.flac\" -o -name \"*.mp3\" -o -name \"*.ogg\" \\) -exec ./artist_to_albumartist [--dry-run] {} \\;\n";
+|    | 156|+      }
+|    | 157|+    else
+|    | 158|+      {
+|    | 159|+          bool dry_run = !strcmp (argv[1], "--dry-run");
+|    | 160|+          convert (argc - 1 - dry_run, &argv[1 + dry_run], dry_run);
+|    | 161|+      }
+|    | 162|+    return 0;
+| 155| 163| }
+
+extras/artist_to_albumartist.cpp
+|  34| bool•is_framelist_empty(const•TagLib::ID3v2::FrameList•&list)
+|    | [NORMAL] CPPCleanBear:
+|    | 'is_framelist_empty' not found in any directly #included header
+
+extras/artist_to_albumartist.cpp
+|  42| CopyResult•copy_album_artist(TagLib::ID3v2::Tag•*tag)
+|    | [NORMAL] CPPCleanBear:
+|    | 'copy_album_artist' not found in any directly #included header
+
+extras/artist_to_albumartist.cpp
+|  66| CopyResult•copy_album_artist(TagLib::Ogg::XiphComment•*tag)
+|    | [NORMAL] CPPCleanBear:
+|    | 'copy_album_artist' not found in any directly #included header
+
+extras/artist_to_albumartist.cpp
+|  81| void•convert(int•n,•char•**files,•bool•dry_run)
+|    | [NORMAL] CPPCleanBear:
+|    | 'convert' not found in any directly #included header
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song.h
+|    |++++| /app/src/song.h
+|  29|  29| 
+|  30|  30| #include <mpd/client.h>
+|  31|  31| 
+|  32|    |-namespace MPD {
+|    |  32|+namespace MPD
+|    |  33|+{
+|  33|  34| 
+|  34|    |-struct Song
+|  35|    |-{
+|  36|    |-	struct Hash {
+|  37|    |-		size_t operator()(const Song &s) const { return s.m_hash; }
+|  38|    |-	};
+|    |  35|+    struct Song
+|    |  36|+    {
+|    |  37|+        struct Hash
+|    |  38|+        {
+|    |  39|+            size_t operator () (const Song & s) const
+|    |  40|+            {
+|    |  41|+                return s.m_hash;
+|    |  42|+            }
+|    |  43|+        };
+|  39|  44| 
+|  40|    |-	typedef std::string (Song::*GetFunction)(unsigned) const;
+|  41|    |-	
+|  42|    |-	Song() : m_hash(0) { }
+|  43|    |-	virtual ~Song() { }
+|  44|    |-	
+|  45|    |-	Song(mpd_song *s);
+|    |  45|+        typedef std::string (Song::*GetFunction) (unsigned) const;
+|  46|  46| 
+|  47|    |-	Song(const Song &rhs) : m_song(rhs.m_song), m_hash(rhs.m_hash) { }
+|  48|    |-	Song(Song &&rhs) : m_song(std::move(rhs.m_song)), m_hash(rhs.m_hash) { }
+|  49|    |-	Song &operator=(Song rhs)
+|  50|    |-	{
+|  51|    |-		m_song = std::move(rhs.m_song);
+|  52|    |-		m_hash = rhs.m_hash;
+|  53|    |-		return *this;
+|  54|    |-	}
+|  55|    |-	
+|  56|    |-	std::string get(mpd_tag_type type, unsigned idx = 0) const;
+|  57|    |-	
+|  58|    |-	virtual std::string getURI(unsigned idx = 0) const;
+|  59|    |-	virtual std::string getName(unsigned idx = 0) const;
+|  60|    |-	virtual std::string getDirectory(unsigned idx = 0) const;
+|  61|    |-	virtual std::string getArtist(unsigned idx = 0) const;
+|  62|    |-	virtual std::string getTitle(unsigned idx = 0) const;
+|  63|    |-	virtual std::string getAlbum(unsigned idx = 0) const;
+|  64|    |-	virtual std::string getAlbumArtist(unsigned idx = 0) const;
+|  65|    |-	virtual std::string getTrack(unsigned idx = 0) const;
+|  66|    |-	virtual std::string getTrackNumber(unsigned idx = 0) const;
+|  67|    |-	virtual std::string getDate(unsigned idx = 0) const;
+|  68|    |-	virtual std::string getGenre(unsigned idx = 0) const;
+|  69|    |-	virtual std::string getComposer(unsigned idx = 0) const;
+|  70|    |-	virtual std::string getPerformer(unsigned idx = 0) const;
+|  71|    |-	virtual std::string getDisc(unsigned idx = 0) const;
+|  72|    |-	virtual std::string getComment(unsigned idx = 0) const;
+|  73|    |-	virtual std::string getLength(unsigned idx = 0) const;
+|  74|    |-	virtual std::string getPriority(unsigned idx = 0) const;
+|  75|    |-	
+|  76|    |-	virtual std::string getTags(GetFunction f) const;
+|  77|    |-	
+|  78|    |-	virtual unsigned getDuration() const;
+|  79|    |-	virtual unsigned getPosition() const;
+|  80|    |-	virtual unsigned getID() const;
+|  81|    |-	virtual unsigned getPrio() const;
+|  82|    |-	virtual time_t getMTime() const;
+|  83|    |-	
+|  84|    |-	virtual bool isFromDatabase() const;
+|  85|    |-	virtual bool isStream() const;
+|  86|    |-	
+|  87|    |-	virtual bool empty() const;
+|  88|    |-	
+|  89|    |-	bool operator==(const Song &rhs) const
+|  90|    |-	{
+|  91|    |-		if (m_hash != rhs.m_hash)
+|  92|    |-			return false;
+|  93|    |-		return strcmp(c_uri(), rhs.c_uri()) == 0;
+|  94|    |-	}
+|  95|    |-	bool operator!=(const Song &rhs) const
+|  96|    |-	{
+|  97|    |-		return !(operator==(rhs));
+|  98|    |-	}
+|    |  47|+          Song ():m_hash (0)
+|    |  48|+        {
+|    |  49|+        }
+|    |  50|+        virtual ~ Song ()
+|    |  51|+        {
+|    |  52|+        }
+|  99|  53| 
+| 100|    |-	const char *c_uri() const { return m_song ? mpd_song_get_uri(m_song.get()) : ""; }
+|    |  54|+        Song (mpd_song * s);
+| 101|  55| 
+| 102|    |-	static std::string ShowTime(unsigned length);
+|    |  56|+        Song (const Song & rhs):m_song (rhs.m_song), m_hash (rhs.m_hash)
+|    |  57|+        {
+|    |  58|+        }
+|    |  59|+      Song (Song && rhs):m_song (std::move (rhs.m_song)),
+|    |  60|+            m_hash (rhs.m_hash)
+|    |  61|+        {
+|    |  62|+        }
+|    |  63|+        Song & operator= (Song rhs)
+|    |  64|+        {
+|    |  65|+            m_song = std::move (rhs.m_song);
+|    |  66|+            m_hash = rhs.m_hash;
+|    |  67|+            return *this;
+|    |  68|+        }
+| 103|  69| 
+| 104|    |-	static std::string TagsSeparator;
+|    |  70|+        std::string get (mpd_tag_type type, unsigned idx = 0) const;
+| 105|  71| 
+| 106|    |-	static bool ShowDuplicateTags;
+|    |  72|+        virtual std::string getURI (unsigned idx = 0) const;
+|    |  73|+        virtual std::string getName (unsigned idx = 0) const;
+|    |  74|+        virtual std::string getDirectory (unsigned idx = 0) const;
+|    |  75|+        virtual std::string getArtist (unsigned idx = 0) const;
+|    |  76|+        virtual std::string getTitle (unsigned idx = 0) const;
+|    |  77|+        virtual std::string getAlbum (unsigned idx = 0) const;
+|    |  78|+        virtual std::string getAlbumArtist (unsigned idx = 0) const;
+|    |  79|+        virtual std::string getTrack (unsigned idx = 0) const;
+|    |  80|+        virtual std::string getTrackNumber (unsigned idx = 0) const;
+|    |  81|+        virtual std::string getDate (unsigned idx = 0) const;
+|    |  82|+        virtual std::string getGenre (unsigned idx = 0) const;
+|    |  83|+        virtual std::string getComposer (unsigned idx = 0) const;
+|    |  84|+        virtual std::string getPerformer (unsigned idx = 0) const;
+|    |  85|+        virtual std::string getDisc (unsigned idx = 0) const;
+|    |  86|+        virtual std::string getComment (unsigned idx = 0) const;
+|    |  87|+        virtual std::string getLength (unsigned idx = 0) const;
+|    |  88|+        virtual std::string getPriority (unsigned idx = 0) const;
+| 107|  89| 
+| 108|    |-private:
+| 109|    |-	std::shared_ptr<mpd_song> m_song;
+| 110|    |-	size_t m_hash;
+| 111|    |-};
+|    |  90|+        virtual std::string getTags (GetFunction f) const;
+|    |  91|+
+|    |  92|+        virtual unsigned getDuration () const;
+|    |  93|+        virtual unsigned getPosition () const;
+|    |  94|+        virtual unsigned getID () const;
+|    |  95|+        virtual unsigned getPrio () const;
+|    |  96|+        virtual time_t getMTime () const;
+|    |  97|+
+|    |  98|+        virtual bool isFromDatabase () const;
+|    |  99|+        virtual bool isStream () const;
+|    | 100|+
+|    | 101|+        virtual bool empty () const;
+|    | 102|+
+|    | 103|+        bool operator== (const Song & rhs) const
+|    | 104|+        {
+|    | 105|+            if (m_hash != rhs.m_hash)
+|    | 106|+                return false;
+|    | 107|+            return strcmp (c_uri (), rhs.c_uri ()) == 0;
+|    | 108|+        }
+|    | 109|+        bool operator!= (const Song & rhs) const
+|    | 110|+        {
+|    | 111|+            return !(operator== (rhs));
+|    | 112|+        }
+|    | 113|+
+|    | 114|+        const char *c_uri () const
+|    | 115|+        {
+|    | 116|+            return m_song ? mpd_song_get_uri (m_song.get ()) : "";
+|    | 117|+        }
+|    | 118|+
+|    | 119|+        static std::string ShowTime (unsigned length);
+|    | 120|+
+|    | 121|+        static std::string TagsSeparator;
+|    | 122|+
+|    | 123|+        static bool ShowDuplicateTags;
+|    | 124|+
+|    | 125|+      private:
+|    | 126|+        std::shared_ptr < mpd_song > m_song;
+|    | 127|+        size_t m_hash;
+|    | 128|+    };
+| 112| 129| 
+| 113| 130| }
+| 114| 131| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/song.h
+|    |++++| /app/src/song.h
+| 113| 113| }
+| 114| 114| 
+| 115| 115| #endif // NCMPCPP_SONG_H
+| 116|    |-
+
+src/song.h
+| 104| »   static•std::string•TagsSeparator;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'TagsSeparator'
+
+src/song.h
+| 106| »   static•bool•ShowDuplicateTags;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'ShowDuplicateTags'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/utility/const.h
+|    |++++| /app/src/utility/const.h
+|  21|  21| #ifndef NCMPCPP_UTILITY_CONST_H
+|  22|  22| #define NCMPCPP_UTILITY_CONST_H
+|  23|  23| 
+|  24|    |-enum class Const { Yes, No };
+|    |  24|+enum class Const
+|    |  25|+{ Yes, No };
+|  25|  26| 
+|  26|  27| #endif // NCMPCPP_UTILITY_CONST_H
+
+src/utility/const.h
+|  24| enum•class•Const•{•Yes,•No•};
+|    | [MAJOR] CPPCheckBear (syntaxError):
+|    | syntax error
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/formatted_color.cpp
+|    |++++| /app/src/curses/formatted_color.cpp
+|  21|  21| #include <istream>
+|  22|  22| #include "formatted_color.h"
+|  23|  23| 
+|  24|    |-namespace {
+|    |  24|+namespace
+|    |  25|+{
+|  25|  26| 
+|  26|    |-void verifyFormats(const NC::FormattedColor::Formats &formats)
+|  27|    |-{
+|  28|    |-	for (auto &fmt : formats)
+|  29|    |-	{
+|  30|    |-		if (fmt == NC::Format::NoBold
+|  31|    |-		    || fmt == NC::Format::NoUnderline
+|  32|    |-		    || fmt == NC::Format::NoReverse
+|  33|    |-		    || fmt == NC::Format::NoAltCharset)
+|  34|    |-			throw std::logic_error("FormattedColor can't hold disabling formats");
+|  35|    |-	}
+|  36|    |-}
+|    |  27|+    void verifyFormats (const NC::FormattedColor::Formats & formats)
+|    |  28|+    {
+|    |  29|+      for (auto & fmt:formats)
+|    |  30|+          {
+|    |  31|+              if (fmt == NC::Format::NoBold
+|    |  32|+                  || fmt == NC::Format::NoUnderline
+|    |  33|+                  || fmt == NC::Format::NoReverse
+|    |  34|+                  || fmt == NC::Format::NoAltCharset)
+|    |  35|+                  throw std::
+|    |  36|+                      logic_error
+|    |  37|+                      ("FormattedColor can't hold disabling formats");
+|    |  38|+          }
+|    |  39|+    }
+|  37|  40| 
+|  38|  41| }
+|  39|  42| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/formatted_color.cpp
+|    |++++| /app/src/curses/formatted_color.cpp
+|  37|  37| 
+|  38|  38| }
+|  39|  39| 
+|  40|    |-NC::FormattedColor::FormattedColor(Color color_, Formats formats_)
+|    |  40|+NC::FormattedColor::FormattedColor (Color color_, Formats formats_)
+|  41|  41| {
+|  42|    |-	if (color_ == NC::Color::End)
+|  43|    |-		throw std::logic_error("FormattedColor can't hold Color::End");
+|  44|    |-	m_color = std::move(color_);
+|  45|    |-	verifyFormats(formats_);
+|  46|    |-	m_formats = std::move(formats_);
+|    |  42|+    if (color_ == NC::Color::End)
+|    |  43|+        throw
+|    |  44|+        std::logic_error ("FormattedColor can't hold Color::End");
+|    |  45|+    m_color = std::move (color_);
+|    |  46|+    verifyFormats (formats_);
+|    |  47|+    m_formats = std::move (formats_);
+|  47|  48| }
+|  48|  49| 
+|  49|  50| std::istream &NC::operator>>(std::istream &is, NC::FormattedColor &fc)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/curses/formatted_color.cpp
+|    |++++| /app/src/curses/formatted_color.cpp
+|  46|  46| 	m_formats = std::move(formats_);
+|  47|  47| }
+|  48|  48| 
+|  49|    |-std::istream &NC::operator>>(std::istream &is, NC::FormattedColor &fc)
+|    |  49|+std::istream & NC::operator>> (std::istream & is, NC::FormattedColor & fc)
+|  50|  50| {
+|  51|    |-	NC::Color c;
+|  52|    |-	is >> c;
+|  53|    |-	if (!is.eof() && is.peek() == ':')
+|  54|    |-	{
+|  55|    |-		is.get();
+|  56|    |-		NC::FormattedColor::Formats formats;
+|  57|    |-		while (!is.eof() && isalpha(is.peek()))
+|  58|    |-		{
+|  59|    |-			char flag = is.get();
+|  60|    |-			switch (flag)
+|  61|    |-			{
+|  62|    |-			case 'b':
+|  63|    |-				formats.push_back(NC::Format::Bold);
+|  64|    |-				break;
+|  65|    |-			case 'u':
+|  66|    |-				formats.push_back(NC::Format::Underline);
+|  67|    |-				break;
+|  68|    |-			case 'r':
+|  69|    |-				formats.push_back(NC::Format::Reverse);
+|  70|    |-				break;
+|  71|    |-			case 'a':
+|  72|    |-				formats.push_back(NC::Format::AltCharset);
+|  73|    |-				break;
+|  74|    |-			default:
+|  75|    |-				is.setstate(std::ios::failbit);
+|  76|    |-				break;
+|  77|    |-			}
+|  78|    |-		}
+|  79|    |-		fc = NC::FormattedColor(c, std::move(formats));
+|  80|    |-	}
+|  81|    |-	else
+|  82|    |-		fc = NC::FormattedColor(c, {});
+|  83|    |-	return is;
+|    |  51|+    NC::Color c;
+|    |  52|+    is >> c;
+|    |  53|+    if (!is.eof () && is.peek () == ':')
+|    |  54|+      {
+|    |  55|+          is.get ();
+|    |  56|+          NC::FormattedColor::Formats formats;
+|    |  57|+          while (!is.eof () && isalpha (is.peek ()))
+|    |  58|+            {
+|    |  59|+                char
+|    |  60|+                    flag = is.get ();
+|    |  61|+                switch (flag)
+|    |  62|+                  {
+|    |  63|+                  case 'b':
+|    |  64|+                      formats.push_back (NC::Format::Bold);
+|    |  65|+                      break;
+|    |  66|+                  case 'u':
+|    |  67|+                      formats.push_back (NC::Format::Underline);
+|    |  68|+                      break;
+|    |  69|+                  case 'r':
+|    |  70|+                      formats.push_back (NC::Format::Reverse);
+|    |  71|+                      break;
+|    |  72|+                  case 'a':
+|    |  73|+                      formats.push_back (NC::Format::AltCharset);
+|    |  74|+                      break;
+|    |  75|+                  default:
+|    |  76|+                      is.setstate (std::ios::failbit);
+|    |  77|+                      break;
+|    |  78|+                  }
+|    |  79|+            }
+|    |  80|+          fc = NC::FormattedColor (c, std::move (formats));
+|    |  81|+      }
+|    |  82|+    else
+|    |  83|+        fc = NC::FormattedColor (c,
+|    |  84|+                                 {
+|    |  85|+                                 }
+|    |  86|+    );
+|    |  87|+    return is;
+|  84|  88| }
+
+src/curses/formatted_color.cpp
+|  73| »   »   »   »   break;
+|    | [NORMAL] CPPCleanBear:
+|    | 'operator==' declared but not defined
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/charset.h
+|    |++++| /app/src/charset.h
+|  24|  24| #include <locale>
+|  25|  25| #include <string>
+|  26|  26| 
+|  27|    |-namespace Charset {
+|    |  27|+namespace Charset
+|    |  28|+{
+|  28|  29| 
+|  29|    |-std::locale internalLocale();
+|    |  30|+    std::locale internalLocale ();
+|  30|  31| 
+|  31|    |-std::string toUtf8From(const std::string &s, const char *charset);
+|  32|    |-std::string fromUtf8To(const std::string &s, const char *charset);
+|    |  32|+    std::string toUtf8From (const std::string & s, const char *charset);
+|    |  33|+      std::string fromUtf8To (const std::string & s, const char *charset);
+|  33|  34| 
+|  34|    |-std::string utf8ToLocale(const std::string &s);
+|  35|    |-std::string utf8ToLocale(std::string &&s);
+|  36|    |-std::string localeToUtf8(const std::string &s);
+|  37|    |-std::string localeToUtf8(std::string &&s);
+|    |  35|+      std::string utf8ToLocale (const std::string & s);
+|    |  36|+      std::string utf8ToLocale (std::string && s);
+|    |  37|+      std::string localeToUtf8 (const std::string & s);
+|    |  38|+      std::string localeToUtf8 (std::string && s);
+|  38|  39| 
+|  39|  40| }
+|  40|  41| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/charset.h
+|    |++++| /app/src/charset.h
+|  38|  38| 
+|  39|  39| }
+|  40|  40| 
+|  41|    |-#endif // NCMPCPP_CHARSET_H
+|    |  41|+#endif                          // NCMPCPP_CHARSET_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.cpp
+|    |++++| /app/src/screens/lastfm.cpp
+|  27|  27| #include "title.h"
+|  28|  28| #include "screens/screen_switcher.h"
+|  29|  29| 
+|  30|    |-using Global::MainHeight;
+|  31|    |-using Global::MainStartY;
+|    |  30|+using
+|    |  31|+    Global::MainHeight;
+|    |  32|+using
+|    |  33|+    Global::MainStartY;
+|  32|  34| 
+|  33|    |-Lastfm *myLastfm;
+|    |  35|+Lastfm *
+|    |  36|+    myLastfm;
+|  34|  37| 
+|  35|    |-Lastfm::Lastfm()
+|  36|    |-	: Screen(NC::Scrollpad(0, MainStartY, COLS, MainHeight, "", Config.main_color, NC::Border()))
+|  37|    |-	, m_refresh_window(false)
+|  38|    |-{ }
+|  39|    |-
+|  40|    |-void Lastfm::resize()
+|    |  38|+Lastfm::Lastfm ():Screen (NC::
+|    |  39|+        Scrollpad (0, MainStartY, COLS, MainHeight, "", Config.main_color,
+|    |  40|+                   NC::Border ())), m_refresh_window (false)
+|  41|  41| {
+|  42|    |-	size_t x_offset, width;
+|  43|    |-	getWindowResizeParams(x_offset, width);
+|  44|    |-	w.resize(width, MainHeight);
+|  45|    |-	w.moveTo(x_offset, MainStartY);
+|  46|    |-	hasToBeResized = 0;
+|  47|  42| }
+|  48|  43| 
+|  49|  44| std::wstring Lastfm::title()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.cpp
+|    |++++| /app/src/screens/lastfm.cpp
+|  46|  46| 	hasToBeResized = 0;
+|  47|  47| }
+|  48|  48| 
+|  49|    |-std::wstring Lastfm::title()
+|    |  49|+void
+|    |  50|+Lastfm::resize ()
+|  50|  51| {
+|  51|    |-	if (m_title.empty())
+|  52|    |-		return L"Last.fm";
+|  53|    |-	else
+|  54|    |-		return m_title;
+|    |  52|+    size_t x_offset, width;
+|    |  53|+    getWindowResizeParams (x_offset, width);
+|    |  54|+    w.resize (width, MainHeight);
+|    |  55|+    w.moveTo (x_offset, MainStartY);
+|    |  56|+    hasToBeResized = 0;
+|  55|  57| }
+|  56|  58| 
+|  57|  59| void Lastfm::update()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.cpp
+|    |++++| /app/src/screens/lastfm.cpp
+|  54|  54| 		return m_title;
+|  55|  55| }
+|  56|  56| 
+|  57|    |-void Lastfm::update()
+|    |  57|+std::wstring Lastfm::title ()
+|  58|  58| {
+|  59|    |-	if (m_worker.valid() && m_worker.is_ready())
+|  60|    |-	{
+|  61|    |-		auto result = m_worker.get();
+|  62|    |-		if (result.first)
+|  63|    |-		{
+|  64|    |-			w.clear();
+|  65|    |-			w << Charset::utf8ToLocale(result.second);
+|  66|    |-			m_service->beautifyOutput(w);
+|  67|    |-		}
+|  68|    |-		else
+|  69|    |-			w << " " << NC::Color::Red << result.second << NC::Color::End;
+|  70|    |-		// reset m_worker so it's no longer valid
+|  71|    |-		m_worker = boost::BOOST_THREAD_FUTURE<LastFm::Service::Result>();
+|  72|    |-		m_refresh_window = true;
+|  73|    |-	}
+|  74|    |-
+|  75|    |-	if (m_refresh_window)
+|  76|    |-	{
+|  77|    |-		m_refresh_window = false;
+|  78|    |-		w.flush();
+|  79|    |-		w.refresh();
+|  80|    |-	}
+|    |  59|+    if (m_title.empty ())
+|    |  60|+        return L"Last.fm";
+|    |  61|+    else
+|    |  62|+        return m_title;
+|  81|  63| }
+|  82|  64| 
+|  83|  65| void Lastfm::switchTo()
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lastfm.cpp
+|    |++++| /app/src/screens/lastfm.cpp
+|  80|  80| 	}
+|  81|  81| }
+|  82|  82| 
+|  83|    |-void Lastfm::switchTo()
+|    |  83|+void
+|    |  84|+Lastfm::update ()
+|  84|  85| {
+|  85|    |-	using Global::myScreen;
+|  86|    |-	if (myScreen != this)
+|  87|    |-	{
+|  88|    |-		SwitchTo::execute(this);
+|  89|    |-		drawHeader();
+|  90|    |-	}
+|  91|    |-	else
+|  92|    |-		switchToPreviousScreen();
+|    |  86|+    if (m_worker.valid () && m_worker.is_ready ())
+|    |  87|+      {
+|    |  88|+          auto result = m_worker.get ();
+|    |  89|+          if (result.first)
+|    |  90|+            {
+|    |  91|+                w.clear ();
+|    |  92|+                w << Charset::utf8ToLocale (result.second);
+|    |  93|+                m_service->beautifyOutput (w);
+|    |  94|+            }
+|    |  95|+          else
+|    |  96|+              w << " " << NC::Color::Red << result.second << NC::Color::End;
+|    |  97|+          // reset m_worker so it's no longer valid
+|    |  98|+          m_worker = boost::BOOST_THREAD_FUTURE < LastFm::Service::Result > ();
+|    |  99|+          m_refresh_window = true;
+|    | 100|+      }
+|    | 101|+
+|    | 102|+    if (m_refresh_window)
+|    | 103|+      {
+|    | 104|+          m_refresh_window = false;
+|    | 105|+          w.flush ();
+|    | 106|+          w.refresh ();
+|    | 107|+      }
+|  93| 108| }
+|    | 109|+
+|    | 110|+void
+|    | 111|+Lastfm::switchTo ()
+|    | 112|+{
+|    | 113|+    using Global::myScreen;
+|    | 114|+    if (myScreen != this)
+|    | 115|+      {
+|    | 116|+          SwitchTo::execute (this);
+|    | 117|+          drawHeader ();
+|    | 118|+      }
+|    | 119|+    else
+|    | 120|+        switchToPreviousScreen ();
+|    | 121|+}
+
+src/screens/lastfm.cpp
+|  21| #include•"screens/lastfm.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/lastfm.h'
+
+src/screens/lastfm.cpp
+|  23| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/lastfm.cpp
+|  24| #include•"charset.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'charset.h'
+
+src/screens/lastfm.cpp
+|  25| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/lastfm.cpp
+|  26| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'statusbar.h'
+
+src/screens/lastfm.cpp
+|  27| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/lastfm.cpp
+|  28| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/lastfm.cpp
+|  33| Lastfm•*myLastfm;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myLastfm'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/runnable_item.h
+|    |++++| /app/src/runnable_item.h
+|  23|  23| 
+|  24|  24| #include <functional>
+|  25|  25| 
+|  26|    |-template <typename ItemT, typename FunctionT>
+|  27|    |-struct RunnableItem
+|    |  26|+template < typename ItemT, typename FunctionT > struct RunnableItem
+|  28|  27| {
+|  29|    |-	typedef ItemT Item;
+|  30|    |-	typedef std::function<FunctionT> Function;
+|  31|    |-	
+|  32|    |-	RunnableItem() { }
+|  33|    |-	template <typename Arg1, typename Arg2>
+|  34|    |-	RunnableItem(Arg1 &&opt, Arg2 &&f)
+|  35|    |-	: m_item(std::forward<Arg1>(opt)), m_f(std::forward<Arg2>(f)) { }
+|  36|    |-	
+|  37|    |-	template <typename... Args>
+|  38|    |-	typename Function::result_type run(Args&&... args) const
+|  39|    |-	{
+|  40|    |-		return m_f(std::forward<Args>(args)...);
+|  41|    |-	}
+|  42|    |-	
+|  43|    |-	Item &item() { return m_item; }
+|  44|    |-	const Item &item() const { return m_item; }
+|  45|    |-	
+|  46|    |-private:
+|  47|    |-	Item m_item;
+|  48|    |-	Function m_f;
+|    |  28|+    typedef ItemT Item;
+|    |  29|+    typedef std::function < FunctionT > Function;
+|    |  30|+
+|    |  31|+      RunnableItem ()
+|    |  32|+    {
+|    |  33|+    }
+|    |  34|+    template < typename Arg1, typename Arg2 >
+|    |  35|+        RunnableItem (Arg1 && opt, Arg2
+|    |  36|+                      && f):m_item (std::forward < Arg1 > (opt)),
+|    |  37|+        m_f (std::forward < Arg2 > (f))
+|    |  38|+    {
+|    |  39|+    }
+|    |  40|+
+|    |  41|+    template < typename...Args >
+|    |  42|+        typename Function::result_type run (Args &&...args) const
+|    |  43|+    {
+|    |  44|+        return m_f (std::forward < Args > (args) ...);
+|    |  45|+    }
+|    |  46|+
+|    |  47|+    Item & item ()
+|    |  48|+    {
+|    |  49|+        return m_item;
+|    |  50|+    }
+|    |  51|+    const Item & item () const
+|    |  52|+    {
+|    |  53|+        return m_item;
+|    |  54|+    }
+|    |  55|+
+|    |  56|+  private:
+|    |  57|+      Item m_item;
+|    |  58|+    Function m_f;
+|  49|  59| };
+|  50|  60| 
+|  51|  61| #endif // NCMPCPP_EXEC_ITEM_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  34|  34| # include <fftw3.h>
+|  35|  35| #endif
+|  36|  36| 
+|  37|    |-struct Visualizer: Screen<NC::Window>, Tabbable
+|    |  37|+struct Visualizer:Screen <
+|    |  38|+    NC::Window >,
+|    |  39|+    Tabbable
+|  38|  40| {
+|  39|    |-	Visualizer();
+|    |  41|+    Visualizer ();
+|  40|  42| 
+|  41|    |-	virtual void switchTo() override;
+|  42|    |-	virtual void resize() override;
+|    |  43|+    virtual void
+|    |  44|+    switchTo ()
+|    |  45|+        override;
+|    |  46|+    virtual void
+|    |  47|+    resize ()
+|    |  48|+        override;
+|  43|  49| 
+|  44|    |-	virtual std::wstring title() override;
+|  45|    |-	virtual ScreenType type() override { return ScreenType::Visualizer; }
+|    |  50|+    virtual
+|    |  51|+        std::wstring
+|    |  52|+    title ()
+|    |  53|+        override;
+|    |  54|+    virtual ScreenType
+|    |  55|+    type ()
+|    |  56|+        override
+|    |  57|+    {
+|    |  58|+        return ScreenType::Visualizer;
+|    |  59|+    }
+|  46|  60| 
+|  47|    |-	virtual void update() override;
+|  48|    |-	virtual void scroll(NC::Scroll) override { }
+|    |  61|+    virtual void
+|    |  62|+    update ()
+|    |  63|+        override;
+|    |  64|+    virtual void
+|    |  65|+    scroll (NC::Scroll)
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+    }
+|  49|  69| 
+|  50|    |-	virtual int windowTimeout() override;
+|    |  70|+    virtual int
+|    |  71|+    windowTimeout ()
+|    |  72|+        override;
+|  51|  73| 
+|  52|    |-	virtual void mouseButtonPressed(MEVENT) override { }
+|    |  74|+    virtual void
+|    |  75|+    mouseButtonPressed (MEVENT)
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+    }
+|  53|  79| 
+|  54|    |-	virtual bool isLockable() override { return true; }
+|  55|    |-	virtual bool isMergable() override { return true; }
+|    |  80|+    virtual bool
+|    |  81|+    isLockable ()
+|    |  82|+        override
+|    |  83|+    {
+|    |  84|+        return true;
+|    |  85|+    }
+|    |  86|+    virtual bool
+|    |  87|+    isMergable ()
+|    |  88|+        override
+|    |  89|+    {
+|    |  90|+        return true;
+|    |  91|+    }
+|  56|  92| 
+|  57|    |-	// private members
+|  58|    |-	void ToggleVisualizationType();
+|  59|    |-	void SetFD();
+|  60|    |-	void ResetFD();
+|  61|    |-	void FindOutputID();
+|  62|    |-	void ResetAutoScaleMultiplier();
+|    |  93|+    // private members
+|    |  94|+    void
+|    |  95|+    ToggleVisualizationType ();
+|    |  96|+    void
+|    |  97|+    SetFD ();
+|    |  98|+    void
+|    |  99|+    ResetFD ();
+|    | 100|+    void
+|    | 101|+    FindOutputID ();
+|    | 102|+    void
+|    | 103|+    ResetAutoScaleMultiplier ();
+|  63| 104| 
+|  64|    |-private:
+|  65|    |-	void DrawSoundWave(int16_t *, ssize_t, size_t, size_t);
+|  66|    |-	void DrawSoundWaveStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  67|    |-	void DrawSoundWaveFill(int16_t *, ssize_t, size_t, size_t);
+|  68|    |-	void DrawSoundWaveFillStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  69|    |-	void DrawSoundEllipse(int16_t *, ssize_t, size_t, size_t);
+|  70|    |-	void DrawSoundEllipseStereo(int16_t *, int16_t *, ssize_t, size_t);
+|    | 105|+  private:
+|    | 106|+    void
+|    | 107|+    DrawSoundWave (int16_t *, ssize_t, size_t, size_t);
+|    | 108|+    void
+|    | 109|+    DrawSoundWaveStereo (int16_t *, int16_t *, ssize_t, size_t);
+|    | 110|+    void
+|    | 111|+    DrawSoundWaveFill (int16_t *, ssize_t, size_t, size_t);
+|    | 112|+    void
+|    | 113|+    DrawSoundWaveFillStereo (int16_t *, int16_t *, ssize_t, size_t);
+|    | 114|+    void
+|    | 115|+    DrawSoundEllipse (int16_t *, ssize_t, size_t, size_t);
+|    | 116|+    void
+|    | 117|+    DrawSoundEllipseStereo (int16_t *, int16_t *, ssize_t, size_t);
+|  71| 118| #	ifdef HAVE_FFTW3_H
+|  72|    |-	void DrawFrequencySpectrum(int16_t *, ssize_t, size_t, size_t);
+|  73|    |-	void DrawFrequencySpectrumStereo(int16_t *, int16_t *, ssize_t, size_t);
+|    | 119|+    void
+|    | 120|+    DrawFrequencySpectrum (int16_t *, ssize_t, size_t, size_t);
+|    | 121|+    void
+|    | 122|+    DrawFrequencySpectrumStereo (int16_t *, int16_t *, ssize_t, size_t);
+|  74| 123| #	endif // HAVE_FFTW3_H
+|  75| 124| 
+|  76| 125| 	int m_output_id;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  73|  73| 	void DrawFrequencySpectrumStereo(int16_t *, int16_t *, ssize_t, size_t);
+|  74|  74| #	endif // HAVE_FFTW3_H
+|  75|  75| 
+|  76|    |-	int m_output_id;
+|  77|    |-	boost::posix_time::ptime m_timer;
+|    |  76|+    int
+|    |  77|+        m_output_id;
+|    |  78|+    boost::posix_time::ptime m_timer;
+|  78|  79| 
+|  79|    |-	int m_fifo;
+|  80|    |-	size_t m_samples;
+|  81|    |-	double m_auto_scale_multiplier;
+|    |  80|+    int
+|    |  81|+        m_fifo;
+|    |  82|+    size_t
+|    |  83|+        m_samples;
+|    |  84|+    double
+|    |  85|+        m_auto_scale_multiplier;
+|  82|  86| #	ifdef HAVE_FFTW3_H
+|  83|    |-	size_t m_fftw_results;
+|  84|    |-	double *m_fftw_input;
+|  85|    |-	fftw_complex *m_fftw_output;
+|  86|    |-	fftw_plan m_fftw_plan;
+|    |  87|+    size_t
+|    |  88|+        m_fftw_results;
+|    |  89|+    double *
+|    |  90|+        m_fftw_input;
+|    |  91|+    fftw_complex *
+|    |  92|+        m_fftw_output;
+|    |  93|+    fftw_plan
+|    |  94|+        m_fftw_plan;
+|  87|  95| 
+|  88|    |-	std::vector<double> m_freq_magnitudes;
+|    |  96|+    std::vector < double >
+|    |  97|+        m_freq_magnitudes;
+|  89|  98| #	endif // HAVE_FFTW3_H
+|  90|  99| };
+|  91| 100| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/visualizer.h
+|    |++++| /app/src/screens/visualizer.h
+|  89|  89| #	endif // HAVE_FFTW3_H
+|  90|  90| };
+|  91|  91| 
+|  92|    |-extern Visualizer *myVisualizer;
+|    |  92|+extern Visualizer *
+|    |  93|+    myVisualizer;
+|  93|  94| 
+|  94|  95| #endif // ENABLE_VISUALIZER
+|  95|  96| 
+
+src/screens/visualizer.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/visualizer.h
+|  29| #include•"curses/window.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/window.h'
+
+src/screens/visualizer.h
+|  30| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/visualizer.h
+|  31| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/visualizer.h
+|  92| extern•Visualizer•*myVisualizer;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myVisualizer'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+|  33|  33| #include "screens/screen.h"
+|  34|  34| #include "song_list.h"
+|  35|  35| 
+|  36|    |-struct TagsWindow: NC::Menu<MPD::MutableSong>, SongList
+|    |  36|+struct TagsWindow:
+|    |  37|+    NC::Menu <
+|    |  38|+    MPD::MutableSong >,
+|    |  39|+    SongList
+|  37|  40| {
+|  38|    |-	TagsWindow() { }
+|  39|    |-	TagsWindow(NC::Menu<MPD::MutableSong> &&base)
+|  40|    |-	: NC::Menu<MPD::MutableSong>(std::move(base)) { }
+|    |  41|+    TagsWindow ()
+|    |  42|+    {
+|    |  43|+    }
+|    |  44|+    TagsWindow (NC::Menu < MPD::MutableSong > &&base):
+|    |  45|+        NC::Menu <
+|    |  46|+    MPD::MutableSong > (std::move (base))
+|    |  47|+    {
+|    |  48|+    }
+|  41|  49| 
+|  42|    |-	virtual SongIterator currentS() override;
+|  43|    |-	virtual ConstSongIterator currentS() const override;
+|  44|    |-	virtual SongIterator beginS() override;
+|  45|    |-	virtual ConstSongIterator beginS() const override;
+|  46|    |-	virtual SongIterator endS() override;
+|  47|    |-	virtual ConstSongIterator endS() const override;
+|    |  50|+    virtual SongIterator
+|    |  51|+    currentS ()
+|    |  52|+        override;
+|    |  53|+    virtual ConstSongIterator
+|    |  54|+    currentS () const
+|    |  55|+        override;
+|    |  56|+    virtual SongIterator
+|    |  57|+    beginS ()
+|    |  58|+        override;
+|    |  59|+    virtual ConstSongIterator
+|    |  60|+    beginS () const
+|    |  61|+        override;
+|    |  62|+    virtual SongIterator
+|    |  63|+    endS ()
+|    |  64|+        override;
+|    |  65|+    virtual ConstSongIterator
+|    |  66|+    endS () const
+|    |  67|+        override;
+|  48|  68| 
+|  49|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|    |  69|+    virtual
+|    |  70|+        std::vector <
+|    |  71|+        MPD::Song >
+|    |  72|+    getSelectedSongs ()
+|    |  73|+        override;
+|  50|  74| };
+|  51|  75| 
+|  52|  76| struct TagEditor: Screen<NC::Window *>, HasActions, HasColumns, HasSongs, Searchable, Tabbable
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+|  49|  49| 	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  50|  50| };
+|  51|  51| 
+|  52|    |-struct TagEditor: Screen<NC::Window *>, HasActions, HasColumns, HasSongs, Searchable, Tabbable
+|    |  52|+struct TagEditor:
+|    |  53|+    Screen <
+|    |  54|+NC::Window * >,
+|    |  55|+    HasActions,
+|    |  56|+    HasColumns,
+|    |  57|+    HasSongs,
+|    |  58|+    Searchable,
+|    |  59|+    Tabbable
+|  53|  60| {
+|  54|    |-	TagEditor();
+|  55|    |-	
+|  56|    |-	virtual void resize() override;
+|  57|    |-	virtual void switchTo() override;
+|  58|    |-	
+|  59|    |-	virtual std::wstring title() override;
+|  60|    |-	virtual ScreenType type() override { return ScreenType::TagEditor; }
+|  61|    |-	
+|  62|    |-	virtual void refresh() override;
+|  63|    |-	virtual void update() override;
+|  64|    |-	
+|  65|    |-	virtual void mouseButtonPressed(MEVENT) override;
+|  66|    |-	
+|  67|    |-	virtual bool isLockable() override { return true; }
+|  68|    |-	virtual bool isMergable() override { return true; }
+|  69|    |-	
+|  70|    |-	// Searchable implementation
+|  71|    |-	virtual bool allowsSearching() override;
+|  72|    |-	virtual const std::string &searchConstraint() override;
+|  73|    |-	virtual void setSearchConstraint(const std::string &constraint) override;
+|  74|    |-	virtual void clearSearchConstraint() override;
+|  75|    |-	virtual bool search(SearchDirection direction, bool wrap, bool skip_current) override;
+|  76|    |-
+|  77|    |-	// HasActions implementation
+|  78|    |-	virtual bool actionRunnable() override;
+|  79|    |-	virtual void runAction() override;
+|  80|    |-
+|  81|    |-	// HasSongs implementation
+|  82|    |-	virtual bool itemAvailable() override;
+|  83|    |-	virtual bool addItemToPlaylist(bool play) override;
+|  84|    |-	virtual std::vector<MPD::Song> getSelectedSongs() override;
+|  85|    |-	
+|  86|    |-	// HasColumns implementation
+|  87|    |-	virtual bool previousColumnAvailable() override;
+|  88|    |-	virtual void previousColumn() override;
+|  89|    |-	
+|  90|    |-	virtual bool nextColumnAvailable() override;
+|  91|    |-	virtual void nextColumn() override;
+|  92|    |-	
+|  93|    |-	// private members
+|  94|    |-	bool enterDirectory();
+|  95|    |-	void LocateSong(const MPD::Song &s);
+|  96|    |-	const std::string &CurrentDir() { return itsBrowsedDir; }
+|  97|    |-	
+|  98|    |-	NC::Menu< std::pair<std::string, std::string> > *Dirs;
+|  99|    |-	NC::Menu<std::string> *TagTypes;
+| 100|    |-	TagsWindow *Tags;
+| 101|    |-	
+| 102|    |-private:
+| 103|    |-	void SetDimensions(size_t, size_t);
+| 104|    |-	
+| 105|    |-	std::vector<MPD::MutableSong *> EditedSongs;
+| 106|    |-	NC::Menu<std::string> *FParserDialog;
+| 107|    |-	NC::Menu<std::string> *FParser;
+| 108|    |-	NC::Scrollpad *FParserHelper;
+| 109|    |-	NC::Scrollpad *FParserLegend;
+| 110|    |-	NC::Scrollpad *FParserPreview;
+| 111|    |-	bool FParserUsePreview;
+| 112|    |-	
+| 113|    |-	std::string itsBrowsedDir;
+| 114|    |-	std::string itsHighlightedDir;
+| 115|    |-
+| 116|    |-	Regex::Filter<std::pair<std::string, std::string>> m_directories_search_predicate;
+| 117|    |-	Regex::Filter<MPD::MutableSong> m_songs_search_predicate;
+|    |  61|+    TagEditor ();
+|    |  62|+
+|    |  63|+    virtual void
+|    |  64|+    resize ()
+|    |  65|+        override;
+|    |  66|+    virtual void
+|    |  67|+    switchTo ()
+|    |  68|+        override;
+|    |  69|+
+|    |  70|+    virtual
+|    |  71|+        std::wstring
+|    |  72|+    title ()
+|    |  73|+        override;
+|    |  74|+    virtual ScreenType
+|    |  75|+    type ()
+|    |  76|+        override
+|    |  77|+    {
+|    |  78|+        return ScreenType::TagEditor;
+|    |  79|+    }
+|    |  80|+
+|    |  81|+    virtual void
+|    |  82|+    refresh ()
+|    |  83|+        override;
+|    |  84|+    virtual void
+|    |  85|+    update ()
+|    |  86|+        override;
+|    |  87|+
+|    |  88|+    virtual void
+|    |  89|+    mouseButtonPressed (MEVENT)
+|    |  90|+        override;
+|    |  91|+
+|    |  92|+    virtual bool
+|    |  93|+    isLockable ()
+|    |  94|+        override
+|    |  95|+    {
+|    |  96|+        return true;
+|    |  97|+    }
+|    |  98|+    virtual bool
+|    |  99|+    isMergable ()
+|    | 100|+        override
+|    | 101|+    {
+|    | 102|+        return true;
+|    | 103|+    }
+|    | 104|+
+|    | 105|+    // Searchable implementation
+|    | 106|+    virtual bool
+|    | 107|+    allowsSearching ()
+|    | 108|+        override;
+|    | 109|+    virtual const
+|    | 110|+        std::string &
+|    | 111|+    searchConstraint ()
+|    | 112|+        override;
+|    | 113|+    virtual void
+|    | 114|+    setSearchConstraint (const std::string & constraint)
+|    | 115|+        override;
+|    | 116|+    virtual void
+|    | 117|+    clearSearchConstraint ()
+|    | 118|+        override;
+|    | 119|+    virtual bool
+|    | 120|+    search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 121|+        override;
+|    | 122|+
+|    | 123|+    // HasActions implementation
+|    | 124|+    virtual bool
+|    | 125|+    actionRunnable ()
+|    | 126|+        override;
+|    | 127|+    virtual void
+|    | 128|+    runAction ()
+|    | 129|+        override;
+|    | 130|+
+|    | 131|+    // HasSongs implementation
+|    | 132|+    virtual bool
+|    | 133|+    itemAvailable ()
+|    | 134|+        override;
+|    | 135|+    virtual bool
+|    | 136|+    addItemToPlaylist (bool play)
+|    | 137|+        override;
+|    | 138|+    virtual
+|    | 139|+        std::vector <
+|    | 140|+        MPD::Song >
+|    | 141|+    getSelectedSongs ()
+|    | 142|+        override;
+|    | 143|+
+|    | 144|+    // HasColumns implementation
+|    | 145|+    virtual bool
+|    | 146|+    previousColumnAvailable ()
+|    | 147|+        override;
+|    | 148|+    virtual void
+|    | 149|+    previousColumn ()
+|    | 150|+        override;
+|    | 151|+
+|    | 152|+    virtual bool
+|    | 153|+    nextColumnAvailable ()
+|    | 154|+        override;
+|    | 155|+    virtual void
+|    | 156|+    nextColumn ()
+|    | 157|+        override;
+|    | 158|+
+|    | 159|+    // private members
+|    | 160|+    bool
+|    | 161|+    enterDirectory ();
+|    | 162|+    void
+|    | 163|+    LocateSong (const MPD::Song & s);
+|    | 164|+    const
+|    | 165|+        std::string &
+|    | 166|+    CurrentDir ()
+|    | 167|+    {
+|    | 168|+        return itsBrowsedDir;
+|    | 169|+    }
+|    | 170|+
+|    | 171|+    NC::Menu < std::pair < std::string, std::string > >*Dirs;
+|    | 172|+    NC::Menu < std::string > *TagTypes;
+|    | 173|+    TagsWindow *
+|    | 174|+        Tags;
+|    | 175|+
+|    | 176|+  private:
+|    | 177|+    void
+|    | 178|+    SetDimensions (size_t, size_t);
+|    | 179|+
+|    | 180|+    std::vector < MPD::MutableSong * >EditedSongs;
+|    | 181|+    NC::Menu < std::string > *FParserDialog;
+|    | 182|+    NC::Menu < std::string > *FParser;
+|    | 183|+    NC::Scrollpad * FParserHelper;
+|    | 184|+    NC::Scrollpad * FParserLegend;
+|    | 185|+    NC::Scrollpad * FParserPreview;
+|    | 186|+    bool
+|    | 187|+        FParserUsePreview;
+|    | 188|+
+|    | 189|+    std::string itsBrowsedDir;
+|    | 190|+    std::string itsHighlightedDir;
+|    | 191|+
+|    | 192|+    Regex::Filter < std::pair < std::string,
+|    | 193|+        std::string >> m_directories_search_predicate;
+|    | 194|+    Regex::Filter < MPD::MutableSong > m_songs_search_predicate;
+| 118| 195| };
+| 119| 196| 
+| 120| 197| extern TagEditor *myTagEditor;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+| 117| 117| 	Regex::Filter<MPD::MutableSong> m_songs_search_predicate;
+| 118| 118| };
+| 119| 119| 
+| 120|    |-extern TagEditor *myTagEditor;
+|    | 120|+extern TagEditor *
+|    | 121|+    myTagEditor;
+| 121| 122| 
+| 122| 123| #endif // HAVE_TAGLIB_H
+| 123| 124| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tag_editor.h
+|    |++++| /app/src/screens/tag_editor.h
+| 122| 122| #endif // HAVE_TAGLIB_H
+| 123| 123| 
+| 124| 124| #endif // NCMPCPP_TAG_EDITOR_H
+| 125|    |-
+
+src/screens/tag_editor.h
+|  24| #include•"config.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'config.h'
+
+src/screens/tag_editor.h
+|  30| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/tag_editor.h
+|  31| #include•"mutable_song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'mutable_song.h'
+
+src/screens/tag_editor.h
+|  32| #include•"regex_filter.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'regex_filter.h'
+
+src/screens/tag_editor.h
+|  33| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/tag_editor.h
+|  34| #include•"song_list.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song_list.h'
+
+src/screens/tag_editor.h
+| 120| extern•TagEditor•*myTagEditor;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myTagEditor'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lyrics.h
+|    |++++| /app/src/screens/lyrics.h
+|  33|  33| #include "song.h"
+|  34|  34| #include "utility/shared_resource.h"
+|  35|  35| 
+|  36|    |-struct Lyrics: Screen<NC::Scrollpad>, Tabbable
+|    |  36|+struct Lyrics:Screen <
+|    |  37|+    NC::Scrollpad >,
+|    |  38|+    Tabbable
+|  37|  39| {
+|  38|    |-	Lyrics();
+|  39|    |-	
+|  40|    |-	// Screen<NC::Scrollpad> implementation
+|  41|    |-	virtual void resize() override;
+|  42|    |-	virtual void switchTo() override;
+|  43|    |-	
+|  44|    |-	virtual std::wstring title() override;
+|  45|    |-	virtual ScreenType type() override { return ScreenType::Lyrics; }
+|  46|    |-	
+|  47|    |-	virtual void update() override;
+|  48|    |-	
+|  49|    |-	virtual bool isLockable() override { return true; }
+|  50|    |-	virtual bool isMergable() override { return true; }
+|    |  40|+    Lyrics ();
+|  51|  41| 
+|  52|    |-	// other members
+|  53|    |-	void fetch(const MPD::Song &s);
+|  54|    |-	void refetchCurrent();
+|  55|    |-	void edit();
+|  56|    |-	void toggleFetcher();
+|    |  42|+    // Screen<NC::Scrollpad> implementation
+|    |  43|+    virtual void
+|    |  44|+    resize ()
+|    |  45|+        override;
+|    |  46|+    virtual void
+|    |  47|+    switchTo ()
+|    |  48|+        override;
+|  57|  49| 
+|  58|    |-	void fetchInBackground(const MPD::Song &s, bool notify_);
+|  59|    |-	boost::optional<std::string> tryTakeConsumerMessage();
+|    |  50|+    virtual
+|    |  51|+        std::wstring
+|    |  52|+    title ()
+|    |  53|+        override;
+|    |  54|+    virtual ScreenType
+|    |  55|+    type ()
+|    |  56|+        override
+|    |  57|+    {
+|    |  58|+        return ScreenType::Lyrics;
+|    |  59|+    }
+|  60|  60| 
+|  61|    |-private:
+|  62|    |-	struct ConsumerState
+|  63|    |-	{
+|  64|    |-		struct Song
+|  65|    |-		{
+|  66|    |-			Song()
+|  67|    |-				: m_notify(false)
+|  68|    |-			{ }
+|    |  61|+    virtual void
+|    |  62|+    update ()
+|    |  63|+        override;
+|  69|  64| 
+|  70|    |-			Song(const MPD::Song &s, bool notify_)
+|  71|    |-				: m_song(s), m_notify(notify_)
+|  72|    |-			{ }
+|    |  65|+    virtual bool
+|    |  66|+    isLockable ()
+|    |  67|+        override
+|    |  68|+    {
+|    |  69|+        return true;
+|    |  70|+    }
+|    |  71|+    virtual bool
+|    |  72|+    isMergable ()
+|    |  73|+        override
+|    |  74|+    {
+|    |  75|+        return true;
+|    |  76|+    }
+|  73|  77| 
+|  74|    |-			const MPD::Song &song() const { return m_song; }
+|  75|    |-			bool notify() const { return m_notify; }
+|    |  78|+    // other members
+|    |  79|+    void
+|    |  80|+    fetch (const MPD::Song & s);
+|    |  81|+    void
+|    |  82|+    refetchCurrent ();
+|    |  83|+    void
+|    |  84|+    edit ();
+|    |  85|+    void
+|    |  86|+    toggleFetcher ();
+|  76|  87| 
+|  77|    |-		private:
+|  78|    |-			MPD::Song m_song;
+|  79|    |-			bool m_notify;
+|  80|    |-		};
+|    |  88|+    void
+|    |  89|+    fetchInBackground (const MPD::Song & s, bool notify_);
+|    |  90|+    boost::optional < std::string > tryTakeConsumerMessage ();
+|  81|  91| 
+|  82|    |-		ConsumerState()
+|  83|    |-			: running(false)
+|  84|    |-		{ }
+|    |  92|+  private:
+|    |  93|+    struct ConsumerState
+|    |  94|+    {
+|    |  95|+        struct Song
+|    |  96|+        {
+|    |  97|+            Song ():
+|    |  98|+            m_notify (false)
+|    |  99|+            {
+|    | 100|+            }
+|  85| 101| 
+|  86|    |-		bool running;
+|  87|    |-		std::queue<Song> songs;
+|  88|    |-		boost::optional<std::string> message;
+|  89|    |-	};
+|    | 102|+            Song (const MPD::Song & s, bool notify_):
+|    | 103|+            m_song (s),
+|    | 104|+            m_notify (notify_)
+|    | 105|+            {
+|    | 106|+            }
+|  90| 107| 
+|  91|    |-	void clearWorker();
+|  92|    |-	void stopDownload();
+|    | 108|+            const
+|    | 109|+                MPD::Song &
+|    | 110|+            song () const
+|    | 111|+            {
+|    | 112|+                return
+|    | 113|+                    m_song;
+|    | 114|+            }
+|    | 115|+            bool
+|    | 116|+            notify () const
+|    | 117|+            {
+|    | 118|+                return
+|    | 119|+                    m_notify;
+|    | 120|+            }
+|  93| 121| 
+|  94|    |-	bool m_refresh_window;
+|  95|    |-	size_t m_scroll_begin;
+|    | 122|+          private:
+|    | 123|+            MPD::Song
+|    | 124|+                m_song;
+|    | 125|+            bool
+|    | 126|+                m_notify;
+|    | 127|+        };
+|  96| 128| 
+|  97|    |-	std::shared_ptr<Shared<NC::Buffer>> m_shared_buffer;
+|  98|    |-	std::shared_ptr<std::atomic<bool>> m_download_stopper;
+|    | 129|+      ConsumerState ():running (false)
+|    | 130|+        {
+|    | 131|+        }
+|  99| 132| 
+| 100|    |-	MPD::Song m_song;
+| 101|    |-	LyricsFetcher *m_fetcher;
+| 102|    |-	boost::BOOST_THREAD_FUTURE<boost::optional<std::string>> m_worker;
+|    | 133|+        bool
+|    | 134|+            running;
+|    | 135|+        std::queue < Song > songs;
+|    | 136|+        boost::optional < std::string > message;
+|    | 137|+    };
+| 103| 138| 
+| 104|    |-	Shared<ConsumerState> m_consumer_state;
+|    | 139|+    void
+|    | 140|+    clearWorker ();
+|    | 141|+    void
+|    | 142|+    stopDownload ();
+|    | 143|+
+|    | 144|+    bool
+|    | 145|+        m_refresh_window;
+|    | 146|+    size_t
+|    | 147|+        m_scroll_begin;
+|    | 148|+
+|    | 149|+    std::shared_ptr < Shared < NC::Buffer >> m_shared_buffer;
+|    | 150|+    std::shared_ptr < std::atomic < bool >> m_download_stopper;
+|    | 151|+
+|    | 152|+    MPD::Song m_song;
+|    | 153|+    LyricsFetcher *
+|    | 154|+        m_fetcher;
+|    | 155|+    boost::BOOST_THREAD_FUTURE < boost::optional < std::string >> m_worker;
+|    | 156|+
+|    | 157|+    Shared < ConsumerState > m_consumer_state;
+| 105| 158| };
+| 106| 159| 
+| 107| 160| extern Lyrics *myLyrics;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/lyrics.h
+|    |++++| /app/src/screens/lyrics.h
+| 104| 104| 	Shared<ConsumerState> m_consumer_state;
+| 105| 105| };
+| 106| 106| 
+| 107|    |-extern Lyrics *myLyrics;
+|    | 107|+extern Lyrics *
+|    | 108|+    myLyrics;
+| 108| 109| 
+| 109| 110| #endif // NCMPCPP_LYRICS_H
+
+src/screens/lyrics.h
+|  30| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/lyrics.h
+|  31| #include•"lyrics_fetcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'lyrics_fetcher.h'
+
+src/screens/lyrics.h
+|  32| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/lyrics.h
+|  33| #include•"song.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'song.h'
+
+src/screens/lyrics.h
+|  34| #include•"utility/shared_resource.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/shared_resource.h'
+
+src/screens/lyrics.h
+| 107| extern•Lyrics•*myLyrics;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myLyrics'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+|  28|  28| 
+|  29|  29| BindingsConfiguration Bindings;
+|  30|  30| 
+|  31|    |-namespace {
+|  32|    |-
+|  33|    |-void warning(const char *msg)
+|  34|    |-{
+|  35|    |-	std::cerr << "WARNING: " << msg << "\n";
+|    |  31|+namespace
+|    |  32|+{
+|    |  33|+
+|    |  34|+    void warning (const char *msg)
+|    |  35|+    {
+|    |  36|+        std::cerr << "WARNING: " << msg << "\n";
+|    |  37|+    }
+|    |  38|+
+|    |  39|+    NC::Key::Type stringToKey (const std::string & s);
+|    |  40|+
+|    |  41|+    NC::Key::Type stringToSpecialKey (const std::string & s)
+|    |  42|+    {
+|    |  43|+        NC::Key::Type result = NC::Key::None;
+|    |  44|+        if (!s.compare (0, 4, "ctrl") && s.length () == 6 && s[4] == '-')
+|    |  45|+          {
+|    |  46|+              if (s[5] >= 'a' && s[5] <= 'z')
+|    |  47|+                  result = NC::Key::Ctrl_A + (s[5] - 'a');
+|    |  48|+              else if (s[5] == '[')
+|    |  49|+                  result = NC::Key::Ctrl_LeftBracket;
+|    |  50|+              else if (s[5] == '\\')
+|    |  51|+                  result = NC::Key::Ctrl_Backslash;
+|    |  52|+              else if (s[5] == ']')
+|    |  53|+                  result = NC::Key::Ctrl_RightBracket;
+|    |  54|+              else if (s[5] == '^')
+|    |  55|+                  result = NC::Key::Ctrl_Caret;
+|    |  56|+              else if (s[5] == '_')
+|    |  57|+                  result = NC::Key::Ctrl_Underscore;
+|    |  58|+          }
+|    |  59|+        else if (!s.compare (0, 3, "alt") && s.length () > 3 && s[3] == '-')
+|    |  60|+          {
+|    |  61|+              result = NC::Key::Alt | stringToKey (s.substr (4));
+|    |  62|+          }
+|    |  63|+        else if (!s.compare (0, 4, "ctrl") && s.length () > 4 && s[4] == '-')
+|    |  64|+          {
+|    |  65|+              result = NC::Key::Ctrl | stringToKey (s.substr (5));
+|    |  66|+          }
+|    |  67|+        else if (!s.compare (0, 5, "shift") && s.length () > 5 && s[5] == '-')
+|    |  68|+          {
+|    |  69|+              result = NC::Key::Shift | stringToKey (s.substr (6));
+|    |  70|+          }
+|    |  71|+        else if (!s.compare ("escape"))
+|    |  72|+            result = NC::Key::Escape;
+|    |  73|+        else if (!s.compare ("mouse"))
+|    |  74|+            result = NC::Key::Mouse;
+|    |  75|+        else if (!s.compare ("up"))
+|    |  76|+            result = NC::Key::Up;
+|    |  77|+        else if (!s.compare ("down"))
+|    |  78|+            result = NC::Key::Down;
+|    |  79|+        else if (!s.compare ("page_up"))
+|    |  80|+            result = NC::Key::PageUp;
+|    |  81|+        else if (!s.compare ("page_down"))
+|    |  82|+            result = NC::Key::PageDown;
+|    |  83|+        else if (!s.compare ("home"))
+|    |  84|+            result = NC::Key::Home;
+|    |  85|+        else if (!s.compare ("end"))
+|    |  86|+            result = NC::Key::End;
+|    |  87|+        else if (!s.compare ("space"))
+|    |  88|+            result = NC::Key::Space;
+|    |  89|+        else if (!s.compare ("enter"))
+|    |  90|+            result = NC::Key::Enter;
+|    |  91|+        else if (!s.compare ("insert"))
+|    |  92|+            result = NC::Key::Insert;
+|    |  93|+        else if (!s.compare ("delete"))
+|    |  94|+            result = NC::Key::Delete;
+|    |  95|+        else if (!s.compare ("left"))
+|    |  96|+            result = NC::Key::Left;
+|    |  97|+        else if (!s.compare ("right"))
+|    |  98|+            result = NC::Key::Right;
+|    |  99|+        else if (!s.compare ("tab"))
+|    | 100|+            result = NC::Key::Tab;
+|    | 101|+        else if ((s.length () == 2 || s.length () == 3) && s[0] == 'f')
+|    | 102|+          {
+|    | 103|+              int n = atoi (s.c_str () + 1);
+|    | 104|+              if (n >= 1 && n <= 12)
+|    | 105|+                  result = NC::Key::F1 + n - 1;
+|    | 106|+          }
+|    | 107|+        else if (!s.compare ("backspace"))
+|    | 108|+            result = NC::Key::Backspace;
+|    | 109|+        return result;
+|    | 110|+    }
+|    | 111|+
+|    | 112|+    NC::Key::Type stringToKey (const std::string & s)
+|    | 113|+    {
+|    | 114|+        NC::Key::Type result = stringToSpecialKey (s);
+|    | 115|+        if (result == NC::Key::None)
+|    | 116|+          {
+|    | 117|+              std::wstring ws = ToWString (s);
+|    | 118|+              if (ws.length () == 1)
+|    | 119|+                  result = ws[0];
+|    | 120|+          }
+|    | 121|+        return result;
+|    | 122|+    }
+|    | 123|+
+|    | 124|+    template < typename F >
+|    | 125|+        std::shared_ptr < Actions::BaseAction >
+|    | 126|+        parseActionLine (const std::string & line, F error)
+|    | 127|+    {
+|    | 128|+        std::shared_ptr < Actions::BaseAction > result;
+|    | 129|+        size_t i = 0;
+|    | 130|+        for (; i < line.size () && !isspace (line[i]); ++i)
+|    | 131|+          {
+|    | 132|+          }
+|    | 133|+        if (i == line.size ())  // only action name
+|    | 134|+          {
+|    | 135|+              if (line == "set_visualizer_sample_multiplier")
+|    | 136|+                {
+|    | 137|+                    warning
+|    | 138|+                        ("action 'set_visualizer_sample_multiplier' is deprecated"
+|    | 139|+                         " and will be removed in 0.9");
+|    | 140|+                    result = Actions::get_ (Actions::Type::Dummy);
+|    | 141|+                }
+|    | 142|+              else
+|    | 143|+                  result = Actions::get_ (line);
+|    | 144|+          }
+|    | 145|+        else                    // there is something else
+|    | 146|+          {
+|    | 147|+              std::string action_name = line.substr (0, i);
+|    | 148|+              if (action_name == "push_character")
+|    | 149|+                {
+|    | 150|+                    // push single character into input queue
+|    | 151|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 152|+                    NC::Key::Type k = stringToSpecialKey (arg);
+|    | 153|+                    if (k != NC::Key::None)
+|    | 154|+                        result =
+|    | 155|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 156|+                            (std::make_shared < Actions::PushCharacters >
+|    | 157|+                             (&Global::wFooter, std::vector < NC::Key::Type >
+|    | 158|+                              {
+|    | 159|+                              k}
+|    | 160|+                             ));
+|    | 161|+                    else
+|    | 162|+                    error () << "invalid character passed to push_character: '"
+|    | 163|+                        << arg << "'\n";
+|    | 164|+                }
+|    | 165|+              else if (action_name == "push_characters")
+|    | 166|+                {
+|    | 167|+                    // push sequence of characters into input queue
+|    | 168|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 169|+                    if (!arg.empty ())
+|    | 170|+                      {
+|    | 171|+                          // if char is signed, erase 1s from char -> int conversion
+|    | 172|+                          for (auto it = arg.begin (); it != arg.end (); ++it)
+|    | 173|+                              *it &= 0xff;
+|    | 174|+                          result =
+|    | 175|+                              std::static_pointer_cast < Actions::BaseAction >
+|    | 176|+                              (std::make_shared < Actions::PushCharacters >
+|    | 177|+                               (&Global::wFooter, std::vector < NC::Key::Type >
+|    | 178|+                                {
+|    | 179|+                                arg.begin (), arg.end ()}
+|    | 180|+                               ));
+|    | 181|+                      }
+|    | 182|+                    else
+|    | 183|+                        error () <<
+|    | 184|+                            "empty argument passed to push_characters\n";
+|    | 185|+                }
+|    | 186|+              else if (action_name == "require_screen")
+|    | 187|+                {
+|    | 188|+                    // require screen of given type
+|    | 189|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 190|+                    ScreenType screen_type = stringToScreenType (arg);
+|    | 191|+                    if (screen_type != ScreenType::Unknown)
+|    | 192|+                        result =
+|    | 193|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 194|+                            (std::make_shared < Actions::RequireScreen >
+|    | 195|+                             (screen_type));
+|    | 196|+                    else
+|    | 197|+                        error () <<
+|    | 198|+                            "unknown screen passed to require_screen: '" << arg
+|    | 199|+                            << "'\n";
+|    | 200|+                }
+|    | 201|+              else if (action_name == "require_runnable")
+|    | 202|+                {
+|    | 203|+                    // require that given action is runnable
+|    | 204|+                    std::string arg = getEnclosedString (line, '"', '"', 0);
+|    | 205|+                    auto action = Actions::get_ (arg);
+|    | 206|+                    if (action)
+|    | 207|+                        result =
+|    | 208|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 209|+                            (std::make_shared < Actions::RequireRunnable >
+|    | 210|+                             (action));
+|    | 211|+                    else
+|    | 212|+                        error () <<
+|    | 213|+                            "unknown action passed to require_runnable: '" <<
+|    | 214|+                            arg << "'\n";
+|    | 215|+                }
+|    | 216|+              else if (action_name == "run_external_command")
+|    | 217|+                {
+|    | 218|+                    std::string command =
+|    | 219|+                        getEnclosedString (line, '"', '"', 0);
+|    | 220|+                    if (!command.empty ())
+|    | 221|+                        result =
+|    | 222|+                            std::static_pointer_cast < Actions::BaseAction >
+|    | 223|+                            (std::make_shared < Actions::RunExternalCommand >
+|    | 224|+                             (std::move (command)));
+|    | 225|+                    else
+|    | 226|+                        error () <<
+|    | 227|+                            "empty command passed to run_external_command\n";
+|    | 228|+                }
+|    | 229|+          }
+|    | 230|+        return result;
+|    | 231|+    }
+|    | 232|+
+|  36| 233| }
+|  37| 234| 
+|  38| 235| NC::Key::Type stringToKey(const std::string &s);
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+|  35|  35| 	std::cerr << "WARNING: " << msg << "\n";
+|  36|  36| }
+|  37|  37| 
+|  38|    |-NC::Key::Type stringToKey(const std::string &s);
+|  39|    |-
+|  40|    |-NC::Key::Type stringToSpecialKey(const std::string &s)
+|  41|    |-{
+|  42|    |-	NC::Key::Type result = NC::Key::None;
+|  43|    |-	if (!s.compare(0, 4, "ctrl") && s.length() == 6 && s[4] == '-')
+|  44|    |-	{
+|  45|    |-		if (s[5] >= 'a' && s[5] <= 'z')
+|  46|    |-			result = NC::Key::Ctrl_A + (s[5] - 'a');
+|  47|    |-		else if (s[5] == '[')
+|  48|    |-			result = NC::Key::Ctrl_LeftBracket;
+|  49|    |-		else if (s[5] == '\\')
+|  50|    |-			result = NC::Key::Ctrl_Backslash;
+|  51|    |-		else if (s[5] == ']')
+|  52|    |-			result = NC::Key::Ctrl_RightBracket;
+|  53|    |-		else if (s[5] == '^')
+|  54|    |-			result = NC::Key::Ctrl_Caret;
+|  55|    |-		else if (s[5] == '_')
+|  56|    |-			result = NC::Key::Ctrl_Underscore;
+|  57|    |-	}
+|  58|    |-	else if (!s.compare(0, 3, "alt") && s.length() > 3 && s[3] == '-')
+|  59|    |-	{
+|  60|    |-		result = NC::Key::Alt | stringToKey(s.substr(4));
+|  61|    |-	}
+|  62|    |-	else if (!s.compare(0, 4, "ctrl") && s.length() > 4 && s[4] == '-')
+|  63|    |-	{
+|  64|    |-		result = NC::Key::Ctrl | stringToKey(s.substr(5));
+|  65|    |-	}
+|  66|    |-	else if (!s.compare(0, 5, "shift") && s.length() > 5 && s[5] == '-')
+|  67|    |-	{
+|  68|    |-		result = NC::Key::Shift | stringToKey(s.substr(6));
+|  69|    |-	}
+|  70|    |-	else if (!s.compare("escape"))
+|  71|    |-		result = NC::Key::Escape;
+|  72|    |-	else if (!s.compare("mouse"))
+|  73|    |-		result = NC::Key::Mouse;
+|  74|    |-	else if (!s.compare("up"))
+|  75|    |-		result = NC::Key::Up;
+|  76|    |-	else if (!s.compare("down"))
+|  77|    |-		result = NC::Key::Down;
+|  78|    |-	else if (!s.compare("page_up"))
+|  79|    |-		result = NC::Key::PageUp;
+|  80|    |-	else if (!s.compare("page_down"))
+|  81|    |-		result = NC::Key::PageDown;
+|  82|    |-	else if (!s.compare("home"))
+|  83|    |-		result = NC::Key::Home;
+|  84|    |-	else if (!s.compare("end"))
+|  85|    |-		result = NC::Key::End;
+|  86|    |-	else if (!s.compare("space"))
+|  87|    |-		result = NC::Key::Space;
+|  88|    |-	else if (!s.compare("enter"))
+|  89|    |-		result = NC::Key::Enter;
+|  90|    |-	else if (!s.compare("insert"))
+|  91|    |-		result = NC::Key::Insert;
+|  92|    |-	else if (!s.compare("delete"))
+|  93|    |-		result = NC::Key::Delete;
+|  94|    |-	else if (!s.compare("left"))
+|  95|    |-		result = NC::Key::Left;
+|  96|    |-	else if (!s.compare("right"))
+|  97|    |-		result = NC::Key::Right;
+|  98|    |-	else if (!s.compare("tab"))
+|  99|    |-		result = NC::Key::Tab;
+| 100|    |-	else if ((s.length() == 2 || s.length() == 3) && s[0] == 'f')
+| 101|    |-	{
+| 102|    |-		int n = atoi(s.c_str() + 1);
+| 103|    |-		if (n >= 1 && n <= 12)
+| 104|    |-			result = NC::Key::F1 + n - 1;
+| 105|    |-	}
+| 106|    |-	else if (!s.compare("backspace"))
+| 107|    |-		result = NC::Key::Backspace;
+| 108|    |-	return result;
+|    |  38|+NC::Key::Type readKey (NC::Window & w)
+|    |  39|+{
+|    |  40|+    NC::Key::Type result = NC::Key::None;
+|    |  41|+    std::string tmp;
+|    |  42|+    NC::Key::Type input;
+|    |  43|+    bool
+|    |  44|+        alt_pressed = false;
+|    |  45|+    while (true)
+|    |  46|+      {
+|    |  47|+          input = w.readKey ();
+|    |  48|+          if (input == NC::Key::None)
+|    |  49|+              break;
+|    |  50|+          if (input & NC::Key::Alt)
+|    |  51|+            {
+|    |  52|+                // Complete the key and reapply the mask at the end.
+|    |  53|+                alt_pressed = true;
+|    |  54|+                input &= ~NC::Key::Alt;
+|    |  55|+            }
+|    |  56|+          if (input > 255)      // NC special character
+|    |  57|+            {
+|    |  58|+                result = input;
+|    |  59|+                break;
+|    |  60|+            }
+|    |  61|+          else
+|    |  62|+            {
+|    |  63|+                wchar_t
+|    |  64|+                    wc;
+|    |  65|+                tmp += input;
+|    |  66|+                size_t
+|    |  67|+                    conv_res = mbrtowc (&wc, tmp.c_str (), MB_CUR_MAX, 0);
+|    |  68|+                if (conv_res == size_t (-1))    // incomplete multibyte character
+|    |  69|+                    continue;
+|    |  70|+                else if (conv_res == size_t (-2))   // garbage character sequence
+|    |  71|+                    break;
+|    |  72|+                else            // character complete
+|    |  73|+                  {
+|    |  74|+                      result = wc;
+|    |  75|+                      break;
+|    |  76|+                  }
+|    |  77|+            }
+|    |  78|+      }
+|    |  79|+    if (alt_pressed)
+|    |  80|+        result |= NC::Key::Alt;
+|    |  81|+    return result;
+| 109|  82| }
+| 110|  83| 
+| 111|  84| NC::Key::Type stringToKey(const std::string &s)
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+| 108| 108| 	return result;
+| 109| 109| }
+| 110| 110| 
+| 111|    |-NC::Key::Type stringToKey(const std::string &s)
+| 112|    |-{
+| 113|    |-	NC::Key::Type result = stringToSpecialKey(s);
+| 114|    |-	if (result == NC::Key::None)
+| 115|    |-	{
+| 116|    |-		std::wstring ws = ToWString(s);
+| 117|    |-		if (ws.length() == 1)
+| 118|    |-			result = ws[0];
+| 119|    |-	}
+| 120|    |-	return result;
+|    | 111|+std::wstring keyToWString (const NC::Key::Type key)
+|    | 112|+{
+|    | 113|+    std::wstring result;
+|    | 114|+
+|    | 115|+    if (key == NC::Key::Tab)
+|    | 116|+        result += L"Tab";
+|    | 117|+    else if (key == NC::Key::Enter)
+|    | 118|+        result += L"Enter";
+|    | 119|+    else if (key == NC::Key::Escape)
+|    | 120|+        result += L"Escape";
+|    | 121|+    else if (key >= NC::Key::Ctrl_A && key <= NC::Key::Ctrl_Z)
+|    | 122|+      {
+|    | 123|+          result += L"Ctrl-";
+|    | 124|+          result += 'A' + (key - NC::Key::Ctrl_A);
+|    | 125|+      }
+|    | 126|+    else if (key == NC::Key::Ctrl_LeftBracket)
+|    | 127|+        result += L"Ctrl-[";
+|    | 128|+    else if (key == NC::Key::Ctrl_Backslash)
+|    | 129|+        result += L"Ctrl-\\";
+|    | 130|+    else if (key == NC::Key::Ctrl_RightBracket)
+|    | 131|+        result += L"Ctrl-]";
+|    | 132|+    else if (key == NC::Key::Ctrl_Caret)
+|    | 133|+        result += L"Ctrl-^";
+|    | 134|+    else if (key == NC::Key::Ctrl_Underscore)
+|    | 135|+        result += L"Ctrl-_";
+|    | 136|+    else if (key & NC::Key::Alt)
+|    | 137|+      {
+|    | 138|+          result += L"Alt-";
+|    | 139|+          result += keyToWString (key & ~NC::Key::Alt);
+|    | 140|+      }
+|    | 141|+    else if (key & NC::Key::Ctrl)
+|    | 142|+      {
+|    | 143|+          result += L"Ctrl-";
+|    | 144|+          result += keyToWString (key & ~NC::Key::Ctrl);
+|    | 145|+      }
+|    | 146|+    else if (key & NC::Key::Shift)
+|    | 147|+      {
+|    | 148|+          result += L"Shift-";
+|    | 149|+          result += keyToWString (key & ~NC::Key::Shift);
+|    | 150|+      }
+|    | 151|+    else if (key == NC::Key::Space)
+|    | 152|+        result += L"Space";
+|    | 153|+    else if (key == NC::Key::Backspace)
+|    | 154|+        result += L"Backspace";
+|    | 155|+    else if (key == NC::Key::Insert)
+|    | 156|+        result += L"Insert";
+|    | 157|+    else if (key == NC::Key::Delete)
+|    | 158|+        result += L"Delete";
+|    | 159|+    else if (key == NC::Key::Home)
+|    | 160|+        result += L"Home";
+|    | 161|+    else if (key == NC::Key::End)
+|    | 162|+        result += L"End";
+|    | 163|+    else if (key == NC::Key::PageUp)
+|    | 164|+        result += L"PageUp";
+|    | 165|+    else if (key == NC::Key::PageDown)
+|    | 166|+        result += L"PageDown";
+|    | 167|+    else if (key == NC::Key::Up)
+|    | 168|+        result += L"Up";
+|    | 169|+    else if (key == NC::Key::Down)
+|    | 170|+        result += L"Down";
+|    | 171|+    else if (key == NC::Key::Left)
+|    | 172|+        result += L"Left";
+|    | 173|+    else if (key == NC::Key::Right)
+|    | 174|+        result += L"Right";
+|    | 175|+    else if (key >= NC::Key::F1 && key <= NC::Key::F9)
+|    | 176|+      {
+|    | 177|+          result += L"F";
+|    | 178|+          result += '1' + (key - NC::Key::F1);
+|    | 179|+      }
+|    | 180|+    else if (key >= NC::Key::F10 && key <= NC::Key::F12)
+|    | 181|+      {
+|    | 182|+          result += L"F1";
+|    | 183|+          result += '0' + (key - NC::Key::F10);
+|    | 184|+      }
+|    | 185|+    else
+|    | 186|+        result += std::wstring (1, key);
+|    | 187|+
+|    | 188|+    return result;
+| 121| 189| }
+| 122| 190| 
+| 123| 191| template <typename F>
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/bindings.cpp
+|    |++++| /app/src/bindings.cpp
+| 120| 120| 	return result;
+| 121| 121| }
+| 122| 122| 
+| 123|    |-template <typename F>
+| 124|    |-std::shared_ptr<Actions::BaseAction> parseActionLine(const std::string &line, F error)
+|    | 123|+bool
+|    | 124|+BindingsConfiguration::read (const std::string & file)
+| 125| 125| {
+| 126|    |-	std::shared_ptr<Actions::BaseAction> result;
+| 127|    |-	size_t i = 0;
+| 128|    |-	for (; i < line.size() && !isspace(line[i]); ++i) { }
+| 129|    |-	if (i == line.size()) // only action name
+| 130|    |-	{
+| 131|    |-		if (line == "set_visualizer_sample_multiplier")
+| 132|    |-		{
+| 133|    |-			warning("action 'set_visualizer_sample_multiplier' is deprecated"
+| 134|    |-			        " and will be removed in 0.9");
+| 135|    |-			result = Actions::get_(Actions::Type::Dummy);
+| 136|    |-		}
+| 137|    |-		else
+| 138|    |-			result = Actions::get_(line);
+| 139|    |-	}
+| 140|    |-	else // there is something else
+| 141|    |-	{
+| 142|    |-		std::string action_name = line.substr(0, i);
+| 143|    |-		if (action_name == "push_character")
+| 144|    |-		{
+| 145|    |-			// push single character into input queue
+| 146|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 147|    |-			NC::Key::Type k = stringToSpecialKey(arg);
+| 148|    |-			if (k != NC::Key::None)
+| 149|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 150|    |-					std::make_shared<Actions::PushCharacters>(
+| 151|    |-						&Global::wFooter,
+| 152|    |-						std::vector<NC::Key::Type>{k}));
+| 153|    |-			else
+| 154|    |-				error() << "invalid character passed to push_character: '" << arg << "'\n";
+| 155|    |-		}
+| 156|    |-		else if (action_name == "push_characters")
+| 157|    |-		{
+| 158|    |-			// push sequence of characters into input queue
+| 159|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 160|    |-			if (!arg.empty())
+| 161|    |-			{
+| 162|    |-				// if char is signed, erase 1s from char -> int conversion
+| 163|    |-				for (auto it = arg.begin(); it != arg.end(); ++it)
+| 164|    |-					*it &= 0xff;
+| 165|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 166|    |-					std::make_shared<Actions::PushCharacters>(
+| 167|    |-						&Global::wFooter,
+| 168|    |-						std::vector<NC::Key::Type>{arg.begin(), arg.end()}));
+| 169|    |-			}
+| 170|    |-			else
+| 171|    |-				error() << "empty argument passed to push_characters\n";
+| 172|    |-		}
+| 173|    |-		else if (action_name == "require_screen")
+| 174|    |-		{
+| 175|    |-			// require screen of given type
+| 176|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 177|    |-			ScreenType screen_type = stringToScreenType(arg);
+| 178|    |-			if (screen_type != ScreenType::Unknown)
+| 179|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 180|    |-					std::make_shared<Actions::RequireScreen>(screen_type));
+| 181|    |-			else
+| 182|    |-				error() << "unknown screen passed to require_screen: '" << arg << "'\n";
+| 183|    |-		}
+| 184|    |-		else if (action_name == "require_runnable")
+| 185|    |-		{
+| 186|    |-			// require that given action is runnable
+| 187|    |-			std::string arg = getEnclosedString(line, '"', '"', 0);
+| 188|    |-			auto action = Actions::get_(arg);
+| 189|    |-			if (action)
+| 190|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 191|    |-					std::make_shared<Actions::RequireRunnable>(action));
+| 192|    |-			else
+| 193|    |-				error() << "unknown action passed to require_runnable: '" << arg << "'\n";
+| 194|    |-		}
+| 195|    |-		else if (action_name == "run_external_command")
+| 196|    |-		{
+| 197|    |-			std::string command = getEnclosedString(line, '"', '"', 0);
+| 198|    |-			if (!command.empty())
+| 199|    |-				result = std::static_pointer_cast<Actions::BaseAction>(
+| 200|    |-					std::make_shared<Actions::RunExternalCommand>(std::move(command)));
+| 201|    |-			else
+| 202|    |-				error() << "empty command passed to run_external_command\n";
+| 203|    |-		}
+| 204|    |-	}
+| 205|    |-	return result;
+| 206|    |-}
+| 207|    |-
+| 208|    |-}
+| 209|    |-
+| 210|    |-NC::Key::Type readKey(NC::Window &w)
+| 211|    |-{
+| 212|    |-	NC::Key::Type result = NC::Key::None;
+| 213|    |-	std::string tmp;
+| 214|    |-	NC::Key::Type input;
+| 215|    |-	bool alt_pressed = false;
+| 216|    |-	while (true)
+| 217|    |-	{
+| 218|    |-		input = w.readKey();
+| 219|    |-		if (input == NC::Key::None)
+| 220|    |-			break;
+| 221|    |-		if (input & NC::Key::Alt)
+| 222|    |-		{
+| 223|    |-			// Complete the key and reapply the mask at the end.
+| 224|    |-			alt_pressed = true;
+| 225|    |-			input &= ~NC::Key::Alt;
+| 226|    |-		}
+| 227|    |-		if (input > 255) // NC special character
+| 228|    |-		{
+| 229|    |-			result = input;
+| 230|    |-			break;
+| 231|    |-		}
+| 232|    |-		else
+| 233|    |-		{
+| 234|    |-			wchar_t wc;
+| 235|    |-			tmp += input;
+| 236|    |-			size_t conv_res = mbrtowc(&wc, tmp.c_str(), MB_CUR_MAX, 0);
+| 237|    |-			if (conv_res == size_t(-1)) // incomplete multibyte character
+| 238|    |-				continue;
+| 239|    |-			else if (conv_res == size_t(-2)) // garbage character sequence
+| 240|    |-				break;
+| 241|    |-			else // character complete
+| 242|    |-			{
+| 243|    |-				result = wc;
+| 244|    |-				break;
+| 245|    |-			}
+| 246|    |-		}
+| 247|    |-	}
+| 248|    |-	if (alt_pressed)
+| 249|    |-		result |= NC::Key::Alt;
+| 250|    |-	return result;
+| 251|    |-}
+| 252|    |-
+| 253|    |-std::wstring keyToWString(const NC::Key::Type key)
+| 254|    |-{
+| 255|    |-	std::wstring result;
+| 256|    |-
+| 257|    |-	if (key == NC::Key::Tab)
+| 258|    |-		result += L"Tab";
+| 259|    |-	else if (key == NC::Key::Enter)
+| 260|    |-		result += L"Enter";
+| 261|    |-	else if (key == NC::Key::Escape)
+| 262|    |-		result += L"Escape";
+| 263|    |-	else if (key >= NC::Key::Ctrl_A && key <= NC::Key::Ctrl_Z)
+| 264|    |-	{
+| 265|    |-		result += L"Ctrl-";
+| 266|    |-		result += 'A' + (key - NC::Key::Ctrl_A);
+| 267|    |-	}
+| 268|    |-	else if (key == NC::Key::Ctrl_LeftBracket)
+| 269|    |-		result += L"Ctrl-[";
+| 270|    |-	else if (key == NC::Key::Ctrl_Backslash)
+| 271|    |-		result += L"Ctrl-\\";
+| 272|    |-	else if (key == NC::Key::Ctrl_RightBracket)
+| 273|    |-		result += L"Ctrl-]";
+| 274|    |-	else if (key == NC::Key::Ctrl_Caret)
+| 275|    |-		result += L"Ctrl-^";
+| 276|    |-	else if (key == NC::Key::Ctrl_Underscore)
+| 277|    |-		result += L"Ctrl-_";
+| 278|    |-	else if (key & NC::Key::Alt)
+| 279|    |-	{
+| 280|    |-		result += L"Alt-";
+| 281|    |-		result += keyToWString(key & ~NC::Key::Alt);
+| 282|    |-	}
+| 283|    |-	else if (key & NC::Key::Ctrl)
+| 284|    |-	{
+| 285|    |-		result += L"Ctrl-";
+| 286|    |-		result += keyToWString(key & ~NC::Key::Ctrl);
+| 287|    |-	}
+| 288|    |-	else if (key & NC::Key::Shift)
+| 289|    |-	{
+| 290|    |-		result += L"Shift-";
+| 291|    |-		result += keyToWString(key & ~NC::Key::Shift);
+| 292|    |-	}
+| 293|    |-	else if (key == NC::Key::Space)
+| 294|    |-		result += L"Space";
+| 295|    |-	else if (key == NC::Key::Backspace)
+| 296|    |-		result += L"Backspace";
+| 297|    |-	else if (key == NC::Key::Insert)
+| 298|    |-		result += L"Insert";
+| 299|    |-	else if (key == NC::Key::Delete)
+| 300|    |-		result += L"Delete";
+| 301|    |-	else if (key == NC::Key::Home)
+| 302|    |-		result += L"Home";
+| 303|    |-	else if (key == NC::Key::End)
+| 304|    |-		result += L"End";
+| 305|    |-	else if (key == NC::Key::PageUp)
+| 306|    |-		result += L"PageUp";
+| 307|    |-	else if (key == NC::Key::PageDown)
+| 308|    |-		result += L"PageDown";
+| 309|    |-	else if (key == NC::Key::Up)
+| 310|    |-		result += L"Up";
+| 311|    |-	else if (key == NC::Key::Down)
+| 312|    |-		result += L"Down";
+| 313|    |-	else if (key == NC::Key::Left)
+| 314|    |-		result += L"Left";
+| 315|    |-	else if (key == NC::Key::Right)
+| 316|    |-		result += L"Right";
+| 317|    |-	else if (key >= NC::Key::F1 && key <= NC::Key::F9)
+| 318|    |-	{
+| 319|    |-		result += L"F";
+| 320|    |-		result += '1' + (key - NC::Key::F1);
+| 321|    |-	}
+| 322|    |-	else if (key >= NC::Key::F10 && key <= NC::Key::F12)
+| 323|    |-	{
+| 324|    |-		result += L"F1";
+| 325|    |-		result += '0' + (key - NC::Key::F10);
+| 326|    |-	}
+| 327|    |-	else
+| 328|    |-		result += std::wstring(1, key);
+| 329|    |-
+| 330|    |-	return result;
+| 331|    |-}
+| 332|    |-
+| 333|    |-bool BindingsConfiguration::read(const std::string &file)
+| 334|    |-{
+| 335|    |-	enum class InProgress { None, Command, Key };
+| 336|    |-	
+| 337|    |-	bool result = true;
+| 338|    |-	
+| 339|    |-	std::ifstream f(file);
+| 340|    |-	if (!f.is_open())
+| 341|    |-		return result;
+| 342|    |-	
+| 343|    |-	// shared variables
+| 344|    |-	InProgress in_progress = InProgress::None;
+| 345|    |-	size_t line_no = 0;
+| 346|    |-	std::string line;
+| 347|    |-	Binding::ActionChain actions;
+| 348|    |-	
+| 349|    |-	// def_key specific variables
+| 350|    |-	NC::Key::Type key = NC::Key::None;
+| 351|    |-	std::string strkey;
+| 352|    |-	
+| 353|    |-	// def_command specific variables
+| 354|    |-	bool cmd_immediate = false;
+| 355|    |-	std::string cmd_name;
+| 356|    |-	
+| 357|    |-	auto error = [&]() -> std::ostream & {
+| 358|    |-		std::cerr << file << ":" << line_no << ": error: ";
+| 359|    |-		in_progress = InProgress::None;
+| 360|    |-		result = false;
+| 361|    |-		return std::cerr;
+| 362|    |-	};
+| 363|    |-	
+| 364|    |-	auto bind_in_progress = [&]() -> bool {
+| 365|    |-		if (in_progress == InProgress::Command)
+| 366|    |-		{
+| 367|    |-			if (!actions.empty())
+| 368|    |-			{
+| 369|    |-				m_commands.insert(std::make_pair(cmd_name, Command(std::move(actions), cmd_immediate)));
+| 370|    |-				actions.clear();
+| 371|    |-				return true;
+| 372|    |-			}
+| 373|    |-			else
+| 374|    |-			{
+| 375|    |-				error() << "definition of command '" << cmd_name << "' cannot be empty\n";
+| 376|    |-				return false;
+| 377|    |-			}
+| 378|    |-		}
+| 379|    |-		else if (in_progress == InProgress::Key)
+| 380|    |-		{
+| 381|    |-			if (!actions.empty())
+| 382|    |-			{
+| 383|    |-				bind(key, actions);
+| 384|    |-				actions.clear();
+| 385|    |-				return true;
+| 386|    |-			}
+| 387|    |-			else
+| 388|    |-			{
+| 389|    |-				error() << "definition of key '" << strkey << "' cannot be empty\n";
+| 390|    |-				return false;
+| 391|    |-			}
+| 392|    |-		}
+| 393|    |-		return true;
+| 394|    |-	};
+| 395|    |-	
+| 396|    |-	const char def_command[] = "def_command";
+| 397|    |-	const char def_key[] = "def_key";
+| 398|    |-	
+| 399|    |-	while (!f.eof() && ++line_no)
+| 400|    |-	{
+| 401|    |-		getline(f, line);
+| 402|    |-		if (line.empty() || line[0] == '#')
+| 403|    |-			continue;
+| 404|    |-		
+| 405|    |-		// beginning of command definition
+| 406|    |-		if (!line.compare(0, const_strlen(def_command), def_command))
+| 407|    |-		{
+| 408|    |-			if (!bind_in_progress())
+| 409|    |-				break;
+| 410|    |-			in_progress = InProgress::Command;
+| 411|    |-			cmd_name = getEnclosedString(line, '"', '"', 0);
+| 412|    |-			if (cmd_name.empty())
+| 413|    |-			{
+| 414|    |-				error() << "command must have non-empty name\n";
+| 415|    |-				break;
+| 416|    |-			}
+| 417|    |-			if (m_commands.find(cmd_name) != m_commands.end())
+| 418|    |-			{
+| 419|    |-				error() << "redefinition of command '" << cmd_name << "'\n";
+| 420|    |-				break;
+| 421|    |-			}
+| 422|    |-			std::string cmd_type = getEnclosedString(line, '[', ']', 0);
+| 423|    |-			if (cmd_type == "immediate")
+| 424|    |-				cmd_immediate = true;
+| 425|    |-			else if (cmd_type == "deferred")
+| 426|    |-				cmd_immediate = false;
+| 427|    |-			else
+| 428|    |-			{
+| 429|    |-				error() << "invalid type of command: '" << cmd_type << "'\n";
+| 430|    |-				break;
+| 431|    |-			}
+| 432|    |-		}
+| 433|    |-		// beginning of key definition
+| 434|    |-		else if (!line.compare(0, const_strlen(def_key), def_key))
+| 435|    |-		{
+| 436|    |-			if (!bind_in_progress())
+| 437|    |-				break;
+| 438|    |-			in_progress = InProgress::Key;
+| 439|    |-			strkey = getEnclosedString(line, '"', '"', 0);
+| 440|    |-			key = stringToKey(strkey);
+| 441|    |-			if (key == NC::Key::None)
+| 442|    |-			{
+| 443|    |-				error() << "invalid key: '" << strkey << "'\n";
+| 444|    |-				break;
+| 445|    |-			}
+| 446|    |-		}
+| 447|    |-		else if (isspace(line[0])) // name of action to be bound
+| 448|    |-		{
+| 449|    |-			boost::trim(line);
+| 450|    |-			auto action = parseActionLine(line, error);
+| 451|    |-			if (action)
+| 452|    |-				actions.push_back(action);
+| 453|    |-			else
+| 454|    |-			{
+| 455|    |-				error() << "unknown action: '" << line << "'\n";
+| 456|    |-				break;
+| 457|    |-			}
+| 458|    |-		}
+| 459|    |-		else
+| 460|    |-		{
+| 461|    |-			error() << "invalid line: '" << line << "'\n";
+| 462|    |-			break;
+| 463|    |-		}
+| 464|    |-	}
+| 465|    |-	bind_in_progress();
+| 466|    |-	f.close();
+| 467|    |-	return result;
+| 468|    |-}
+| 469|    |-
+| 470|    |-bool BindingsConfiguration::read(const std::vector<std::string> &binding_paths)
+| 471|    |-{
+| 472|    |-	return std::all_of(
+| 473|    |-		binding_paths.begin(),
+| 474|    |-		binding_paths.end(),
+| 475|    |-		[&](const std::string &binding_path) {
+| 476|    |-			return read(binding_path);
+| 477|    |-		}
+| 478|    |-	);
+| 479|    |-}
+| 480|    |-
+| 481|    |-void BindingsConfiguration::generateDefaults()
+| 482|    |-{
+| 483|    |-	NC::Key::Type k = NC::Key::None;
+| 484|    |-	bind(NC::Key::EoF, Actions::Type::Quit);
+| 485|    |-	if (notBound(k = stringToKey("mouse")))
+| 486|    |-		bind(k, Actions::Type::MouseEvent);
+| 487|    |-	if (notBound(k = stringToKey("up")))
+| 488|    |-		bind(k, Actions::Type::ScrollUp);
+| 489|    |-	if (notBound(k = stringToKey("shift-up")))
+| 490|    |-		bind(k, Binding::ActionChain({Actions::get_(Actions::Type::SelectItem), Actions::get_(Actions::Type::ScrollUp)}));
+| 491|    |-	if (notBound(k = stringToKey("down")))
+| 492|    |-		bind(k, Actions::Type::ScrollDown);
+| 493|    |-	if (notBound(k = stringToKey("shift-down")))
+| 494|    |-		bind(k, Binding::ActionChain({Actions::get_(Actions::Type::SelectItem), Actions::get_(Actions::Type::ScrollDown)}));
+| 495|    |-	if (notBound(k = stringToKey("[")))
+| 496|    |-		bind(k, Actions::Type::ScrollUpAlbum);
+| 497|    |-	if (notBound(k = stringToKey("]")))
+| 498|    |-		bind(k, Actions::Type::ScrollDownAlbum);
+| 499|    |-	if (notBound(k = stringToKey("{")))
+| 500|    |-		bind(k, Actions::Type::ScrollUpArtist);
+| 501|    |-	if (notBound(k = stringToKey("}")))
+| 502|    |-		bind(k, Actions::Type::ScrollDownArtist);
+| 503|    |-	if (notBound(k = stringToKey("page_up")))
+| 504|    |-		bind(k, Actions::Type::PageUp);
+| 505|    |-	if (notBound(k = stringToKey("page_down")))
+| 506|    |-		bind(k, Actions::Type::PageDown);
+| 507|    |-	if (notBound(k = stringToKey("home")))
+| 508|    |-		bind(k, Actions::Type::MoveHome);
+| 509|    |-	if (notBound(k = stringToKey("end")))
+| 510|    |-		bind(k, Actions::Type::MoveEnd);
+| 511|    |-	if (notBound(k = stringToKey("insert")))
+| 512|    |-		bind(k, Actions::Type::SelectItem);
+| 513|    |-	if (notBound(k = stringToKey("enter")))
+| 514|    |-	{
+| 515|    |-		bind(k, Actions::Type::EnterDirectory);
+| 516|    |-		bind(k, Actions::Type::ToggleOutput);
+| 517|    |-		bind(k, Actions::Type::RunAction);
+| 518|    |-		bind(k, Actions::Type::PlayItem);
+| 519|    |-	}
+| 520|    |-	if (notBound(k = stringToKey("space")))
+| 521|    |-	{
+| 522|    |-		bind(k, Actions::Type::AddItemToPlaylist);
+| 523|    |-		bind(k, Actions::Type::ToggleLyricsUpdateOnSongChange);
+| 524|    |-		bind(k, Actions::Type::ToggleVisualizationType);
+| 525|    |-	}
+| 526|    |-	if (notBound(k = stringToKey("delete")))
+| 527|    |-	{
+| 528|    |-		bind(k, Actions::Type::DeletePlaylistItems);
+| 529|    |-		bind(k, Actions::Type::DeleteBrowserItems);
+| 530|    |-		bind(k, Actions::Type::DeleteStoredPlaylist);
+| 531|    |-	}
+| 532|    |-	if (notBound(k = stringToKey("right")))
+| 533|    |-	{
+| 534|    |-		bind(k, Actions::Type::NextColumn);
+| 535|    |-		bind(k, Actions::Type::SlaveScreen);
+| 536|    |-		bind(k, Actions::Type::VolumeUp);
+| 537|    |-	}
+| 538|    |-	if (notBound(k = stringToKey("+")))
+| 539|    |-		bind(k, Actions::Type::VolumeUp);
+| 540|    |-	if (notBound(k = stringToKey("left")))
+| 541|    |-	{
+| 542|    |-		bind(k, Actions::Type::PreviousColumn);
+| 543|    |-		bind(k, Actions::Type::MasterScreen);
+| 544|    |-		bind(k, Actions::Type::VolumeDown);
+| 545|    |-	}
+| 546|    |-	if (notBound(k = stringToKey("-")))
+| 547|    |-		bind(k, Actions::Type::VolumeDown);
+| 548|    |-	if (notBound(k = stringToKey(":")))
+| 549|    |-		bind(k, Actions::Type::ExecuteCommand);
+| 550|    |-	if (notBound(k = stringToKey("tab")))
+| 551|    |-		bind(k, Actions::Type::NextScreen);
+| 552|    |-	if (notBound(k = stringToKey("shift-tab")))
+| 553|    |-		bind(k, Actions::Type::PreviousScreen);
+| 554|    |-	if (notBound(k = stringToKey("f1")))
+| 555|    |-		bind(k, Actions::Type::ShowHelp);
+| 556|    |-	if (notBound(k = stringToKey("1")))
+| 557|    |-		bind(k, Actions::Type::ShowPlaylist);
+| 558|    |-	if (notBound(k = stringToKey("2")))
+| 559|    |-	{
+| 560|    |-		bind(k, Actions::Type::ShowBrowser);
+| 561|    |-		bind(k, Actions::Type::ChangeBrowseMode);
+| 562|    |-	}
+| 563|    |-	if (notBound(k = stringToKey("3")))
+| 564|    |-	{
+| 565|    |-		bind(k, Actions::Type::ShowSearchEngine);
+| 566|    |-		bind(k, Actions::Type::ResetSearchEngine);
+| 567|    |-	}
+| 568|    |-	if (notBound(k = stringToKey("4")))
+| 569|    |-	{
+| 570|    |-		bind(k, Actions::Type::ShowMediaLibrary);
+| 571|    |-		bind(k, Actions::Type::ToggleMediaLibraryColumnsMode);
+| 572|    |-	}
+| 573|    |-	if (notBound(k = stringToKey("5")))
+| 574|    |-		bind(k, Actions::Type::ShowPlaylistEditor);
+| 575|    |-	if (notBound(k = stringToKey("6")))
+| 576|    |-		bind(k, Actions::Type::ShowTagEditor);
+| 577|    |-	if (notBound(k = stringToKey("7")))
+| 578|    |-		bind(k, Actions::Type::ShowOutputs);
+| 579|    |-	if (notBound(k = stringToKey("8")))
+| 580|    |-		bind(k, Actions::Type::ShowVisualizer);
+| 581|    |-	if (notBound(k = stringToKey("=")))
+| 582|    |-		bind(k, Actions::Type::ShowClock);
+| 583|    |-	if (notBound(k = stringToKey("@")))
+| 584|    |-		bind(k, Actions::Type::ShowServerInfo);
+| 585|    |-	if (notBound(k = stringToKey("s")))
+| 586|    |-		bind(k, Actions::Type::Stop);
+| 587|    |-	if (notBound(k = stringToKey("p")))
+| 588|    |-		bind(k, Actions::Type::Pause);
+| 589|    |-	if (notBound(k = stringToKey(">")))
+| 590|    |-		bind(k, Actions::Type::Next);
+| 591|    |-	if (notBound(k = stringToKey("<")))
+| 592|    |-		bind(k, Actions::Type::Previous);
+| 593|    |-	if (notBound(k = stringToKey("ctrl-h")))
+| 594|    |-	{
+| 595|    |-		bind(k, Actions::Type::JumpToParentDirectory);
+| 596|    |-		bind(k, Actions::Type::ReplaySong);
+| 597|    |-	}
+| 598|    |-	if (notBound(k = stringToKey("backspace")))
+| 599|    |-	{
+| 600|    |-		bind(k, Actions::Type::JumpToParentDirectory);
+| 601|    |-		bind(k, Actions::Type::ReplaySong);
+| 602|    |-	}
+| 603|    |-	if (notBound(k = stringToKey("f")))
+| 604|    |-		bind(k, Actions::Type::SeekForward);
+| 605|    |-	if (notBound(k = stringToKey("b")))
+| 606|    |-		bind(k, Actions::Type::SeekBackward);
+| 607|    |-	if (notBound(k = stringToKey("r")))
+| 608|    |-		bind(k, Actions::Type::ToggleRepeat);
+| 609|    |-	if (notBound(k = stringToKey("z")))
+| 610|    |-		bind(k, Actions::Type::ToggleRandom);
+| 611|    |-	if (notBound(k = stringToKey("y")))
+| 612|    |-	{
+| 613|    |-		bind(k, Actions::Type::SaveTagChanges);
+| 614|    |-		bind(k, Actions::Type::StartSearching);
+| 615|    |-		bind(k, Actions::Type::ToggleSingle);
+| 616|    |-	}
+| 617|    |-	if (notBound(k = stringToKey("R")))
+| 618|    |-		bind(k, Actions::Type::ToggleConsume);
+| 619|    |-	if (notBound(k = stringToKey("Y")))
+| 620|    |-		bind(k, Actions::Type::ToggleReplayGainMode);
+| 621|    |-	if (notBound(k = stringToKey("T")))
+| 622|    |-		bind(k, Actions::Type::ToggleAddMode);
+| 623|    |-	if (notBound(k = stringToKey("|")))
+| 624|    |-		bind(k, Actions::Type::ToggleMouse);
+| 625|    |-	if (notBound(k = stringToKey("#")))
+| 626|    |-		bind(k, Actions::Type::ToggleBitrateVisibility);
+| 627|    |-	if (notBound(k = stringToKey("Z")))
+| 628|    |-		bind(k, Actions::Type::Shuffle);
+| 629|    |-	if (notBound(k = stringToKey("x")))
+| 630|    |-		bind(k, Actions::Type::ToggleCrossfade);
+| 631|    |-	if (notBound(k = stringToKey("X")))
+| 632|    |-		bind(k, Actions::Type::SetCrossfade);
+| 633|    |-	if (notBound(k = stringToKey("u")))
+| 634|    |-		bind(k, Actions::Type::UpdateDatabase);
+| 635|    |-	if (notBound(k = stringToKey("ctrl-s")))
+| 636|    |-	{
+| 637|    |-		bind(k, Actions::Type::SortPlaylist);
+| 638|    |-		bind(k, Actions::Type::ToggleBrowserSortMode);
+| 639|    |-		bind(k, Actions::Type::ToggleMediaLibrarySortMode);
+| 640|    |-	}
+| 641|    |-	if (notBound(k = stringToKey("ctrl-r")))
+| 642|    |-		bind(k, Actions::Type::ReversePlaylist);
+| 643|    |-	if (notBound(k = stringToKey("ctrl-f")))
+| 644|    |-		bind(k, Actions::Type::ApplyFilter);
+| 645|    |-	if (notBound(k = stringToKey("ctrl-_")))
+| 646|    |-		bind(k, Actions::Type::SelectFoundItems);
+| 647|    |-	if (notBound(k = stringToKey("/")))
+| 648|    |-	{
+| 649|    |-		bind(k, Actions::Type::Find);
+| 650|    |-		bind(k, Actions::Type::FindItemForward);
+| 651|    |-	}
+| 652|    |-	if (notBound(k = stringToKey("?")))
+| 653|    |-	{
+| 654|    |-		bind(k, Actions::Type::Find);
+| 655|    |-		bind(k, Actions::Type::FindItemBackward);
+| 656|    |-	}
+| 657|    |-	if (notBound(k = stringToKey(".")))
+| 658|    |-		bind(k, Actions::Type::NextFoundItem);
+| 659|    |-	if (notBound(k = stringToKey(",")))
+| 660|    |-		bind(k, Actions::Type::PreviousFoundItem);
+| 661|    |-	if (notBound(k = stringToKey("w")))
+| 662|    |-		bind(k, Actions::Type::ToggleFindMode);
+| 663|    |-	if (notBound(k = stringToKey("e")))
+| 664|    |-	{
+| 665|    |-		bind(k, Actions::Type::EditSong);
+| 666|    |-		bind(k, Actions::Type::EditLibraryTag);
+| 667|    |-		bind(k, Actions::Type::EditLibraryAlbum);
+| 668|    |-		bind(k, Actions::Type::EditDirectoryName);
+| 669|    |-		bind(k, Actions::Type::EditPlaylistName);
+| 670|    |-		bind(k, Actions::Type::EditLyrics);
+| 671|    |-	}
+| 672|    |-	if (notBound(k = stringToKey("i")))
+| 673|    |-		bind(k, Actions::Type::ShowSongInfo);
+| 674|    |-	if (notBound(k = stringToKey("I")))
+| 675|    |-		bind(k, Actions::Type::ShowArtistInfo);
+| 676|    |-	if (notBound(k = stringToKey("g")))
+| 677|    |-		bind(k, Actions::Type::JumpToPositionInSong);
+| 678|    |-	if (notBound(k = stringToKey("l")))
+| 679|    |-		bind(k, Actions::Type::ShowLyrics);
+| 680|    |-	if (notBound(k = stringToKey("ctrl-v")))
+| 681|    |-		bind(k, Actions::Type::SelectRange);
+| 682|    |-	if (notBound(k = stringToKey("v")))
+| 683|    |-		bind(k, Actions::Type::ReverseSelection);
+| 684|    |-	if (notBound(k = stringToKey("V")))
+| 685|    |-		bind(k, Actions::Type::RemoveSelection);
+| 686|    |-	if (notBound(k = stringToKey("B")))
+| 687|    |-		bind(k, Actions::Type::SelectAlbum);
+| 688|    |-	if (notBound(k = stringToKey("a")))
+| 689|    |-		bind(k, Actions::Type::AddSelectedItems);
+| 690|    |-	if (notBound(k = stringToKey("c")))
+| 691|    |-	{
+| 692|    |-		bind(k, Actions::Type::ClearPlaylist);
+| 693|    |-		bind(k, Actions::Type::ClearMainPlaylist);
+| 694|    |-	}
+| 695|    |-	if (notBound(k = stringToKey("C")))
+| 696|    |-	{
+| 697|    |-		bind(k, Actions::Type::CropPlaylist);
+| 698|    |-		bind(k, Actions::Type::CropMainPlaylist);
+| 699|    |-	}
+| 700|    |-	if (notBound(k = stringToKey("m")))
+| 701|    |-	{
+| 702|    |-		bind(k, Actions::Type::MoveSortOrderUp);
+| 703|    |-		bind(k, Actions::Type::MoveSelectedItemsUp);
+| 704|    |-	}
+| 705|    |-	if (notBound(k = stringToKey("n")))
+| 706|    |-	{
+| 707|    |-		bind(k, Actions::Type::MoveSortOrderDown);
+| 708|    |-		bind(k, Actions::Type::MoveSelectedItemsDown);
+| 709|    |-	}
+| 710|    |-	if (notBound(k = stringToKey("M")))
+| 711|    |-		bind(k, Actions::Type::MoveSelectedItemsTo);
+| 712|    |-	if (notBound(k = stringToKey("A")))
+| 713|    |-		bind(k, Actions::Type::Add);
+| 714|    |-	if (notBound(k = stringToKey("S")))
+| 715|    |-		bind(k, Actions::Type::SavePlaylist);
+| 716|    |-	if (notBound(k = stringToKey("o")))
+| 717|    |-		bind(k, Actions::Type::JumpToPlayingSong);
+| 718|    |-	if (notBound(k = stringToKey("G")))
+| 719|    |-	{
+| 720|    |-		bind(k, Actions::Type::JumpToBrowser);
+| 721|    |-		bind(k, Actions::Type::JumpToPlaylistEditor);
+| 722|    |-	}
+| 723|    |-	if (notBound(k = stringToKey("~")))
+| 724|    |-		bind(k, Actions::Type::JumpToMediaLibrary);
+| 725|    |-	if (notBound(k = stringToKey("E")))
+| 726|    |-		bind(k, Actions::Type::JumpToTagEditor);
+| 727|    |-	if (notBound(k = stringToKey("U")))
+| 728|    |-		bind(k, Actions::Type::TogglePlayingSongCentering);
+| 729|    |-	if (notBound(k = stringToKey("P")))
+| 730|    |-		bind(k, Actions::Type::ToggleDisplayMode);
+| 731|    |-	if (notBound(k = stringToKey("\\")))
+| 732|    |-		bind(k, Actions::Type::ToggleInterface);
+| 733|    |-	if (notBound(k = stringToKey("!")))
+| 734|    |-		bind(k, Actions::Type::ToggleSeparatorsBetweenAlbums);
+| 735|    |-	if (notBound(k = stringToKey("L")))
+| 736|    |-		bind(k, Actions::Type::ToggleLyricsFetcher);
+| 737|    |-	if (notBound(k = stringToKey("F")))
+| 738|    |-		bind(k, Actions::Type::FetchLyricsInBackground);
+| 739|    |-	if (notBound(k = stringToKey("alt-l")))
+| 740|    |-		bind(k, Actions::Type::ToggleFetchingLyricsInBackground);
+| 741|    |-	if (notBound(k = stringToKey("ctrl-l")))
+| 742|    |-		bind(k, Actions::Type::ToggleScreenLock);
+| 743|    |-	if (notBound(k = stringToKey("`")))
+| 744|    |-	{
+| 745|    |-		bind(k, Actions::Type::ToggleLibraryTagType);
+| 746|    |-		bind(k, Actions::Type::RefetchLyrics);
+| 747|    |-		bind(k, Actions::Type::AddRandomItems);
+| 748|    |-	}
+| 749|    |-	if (notBound(k = stringToKey("ctrl-p")))
+| 750|    |-		bind(k, Actions::Type::SetSelectedItemsPriority);
+| 751|    |-	if (notBound(k = stringToKey("q")))
+| 752|    |-		bind(k, Actions::Type::Quit);
+| 753|    |-}
+| 754|    |-
+| 755|    |-const Command *BindingsConfiguration::findCommand(const std::string &name)
+| 756|    |-{
+| 757|    |-	const Command *ptr = nullptr;
+| 758|    |-	auto it = m_commands.find(name);
+| 759|    |-	if (it != m_commands.end())
+| 760|    |-		ptr = &it->second;
+| 761|    |-	return ptr;
+| 762|    |-}
+| 763|    |-
+| 764|    |-BindingsConfiguration::BindingIteratorPair BindingsConfiguration::get(const NC::Key::Type &k)
+| 765|    |-{
+| 766|    |-	std::pair<BindingIterator, BindingIterator> result;
+| 767|    |-	auto it = m_bindings.find(k);
+| 768|    |-	if (it != m_bindings.end()) {
+| 769|    |-		result.first = it->second.begin();
+| 770|    |-		result.second = it->second.end();
+| 771|    |-	} else {
+| 772|    |-		auto list_end = m_bindings.begin()->second.end();
+| 773|    |-		result.first = list_end;
+| 774|    |-		result.second = list_end;
+| 775|    |-	}
+| 776|    |-	return result;
+| 777|    |-}
+|    | 126|+    enum class InProgress
+|    | 127|+    { None, Command, Key };
+|    | 128|+
+|    | 129|+    bool result = true;
+|    | 130|+
+|    | 131|+    std::ifstream f (file);
+|    | 132|+    if (!f.is_open ())
+|    | 133|+        return result;
+|    | 134|+
+|    | 135|+    // shared variables
+|    | 136|+    InProgress in_progress = InProgress::None;
+|    | 137|+    size_t line_no = 0;
+|    | 138|+    std::string line;
+|    | 139|+    Binding::ActionChain actions;
+|    | 140|+
+|    | 141|+    // def_key specific variables
+|    | 142|+    NC::Key::Type key = NC::Key::None;
+|    | 143|+    std::string strkey;
+|    | 144|+
+|    | 145|+    // def_command specific variables
+|    | 146|+    bool cmd_immediate = false;
+|    | 147|+    std::string cmd_name;
+|    | 148|+
+|    | 149|+    auto error =[&]()->std::ostream & {
+|    | 150|+        std::cerr << file << ":" << line_no << ": error: ";
+|    | 151|+        in_progress = InProgress::None;
+|    | 152|+        result = false;
+|    | 153|+        return std::cerr;
+|    | 154|+    };
+|    | 155|+
+|    | 156|+    auto bind_in_progress =[&]()->bool {
+|    | 157|+        if (in_progress == InProgress::Command)
+|    | 158|+          {
+|    | 159|+           if (!actions.empty ()){
+|    | 160|+                                  m_commands.
+|    | 161|+                                  insert (std::
+|    | 162|+                                          make_pair (cmd_name,
+|    | 163|+                                                     Command (std::
+|    | 164|+                                                              move (actions),
+|    | 165|+                                                              cmd_immediate)));
+|    | 166|+                                  actions.clear (); return true;}
+|    | 167|+                                  else
+|    | 168|+                                  {
+|    | 169|+                                  error () << "definition of command '" <<
+|    | 170|+                                  cmd_name << "' cannot be empty\n";
+|    | 171|+                                  return false;}
+|    | 172|+                                  }
+|    | 173|+                                  else if (in_progress == InProgress::Key)
+|    | 174|+                                  {
+|    | 175|+                                  if (!actions.empty ())
+|    | 176|+                                  {
+|    | 177|+                                  bind (key, actions);
+|    | 178|+                                  actions.clear (); return true;}
+|    | 179|+                                  else
+|    | 180|+                                  {
+|    | 181|+                                  error () << "definition of key '" << strkey
+|    | 182|+                                  << "' cannot be empty\n"; return false;}
+|    | 183|+                                  }
+|    | 184|+                                  return true;};
+|    | 185|+                                  const char def_command[] = "def_command";
+|    | 186|+                                  const char def_key[] = "def_key";
+|    | 187|+                                  while (!f.eof () && ++line_no)
+|    | 188|+                                  {
+|    | 189|+                                  getline (f, line);
+|    | 190|+                                  if (line.empty () || line[0] == '#')
+|    | 191|+                                  continue;
+|    | 192|+                                  // beginning of command definition
+|    | 193|+                                  if (!line.
+|    | 194|+                                      compare (0, const_strlen (def_command),
+|    | 195|+                                               def_command))
+|    | 196|+                                  {
+|    | 197|+                                  if (!bind_in_progress ())break;
+|    | 198|+                                  in_progress = InProgress::Command;
+|    | 199|+                                  cmd_name =
+|    | 200|+                                  getEnclosedString (line, '"', '"', 0);
+|    | 201|+                                  if (cmd_name.empty ())
+|    | 202|+                                  {
+|    | 203|+                                  error () <<
+|    | 204|+                                  "command must have non-empty name\n"; break;}
+|    | 205|+                                  if (m_commands.find (cmd_name) !=
+|    | 206|+                                      m_commands.end ())
+|    | 207|+                                  {
+|    | 208|+                                  error () << "redefinition of command '" <<
+|    | 209|+                                  cmd_name << "'\n"; break;}
+|    | 210|+                                  std::string cmd_type =
+|    | 211|+                                  getEnclosedString (line, '[', ']', 0);
+|    | 212|+                                  if (cmd_type == "immediate") cmd_immediate =
+|    | 213|+                                  true;
+|    | 214|+                                  else
+|    | 215|+                                  if (cmd_type == "deferred")
+|    | 216|+                                  cmd_immediate = false;
+|    | 217|+                                  else
+|    | 218|+                                  {
+|    | 219|+                                  error () << "invalid type of command: '" <<
+|    | 220|+                                  cmd_type << "'\n"; break;}
+|    | 221|+                                  }
+|    | 222|+                                  // beginning of key definition
+|    | 223|+                                  else
+|    | 224|+                                  if (!line.
+|    | 225|+                                      compare (0, const_strlen (def_key),
+|    | 226|+                                               def_key))
+|    | 227|+                                  {
+|    | 228|+                                  if (!bind_in_progress ())break;
+|    | 229|+                                  in_progress = InProgress::Key;
+|    | 230|+                                  strkey =
+|    | 231|+                                  getEnclosedString (line, '"', '"', 0);
+|    | 232|+                                  key = stringToKey (strkey);
+|    | 233|+                                  if (key == NC::Key::None)
+|    | 234|+                                  {
+|    | 235|+                                  error () << "invalid key: '" << strkey <<
+|    | 236|+                                  "'\n"; break;}
+|    | 237|+                                  }
+|    | 238|+                                  else
+|    | 239|+                                  if (isspace (line[0]))    // name of action to be bound
+|    | 240|+                                  {
+|    | 241|+                                  boost::trim (line);
+|    | 242|+                                  auto action = parseActionLine (line, error);
+|    | 243|+                                  if (action) actions.push_back (action);
+|    | 244|+                                  else
+|    | 245|+                                  {
+|    | 246|+                                  error () << "unknown action: '" << line <<
+|    | 247|+                                  "'\n"; break;}
+|    | 248|+                                  }
+|    | 249|+                                  else
+|    | 250|+                                  {
+|    | 251|+                                  error () << "invalid line: '" << line <<
+|    | 252|+                                  "'\n"; break;}
+|    | 253|+                                  }
+|    | 254|+                                  bind_in_progress ();
+|    | 255|+                                  f.close (); return result;}
+|    | 256|+
+|    | 257|+                                  bool BindingsConfiguration::read (const std::
+|    | 258|+                                                                    vector <
+|    | 259|+                                                                    std::
+|    | 260|+                                                                    string >
+|    | 261|+                                                                    &binding_paths)
+|    | 262|+                                  {
+|    | 263|+                                  return std::all_of (binding_paths.begin (),
+|    | 264|+                                                      binding_paths.end (),
+|    | 265|+                                                      [&](const std::
+|    | 266|+                                                          string &
+|    | 267|+                                                          binding_path)
+|    | 268|+                                                      {
+|    | 269|+                                                      return
+|    | 270|+                                                      read (binding_path);}
+|    | 271|+                                  );}
+|    | 272|+
+|    | 273|+                                  void BindingsConfiguration::
+|    | 274|+                                  generateDefaults ()
+|    | 275|+                                  {
+|    | 276|+                                  NC::Key::Type k = NC::Key::None;
+|    | 277|+                                  bind (NC::Key::EoF, Actions::Type::Quit);
+|    | 278|+                                  if (notBound (k = stringToKey ("mouse")))
+|    | 279|+                                  bind (k, Actions::Type::MouseEvent);
+|    | 280|+                                  if (notBound (k = stringToKey ("up")))
+|    | 281|+                                  bind (k, Actions::Type::ScrollUp);
+|    | 282|+                                  if (notBound (k = stringToKey ("shift-up")))
+|    | 283|+                                  bind (k, Binding::ActionChain (
+|    | 284|+                                                                                         {
+|    | 285|+                                                                                         Actions::
+|    | 286|+                                                                                         get_
+|    | 287|+                                                                                         (Actions::
+|    | 288|+                                                                                          Type::
+|    | 289|+                                                                                          SelectItem),
+|    | 290|+                                                                                         Actions::
+|    | 291|+                                                                                         get_
+|    | 292|+                                                                                         (Actions::
+|    | 293|+                                                                                          Type::
+|    | 294|+                                                                                          ScrollUp)}
+|    | 295|+                                        ));
+|    | 296|+                                  if (notBound (k = stringToKey ("down")))
+|    | 297|+                                  bind (k, Actions::Type::ScrollDown);
+|    | 298|+                                  if (notBound
+|    | 299|+                                      (k =
+|    | 300|+                                       stringToKey ("shift-down"))) bind (k,
+|    | 301|+                                                                          Binding::
+|    | 302|+                                                                          ActionChain
+|    | 303|+                                                                          (
+|    | 304|+                                                                                                      {
+|    | 305|+                                                                                                      Actions::
+|    | 306|+                                                                                                      get_
+|    | 307|+                                                                                                      (Actions::
+|    | 308|+                                                                                                       Type::
+|    | 309|+                                                                                                       SelectItem),
+|    | 310|+                                                                                                      Actions::
+|    | 311|+                                                                                                      get_
+|    | 312|+                                                                                                      (Actions::
+|    | 313|+                                                                                                       Type::
+|    | 314|+                                                                                                       ScrollDown)}
+|    | 315|+                                                                          ));
+|    | 316|+                                  if (notBound (k = stringToKey ("[")))
+|    | 317|+                                  bind (k, Actions::Type::ScrollUpAlbum);
+|    | 318|+                                  if (notBound (k = stringToKey ("]")))
+|    | 319|+                                  bind (k, Actions::Type::ScrollDownAlbum);
+|    | 320|+                                  if (notBound (k = stringToKey ("{")))
+|    | 321|+                                  bind (k, Actions::Type::ScrollUpArtist);
+|    | 322|+                                  if (notBound (k = stringToKey ("}")))
+|    | 323|+                                  bind (k, Actions::Type::ScrollDownArtist);
+|    | 324|+                                  if (notBound (k = stringToKey ("page_up")))
+|    | 325|+                                  bind (k, Actions::Type::PageUp);
+|    | 326|+                                  if (notBound (k = stringToKey ("page_down")))
+|    | 327|+                                  bind (k, Actions::Type::PageDown);
+|    | 328|+                                  if (notBound (k = stringToKey ("home")))
+|    | 329|+                                  bind (k, Actions::Type::MoveHome);
+|    | 330|+                                  if (notBound (k = stringToKey ("end")))
+|    | 331|+                                  bind (k, Actions::Type::MoveEnd);
+|    | 332|+                                  if (notBound (k = stringToKey ("insert")))
+|    | 333|+                                  bind (k, Actions::Type::SelectItem);
+|    | 334|+                                  if (notBound (k = stringToKey ("enter")))
+|    | 335|+                                  {
+|    | 336|+                                  bind (k, Actions::Type::EnterDirectory);
+|    | 337|+                                  bind (k, Actions::Type::ToggleOutput);
+|    | 338|+                                  bind (k, Actions::Type::RunAction);
+|    | 339|+                                  bind (k, Actions::Type::PlayItem);}
+|    | 340|+                                  if (notBound (k = stringToKey ("space")))
+|    | 341|+                                  {
+|    | 342|+                                  bind (k, Actions::Type::AddItemToPlaylist);
+|    | 343|+                                  bind (k,
+|    | 344|+                                        Actions::Type::
+|    | 345|+                                        ToggleLyricsUpdateOnSongChange);
+|    | 346|+                                  bind (k,
+|    | 347|+                                        Actions::Type::
+|    | 348|+                                        ToggleVisualizationType);}
+|    | 349|+                                  if (notBound (k = stringToKey ("delete")))
+|    | 350|+                                  {
+|    | 351|+                                  bind (k, Actions::Type::DeletePlaylistItems);
+|    | 352|+                                  bind (k, Actions::Type::DeleteBrowserItems);
+|    | 353|+                                  bind (k,
+|    | 354|+                                        Actions::Type::DeleteStoredPlaylist);}
+|    | 355|+                                  if (notBound (k = stringToKey ("right")))
+|    | 356|+                                  {
+|    | 357|+                                  bind (k, Actions::Type::NextColumn);
+|    | 358|+                                  bind (k, Actions::Type::SlaveScreen);
+|    | 359|+                                  bind (k, Actions::Type::VolumeUp);}
+|    | 360|+                                  if (notBound (k = stringToKey ("+")))
+|    | 361|+                                  bind (k, Actions::Type::VolumeUp);
+|    | 362|+                                  if (notBound (k = stringToKey ("left")))
+|    | 363|+                                  {
+|    | 364|+                                  bind (k, Actions::Type::PreviousColumn);
+|    | 365|+                                  bind (k, Actions::Type::MasterScreen);
+|    | 366|+                                  bind (k, Actions::Type::VolumeDown);}
+|    | 367|+                                  if (notBound (k = stringToKey ("-")))
+|    | 368|+                                  bind (k, Actions::Type::VolumeDown);
+|    | 369|+                                  if (notBound (k = stringToKey (":")))
+|    | 370|+                                  bind (k, Actions::Type::ExecuteCommand);
+|    | 371|+                                  if (notBound (k = stringToKey ("tab")))
+|    | 372|+                                  bind (k, Actions::Type::NextScreen);
+|    | 373|+                                  if (notBound (k = stringToKey ("shift-tab")))
+|    | 374|+                                  bind (k, Actions::Type::PreviousScreen);
+|    | 375|+                                  if (notBound (k = stringToKey ("f1")))
+|    | 376|+                                  bind (k, Actions::Type::ShowHelp);
+|    | 377|+                                  if (notBound (k = stringToKey ("1")))
+|    | 378|+                                  bind (k, Actions::Type::ShowPlaylist);
+|    | 379|+                                  if (notBound (k = stringToKey ("2")))
+|    | 380|+                                  {
+|    | 381|+                                  bind (k, Actions::Type::ShowBrowser);
+|    | 382|+                                  bind (k, Actions::Type::ChangeBrowseMode);}
+|    | 383|+                                  if (notBound (k = stringToKey ("3")))
+|    | 384|+                                  {
+|    | 385|+                                  bind (k, Actions::Type::ShowSearchEngine);
+|    | 386|+                                  bind (k, Actions::Type::ResetSearchEngine);}
+|    | 387|+                                  if (notBound (k = stringToKey ("4")))
+|    | 388|+                                  {
+|    | 389|+                                  bind (k, Actions::Type::ShowMediaLibrary);
+|    | 390|+                                  bind (k,
+|    | 391|+                                        Actions::Type::
+|    | 392|+                                        ToggleMediaLibraryColumnsMode);}
+|    | 393|+                                  if (notBound (k = stringToKey ("5")))
+|    | 394|+                                  bind (k, Actions::Type::ShowPlaylistEditor);
+|    | 395|+                                  if (notBound (k = stringToKey ("6")))
+|    | 396|+                                  bind (k, Actions::Type::ShowTagEditor);
+|    | 397|+                                  if (notBound (k = stringToKey ("7")))
+|    | 398|+                                  bind (k, Actions::Type::ShowOutputs);
+|    | 399|+                                  if (notBound (k = stringToKey ("8")))
+|    | 400|+                                  bind (k, Actions::Type::ShowVisualizer);
+|    | 401|+                                  if (notBound (k = stringToKey ("=")))
+|    | 402|+                                  bind (k, Actions::Type::ShowClock);
+|    | 403|+                                  if (notBound (k = stringToKey ("@")))
+|    | 404|+                                  bind (k, Actions::Type::ShowServerInfo);
+|    | 405|+                                  if (notBound (k = stringToKey ("s")))
+|    | 406|+                                  bind (k, Actions::Type::Stop);
+|    | 407|+                                  if (notBound (k = stringToKey ("p")))
+|    | 408|+                                  bind (k, Actions::Type::Pause);
+|    | 409|+                                  if (notBound (k = stringToKey (">")))
+|    | 410|+                                  bind (k, Actions::Type::Next);
+|    | 411|+                                  if (notBound (k = stringToKey ("<")))
+|    | 412|+                                  bind (k, Actions::Type::Previous);
+|    | 413|+                                  if (notBound (k = stringToKey ("ctrl-h")))
+|    | 414|+                                  {
+|    | 415|+                                  bind (k,
+|    | 416|+                                        Actions::Type::JumpToParentDirectory);
+|    | 417|+                                  bind (k, Actions::Type::ReplaySong);}
+|    | 418|+                                  if (notBound (k = stringToKey ("backspace")))
+|    | 419|+                                  {
+|    | 420|+                                  bind (k,
+|    | 421|+                                        Actions::Type::JumpToParentDirectory);
+|    | 422|+                                  bind (k, Actions::Type::ReplaySong);}
+|    | 423|+                                  if (notBound (k = stringToKey ("f")))
+|    | 424|+                                  bind (k, Actions::Type::SeekForward);
+|    | 425|+                                  if (notBound (k = stringToKey ("b")))
+|    | 426|+                                  bind (k, Actions::Type::SeekBackward);
+|    | 427|+                                  if (notBound (k = stringToKey ("r")))
+|    | 428|+                                  bind (k, Actions::Type::ToggleRepeat);
+|    | 429|+                                  if (notBound (k = stringToKey ("z")))
+|    | 430|+                                  bind (k, Actions::Type::ToggleRandom);
+|    | 431|+                                  if (notBound (k = stringToKey ("y")))
+|    | 432|+                                  {
+|    | 433|+                                  bind (k, Actions::Type::SaveTagChanges);
+|    | 434|+                                  bind (k, Actions::Type::StartSearching);
+|    | 435|+                                  bind (k, Actions::Type::ToggleSingle);}
+|    | 436|+                                  if (notBound (k = stringToKey ("R")))
+|    | 437|+                                  bind (k, Actions::Type::ToggleConsume);
+|    | 438|+                                  if (notBound (k = stringToKey ("Y")))
+|    | 439|+                                  bind (k,
+|    | 440|+                                        Actions::Type::ToggleReplayGainMode);
+|    | 441|+                                  if (notBound (k = stringToKey ("T")))
+|    | 442|+                                  bind (k, Actions::Type::ToggleAddMode);
+|    | 443|+                                  if (notBound (k = stringToKey ("|")))
+|    | 444|+                                  bind (k, Actions::Type::ToggleMouse);
+|    | 445|+                                  if (notBound (k = stringToKey ("#")))
+|    | 446|+                                  bind (k,
+|    | 447|+                                        Actions::Type::
+|    | 448|+                                        ToggleBitrateVisibility);
+|    | 449|+                                  if (notBound (k = stringToKey ("Z")))
+|    | 450|+                                  bind (k, Actions::Type::Shuffle);
+|    | 451|+                                  if (notBound (k = stringToKey ("x")))
+|    | 452|+                                  bind (k, Actions::Type::ToggleCrossfade);
+|    | 453|+                                  if (notBound (k = stringToKey ("X")))
+|    | 454|+                                  bind (k, Actions::Type::SetCrossfade);
+|    | 455|+                                  if (notBound (k = stringToKey ("u")))
+|    | 456|+                                  bind (k, Actions::Type::UpdateDatabase);
+|    | 457|+                                  if (notBound (k = stringToKey ("ctrl-s")))
+|    | 458|+                                  {
+|    | 459|+                                  bind (k, Actions::Type::SortPlaylist);
+|    | 460|+                                  bind (k,
+|    | 461|+                                        Actions::Type::ToggleBrowserSortMode);
+|    | 462|+                                  bind (k,
+|    | 463|+                                        Actions::Type::
+|    | 464|+                                        ToggleMediaLibrarySortMode);}
+|    | 465|+                                  if (notBound (k = stringToKey ("ctrl-r")))
+|    | 466|+                                  bind (k, Actions::Type::ReversePlaylist);
+|    | 467|+                                  if (notBound (k = stringToKey ("ctrl-f")))
+|    | 468|+                                  bind (k, Actions::Type::ApplyFilter);
+|    | 469|+                                  if (notBound (k = stringToKey ("ctrl-_")))
+|    | 470|+                                  bind (k, Actions::Type::SelectFoundItems);
+|    | 471|+                                  if (notBound (k = stringToKey ("/")))
+|    | 472|+                                  {
+|    | 473|+                                  bind (k, Actions::Type::Find);
+|    | 474|+                                  bind (k, Actions::Type::FindItemForward);}
+|    | 475|+                                  if (notBound (k = stringToKey ("?")))
+|    | 476|+                                  {
+|    | 477|+                                  bind (k, Actions::Type::Find);
+|    | 478|+                                  bind (k, Actions::Type::FindItemBackward);}
+|    | 479|+                                  if (notBound (k = stringToKey (".")))
+|    | 480|+                                  bind (k, Actions::Type::NextFoundItem);
+|    | 481|+                                  if (notBound (k = stringToKey (",")))
+|    | 482|+                                  bind (k, Actions::Type::PreviousFoundItem);
+|    | 483|+                                  if (notBound (k = stringToKey ("w")))
+|    | 484|+                                  bind (k, Actions::Type::ToggleFindMode);
+|    | 485|+                                  if (notBound (k = stringToKey ("e")))
+|    | 486|+                                  {
+|    | 487|+                                  bind (k, Actions::Type::EditSong);
+|    | 488|+                                  bind (k, Actions::Type::EditLibraryTag);
+|    | 489|+                                  bind (k, Actions::Type::EditLibraryAlbum);
+|    | 490|+                                  bind (k, Actions::Type::EditDirectoryName);
+|    | 491|+                                  bind (k, Actions::Type::EditPlaylistName);
+|    | 492|+                                  bind (k, Actions::Type::EditLyrics);}
+|    | 493|+                                  if (notBound (k = stringToKey ("i")))
+|    | 494|+                                  bind (k, Actions::Type::ShowSongInfo);
+|    | 495|+                                  if (notBound (k = stringToKey ("I")))
+|    | 496|+                                  bind (k, Actions::Type::ShowArtistInfo);
+|    | 497|+                                  if (notBound (k = stringToKey ("g")))
+|    | 498|+                                  bind (k,
+|    | 499|+                                        Actions::Type::JumpToPositionInSong);
+|    | 500|+                                  if (notBound (k = stringToKey ("l")))
+|    | 501|+                                  bind (k, Actions::Type::ShowLyrics);
+|    | 502|+                                  if (notBound (k = stringToKey ("ctrl-v")))
+|    | 503|+                                  bind (k, Actions::Type::SelectRange);
+|    | 504|+                                  if (notBound (k = stringToKey ("v")))
+|    | 505|+                                  bind (k, Actions::Type::ReverseSelection);
+|    | 506|+                                  if (notBound (k = stringToKey ("V")))
+|    | 507|+                                  bind (k, Actions::Type::RemoveSelection);
+|    | 508|+                                  if (notBound (k = stringToKey ("B")))
+|    | 509|+                                  bind (k, Actions::Type::SelectAlbum);
+|    | 510|+                                  if (notBound (k = stringToKey ("a")))
+|    | 511|+                                  bind (k, Actions::Type::AddSelectedItems);
+|    | 512|+                                  if (notBound (k = stringToKey ("c")))
+|    | 513|+                                  {
+|    | 514|+                                  bind (k, Actions::Type::ClearPlaylist);
+|    | 515|+                                  bind (k, Actions::Type::ClearMainPlaylist);}
+|    | 516|+                                  if (notBound (k = stringToKey ("C")))
+|    | 517|+                                  {
+|    | 518|+                                  bind (k, Actions::Type::CropPlaylist);
+|    | 519|+                                  bind (k, Actions::Type::CropMainPlaylist);}
+|    | 520|+                                  if (notBound (k = stringToKey ("m")))
+|    | 521|+                                  {
+|    | 522|+                                  bind (k, Actions::Type::MoveSortOrderUp);
+|    | 523|+                                  bind (k,
+|    | 524|+                                        Actions::Type::MoveSelectedItemsUp);}
+|    | 525|+                                  if (notBound (k = stringToKey ("n")))
+|    | 526|+                                  {
+|    | 527|+                                  bind (k, Actions::Type::MoveSortOrderDown);
+|    | 528|+                                  bind (k,
+|    | 529|+                                        Actions::Type::MoveSelectedItemsDown);}
+|    | 530|+                                  if (notBound (k = stringToKey ("M")))
+|    | 531|+                                  bind (k, Actions::Type::MoveSelectedItemsTo);
+|    | 532|+                                  if (notBound (k = stringToKey ("A")))
+|    | 533|+                                  bind (k, Actions::Type::Add);
+|    | 534|+                                  if (notBound (k = stringToKey ("S")))
+|    | 535|+                                  bind (k, Actions::Type::SavePlaylist);
+|    | 536|+                                  if (notBound (k = stringToKey ("o")))
+|    | 537|+                                  bind (k, Actions::Type::JumpToPlayingSong);
+|    | 538|+                                  if (notBound (k = stringToKey ("G")))
+|    | 539|+                                  {
+|    | 540|+                                  bind (k, Actions::Type::JumpToBrowser);
+|    | 541|+                                  bind (k,
+|    | 542|+                                        Actions::Type::JumpToPlaylistEditor);}
+|    | 543|+                                  if (notBound (k = stringToKey ("~")))
+|    | 544|+                                  bind (k, Actions::Type::JumpToMediaLibrary);
+|    | 545|+                                  if (notBound (k = stringToKey ("E")))
+|    | 546|+                                  bind (k, Actions::Type::JumpToTagEditor);
+|    | 547|+                                  if (notBound (k = stringToKey ("U")))
+|    | 548|+                                  bind (k,
+|    | 549|+                                        Actions::Type::
+|    | 550|+                                        TogglePlayingSongCentering);
+|    | 551|+                                  if (notBound (k = stringToKey ("P")))
+|    | 552|+                                  bind (k, Actions::Type::ToggleDisplayMode);
+|    | 553|+                                  if (notBound (k = stringToKey ("\\")))
+|    | 554|+                                  bind (k, Actions::Type::ToggleInterface);
+|    | 555|+                                  if (notBound (k = stringToKey ("!")))
+|    | 556|+                                  bind (k,
+|    | 557|+                                        Actions::Type::
+|    | 558|+                                        ToggleSeparatorsBetweenAlbums);
+|    | 559|+                                  if (notBound (k = stringToKey ("L")))
+|    | 560|+                                  bind (k, Actions::Type::ToggleLyricsFetcher);
+|    | 561|+                                  if (notBound (k = stringToKey ("F")))
+|    | 562|+                                  bind (k,
+|    | 563|+                                        Actions::Type::
+|    | 564|+                                        FetchLyricsInBackground);
+|    | 565|+                                  if (notBound (k = stringToKey ("alt-l")))
+|    | 566|+                                  bind (k,
+|    | 567|+                                        Actions::Type::
+|    | 568|+                                        ToggleFetchingLyricsInBackground);
+|    | 569|+                                  if (notBound (k = stringToKey ("ctrl-l")))
+|    | 570|+                                  bind (k, Actions::Type::ToggleScreenLock);
+|    | 571|+                                  if (notBound (k = stringToKey ("`")))
+|    | 572|+                                  {
+|    | 573|+                                  bind (k,
+|    | 574|+                                        Actions::Type::ToggleLibraryTagType);
+|    | 575|+                                  bind (k, Actions::Type::RefetchLyrics);
+|    | 576|+                                  bind (k, Actions::Type::AddRandomItems);}
+|    | 577|+                                  if (notBound (k = stringToKey ("ctrl-p")))
+|    | 578|+                                  bind (k,
+|    | 579|+                                        Actions::Type::
+|    | 580|+                                        SetSelectedItemsPriority);
+|    | 581|+                                  if (notBound (k = stringToKey ("q")))
+|    | 582|+                                  bind (k, Actions::Type::Quit);}
+|    | 583|+
+|    | 584|+                                  const Command *
+|    | 585|+                                  BindingsConfiguration::
+|    | 586|+                                  findCommand (const std::string & name)
+|    | 587|+                                  {
+|    | 588|+                                  const Command * ptr = nullptr;
+|    | 589|+                                  auto it = m_commands.find (name);
+|    | 590|+                                  if (it != m_commands.end ())ptr =
+|    | 591|+                                  &it->second; return ptr;}
+|    | 592|+
+|    | 593|+                                  BindingsConfiguration::
+|    | 594|+                                  BindingIteratorPair BindingsConfiguration::
+|    | 595|+                                  get (const NC::Key::Type & k)
+|    | 596|+                                  {
+|    | 597|+                                  std::pair < BindingIterator,
+|    | 598|+                                  BindingIterator > result;
+|    | 599|+                                  auto it = m_bindings.find (k);
+|    | 600|+                                  if (it != m_bindings.end ())
+|    | 601|+                                  {
+|    | 602|+                                  result.first = it->second.begin ();
+|    | 603|+                                  result.second = it->second.end ();}
+|    | 604|+                                  else
+|    | 605|+                                  {
+|    | 606|+                                  auto list_end =
+|    | 607|+                                  m_bindings.begin ()->second.end ();
+|    | 608|+                                  result.first = list_end;
+|    | 609|+                                  result.second = list_end;}
+|    | 610|+                                  return result;}
+
+src/bindings.cpp
+|  29| BindingsConfiguration•Bindings;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'Bindings'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.h
+|    |++++| /app/src/screens/server_info.h
+|  26|  26| #include "interfaces.h"
+|  27|  27| #include "screens/screen.h"
+|  28|  28| 
+|  29|    |-struct ServerInfo: Screen<NC::Scrollpad>, Tabbable
+|    |  29|+struct ServerInfo:Screen <
+|    |  30|+    NC::Scrollpad >,
+|    |  31|+    Tabbable
+|  30|  32| {
+|  31|    |-	ServerInfo();
+|  32|    |-	
+|  33|    |-	// Screen<NC::Scrollpad> implementation
+|  34|    |-	virtual void switchTo() override;
+|  35|    |-	virtual void resize() override;
+|  36|    |-	
+|  37|    |-	virtual std::wstring title() override;
+|  38|    |-	virtual ScreenType type() override { return ScreenType::ServerInfo; }
+|  39|    |-	
+|  40|    |-	virtual void update() override;
+|  41|    |-	
+|  42|    |-	virtual bool isLockable() override { return false; }
+|  43|    |-	virtual bool isMergable() override { return false; }
+|  44|    |-	
+|  45|    |-private:
+|  46|    |-	void SetDimensions();
+|  47|    |-	
+|  48|    |-	boost::posix_time::ptime m_timer;
+|    |  33|+    ServerInfo ();
+|  49|  34| 
+|  50|    |-	std::vector<std::string> m_url_handlers;
+|  51|    |-	std::vector<std::string> m_tag_types;
+|  52|    |-	
+|  53|    |-	size_t m_width;
+|  54|    |-	size_t m_height;
+|    |  35|+    // Screen<NC::Scrollpad> implementation
+|    |  36|+    virtual void
+|    |  37|+    switchTo ()
+|    |  38|+        override;
+|    |  39|+    virtual void
+|    |  40|+    resize ()
+|    |  41|+        override;
+|    |  42|+
+|    |  43|+    virtual
+|    |  44|+        std::wstring
+|    |  45|+    title ()
+|    |  46|+        override;
+|    |  47|+    virtual ScreenType
+|    |  48|+    type ()
+|    |  49|+        override
+|    |  50|+    {
+|    |  51|+        return ScreenType::ServerInfo;
+|    |  52|+    }
+|    |  53|+
+|    |  54|+    virtual void
+|    |  55|+    update ()
+|    |  56|+        override;
+|    |  57|+
+|    |  58|+    virtual bool
+|    |  59|+    isLockable ()
+|    |  60|+        override
+|    |  61|+    {
+|    |  62|+        return false;
+|    |  63|+    }
+|    |  64|+    virtual bool
+|    |  65|+    isMergable ()
+|    |  66|+        override
+|    |  67|+    {
+|    |  68|+        return false;
+|    |  69|+    }
+|    |  70|+
+|    |  71|+  private:
+|    |  72|+    void
+|    |  73|+    SetDimensions ();
+|    |  74|+
+|    |  75|+    boost::posix_time::ptime m_timer;
+|    |  76|+
+|    |  77|+    std::vector < std::string > m_url_handlers;
+|    |  78|+    std::vector < std::string > m_tag_types;
+|    |  79|+
+|    |  80|+    size_t
+|    |  81|+        m_width;
+|    |  82|+    size_t
+|    |  83|+        m_height;
+|  55|  84| };
+|  56|  85| 
+|  57|  86| extern ServerInfo *myServerInfo;
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.h
+|    |++++| /app/src/screens/server_info.h
+|  54|  54| 	size_t m_height;
+|  55|  55| };
+|  56|  56| 
+|  57|    |-extern ServerInfo *myServerInfo;
+|    |  57|+extern ServerInfo *
+|    |  58|+    myServerInfo;
+|  58|  59| 
+|  59|  60| #endif // NCMPCPP_SERVER_INFO_H
+|  60|  61| 
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/server_info.h
+|    |++++| /app/src/screens/server_info.h
+|  57|  57| extern ServerInfo *myServerInfo;
+|  58|  58| 
+|  59|  59| #endif // NCMPCPP_SERVER_INFO_H
+|  60|    |-
+
+src/screens/server_info.h
+|  26| #include•"interfaces.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'interfaces.h'
+
+src/screens/server_info.h
+|  27| #include•"screens/screen.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen.h'
+
+src/screens/server_info.h
+|  57| extern•ServerInfo•*myServerInfo;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myServerInfo'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tiny_tag_editor.cpp
+|    |++++| /app/src/screens/tiny_tag_editor.cpp
+|  44|  44| #include "screens/screen_switcher.h"
+|  45|  45| #include "utility/string.h"
+|  46|  46| 
+|  47|    |-using Global::MainHeight;
+|  48|    |-using Global::MainStartY;
+|  49|    |-
+|  50|    |-TinyTagEditor *myTinyTagEditor;
+|  51|    |-
+|  52|    |-TinyTagEditor::TinyTagEditor()
+|  53|    |-: Screen(NC::Menu<NC::Buffer>(0, MainStartY, COLS, MainHeight, "", Config.main_color, NC::Border()))
+|  54|    |-{
+|  55|    |-	w.setHighlightPrefix(Config.current_item_prefix);
+|  56|    |-	w.setHighlightSuffix(Config.current_item_suffix);
+|  57|    |-	w.cyclicScrolling(Config.use_cyclic_scrolling);
+|  58|    |-	w.centeredCursor(Config.centered_cursor);
+|  59|    |-	w.setItemDisplayer([](NC::Menu<NC::Buffer> &menu) {
+|  60|    |-		menu << menu.drawn()->value();
+|  61|    |-	});
+|  62|    |-}
+|  63|    |-
+|  64|    |-void TinyTagEditor::resize()
+|  65|    |-{
+|  66|    |-	size_t x_offset, width;
+|  67|    |-	getWindowResizeParams(x_offset, width);
+|  68|    |-	w.resize(width, MainHeight);
+|  69|    |-	w.moveTo(x_offset, MainStartY);
+|  70|    |-	hasToBeResized = 0;
+|  71|    |-}
+|  72|    |-
+|  73|    |-void TinyTagEditor::switchTo()
+|  74|    |-{
+|  75|    |-	using Global::myScreen;
+|  76|    |-	if (itsEdited.isStream())
+|  77|    |-	{
+|  78|    |-		Statusbar::print("Streams can't be edited");
+|  79|    |-	}
+|  80|    |-	else if (getTags())
+|  81|    |-	{
+|  82|    |-		m_previous_screen = myScreen;
+|  83|    |-		SwitchTo::execute(this);
+|  84|    |-		drawHeader();
+|  85|    |-	}
+|  86|    |-	else
+|  87|    |-	{
+|  88|    |-		std::string full_path;
+|  89|    |-		if (itsEdited.isFromDatabase())
+|  90|    |-			full_path += Config.mpd_music_dir;
+|  91|    |-		full_path += itsEdited.getURI();
+|  92|    |-		
+|  93|    |-		const char msg[] = "Couldn't read file \"%1%\"";
+|  94|    |-		Statusbar::printf(msg, wideShorten(full_path, COLS-const_strlen(msg)));
+|  95|    |-	}
+|  96|    |-}
+|  97|    |-
+|  98|    |-std::wstring TinyTagEditor::title()
+|  99|    |-{
+| 100|    |-	return L"Tiny tag editor";
+| 101|    |-}
+| 102|    |-
+| 103|    |-void TinyTagEditor::mouseButtonPressed(MEVENT me)
+| 104|    |-{
+| 105|    |-	if (w.empty() || !w.hasCoords(me.x, me.y) || size_t(me.y) >= w.size())
+| 106|    |-		return;
+| 107|    |-	if (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED))
+| 108|    |-	{
+| 109|    |-		if (!w.Goto(me.y))
+| 110|    |-			return;
+| 111|    |-		if (me.bstate & BUTTON3_PRESSED)
+| 112|    |-		{
+| 113|    |-			w.refresh();
+| 114|    |-			runAction();
+| 115|    |-		}
+| 116|    |-	}
+| 117|    |-	else
+| 118|    |-		Screen<WindowType>::mouseButtonPressed(me);
+|    |  47|+using
+|    |  48|+    Global::MainHeight;
+|    |  49|+using
+|    |  50|+    Global::MainStartY;
+|    |  51|+
+|    |  52|+TinyTagEditor *
+|    |  53|+    myTinyTagEditor;
+|    |  54|+
+|    |  55|+TinyTagEditor::TinyTagEditor ():Screen (NC::Menu < NC::Buffer >
+|    |  56|+        (0, MainStartY, COLS, MainHeight, "", Config.main_color,
+|    |  57|+         NC::Border ()))
+|    |  58|+{
+|    |  59|+    w.setHighlightPrefix (Config.current_item_prefix);
+|    |  60|+    w.setHighlightSuffix (Config.current_item_suffix);
+|    |  61|+    w.cyclicScrolling (Config.use_cyclic_scrolling);
+|    |  62|+    w.centeredCursor (Config.centered_cursor);
+|    |  63|+    w.setItemDisplayer ([](NC::Menu < NC::Buffer > &menu)
+|    |  64|+                        {
+|    |  65|+                        menu << menu.drawn ()->value ();}
+|    |  66|+    );
+|    |  67|+}
+|    |  68|+
+|    |  69|+void
+|    |  70|+TinyTagEditor::resize ()
+|    |  71|+{
+|    |  72|+    size_t x_offset, width;
+|    |  73|+    getWindowResizeParams (x_offset, width);
+|    |  74|+    w.resize (width, MainHeight);
+|    |  75|+    w.moveTo (x_offset, MainStartY);
+|    |  76|+    hasToBeResized = 0;
+|    |  77|+}
+|    |  78|+
+|    |  79|+void
+|    |  80|+TinyTagEditor::switchTo ()
+|    |  81|+{
+|    |  82|+    using Global::myScreen;
+|    |  83|+    if (itsEdited.isStream ())
+|    |  84|+      {
+|    |  85|+          Statusbar::print ("Streams can't be edited");
+|    |  86|+      }
+|    |  87|+    else if (getTags ())
+|    |  88|+      {
+|    |  89|+          m_previous_screen = myScreen;
+|    |  90|+          SwitchTo::execute (this);
+|    |  91|+          drawHeader ();
+|    |  92|+      }
+|    |  93|+    else
+|    |  94|+      {
+|    |  95|+          std::string full_path;
+|    |  96|+          if (itsEdited.isFromDatabase ())
+|    |  97|+              full_path += Config.mpd_music_dir;
+|    |  98|+          full_path += itsEdited.getURI ();
+|    |  99|+
+|    | 100|+          const char msg[] = "Couldn't read file \"%1%\"";
+|    | 101|+          Statusbar::printf (msg,
+|    | 102|+                             wideShorten (full_path,
+|    | 103|+                                          COLS - const_strlen (msg)));
+|    | 104|+      }
+|    | 105|+}
+|    | 106|+
+|    | 107|+std::wstring TinyTagEditor::title ()
+|    | 108|+{
+|    | 109|+    return L"Tiny tag editor";
+|    | 110|+}
+|    | 111|+
+|    | 112|+void
+|    | 113|+TinyTagEditor::mouseButtonPressed (MEVENT me)
+|    | 114|+{
+|    | 115|+    if (w.empty () || !w.hasCoords (me.x, me.y) || size_t (me.y) >= w.size ())
+|    | 116|+        return;
+|    | 117|+    if (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED))
+|    | 118|+      {
+|    | 119|+          if (!w.Goto (me.y))
+|    | 120|+              return;
+|    | 121|+          if (me.bstate & BUTTON3_PRESSED)
+|    | 122|+            {
+|    | 123|+                w.refresh ();
+|    | 124|+                runAction ();
+|    | 125|+            }
+|    | 126|+      }
+|    | 127|+    else
+|    | 128|+        Screen < WindowType >::mouseButtonPressed (me);
+| 119| 129| }
+| 120| 130| 
+| 121| 131| /**********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tiny_tag_editor.cpp
+|    |++++| /app/src/screens/tiny_tag_editor.cpp
+| 120| 120| 
+| 121| 121| /**********************************************************************/
+| 122| 122| 
+| 123|    |-bool TinyTagEditor::actionRunnable()
+| 124|    |-{
+| 125|    |-	return !w.empty();
+| 126|    |-}
+| 127|    |-
+| 128|    |-void TinyTagEditor::runAction()
+| 129|    |-{
+| 130|    |-	size_t option = w.choice();
+| 131|    |-	if (option < 19) // separator after comment
+| 132|    |-	{
+| 133|    |-		Statusbar::ScopedLock slock;
+| 134|    |-		size_t pos = option-8;
+| 135|    |-		Statusbar::put() << NC::Format::Bold << SongInfo::Tags[pos].Name << ": " << NC::Format::NoBold;
+| 136|    |-		itsEdited.setTags(SongInfo::Tags[pos].Set, Global::wFooter->prompt(
+| 137|    |-			itsEdited.getTags(SongInfo::Tags[pos].Get)));
+| 138|    |-		w.at(option).value().clear();
+| 139|    |-		w.at(option).value() << NC::Format::Bold << SongInfo::Tags[pos].Name << ':' << NC::Format::NoBold << ' ';
+| 140|    |-		ShowTag(w.at(option).value(), itsEdited.getTags(SongInfo::Tags[pos].Get));
+| 141|    |-	}
+| 142|    |-	else if (option == 20)
+| 143|    |-	{
+| 144|    |-		Statusbar::ScopedLock slock;
+| 145|    |-		Statusbar::put() << NC::Format::Bold << "Filename: " << NC::Format::NoBold;
+| 146|    |-		std::string filename = itsEdited.getNewName().empty() ? itsEdited.getName() : itsEdited.getNewName();
+| 147|    |-		size_t dot = filename.rfind(".");
+| 148|    |-		std::string extension = filename.substr(dot);
+| 149|    |-		filename = filename.substr(0, dot);
+| 150|    |-		std::string new_name = Global::wFooter->prompt(filename);
+| 151|    |-		if (!new_name.empty())
+| 152|    |-		{
+| 153|    |-			itsEdited.setNewName(new_name + extension);
+| 154|    |-			w.at(option).value().clear();
+| 155|    |-			w.at(option).value() << NC::Format::Bold << "Filename:" << NC::Format::NoBold << ' ' << (itsEdited.getNewName().empty() ? itsEdited.getName() : itsEdited.getNewName());
+| 156|    |-		}
+| 157|    |-	}
+| 158|    |-
+| 159|    |-	if (option == 22)
+| 160|    |-	{
+| 161|    |-		Statusbar::print("Updating tags...");
+| 162|    |-		if (Tags::write(itsEdited))
+| 163|    |-		{
+| 164|    |-			Statusbar::print("Tags updated");
+| 165|    |-			if (itsEdited.isFromDatabase())
+| 166|    |-				Mpd.UpdateDirectory(itsEdited.getDirectory());
+| 167|    |-			else
+| 168|    |-			{
+| 169|    |-				if (m_previous_screen == myPlaylist)
+| 170|    |-					myPlaylist->main().current()->value() = itsEdited;
+| 171|    |-				else if (m_previous_screen == myBrowser)
+| 172|    |-					myBrowser->requestUpdate();
+| 173|    |-			}
+| 174|    |-		}
+| 175|    |-		else
+| 176|    |-			Statusbar::printf("Error while writing tags: %1%", strerror(errno));
+| 177|    |-	}
+| 178|    |-	if (option > 21)
+| 179|    |-		m_previous_screen->switchTo();
+|    | 123|+bool
+|    | 124|+TinyTagEditor::actionRunnable ()
+|    | 125|+{
+|    | 126|+    return !w.empty ();
+|    | 127|+}
+|    | 128|+
+|    | 129|+void
+|    | 130|+TinyTagEditor::runAction ()
+|    | 131|+{
+|    | 132|+    size_t option = w.choice ();
+|    | 133|+    if (option < 19)            // separator after comment
+|    | 134|+      {
+|    | 135|+          Statusbar::ScopedLock slock;
+|    | 136|+          size_t pos = option - 8;
+|    | 137|+          Statusbar::put () << NC::Format::Bold << SongInfo::Tags[pos].
+|    | 138|+              Name << ": " << NC::Format::NoBold;
+|    | 139|+          itsEdited.setTags (SongInfo::Tags[pos].Set,
+|    | 140|+                             Global::wFooter->prompt (itsEdited.
+|    | 141|+                                                      getTags (SongInfo::
+|    | 142|+                                                               Tags[pos].
+|    | 143|+                                                               Get)));
+|    | 144|+          w.at (option).value ().clear ();
+|    | 145|+          w.at (option).value () << NC::Format::Bold << SongInfo::Tags[pos].
+|    | 146|+              Name << ':' << NC::Format::NoBold << ' ';
+|    | 147|+          ShowTag (w.at (option).value (),
+|    | 148|+                   itsEdited.getTags (SongInfo::Tags[pos].Get));
+|    | 149|+      }
+|    | 150|+    else if (option == 20)
+|    | 151|+      {
+|    | 152|+          Statusbar::ScopedLock slock;
+|    | 153|+          Statusbar::put () << NC::Format::Bold << "Filename: " << NC::Format::
+|    | 154|+              NoBold;
+|    | 155|+          std::string filename =
+|    | 156|+              itsEdited.getNewName ().empty ()? itsEdited.
+|    | 157|+              getName () : itsEdited.getNewName ();
+|    | 158|+          size_t dot = filename.rfind (".");
+|    | 159|+          std::string extension = filename.substr (dot);
+|    | 160|+          filename = filename.substr (0, dot);
+|    | 161|+          std::string new_name = Global::wFooter->prompt (filename);
+|    | 162|+          if (!new_name.empty ())
+|    | 163|+            {
+|    | 164|+                itsEdited.setNewName (new_name + extension);
+|    | 165|+                w.at (option).value ().clear ();
+|    | 166|+                w.at (option).
+|    | 167|+                    value () << NC::Format::Bold << "Filename:" << NC::Format::
+|    | 168|+                    NoBold << ' ' << (itsEdited.getNewName ().
+|    | 169|+                                      empty ()? itsEdited.
+|    | 170|+                                      getName () : itsEdited.getNewName ());
+|    | 171|+            }
+|    | 172|+      }
+|    | 173|+
+|    | 174|+    if (option == 22)
+|    | 175|+      {
+|    | 176|+          Statusbar::print ("Updating tags...");
+|    | 177|+          if (Tags::write (itsEdited))
+|    | 178|+            {
+|    | 179|+                Statusbar::print ("Tags updated");
+|    | 180|+                if (itsEdited.isFromDatabase ())
+|    | 181|+                    Mpd.UpdateDirectory (itsEdited.getDirectory ());
+|    | 182|+                else
+|    | 183|+                  {
+|    | 184|+                      if (m_previous_screen == myPlaylist)
+|    | 185|+                          myPlaylist->main ().current ()->value () = itsEdited;
+|    | 186|+                      else if (m_previous_screen == myBrowser)
+|    | 187|+                          myBrowser->requestUpdate ();
+|    | 188|+                  }
+|    | 189|+            }
+|    | 190|+          else
+|    | 191|+              Statusbar::printf ("Error while writing tags: %1%",
+|    | 192|+                                 strerror (errno));
+|    | 193|+      }
+|    | 194|+    if (option > 21)
+|    | 195|+        m_previous_screen->switchTo ();
+| 180| 196| }
+| 181| 197| 
+| 182| 198| /**********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tiny_tag_editor.cpp
+|    |++++| /app/src/screens/tiny_tag_editor.cpp
+| 181| 181| 
+| 182| 182| /**********************************************************************/
+| 183| 183| 
+| 184|    |-void TinyTagEditor::SetEdited(const MPD::Song &s)
+| 185|    |-{
+| 186|    |-	if (auto ms = dynamic_cast<const MPD::MutableSong *>(&s))
+| 187|    |-		itsEdited = *ms;
+| 188|    |-	else
+| 189|    |-		itsEdited = s;
+| 190|    |-}
+| 191|    |-
+| 192|    |-bool TinyTagEditor::getTags()
+| 193|    |-{
+| 194|    |-	std::string path_to_file;
+| 195|    |-	if (itsEdited.isFromDatabase())
+| 196|    |-		path_to_file += Config.mpd_music_dir;
+| 197|    |-	path_to_file += itsEdited.getURI();
+| 198|    |-	
+| 199|    |-	TagLib::FileRef f(path_to_file.c_str());
+| 200|    |-	if (f.isNull())
+| 201|    |-		return false;
+| 202|    |-	
+| 203|    |-	std::string ext = itsEdited.getURI();
+| 204|    |-	ext = boost::locale::to_lower(ext.substr(ext.rfind(".")+1));
+| 205|    |-	
+| 206|    |-	w.clear();
+| 207|    |-	w.reset();
+| 208|    |-	
+| 209|    |-	w.resizeList(24);
+| 210|    |-	
+| 211|    |-	for (size_t i = 0; i < 7; ++i)
+| 212|    |-		w[i].setInactive(true);
+| 213|    |-	
+| 214|    |-	w[7].setSeparator(true);
+| 215|    |-	w[19].setSeparator(true);
+| 216|    |-	w[21].setSeparator(true);
+| 217|    |-	
+| 218|    |-	if (!Tags::extendedSetSupported(f.file()))
+| 219|    |-	{
+| 220|    |-		w[10].setInactive(true);
+| 221|    |-		for (size_t i = 15; i <= 17; ++i)
+| 222|    |-			w[i].setInactive(true);
+| 223|    |-	}
+| 224|    |-	
+| 225|    |-	w.highlight(8);
+| 226|    |-
+| 227|    |-	auto print_key_value = [this](NC::Buffer &buf, const char *key, const auto &value) {
+| 228|    |-		buf << NC::Format::Bold
+| 229|    |-		    << Config.color1
+| 230|    |-		    << key
+| 231|    |-		    << ":"
+| 232|    |-		    << NC::FormattedColor::End<>(Config.color1)
+| 233|    |-		    << NC::Format::NoBold
+| 234|    |-		    << " "
+| 235|    |-		    << Config.color2
+| 236|    |-		    << value
+| 237|    |-		    << NC::FormattedColor::End<>(Config.color2);
+| 238|    |-	};
+| 239|    |-
+| 240|    |-	print_key_value(w[0].value(), "Filename", itsEdited.getName());
+| 241|    |-	print_key_value(w[1].value(), "Directory", ShowTag(itsEdited.getDirectory()));
+| 242|    |-	print_key_value(w[3].value(), "Length", itsEdited.getLength());
+| 243|    |-	print_key_value(
+| 244|    |-		w[4].value(),
+| 245|    |-		"Bitrate",
+| 246|    |-		boost::lexical_cast<std::string>(f.audioProperties()->bitrate()) + " kbps");
+| 247|    |-	print_key_value(
+| 248|    |-		w[5].value(),
+| 249|    |-		"Sample rate",
+| 250|    |-		boost::lexical_cast<std::string>(f.audioProperties()->sampleRate()) + " Hz");
+| 251|    |-	print_key_value(
+| 252|    |-		w[6].value(),
+| 253|    |-		"Channels",
+| 254|    |-		channelsToString(f.audioProperties()->channels()));
+| 255|    |-	
+| 256|    |-	unsigned pos = 8;
+| 257|    |-	for (const SongInfo::Metadata *m = SongInfo::Tags; m->Name; ++m, ++pos)
+| 258|    |-	{
+| 259|    |-		w[pos].value() << NC::Format::Bold
+| 260|    |-		                  << m->Name
+| 261|    |-		                  << ":"
+| 262|    |-		                  << NC::Format::NoBold
+| 263|    |-		                  << " ";
+| 264|    |-		ShowTag(w[pos].value(), itsEdited.getTags(m->Get));
+| 265|    |-	}
+| 266|    |-	
+| 267|    |-	w[20].value() << NC::Format::Bold
+| 268|    |-	                 << "Filename:"
+| 269|    |-	                 << NC::Format::NoBold
+| 270|    |-	                 << " "
+| 271|    |-	                 << itsEdited.getName();
+| 272|    |-	
+| 273|    |-	w[22].value() << "Save";
+| 274|    |-	w[23].value() << "Cancel";
+| 275|    |-	return true;
+|    | 184|+void
+|    | 185|+TinyTagEditor::SetEdited (const MPD::Song & s)
+|    | 186|+{
+|    | 187|+    if (auto ms = dynamic_cast < const MPD::MutableSong * >(&s))
+|    | 188|+        itsEdited = *ms;
+|    | 189|+    else
+|    | 190|+        itsEdited = s;
+|    | 191|+}
+|    | 192|+
+|    | 193|+bool
+|    | 194|+TinyTagEditor::getTags ()
+|    | 195|+{
+|    | 196|+    std::string path_to_file;
+|    | 197|+    if (itsEdited.isFromDatabase ())
+|    | 198|+        path_to_file += Config.mpd_music_dir;
+|    | 199|+    path_to_file += itsEdited.getURI ();
+|    | 200|+
+|    | 201|+    TagLib::FileRef f (path_to_file.c_str ());
+|    | 202|+    if (f.isNull ())
+|    | 203|+        return false;
+|    | 204|+
+|    | 205|+    std::string ext = itsEdited.getURI ();
+|    | 206|+    ext = boost::locale::to_lower (ext.substr (ext.rfind (".") + 1));
+|    | 207|+
+|    | 208|+    w.clear ();
+|    | 209|+    w.reset ();
+|    | 210|+
+|    | 211|+    w.resizeList (24);
+|    | 212|+
+|    | 213|+    for (size_t i = 0; i < 7; ++i)
+|    | 214|+        w[i].setInactive (true);
+|    | 215|+
+|    | 216|+    w[7].setSeparator (true);
+|    | 217|+    w[19].setSeparator (true);
+|    | 218|+    w[21].setSeparator (true);
+|    | 219|+
+|    | 220|+    if (!Tags::extendedSetSupported (f.file ()))
+|    | 221|+      {
+|    | 222|+          w[10].setInactive (true);
+|    | 223|+          for (size_t i = 15; i <= 17; ++i)
+|    | 224|+              w[i].setInactive (true);
+|    | 225|+      }
+|    | 226|+
+|    | 227|+    w.highlight (8);
+|    | 228|+
+|    | 229|+    auto print_key_value =
+|    | 230|+        [this] (NC::Buffer & buf, const char *key, const auto & value) {
+|    | 231|+        buf << NC::Format::Bold << Config.
+|    | 232|+            color1 << key << ":" << NC::FormattedColor::End <> (Config.
+|    | 233|+                                                                color1) << NC::
+|    | 234|+            Format::NoBold << " " << Config.
+|    | 235|+            color2 << value << NC::FormattedColor::End <> (Config.color2);
+|    | 236|+    };
+|    | 237|+
+|    | 238|+    print_key_value (w[0].value (), "Filename", itsEdited.getName ());
+|    | 239|+    print_key_value (w[1].value (), "Directory",
+|    | 240|+                     ShowTag (itsEdited.getDirectory ()));
+|    | 241|+    print_key_value (w[3].value (), "Length", itsEdited.getLength ());
+|    | 242|+    print_key_value (w[4].value (),
+|    | 243|+                     "Bitrate",
+|    | 244|+                     boost::lexical_cast < std::string >
+|    | 245|+                     (f.audioProperties ()->bitrate ()) + " kbps");
+|    | 246|+    print_key_value (w[5].value (), "Sample rate",
+|    | 247|+                     boost::lexical_cast < std::string >
+|    | 248|+                     (f.audioProperties ()->sampleRate ()) + " Hz");
+|    | 249|+    print_key_value (w[6].value (), "Channels",
+|    | 250|+                     channelsToString (f.audioProperties ()->channels ()));
+|    | 251|+
+|    | 252|+    unsigned pos = 8;
+|    | 253|+    for (const SongInfo::Metadata * m = SongInfo::Tags; m->Name; ++m, ++pos)
+|    | 254|+      {
+|    | 255|+          w[pos].value () << NC::Format::Bold
+|    | 256|+              << m->Name << ":" << NC::Format::NoBold << " ";
+|    | 257|+          ShowTag (w[pos].value (), itsEdited.getTags (m->Get));
+|    | 258|+      }
+|    | 259|+
+|    | 260|+    w[20].value () << NC::Format::Bold
+|    | 261|+        << "Filename:" << NC::Format::NoBold << " " << itsEdited.getName ();
+|    | 262|+
+|    | 263|+    w[22].value () << "Save";
+|    | 264|+    w[23].value () << "Cancel";
+|    | 265|+    return true;
+| 276| 266| }
+| 277| 267| 
+| 278| 268| #endif // HAVE_TAGLIB_H
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/tiny_tag_editor.cpp
+|    |++++| /app/src/screens/tiny_tag_editor.cpp
+| 276| 276| }
+| 277| 277| 
+| 278| 278| #endif // HAVE_TAGLIB_H
+| 279|    |-
+
+src/screens/tiny_tag_editor.cpp
+|  21| #include•"screens/tiny_tag_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/tiny_tag_editor.h'
+
+src/screens/tiny_tag_editor.cpp
+|  31| #include•"curses/menu_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/menu_impl.h'
+
+src/screens/tiny_tag_editor.cpp
+|  32| #include•"screens/browser.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/browser.h'
+
+src/screens/tiny_tag_editor.cpp
+|  33| #include•"charset.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'charset.h'
+
+src/screens/tiny_tag_editor.cpp
+|  34| #include•"display.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'display.h'
+
+src/screens/tiny_tag_editor.cpp
+|  35| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/tiny_tag_editor.cpp
+|  36| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/tiny_tag_editor.cpp
+|  37| #include•"screens/song_info.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/song_info.h'
+
+src/screens/tiny_tag_editor.cpp
+|  38| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist.h'
+
+src/screens/tiny_tag_editor.cpp
+|  39| #include•"screens/search_engine.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/search_engine.h'
+
+src/screens/tiny_tag_editor.cpp
+|  40| #include•"statusbar.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'statusbar.h'
+
+src/screens/tiny_tag_editor.cpp
+|  41| #include•"screens/tag_editor.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/tag_editor.h'
+
+src/screens/tiny_tag_editor.cpp
+|  42| #include•"title.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'title.h'
+
+src/screens/tiny_tag_editor.cpp
+|  43| #include•"tags.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'tags.h'
+
+src/screens/tiny_tag_editor.cpp
+|  44| #include•"screens/screen_switcher.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/screen_switcher.h'
+
+src/screens/tiny_tag_editor.cpp
+|  45| #include•"utility/string.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'utility/string.h'
+
+src/screens/tiny_tag_editor.cpp
+|  50| TinyTagEditor•*myTinyTagEditor;
+|    | [NORMAL] CPPCleanBear:
+|    | static data 'myTinyTagEditor'
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist.cpp
+|    |++++| /app/src/screens/playlist.cpp
+|  37|  37| #include "utility/functional.h"
+|  38|  38| #include "title.h"
+|  39|  39| 
+|  40|    |-using Global::MainHeight;
+|  41|    |-using Global::MainStartY;
+|  42|    |-
+|  43|    |-namespace ph = std::placeholders;
+|  44|    |-
+|  45|    |-Playlist *myPlaylist;
+|  46|    |-
+|  47|    |-namespace {
+|  48|    |-
+|  49|    |-std::string songToString(const MPD::Song &s);
+|  50|    |-bool playlistEntryMatcher(const Regex::Regex &rx, const MPD::Song &s);
+|  51|    |-
+|  52|    |-}
+|  53|    |-
+|  54|    |-Playlist::Playlist()
+|  55|    |-: m_total_length(0), m_remaining_time(0), m_scroll_begin(0)
+|  56|    |-, m_timer(boost::posix_time::from_time_t(0))
+|  57|    |-, m_reload_total_length(false), m_reload_remaining(false)
+|  58|    |-{
+|  59|    |-	w = NC::Menu<MPD::Song>(0, MainStartY, COLS, MainHeight, Config.playlist_display_mode == DisplayMode::Columns && Config.titles_visibility ? Display::Columns(COLS) : "", Config.main_color, NC::Border());
+|  60|    |-	w.cyclicScrolling(Config.use_cyclic_scrolling);
+|  61|    |-	w.centeredCursor(Config.centered_cursor);
+|  62|    |-	setHighlightFixes(w);
+|  63|    |-	w.setSelectedPrefix(Config.selected_item_prefix);
+|  64|    |-	w.setSelectedSuffix(Config.selected_item_suffix);
+|  65|    |-	switch (Config.playlist_display_mode)
+|  66|    |-	{
+|  67|    |-		case DisplayMode::Classic:
+|  68|    |-			w.setItemDisplayer(std::bind(
+|  69|    |-				Display::Songs, ph::_1, std::cref(w), std::cref(Config.song_list_format)
+|  70|    |-			));
+|  71|    |-			break;
+|  72|    |-		case DisplayMode::Columns:
+|  73|    |-			w.setItemDisplayer(std::bind(
+|  74|    |-				Display::SongsInColumns, ph::_1, std::cref(w)
+|  75|    |-			));
+|  76|    |-			break;
+|  77|    |-	}
+|  78|    |-}
+|  79|    |-
+|  80|    |-void Playlist::switchTo()
+|  81|    |-{
+|  82|    |-	SwitchTo::execute(this);
+|  83|    |-	m_scroll_begin = 0;
+|  84|    |-	drawHeader();
+|  85|    |-}
+|  86|    |-
+|  87|    |-void Playlist::resize()
+|  88|    |-{
+|  89|    |-	size_t x_offset, width;
+|  90|    |-	getWindowResizeParams(x_offset, width);
+|  91|    |-	w.resize(width, MainHeight);
+|  92|    |-	w.moveTo(x_offset, MainStartY);
+|  93|    |-
+|  94|    |-	switch (Config.playlist_display_mode)
+|  95|    |-	{
+|  96|    |-		case DisplayMode::Columns:
+|  97|    |-			if (Config.titles_visibility)
+|  98|    |-			{
+|  99|    |-				w.setTitle(Display::Columns(w.getWidth()));
+| 100|    |-				break;
+| 101|    |-			}
+| 102|    |-		case DisplayMode::Classic:
+| 103|    |-			w.setTitle("");
+| 104|    |-	}
+| 105|    |-
+| 106|    |-	hasToBeResized = 0;
+| 107|    |-}
+| 108|    |-
+| 109|    |-std::wstring Playlist::title()
+| 110|    |-{
+| 111|    |-	std::wstring result = L"Playlist ";
+| 112|    |-	if (Config.playlist_show_mpd_host)
+| 113|    |-	{
+| 114|    |-		result += L"on ";
+| 115|    |-		result += ToWString(Mpd.GetHostname());
+| 116|    |-		result += L" ";
+| 117|    |-	}
+| 118|    |-	if (m_reload_total_length || m_reload_remaining)
+| 119|    |-		m_stats = getTotalLength();
+| 120|    |-	result += Scroller(ToWString(m_stats), m_scroll_begin, COLS-result.length()-(Config.design == Design::Alternative ? 2 : Global::VolumeState.length()));
+| 121|    |-	return result;
+| 122|    |-}
+| 123|    |-
+| 124|    |-void Playlist::update()
+| 125|    |-{
+| 126|    |-	if (w.isHighlighted()
+| 127|    |-	&&  Config.playlist_disable_highlight_delay.time_duration::seconds() > 0
+| 128|    |-	&&  Global::Timer - m_timer > Config.playlist_disable_highlight_delay)
+| 129|    |-	{
+| 130|    |-		w.setHighlighting(false);
+| 131|    |-		w.refresh();
+| 132|    |-	}
+| 133|    |-}
+| 134|    |-
+| 135|    |-void Playlist::mouseButtonPressed(MEVENT me)
+| 136|    |-{
+| 137|    |-	if (!w.empty() && w.hasCoords(me.x, me.y))
+| 138|    |-	{
+| 139|    |-		if (size_t(me.y) < w.size() && (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED)))
+| 140|    |-		{
+| 141|    |-			w.Goto(me.y);
+| 142|    |-			if (me.bstate & BUTTON3_PRESSED)
+| 143|    |-				addItemToPlaylist(true);
+| 144|    |-		}
+| 145|    |-		else
+| 146|    |-			Screen<WindowType>::mouseButtonPressed(me);
+| 147|    |-	}
+|    |  40|+using
+|    |  41|+    Global::MainHeight;
+|    |  42|+using
+|    |  43|+    Global::MainStartY;
+|    |  44|+
+|    |  45|+namespace
+|    |  46|+    ph = std::placeholders;
+|    |  47|+
+|    |  48|+Playlist *
+|    |  49|+    myPlaylist;
+|    |  50|+
+|    |  51|+namespace
+|    |  52|+{
+|    |  53|+
+|    |  54|+    std::string songToString (const MPD::Song & s);
+|    |  55|+    bool
+|    |  56|+    playlistEntryMatcher (const Regex::Regex & rx, const MPD::Song & s);
+|    |  57|+
+|    |  58|+}
+|    |  59|+
+|    |  60|+Playlist::Playlist ():m_total_length (0), m_remaining_time (0), m_scroll_begin (0),
+|    |  61|+m_timer (boost::posix_time::from_time_t (0)), m_reload_total_length (false),
+|    |  62|+m_reload_remaining (false)
+|    |  63|+{
+|    |  64|+    w = NC::Menu < MPD::Song > (0, MainStartY, COLS, MainHeight,
+|    |  65|+                                Config.playlist_display_mode ==
+|    |  66|+                                DisplayMode::Columns
+|    |  67|+                                && Config.
+|    |  68|+                                titles_visibility ? Display::
+|    |  69|+                                Columns (COLS) : "", Config.main_color,
+|    |  70|+                                NC::Border ());
+|    |  71|+    w.cyclicScrolling (Config.use_cyclic_scrolling);
+|    |  72|+    w.centeredCursor (Config.centered_cursor);
+|    |  73|+    setHighlightFixes (w);
+|    |  74|+    w.setSelectedPrefix (Config.selected_item_prefix);
+|    |  75|+    w.setSelectedSuffix (Config.selected_item_suffix);
+|    |  76|+    switch (Config.playlist_display_mode)
+|    |  77|+      {
+|    |  78|+      case DisplayMode::Classic:
+|    |  79|+          w.setItemDisplayer (std::
+|    |  80|+                              bind (Display::Songs, ph::_1, std::cref (w),
+|    |  81|+                                    std::cref (Config.song_list_format)));
+|    |  82|+          break;
+|    |  83|+      case DisplayMode::Columns:
+|    |  84|+          w.setItemDisplayer (std::
+|    |  85|+                              bind (Display::SongsInColumns, ph::_1,
+|    |  86|+                                    std::cref (w)));
+|    |  87|+          break;
+|    |  88|+      }
+|    |  89|+}
+|    |  90|+
+|    |  91|+void
+|    |  92|+Playlist::switchTo ()
+|    |  93|+{
+|    |  94|+    SwitchTo::execute (this);
+|    |  95|+    m_scroll_begin = 0;
+|    |  96|+    drawHeader ();
+|    |  97|+}
+|    |  98|+
+|    |  99|+void
+|    | 100|+Playlist::resize ()
+|    | 101|+{
+|    | 102|+    size_t x_offset, width;
+|    | 103|+    getWindowResizeParams (x_offset, width);
+|    | 104|+    w.resize (width, MainHeight);
+|    | 105|+    w.moveTo (x_offset, MainStartY);
+|    | 106|+
+|    | 107|+    switch (Config.playlist_display_mode)
+|    | 108|+      {
+|    | 109|+      case DisplayMode::Columns:
+|    | 110|+          if (Config.titles_visibility)
+|    | 111|+            {
+|    | 112|+                w.setTitle (Display::Columns (w.getWidth ()));
+|    | 113|+                break;
+|    | 114|+            }
+|    | 115|+      case DisplayMode::Classic:
+|    | 116|+          w.setTitle ("");
+|    | 117|+      }
+|    | 118|+
+|    | 119|+    hasToBeResized = 0;
+|    | 120|+}
+|    | 121|+
+|    | 122|+std::wstring Playlist::title ()
+|    | 123|+{
+|    | 124|+    std::wstring result = L"Playlist ";
+|    | 125|+    if (Config.playlist_show_mpd_host)
+|    | 126|+      {
+|    | 127|+          result += L"on ";
+|    | 128|+          result += ToWString (Mpd.GetHostname ());
+|    | 129|+          result += L" ";
+|    | 130|+      }
+|    | 131|+    if (m_reload_total_length || m_reload_remaining)
+|    | 132|+        m_stats = getTotalLength ();
+|    | 133|+    result +=
+|    | 134|+        Scroller (ToWString (m_stats), m_scroll_begin,
+|    | 135|+                  COLS - result.length () - (Config.design ==
+|    | 136|+                                             Design::Alternative ? 2 : Global::
+|    | 137|+                                             VolumeState.length ()));
+|    | 138|+    return result;
+|    | 139|+}
+|    | 140|+
+|    | 141|+void
+|    | 142|+Playlist::update ()
+|    | 143|+{
+|    | 144|+    if (w.isHighlighted ()
+|    | 145|+        && Config.playlist_disable_highlight_delay.time_duration::seconds () >
+|    | 146|+        0 && Global::Timer - m_timer > Config.playlist_disable_highlight_delay)
+|    | 147|+      {
+|    | 148|+          w.setHighlighting (false);
+|    | 149|+          w.refresh ();
+|    | 150|+      }
+|    | 151|+}
+|    | 152|+
+|    | 153|+void
+|    | 154|+Playlist::mouseButtonPressed (MEVENT me)
+|    | 155|+{
+|    | 156|+    if (!w.empty () && w.hasCoords (me.x, me.y))
+|    | 157|+      {
+|    | 158|+          if (size_t (me.y) < w.size ()
+|    | 159|+              && (me.bstate & (BUTTON1_PRESSED | BUTTON3_PRESSED)))
+|    | 160|+            {
+|    | 161|+                w.Goto (me.y);
+|    | 162|+                if (me.bstate & BUTTON3_PRESSED)
+|    | 163|+                    addItemToPlaylist (true);
+|    | 164|+            }
+|    | 165|+          else
+|    | 166|+              Screen < WindowType >::mouseButtonPressed (me);
+|    | 167|+      }
+| 148| 168| }
+| 149| 169| 
+| 150| 170| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist.cpp
+|    |++++| /app/src/screens/playlist.cpp
+| 149| 149| 
+| 150| 150| /***********************************************************************/
+| 151| 151| 
+| 152|    |-bool Playlist::allowsSearching()
+| 153|    |-{
+| 154|    |-	return true;
+| 155|    |-}
+| 156|    |-
+| 157|    |-const std::string &Playlist::searchConstraint()
+| 158|    |-{
+| 159|    |-	return m_search_predicate.constraint();
+| 160|    |-}
+| 161|    |-
+| 162|    |-void Playlist::setSearchConstraint(const std::string &constraint)
+| 163|    |-{
+| 164|    |-	m_search_predicate = Regex::Filter<MPD::Song>(
+| 165|    |-		constraint,
+| 166|    |-		Config.regex_type,
+| 167|    |-		playlistEntryMatcher);
+| 168|    |-}
+| 169|    |-
+| 170|    |-void Playlist::clearSearchConstraint()
+| 171|    |-{
+| 172|    |-	m_search_predicate.clear();
+| 173|    |-}
+| 174|    |-
+| 175|    |-bool Playlist::search(SearchDirection direction, bool wrap, bool skip_current)
+| 176|    |-{
+| 177|    |-	return ::search(w, m_search_predicate, direction, wrap, skip_current);
+|    | 152|+bool
+|    | 153|+Playlist::allowsSearching ()
+|    | 154|+{
+|    | 155|+    return true;
+|    | 156|+}
+|    | 157|+
+|    | 158|+const
+|    | 159|+    std::string &
+|    | 160|+Playlist::searchConstraint ()
+|    | 161|+{
+|    | 162|+    return m_search_predicate.constraint ();
+|    | 163|+}
+|    | 164|+
+|    | 165|+void
+|    | 166|+Playlist::setSearchConstraint (const std::string & constraint)
+|    | 167|+{
+|    | 168|+    m_search_predicate = Regex::Filter < MPD::Song > (constraint,
+|    | 169|+                                                      Config.regex_type,
+|    | 170|+                                                      playlistEntryMatcher);
+|    | 171|+}
+|    | 172|+
+|    | 173|+void
+|    | 174|+Playlist::clearSearchConstraint ()
+|    | 175|+{
+|    | 176|+    m_search_predicate.clear ();
+|    | 177|+}
+|    | 178|+
+|    | 179|+bool
+|    | 180|+Playlist::search (SearchDirection direction, bool wrap, bool skip_current)
+|    | 181|+{
+|    | 182|+    return::search (w, m_search_predicate, direction, wrap, skip_current);
+| 178| 183| }
+| 179| 184| 
+| 180| 185| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist.cpp
+|    |++++| /app/src/screens/playlist.cpp
+| 179| 179| 
+| 180| 180| /***********************************************************************/
+| 181| 181| 
+| 182|    |-bool Playlist::allowsFiltering()
+| 183|    |-{
+| 184|    |-	return allowsSearching();
+| 185|    |-}
+| 186|    |-
+| 187|    |-std::string Playlist::currentFilter()
+| 188|    |-{
+| 189|    |-	std::string result;
+| 190|    |-	if (auto pred = w.filterPredicate<Regex::Filter<MPD::Song>>())
+| 191|    |-		result = pred->constraint();
+| 192|    |-	return result;
+| 193|    |-}
+| 194|    |-
+| 195|    |-void Playlist::applyFilter(const std::string &constraint)
+| 196|    |-{
+| 197|    |-	if (!constraint.empty())
+| 198|    |-	{
+| 199|    |-		w.applyFilter(Regex::Filter<MPD::Song>(
+| 200|    |-			              constraint,
+| 201|    |-			              Config.regex_type,
+| 202|    |-			              playlistEntryMatcher));
+| 203|    |-	}
+| 204|    |-	else
+| 205|    |-		w.clearFilter();
+|    | 182|+bool
+|    | 183|+Playlist::allowsFiltering ()
+|    | 184|+{
+|    | 185|+    return allowsSearching ();
+|    | 186|+}
+|    | 187|+
+|    | 188|+std::string Playlist::currentFilter ()
+|    | 189|+{
+|    | 190|+    std::string result;
+|    | 191|+    if (auto pred = w.filterPredicate < Regex::Filter < MPD::Song >> ())
+|    | 192|+        result = pred->constraint ();
+|    | 193|+    return result;
+|    | 194|+}
+|    | 195|+
+|    | 196|+void
+|    | 197|+Playlist::applyFilter (const std::string & constraint)
+|    | 198|+{
+|    | 199|+    if (!constraint.empty ())
+|    | 200|+      {
+|    | 201|+          w.applyFilter (Regex::Filter < MPD::Song > (constraint,
+|    | 202|+                                                      Config.regex_type,
+|    | 203|+                                                      playlistEntryMatcher));
+|    | 204|+      }
+|    | 205|+    else
+|    | 206|+        w.clearFilter ();
+| 206| 207| }
+| 207| 208| 
+| 208| 209| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist.cpp
+|    |++++| /app/src/screens/playlist.cpp
+| 207| 207| 
+| 208| 208| /***********************************************************************/
+| 209| 209| 
+| 210|    |-bool Playlist::itemAvailable()
+| 211|    |-{
+| 212|    |-	return !w.empty();
+| 213|    |-}
+| 214|    |-
+| 215|    |-bool Playlist::addItemToPlaylist(bool play)
+| 216|    |-{
+| 217|    |-	if (play)
+| 218|    |-		Mpd.PlayID(w.currentV()->getID());
+| 219|    |-	return true;
+| 220|    |-}
+| 221|    |-
+| 222|    |-std::vector<MPD::Song> Playlist::getSelectedSongs()
+| 223|    |-{
+| 224|    |-	return w.getSelectedSongs();
+|    | 210|+bool
+|    | 211|+Playlist::itemAvailable ()
+|    | 212|+{
+|    | 213|+    return !w.empty ();
+|    | 214|+}
+|    | 215|+
+|    | 216|+bool
+|    | 217|+Playlist::addItemToPlaylist (bool play)
+|    | 218|+{
+|    | 219|+    if (play)
+|    | 220|+        Mpd.PlayID (w.currentV ()->getID ());
+|    | 221|+    return true;
+|    | 222|+}
+|    | 223|+
+|    | 224|+std::vector < MPD::Song > Playlist::getSelectedSongs ()
+|    | 225|+{
+|    | 226|+    return w.getSelectedSongs ();
+| 225| 227| }
+| 226| 228| 
+| 227| 229| /***********************************************************************/
+|    | [NORMAL] GNUIndentBear:
+|    | Indentation can be improved.
+|----|    | /app/src/screens/playlist.cpp
+|    |++++| /app/src/screens/playlist.cpp
+| 226| 226| 
+| 227| 227| /***********************************************************************/
+| 228| 228| 
+| 229|    |-MPD::Song Playlist::nowPlayingSong()
+| 230|    |-{
+| 231|    |-	MPD::Song s;
+| 232|    |-	if (Status::State::player() != MPD::psUnknown)
+| 233|    |-	{
+| 234|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter(ReapplyFilter::No, w);
+| 235|    |-		auto sp = Status::State::currentSongPosition();
+| 236|    |-		if (sp >= 0 && size_t(sp) < w.size())
+| 237|    |-			s = w.at(sp).value();
+| 238|    |-	}
+| 239|    |-	return s;
+| 240|    |-}
+| 241|    |-
+| 242|    |-void Playlist::locateSong(const MPD::Song &s)
+| 243|    |-{
+| 244|    |-	if (!w.isFiltered())
+| 245|    |-		w.highlight(s.getPosition());
+| 246|    |-	else
+| 247|    |-	{
+| 248|    |-		auto cmp = [](const MPD::Song &a, const MPD::Song &b) {
+| 249|    |-			return a.getPosition() < b.getPosition();
+| 250|    |-		};
+| 251|    |-		auto first = w.beginV(), last = w.endV();
+| 252|    |-		auto it = std::lower_bound(first, last, s, cmp);
+| 253|    |-		if (it != last && it->getPosition() == s.getPosition())
+| 254|    |-			w.highlight(it - first);
+| 255|    |-		else
+| 256|    |-			Statusbar::print("Song is filtered out");
+| 257|    |-	}
+| 258|    |-}
+| 259|    |-
+| 260|    |-void Playlist::enableHighlighting()
+| 261|    |-{
+| 262|    |-	w.setHighlighting(true);
+| 263|    |-	m_timer = Global::Timer;
+| 264|    |-}
+| 265|    |-
+| 266|    |-std::string Playlist::getTotalLength()
+| 267|    |-{
+| 268|    |-	std::ostringstream result;
+| 269|    |-	
+| 270|    |-	if (m_reload_total_length)
+| 271|    |-	{
+| 272|    |-		m_total_length = 0;
+| 273|    |-		for (const auto &s : w)
+| 274|    |-			m_total_length += s.value().getDuration();
+| 275|    |-		m_reload_total_length = false;
+| 276|    |-	}
+| 277|    |-	if (Config.playlist_show_remaining_time && m_reload_remaining)
+| 278|    |-	{
+| 279|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter(ReapplyFilter::No, w);
+| 280|    |-		m_remaining_time = 0;
+| 281|    |-		for (size_t i = Status::State::currentSongPosition(); i < w.size(); ++i)
+| 282|    |-			m_remaining_time += w[i].value().getDuration();
+| 283|    |-		m_reload_remaining = false;
+| 284|    |-	}
+| 285|    |-	
+| 286|    |-	result << '(' << w.size() << (w.size() == 1 ? " item" : " items");
+| 287|    |-
+| 288|    |-	if (w.isFiltered())
+| 289|    |-	{
+| 290|    |-		ScopedUnfilteredMenu<MPD::Song> sunfilter(ReapplyFilter::No, w);
+| 291|    |-		result << " (out of " << w.size() << ")";
+| 292|    |-	}
+| 293|    |-	
+| 294|    |-	if (m_total_length)
+| 295|    |-	{
+| 296|    |-		result << ", length: ";
+| 297|    |-		ShowTime(result, m_total_length, Config.playlist_shorten_total_times);
+| 298|    |-	}
+| 299|    |-	if (Config.playlist_show_remaining_time && m_remaining_time && w.size() > 1)
+| 300|    |-	{
+| 301|    |-		result << ", remaining: ";
+| 302|    |-		ShowTime(result, m_remaining_time, Config.playlist_shorten_total_times);
+| 303|    |-	}
+| 304|    |-	result << ')';
+| 305|    |-	return result.str();
+| 306|    |-}
+| 307|    |-
+| 308|    |-void Playlist::setSelectedItemsPriority(int prio)
+| 309|    |-{
+| 310|    |-	auto list = getSelectedOrCurrent(w.begin(), w.end(), w.current());
+| 311|    |-	Mpd.StartCommandsList();
+| 312|    |-	for (auto it = list.begin(); it != list.end(); ++it)
+| 313|    |-		Mpd.SetPriority((*it)->value(), prio);
+| 314|    |-	Mpd.CommitCommandsList();
+| 315|    |-	Statusbar::print("Priority set");
+| 316|    |-}
+| 317|    |-
+| 318|    |-bool Playlist::checkForSong(const MPD::Song &s)
+| 319|    |-{
+| 320|    |-	return m_song_refs.find(s) != m_song_refs.end();
+| 321|    |-}
+| 322|    |-
+| 323|    |-void Playlist::registerSong(const MPD::Song &s)
+| 324|    |-{
+| 325|    |-	++m_song_refs[s];
+| 326|    |-}
+| 327|    |-
+| 328|    |-void Playlist::unregisterSong(const MPD::Song &s)
+| 329|    |-{
+| 330|    |-	auto it = m_song_refs.find(s);
+| 331|    |-	assert(it != m_song_refs.end());
+| 332|    |-	if (it->second == 1)
+| 333|    |-		m_song_refs.erase(it);
+| 334|    |-	else
+| 335|    |-		--it->second;
+| 336|    |-}
+| 337|    |-
+| 338|    |-namespace {
+| 339|    |-
+| 340|    |-std::string songToString(const MPD::Song &s)
+| 341|    |-{
+| 342|    |-	std::string result;
+| 343|    |-	switch (Config.playlist_display_mode)
+| 344|    |-	{
+| 345|    |-		case DisplayMode::Classic:
+| 346|    |-			result = Format::stringify<char>(Config.song_list_format, &s);
+| 347|    |-			break;
+| 348|    |-		case DisplayMode::Columns:
+| 349|    |-			result = Format::stringify<char>(Config.song_columns_mode_format, &s);
+| 350|    |-	}
+| 351|    |-	return result;
+| 352|    |-}
+| 353|    |-
+| 354|    |-bool playlistEntryMatcher(const Regex::Regex &rx, const MPD::Song &s)
+| 355|    |-{
+| 356|    |-	return Regex::search(songToString(s), rx, Config.ignore_diacritics);
+| 357|    |-}
+| 358|    |-
+| 359|    |-}
+|    | 229|+MPD::Song Playlist::nowPlayingSong ()
+|    | 230|+{
+|    | 231|+    MPD::Song s;
+|    | 232|+    if (Status::State::player () != MPD::psUnknown)
+|    | 233|+      {
+|    | 234|+          ScopedUnfilteredMenu < MPD::Song > sunfilter (ReapplyFilter::No, w);
+|    | 235|+          auto
+|    | 236|+              sp = Status::State::currentSongPosition ();
+|    | 237|+          if (sp >= 0 && size_t (sp) < w.size ())
+|    | 238|+              s = w.at (sp).value ();
+|    | 239|+      }
+|    | 240|+    return s;
+|    | 241|+}
+|    | 242|+
+|    | 243|+void
+|    | 244|+Playlist::locateSong (const MPD::Song & s)
+|    | 245|+{
+|    | 246|+    if (!w.isFiltered ())
+|    | 247|+        w.highlight (s.getPosition ());
+|    | 248|+    else
+|    | 249|+      {
+|    | 250|+          auto cmp =[](const MPD::Song & a, const MPD::Song & b) {
+|    | 251|+              return a.getPosition () < b.getPosition ();
+|    | 252|+          };
+|    | 253|+          auto first = w.beginV (), last = w.endV ();
+|    | 254|+          auto it = std::lower_bound (first, last, s, cmp);
+|    | 255|+          if (it != last && it->getPosition () == s.getPosition ())
+|    | 256|+              w.highlight (it - first);
+|    | 257|+          else
+|    | 258|+              Statusbar::print ("Song is filtered out");
+|    | 259|+      }
+|    | 260|+}
+|    | 261|+
+|    | 262|+void
+|    | 263|+Playlist::enableHighlighting ()
+|    | 264|+{
+|    | 265|+    w.setHighlighting (true);
+|    | 266|+    m_timer = Global::Timer;
+|    | 267|+}
+|    | 268|+
+|    | 269|+std::string Playlist::getTotalLength ()
+|    | 270|+{
+|    | 271|+    std::ostringstream result;
+|    | 272|+
+|    | 273|+    if (m_reload_total_length)
+|    | 274|+      {
+|    | 275|+          m_total_length = 0;
+|    | 276|+        for (const auto & s:w)
+|    | 277|+              m_total_length += s.value ().getDuration ();
+|    | 278|+          m_reload_total_length = false;
+|    | 279|+      }
+|    | 280|+    if (Config.playlist_show_remaining_time && m_reload_remaining)
+|    | 281|+      {
+|    | 282|+          ScopedUnfilteredMenu < MPD::Song > sunfilter (ReapplyFilter::No, w);
+|    | 283|+          m_remaining_time = 0;
+|    | 284|+          for (size_t i = Status::State::currentSongPosition (); i < w.size ();
+|    | 285|+               ++i)
+|    | 286|+              m_remaining_time += w[i].value ().getDuration ();
+|    | 287|+          m_reload_remaining = false;
+|    | 288|+      }
+|    | 289|+
+|    | 290|+    result << '(' << w.size () << (w.size () == 1 ? " item" : " items");
+|    | 291|+
+|    | 292|+    if (w.isFiltered ())
+|    | 293|+      {
+|    | 294|+          ScopedUnfilteredMenu < MPD::Song > sunfilter (ReapplyFilter::No, w);
+|    | 295|+          result << " (out of " << w.size () << ")";
+|    | 296|+      }
+|    | 297|+
+|    | 298|+    if (m_total_length)
+|    | 299|+      {
+|    | 300|+          result << ", length: ";
+|    | 301|+          ShowTime (result, m_total_length,
+|    | 302|+                    Config.playlist_shorten_total_times);
+|    | 303|+      }
+|    | 304|+    if (Config.playlist_show_remaining_time && m_remaining_time
+|    | 305|+        && w.size () > 1)
+|    | 306|+      {
+|    | 307|+          result << ", remaining: ";
+|    | 308|+          ShowTime (result, m_remaining_time,
+|    | 309|+                    Config.playlist_shorten_total_times);
+|    | 310|+      }
+|    | 311|+    result << ')';
+|    | 312|+    return result.str ();
+|    | 313|+}
+|    | 314|+
+|    | 315|+void
+|    | 316|+Playlist::setSelectedItemsPriority (int prio)
+|    | 317|+{
+|    | 318|+    auto list = getSelectedOrCurrent (w.begin (), w.end (), w.current ());
+|    | 319|+    Mpd.StartCommandsList ();
+|    | 320|+    for (auto it = list.begin (); it != list.end (); ++it)
+|    | 321|+        Mpd.SetPriority ((*it)->value (), prio);
+|    | 322|+    Mpd.CommitCommandsList ();
+|    | 323|+    Statusbar::print ("Priority set");
+|    | 324|+}
+|    | 325|+
+|    | 326|+bool
+|    | 327|+Playlist::checkForSong (const MPD::Song & s)
+|    | 328|+{
+|    | 329|+    return m_song_refs.find (s) != m_song_refs.end ();
+|    | 330|+}
+|    | 331|+
+|    | 332|+void
+|    | 333|+Playlist::registerSong (const MPD::Song & s)
+|    | 334|+{
+|    | 335|+    ++m_song_refs[s];
+|    | 336|+}
+|    | 337|+
+|    | 338|+void
+|    | 339|+Playlist::unregisterSong (const MPD::Song & s)
+|    | 340|+{
+|    | 341|+    auto it = m_song_refs.find (s);
+|    | 342|+    assert (it != m_song_refs.end ());
+|    | 343|+    if (it->second == 1)
+|    | 344|+        m_song_refs.erase (it);
+|    | 345|+    else
+|    | 346|+        --it->second;
+|    | 347|+}
+|    | 348|+
+|    | 349|+namespace
+|    | 350|+{
+|    | 351|+
+|    | 352|+    std::string songToString (const MPD::Song & s)
+|    | 353|+    {
+|    | 354|+        std::string result;
+|    | 355|+        switch (Config.playlist_display_mode)
+|    | 356|+          {
+|    | 357|+          case DisplayMode::Classic:
+|    | 358|+              result = Format::stringify < char >(Config.song_list_format, &s);
+|    | 359|+              break;
+|    | 360|+          case DisplayMode::Columns:
+|    | 361|+              result =
+|    | 362|+                  Format::stringify < char >(Config.song_columns_mode_format,
+|    | 363|+                                             &s);
+|    | 364|+          }
+|    | 365|+        return result;
+|    | 366|+    }
+|    | 367|+
+|    | 368|+    bool playlistEntryMatcher (const Regex::Regex & rx, const MPD::Song & s)
+|    | 369|+    {
+|    | 370|+        return Regex::search (songToString (s), rx, Config.ignore_diacritics);
+|    | 371|+    }
+|    | 372|+
+|    | 373|+}
+
+src/screens/playlist.cpp
+|  25| #include•"curses/menu_impl.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'curses/menu_impl.h'
+
+src/screens/playlist.cpp
+|  26| #include•"display.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'display.h'
+
+src/screens/playlist.cpp
+|  27| #include•"global.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'global.h'
+
+src/screens/playlist.cpp
+|  28| #include•"helpers.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'helpers.h'
+
+src/screens/playlist.cpp
+|  29| #include•"screens/playlist.h"
+|    | [NORMAL] CPPCleanBear:
+|    | unable to find 'screens/playlist.h'
+
+src/screens/playlist.cpp
+|  30| #include•"screens/screen_swi